// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: converter_additive_storage.proto

#ifndef PROTOBUF_converter_5fadditive_5fstorage_2eproto__INCLUDED
#define PROTOBUF_converter_5fadditive_5fstorage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace converterd {
namespace pb {
class CurrencyConvertionInfo;
class CurrencyConvertionInfoDefaultTypeInternal;
extern CurrencyConvertionInfoDefaultTypeInternal _CurrencyConvertionInfo_default_instance_;
class CurrencyInfo;
class CurrencyInfoDefaultTypeInternal;
extern CurrencyInfoDefaultTypeInternal _CurrencyInfo_default_instance_;
class CurrencySourceInfo;
class CurrencySourceInfoDefaultTypeInternal;
extern CurrencySourceInfoDefaultTypeInternal _CurrencySourceInfo_default_instance_;
class DeclensionInfo;
class DeclensionInfoDefaultTypeInternal;
extern DeclensionInfoDefaultTypeInternal _DeclensionInfo_default_instance_;
class MeasureConvertionInfo;
class MeasureConvertionInfoDefaultTypeInternal;
extern MeasureConvertionInfoDefaultTypeInternal _MeasureConvertionInfo_default_instance_;
class MeasureInfo;
class MeasureInfoDefaultTypeInternal;
extern MeasureInfoDefaultTypeInternal _MeasureInfo_default_instance_;
class MeasureTypeInfo;
class MeasureTypeInfoDefaultTypeInternal;
extern MeasureTypeInfoDefaultTypeInternal _MeasureTypeInfo_default_instance_;
}  // namespace pb
}  // namespace converterd

namespace converterd {
namespace pb {

namespace protobuf_converter_5fadditive_5fstorage_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_converter_5fadditive_5fstorage_2eproto

// ===================================================================

class DeclensionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:converterd.pb.DeclensionInfo) */ {
 public:
  DeclensionInfo();
  virtual ~DeclensionInfo();

  DeclensionInfo(const DeclensionInfo& from);

  inline DeclensionInfo& operator=(const DeclensionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeclensionInfo(DeclensionInfo&& from) noexcept
    : DeclensionInfo() {
    *this = ::std::move(from);
  }

  inline DeclensionInfo& operator=(DeclensionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeclensionInfo& default_instance();

  static inline const DeclensionInfo* internal_default_instance() {
    return reinterpret_cast<const DeclensionInfo*>(
               &_DeclensionInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DeclensionInfo* other);
  friend void swap(DeclensionInfo& a, DeclensionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeclensionInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DeclensionInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeclensionInfo& from);
  void MergeFrom(const DeclensionInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeclensionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string first = 1;
  bool has_first() const;
  void clear_first();
  static const int kFirstFieldNumber = 1;
  const ::std::string& first() const;
  void set_first(const ::std::string& value);
  #if LANG_CXX11
  void set_first(::std::string&& value);
  #endif
  void set_first(const char* value);
  void set_first(const char* value, size_t size);
  ::std::string* mutable_first();
  ::std::string* release_first();
  void set_allocated_first(::std::string* first);

  // required string second = 2;
  bool has_second() const;
  void clear_second();
  static const int kSecondFieldNumber = 2;
  const ::std::string& second() const;
  void set_second(const ::std::string& value);
  #if LANG_CXX11
  void set_second(::std::string&& value);
  #endif
  void set_second(const char* value);
  void set_second(const char* value, size_t size);
  ::std::string* mutable_second();
  ::std::string* release_second();
  void set_allocated_second(::std::string* second);

  // required string third = 3;
  bool has_third() const;
  void clear_third();
  static const int kThirdFieldNumber = 3;
  const ::std::string& third() const;
  void set_third(const ::std::string& value);
  #if LANG_CXX11
  void set_third(::std::string&& value);
  #endif
  void set_third(const char* value);
  void set_third(const char* value, size_t size);
  ::std::string* mutable_third();
  ::std::string* release_third();
  void set_allocated_third(::std::string* third);

  // required string fourth = 4;
  bool has_fourth() const;
  void clear_fourth();
  static const int kFourthFieldNumber = 4;
  const ::std::string& fourth() const;
  void set_fourth(const ::std::string& value);
  #if LANG_CXX11
  void set_fourth(::std::string&& value);
  #endif
  void set_fourth(const char* value);
  void set_fourth(const char* value, size_t size);
  ::std::string* mutable_fourth();
  ::std::string* release_fourth();
  void set_allocated_fourth(::std::string* fourth);

  // @@protoc_insertion_point(class_scope:converterd.pb.DeclensionInfo)
 private:
  void set_has_first();
  void clear_has_first();
  void set_has_second();
  void clear_has_second();
  void set_has_third();
  void clear_has_third();
  void set_has_fourth();
  void clear_has_fourth();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr first_;
  ::google::protobuf::internal::ArenaStringPtr second_;
  ::google::protobuf::internal::ArenaStringPtr third_;
  ::google::protobuf::internal::ArenaStringPtr fourth_;
  friend struct protobuf_converter_5fadditive_5fstorage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CurrencySourceInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:converterd.pb.CurrencySourceInfo) */ {
 public:
  CurrencySourceInfo();
  virtual ~CurrencySourceInfo();

  CurrencySourceInfo(const CurrencySourceInfo& from);

  inline CurrencySourceInfo& operator=(const CurrencySourceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CurrencySourceInfo(CurrencySourceInfo&& from) noexcept
    : CurrencySourceInfo() {
    *this = ::std::move(from);
  }

  inline CurrencySourceInfo& operator=(CurrencySourceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrencySourceInfo& default_instance();

  static inline const CurrencySourceInfo* internal_default_instance() {
    return reinterpret_cast<const CurrencySourceInfo*>(
               &_CurrencySourceInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CurrencySourceInfo* other);
  friend void swap(CurrencySourceInfo& a, CurrencySourceInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CurrencySourceInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CurrencySourceInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CurrencySourceInfo& from);
  void MergeFrom(const CurrencySourceInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CurrencySourceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string link = 3;
  bool has_link() const;
  void clear_link();
  static const int kLinkFieldNumber = 3;
  const ::std::string& link() const;
  void set_link(const ::std::string& value);
  #if LANG_CXX11
  void set_link(::std::string&& value);
  #endif
  void set_link(const char* value);
  void set_link(const char* value, size_t size);
  ::std::string* mutable_link();
  ::std::string* release_link();
  void set_allocated_link(::std::string* link);

  // optional string region_id = 4;
  bool has_region_id() const;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 4;
  const ::std::string& region_id() const;
  void set_region_id(const ::std::string& value);
  #if LANG_CXX11
  void set_region_id(::std::string&& value);
  #endif
  void set_region_id(const char* value);
  void set_region_id(const char* value, size_t size);
  ::std::string* mutable_region_id();
  ::std::string* release_region_id();
  void set_allocated_region_id(::std::string* region_id);

  // @@protoc_insertion_point(class_scope:converterd.pb.CurrencySourceInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_link();
  void clear_has_link();
  void set_has_region_id();
  void clear_has_region_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr link_;
  ::google::protobuf::internal::ArenaStringPtr region_id_;
  friend struct protobuf_converter_5fadditive_5fstorage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CurrencyInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:converterd.pb.CurrencyInfo) */ {
 public:
  CurrencyInfo();
  virtual ~CurrencyInfo();

  CurrencyInfo(const CurrencyInfo& from);

  inline CurrencyInfo& operator=(const CurrencyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CurrencyInfo(CurrencyInfo&& from) noexcept
    : CurrencyInfo() {
    *this = ::std::move(from);
  }

  inline CurrencyInfo& operator=(CurrencyInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrencyInfo& default_instance();

  static inline const CurrencyInfo* internal_default_instance() {
    return reinterpret_cast<const CurrencyInfo*>(
               &_CurrencyInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(CurrencyInfo* other);
  friend void swap(CurrencyInfo& a, CurrencyInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CurrencyInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CurrencyInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CurrencyInfo& from);
  void MergeFrom(const CurrencyInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CurrencyInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .converterd.pb.DeclensionInfo declensions = 2;
  bool has_declensions() const;
  void clear_declensions();
  static const int kDeclensionsFieldNumber = 2;
  const ::converterd::pb::DeclensionInfo& declensions() const;
  ::converterd::pb::DeclensionInfo* mutable_declensions();
  ::converterd::pb::DeclensionInfo* release_declensions();
  void set_allocated_declensions(::converterd::pb::DeclensionInfo* declensions);

  // @@protoc_insertion_point(class_scope:converterd.pb.CurrencyInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_declensions();
  void clear_has_declensions();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::converterd::pb::DeclensionInfo* declensions_;
  friend struct protobuf_converter_5fadditive_5fstorage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CurrencyConvertionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:converterd.pb.CurrencyConvertionInfo) */ {
 public:
  CurrencyConvertionInfo();
  virtual ~CurrencyConvertionInfo();

  CurrencyConvertionInfo(const CurrencyConvertionInfo& from);

  inline CurrencyConvertionInfo& operator=(const CurrencyConvertionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CurrencyConvertionInfo(CurrencyConvertionInfo&& from) noexcept
    : CurrencyConvertionInfo() {
    *this = ::std::move(from);
  }

  inline CurrencyConvertionInfo& operator=(CurrencyConvertionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrencyConvertionInfo& default_instance();

  static inline const CurrencyConvertionInfo* internal_default_instance() {
    return reinterpret_cast<const CurrencyConvertionInfo*>(
               &_CurrencyConvertionInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CurrencyConvertionInfo* other);
  friend void swap(CurrencyConvertionInfo& a, CurrencyConvertionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CurrencyConvertionInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CurrencyConvertionInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CurrencyConvertionInfo& from);
  void MergeFrom(const CurrencyConvertionInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CurrencyConvertionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string from_id = 1;
  bool has_from_id() const;
  void clear_from_id();
  static const int kFromIdFieldNumber = 1;
  const ::std::string& from_id() const;
  void set_from_id(const ::std::string& value);
  #if LANG_CXX11
  void set_from_id(::std::string&& value);
  #endif
  void set_from_id(const char* value);
  void set_from_id(const char* value, size_t size);
  ::std::string* mutable_from_id();
  ::std::string* release_from_id();
  void set_allocated_from_id(::std::string* from_id);

  // required string to_id = 2;
  bool has_to_id() const;
  void clear_to_id();
  static const int kToIdFieldNumber = 2;
  const ::std::string& to_id() const;
  void set_to_id(const ::std::string& value);
  #if LANG_CXX11
  void set_to_id(::std::string&& value);
  #endif
  void set_to_id(const char* value);
  void set_to_id(const char* value, size_t size);
  ::std::string* mutable_to_id();
  ::std::string* release_to_id();
  void set_allocated_to_id(::std::string* to_id);

  // required string a_coeff_numerator = 3;
  bool has_a_coeff_numerator() const;
  void clear_a_coeff_numerator();
  static const int kACoeffNumeratorFieldNumber = 3;
  const ::std::string& a_coeff_numerator() const;
  void set_a_coeff_numerator(const ::std::string& value);
  #if LANG_CXX11
  void set_a_coeff_numerator(::std::string&& value);
  #endif
  void set_a_coeff_numerator(const char* value);
  void set_a_coeff_numerator(const char* value, size_t size);
  ::std::string* mutable_a_coeff_numerator();
  ::std::string* release_a_coeff_numerator();
  void set_allocated_a_coeff_numerator(::std::string* a_coeff_numerator);

  // required string a_coeff_denominator = 4;
  bool has_a_coeff_denominator() const;
  void clear_a_coeff_denominator();
  static const int kACoeffDenominatorFieldNumber = 4;
  const ::std::string& a_coeff_denominator() const;
  void set_a_coeff_denominator(const ::std::string& value);
  #if LANG_CXX11
  void set_a_coeff_denominator(::std::string&& value);
  #endif
  void set_a_coeff_denominator(const char* value);
  void set_a_coeff_denominator(const char* value, size_t size);
  ::std::string* mutable_a_coeff_denominator();
  ::std::string* release_a_coeff_denominator();
  void set_allocated_a_coeff_denominator(::std::string* a_coeff_denominator);

  // optional string source_id = 6;
  bool has_source_id() const;
  void clear_source_id();
  static const int kSourceIdFieldNumber = 6;
  const ::std::string& source_id() const;
  void set_source_id(const ::std::string& value);
  #if LANG_CXX11
  void set_source_id(::std::string&& value);
  #endif
  void set_source_id(const char* value);
  void set_source_id(const char* value, size_t size);
  ::std::string* mutable_source_id();
  ::std::string* release_source_id();
  void set_allocated_source_id(::std::string* source_id);

  // optional string link = 7;
  bool has_link() const;
  void clear_link();
  static const int kLinkFieldNumber = 7;
  const ::std::string& link() const;
  void set_link(const ::std::string& value);
  #if LANG_CXX11
  void set_link(::std::string&& value);
  #endif
  void set_link(const char* value);
  void set_link(const char* value, size_t size);
  ::std::string* mutable_link();
  ::std::string* release_link();
  void set_allocated_link(::std::string* link);

  // required uint64 time = 5;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 5;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // required bool is_live = 8;
  bool has_is_live() const;
  void clear_is_live();
  static const int kIsLiveFieldNumber = 8;
  bool is_live() const;
  void set_is_live(bool value);

  // @@protoc_insertion_point(class_scope:converterd.pb.CurrencyConvertionInfo)
 private:
  void set_has_from_id();
  void clear_has_from_id();
  void set_has_to_id();
  void clear_has_to_id();
  void set_has_a_coeff_numerator();
  void clear_has_a_coeff_numerator();
  void set_has_a_coeff_denominator();
  void clear_has_a_coeff_denominator();
  void set_has_time();
  void clear_has_time();
  void set_has_source_id();
  void clear_has_source_id();
  void set_has_link();
  void clear_has_link();
  void set_has_is_live();
  void clear_has_is_live();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr from_id_;
  ::google::protobuf::internal::ArenaStringPtr to_id_;
  ::google::protobuf::internal::ArenaStringPtr a_coeff_numerator_;
  ::google::protobuf::internal::ArenaStringPtr a_coeff_denominator_;
  ::google::protobuf::internal::ArenaStringPtr source_id_;
  ::google::protobuf::internal::ArenaStringPtr link_;
  ::google::protobuf::uint64 time_;
  bool is_live_;
  friend struct protobuf_converter_5fadditive_5fstorage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MeasureTypeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:converterd.pb.MeasureTypeInfo) */ {
 public:
  MeasureTypeInfo();
  virtual ~MeasureTypeInfo();

  MeasureTypeInfo(const MeasureTypeInfo& from);

  inline MeasureTypeInfo& operator=(const MeasureTypeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeasureTypeInfo(MeasureTypeInfo&& from) noexcept
    : MeasureTypeInfo() {
    *this = ::std::move(from);
  }

  inline MeasureTypeInfo& operator=(MeasureTypeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MeasureTypeInfo& default_instance();

  static inline const MeasureTypeInfo* internal_default_instance() {
    return reinterpret_cast<const MeasureTypeInfo*>(
               &_MeasureTypeInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(MeasureTypeInfo* other);
  friend void swap(MeasureTypeInfo& a, MeasureTypeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeasureTypeInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MeasureTypeInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MeasureTypeInfo& from);
  void MergeFrom(const MeasureTypeInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MeasureTypeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string base_id = 3;
  bool has_base_id() const;
  void clear_base_id();
  static const int kBaseIdFieldNumber = 3;
  const ::std::string& base_id() const;
  void set_base_id(const ::std::string& value);
  #if LANG_CXX11
  void set_base_id(::std::string&& value);
  #endif
  void set_base_id(const char* value);
  void set_base_id(const char* value, size_t size);
  ::std::string* mutable_base_id();
  ::std::string* release_base_id();
  void set_allocated_base_id(::std::string* base_id);

  // @@protoc_insertion_point(class_scope:converterd.pb.MeasureTypeInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_base_id();
  void clear_has_base_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr base_id_;
  friend struct protobuf_converter_5fadditive_5fstorage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MeasureInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:converterd.pb.MeasureInfo) */ {
 public:
  MeasureInfo();
  virtual ~MeasureInfo();

  MeasureInfo(const MeasureInfo& from);

  inline MeasureInfo& operator=(const MeasureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeasureInfo(MeasureInfo&& from) noexcept
    : MeasureInfo() {
    *this = ::std::move(from);
  }

  inline MeasureInfo& operator=(MeasureInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MeasureInfo& default_instance();

  static inline const MeasureInfo* internal_default_instance() {
    return reinterpret_cast<const MeasureInfo*>(
               &_MeasureInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(MeasureInfo* other);
  friend void swap(MeasureInfo& a, MeasureInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeasureInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MeasureInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MeasureInfo& from);
  void MergeFrom(const MeasureInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MeasureInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .converterd.pb.DeclensionInfo declensions = 2;
  bool has_declensions() const;
  void clear_declensions();
  static const int kDeclensionsFieldNumber = 2;
  const ::converterd::pb::DeclensionInfo& declensions() const;
  ::converterd::pb::DeclensionInfo* mutable_declensions();
  ::converterd::pb::DeclensionInfo* release_declensions();
  void set_allocated_declensions(::converterd::pb::DeclensionInfo* declensions);

  // required bool is_optional = 3;
  bool has_is_optional() const;
  void clear_is_optional();
  static const int kIsOptionalFieldNumber = 3;
  bool is_optional() const;
  void set_is_optional(bool value);

  // @@protoc_insertion_point(class_scope:converterd.pb.MeasureInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_declensions();
  void clear_has_declensions();
  void set_has_is_optional();
  void clear_has_is_optional();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::converterd::pb::DeclensionInfo* declensions_;
  bool is_optional_;
  friend struct protobuf_converter_5fadditive_5fstorage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MeasureConvertionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:converterd.pb.MeasureConvertionInfo) */ {
 public:
  MeasureConvertionInfo();
  virtual ~MeasureConvertionInfo();

  MeasureConvertionInfo(const MeasureConvertionInfo& from);

  inline MeasureConvertionInfo& operator=(const MeasureConvertionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeasureConvertionInfo(MeasureConvertionInfo&& from) noexcept
    : MeasureConvertionInfo() {
    *this = ::std::move(from);
  }

  inline MeasureConvertionInfo& operator=(MeasureConvertionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MeasureConvertionInfo& default_instance();

  static inline const MeasureConvertionInfo* internal_default_instance() {
    return reinterpret_cast<const MeasureConvertionInfo*>(
               &_MeasureConvertionInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(MeasureConvertionInfo* other);
  friend void swap(MeasureConvertionInfo& a, MeasureConvertionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeasureConvertionInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MeasureConvertionInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MeasureConvertionInfo& from);
  void MergeFrom(const MeasureConvertionInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MeasureConvertionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string from_id = 1;
  bool has_from_id() const;
  void clear_from_id();
  static const int kFromIdFieldNumber = 1;
  const ::std::string& from_id() const;
  void set_from_id(const ::std::string& value);
  #if LANG_CXX11
  void set_from_id(::std::string&& value);
  #endif
  void set_from_id(const char* value);
  void set_from_id(const char* value, size_t size);
  ::std::string* mutable_from_id();
  ::std::string* release_from_id();
  void set_allocated_from_id(::std::string* from_id);

  // required string to_id = 2;
  bool has_to_id() const;
  void clear_to_id();
  static const int kToIdFieldNumber = 2;
  const ::std::string& to_id() const;
  void set_to_id(const ::std::string& value);
  #if LANG_CXX11
  void set_to_id(::std::string&& value);
  #endif
  void set_to_id(const char* value);
  void set_to_id(const char* value, size_t size);
  ::std::string* mutable_to_id();
  ::std::string* release_to_id();
  void set_allocated_to_id(::std::string* to_id);

  // required string a_coeff = 3;
  bool has_a_coeff() const;
  void clear_a_coeff();
  static const int kACoeffFieldNumber = 3;
  const ::std::string& a_coeff() const;
  void set_a_coeff(const ::std::string& value);
  #if LANG_CXX11
  void set_a_coeff(::std::string&& value);
  #endif
  void set_a_coeff(const char* value);
  void set_a_coeff(const char* value, size_t size);
  ::std::string* mutable_a_coeff();
  ::std::string* release_a_coeff();
  void set_allocated_a_coeff(::std::string* a_coeff);

  // required string b_coeff = 4;
  bool has_b_coeff() const;
  void clear_b_coeff();
  static const int kBCoeffFieldNumber = 4;
  const ::std::string& b_coeff() const;
  void set_b_coeff(const ::std::string& value);
  #if LANG_CXX11
  void set_b_coeff(::std::string&& value);
  #endif
  void set_b_coeff(const char* value);
  void set_b_coeff(const char* value, size_t size);
  ::std::string* mutable_b_coeff();
  ::std::string* release_b_coeff();
  void set_allocated_b_coeff(::std::string* b_coeff);

  // @@protoc_insertion_point(class_scope:converterd.pb.MeasureConvertionInfo)
 private:
  void set_has_from_id();
  void clear_has_from_id();
  void set_has_to_id();
  void clear_has_to_id();
  void set_has_a_coeff();
  void clear_has_a_coeff();
  void set_has_b_coeff();
  void clear_has_b_coeff();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr from_id_;
  ::google::protobuf::internal::ArenaStringPtr to_id_;
  ::google::protobuf::internal::ArenaStringPtr a_coeff_;
  ::google::protobuf::internal::ArenaStringPtr b_coeff_;
  friend struct protobuf_converter_5fadditive_5fstorage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeclensionInfo

// required string first = 1;
inline bool DeclensionInfo::has_first() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeclensionInfo::set_has_first() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeclensionInfo::clear_has_first() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeclensionInfo::clear_first() {
  first_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_first();
}
inline const ::std::string& DeclensionInfo::first() const {
  // @@protoc_insertion_point(field_get:converterd.pb.DeclensionInfo.first)
  return first_.GetNoArena();
}
inline void DeclensionInfo::set_first(const ::std::string& value) {
  set_has_first();
  first_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.DeclensionInfo.first)
}
#if LANG_CXX11
inline void DeclensionInfo::set_first(::std::string&& value) {
  set_has_first();
  first_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.DeclensionInfo.first)
}
#endif
inline void DeclensionInfo::set_first(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_first();
  first_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.DeclensionInfo.first)
}
inline void DeclensionInfo::set_first(const char* value, size_t size) {
  set_has_first();
  first_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.DeclensionInfo.first)
}
inline ::std::string* DeclensionInfo::mutable_first() {
  set_has_first();
  // @@protoc_insertion_point(field_mutable:converterd.pb.DeclensionInfo.first)
  return first_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeclensionInfo::release_first() {
  // @@protoc_insertion_point(field_release:converterd.pb.DeclensionInfo.first)
  clear_has_first();
  return first_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeclensionInfo::set_allocated_first(::std::string* first) {
  if (first != NULL) {
    set_has_first();
  } else {
    clear_has_first();
  }
  first_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), first);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.DeclensionInfo.first)
}

// required string second = 2;
inline bool DeclensionInfo::has_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeclensionInfo::set_has_second() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeclensionInfo::clear_has_second() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeclensionInfo::clear_second() {
  second_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_second();
}
inline const ::std::string& DeclensionInfo::second() const {
  // @@protoc_insertion_point(field_get:converterd.pb.DeclensionInfo.second)
  return second_.GetNoArena();
}
inline void DeclensionInfo::set_second(const ::std::string& value) {
  set_has_second();
  second_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.DeclensionInfo.second)
}
#if LANG_CXX11
inline void DeclensionInfo::set_second(::std::string&& value) {
  set_has_second();
  second_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.DeclensionInfo.second)
}
#endif
inline void DeclensionInfo::set_second(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_second();
  second_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.DeclensionInfo.second)
}
inline void DeclensionInfo::set_second(const char* value, size_t size) {
  set_has_second();
  second_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.DeclensionInfo.second)
}
inline ::std::string* DeclensionInfo::mutable_second() {
  set_has_second();
  // @@protoc_insertion_point(field_mutable:converterd.pb.DeclensionInfo.second)
  return second_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeclensionInfo::release_second() {
  // @@protoc_insertion_point(field_release:converterd.pb.DeclensionInfo.second)
  clear_has_second();
  return second_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeclensionInfo::set_allocated_second(::std::string* second) {
  if (second != NULL) {
    set_has_second();
  } else {
    clear_has_second();
  }
  second_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), second);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.DeclensionInfo.second)
}

// required string third = 3;
inline bool DeclensionInfo::has_third() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeclensionInfo::set_has_third() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeclensionInfo::clear_has_third() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeclensionInfo::clear_third() {
  third_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_third();
}
inline const ::std::string& DeclensionInfo::third() const {
  // @@protoc_insertion_point(field_get:converterd.pb.DeclensionInfo.third)
  return third_.GetNoArena();
}
inline void DeclensionInfo::set_third(const ::std::string& value) {
  set_has_third();
  third_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.DeclensionInfo.third)
}
#if LANG_CXX11
inline void DeclensionInfo::set_third(::std::string&& value) {
  set_has_third();
  third_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.DeclensionInfo.third)
}
#endif
inline void DeclensionInfo::set_third(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_third();
  third_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.DeclensionInfo.third)
}
inline void DeclensionInfo::set_third(const char* value, size_t size) {
  set_has_third();
  third_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.DeclensionInfo.third)
}
inline ::std::string* DeclensionInfo::mutable_third() {
  set_has_third();
  // @@protoc_insertion_point(field_mutable:converterd.pb.DeclensionInfo.third)
  return third_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeclensionInfo::release_third() {
  // @@protoc_insertion_point(field_release:converterd.pb.DeclensionInfo.third)
  clear_has_third();
  return third_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeclensionInfo::set_allocated_third(::std::string* third) {
  if (third != NULL) {
    set_has_third();
  } else {
    clear_has_third();
  }
  third_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), third);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.DeclensionInfo.third)
}

// required string fourth = 4;
inline bool DeclensionInfo::has_fourth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeclensionInfo::set_has_fourth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeclensionInfo::clear_has_fourth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeclensionInfo::clear_fourth() {
  fourth_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fourth();
}
inline const ::std::string& DeclensionInfo::fourth() const {
  // @@protoc_insertion_point(field_get:converterd.pb.DeclensionInfo.fourth)
  return fourth_.GetNoArena();
}
inline void DeclensionInfo::set_fourth(const ::std::string& value) {
  set_has_fourth();
  fourth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.DeclensionInfo.fourth)
}
#if LANG_CXX11
inline void DeclensionInfo::set_fourth(::std::string&& value) {
  set_has_fourth();
  fourth_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.DeclensionInfo.fourth)
}
#endif
inline void DeclensionInfo::set_fourth(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fourth();
  fourth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.DeclensionInfo.fourth)
}
inline void DeclensionInfo::set_fourth(const char* value, size_t size) {
  set_has_fourth();
  fourth_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.DeclensionInfo.fourth)
}
inline ::std::string* DeclensionInfo::mutable_fourth() {
  set_has_fourth();
  // @@protoc_insertion_point(field_mutable:converterd.pb.DeclensionInfo.fourth)
  return fourth_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeclensionInfo::release_fourth() {
  // @@protoc_insertion_point(field_release:converterd.pb.DeclensionInfo.fourth)
  clear_has_fourth();
  return fourth_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeclensionInfo::set_allocated_fourth(::std::string* fourth) {
  if (fourth != NULL) {
    set_has_fourth();
  } else {
    clear_has_fourth();
  }
  fourth_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fourth);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.DeclensionInfo.fourth)
}

// -------------------------------------------------------------------

// CurrencySourceInfo

// required string id = 1;
inline bool CurrencySourceInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrencySourceInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrencySourceInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrencySourceInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& CurrencySourceInfo::id() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencySourceInfo.id)
  return id_.GetNoArena();
}
inline void CurrencySourceInfo::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencySourceInfo.id)
}
#if LANG_CXX11
inline void CurrencySourceInfo::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.CurrencySourceInfo.id)
}
#endif
inline void CurrencySourceInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.CurrencySourceInfo.id)
}
inline void CurrencySourceInfo::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.CurrencySourceInfo.id)
}
inline ::std::string* CurrencySourceInfo::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencySourceInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrencySourceInfo::release_id() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencySourceInfo.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrencySourceInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencySourceInfo.id)
}

// required string name = 2;
inline bool CurrencySourceInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrencySourceInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrencySourceInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrencySourceInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& CurrencySourceInfo::name() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencySourceInfo.name)
  return name_.GetNoArena();
}
inline void CurrencySourceInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencySourceInfo.name)
}
#if LANG_CXX11
inline void CurrencySourceInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.CurrencySourceInfo.name)
}
#endif
inline void CurrencySourceInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.CurrencySourceInfo.name)
}
inline void CurrencySourceInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.CurrencySourceInfo.name)
}
inline ::std::string* CurrencySourceInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencySourceInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrencySourceInfo::release_name() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencySourceInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrencySourceInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencySourceInfo.name)
}

// required string link = 3;
inline bool CurrencySourceInfo::has_link() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CurrencySourceInfo::set_has_link() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CurrencySourceInfo::clear_has_link() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CurrencySourceInfo::clear_link() {
  link_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link();
}
inline const ::std::string& CurrencySourceInfo::link() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencySourceInfo.link)
  return link_.GetNoArena();
}
inline void CurrencySourceInfo::set_link(const ::std::string& value) {
  set_has_link();
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencySourceInfo.link)
}
#if LANG_CXX11
inline void CurrencySourceInfo::set_link(::std::string&& value) {
  set_has_link();
  link_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.CurrencySourceInfo.link)
}
#endif
inline void CurrencySourceInfo::set_link(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_link();
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.CurrencySourceInfo.link)
}
inline void CurrencySourceInfo::set_link(const char* value, size_t size) {
  set_has_link();
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.CurrencySourceInfo.link)
}
inline ::std::string* CurrencySourceInfo::mutable_link() {
  set_has_link();
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencySourceInfo.link)
  return link_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrencySourceInfo::release_link() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencySourceInfo.link)
  clear_has_link();
  return link_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrencySourceInfo::set_allocated_link(::std::string* link) {
  if (link != NULL) {
    set_has_link();
  } else {
    clear_has_link();
  }
  link_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencySourceInfo.link)
}

// optional string region_id = 4;
inline bool CurrencySourceInfo::has_region_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CurrencySourceInfo::set_has_region_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CurrencySourceInfo::clear_has_region_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CurrencySourceInfo::clear_region_id() {
  region_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_region_id();
}
inline const ::std::string& CurrencySourceInfo::region_id() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencySourceInfo.region_id)
  return region_id_.GetNoArena();
}
inline void CurrencySourceInfo::set_region_id(const ::std::string& value) {
  set_has_region_id();
  region_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencySourceInfo.region_id)
}
#if LANG_CXX11
inline void CurrencySourceInfo::set_region_id(::std::string&& value) {
  set_has_region_id();
  region_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.CurrencySourceInfo.region_id)
}
#endif
inline void CurrencySourceInfo::set_region_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_region_id();
  region_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.CurrencySourceInfo.region_id)
}
inline void CurrencySourceInfo::set_region_id(const char* value, size_t size) {
  set_has_region_id();
  region_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.CurrencySourceInfo.region_id)
}
inline ::std::string* CurrencySourceInfo::mutable_region_id() {
  set_has_region_id();
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencySourceInfo.region_id)
  return region_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrencySourceInfo::release_region_id() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencySourceInfo.region_id)
  clear_has_region_id();
  return region_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrencySourceInfo::set_allocated_region_id(::std::string* region_id) {
  if (region_id != NULL) {
    set_has_region_id();
  } else {
    clear_has_region_id();
  }
  region_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), region_id);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencySourceInfo.region_id)
}

// -------------------------------------------------------------------

// CurrencyInfo

// required string id = 1;
inline bool CurrencyInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrencyInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrencyInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrencyInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& CurrencyInfo::id() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencyInfo.id)
  return id_.GetNoArena();
}
inline void CurrencyInfo::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencyInfo.id)
}
#if LANG_CXX11
inline void CurrencyInfo::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.CurrencyInfo.id)
}
#endif
inline void CurrencyInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.CurrencyInfo.id)
}
inline void CurrencyInfo::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.CurrencyInfo.id)
}
inline ::std::string* CurrencyInfo::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencyInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrencyInfo::release_id() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencyInfo.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrencyInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencyInfo.id)
}

// required .converterd.pb.DeclensionInfo declensions = 2;
inline bool CurrencyInfo::has_declensions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrencyInfo::set_has_declensions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrencyInfo::clear_has_declensions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrencyInfo::clear_declensions() {
  if (declensions_ != NULL) declensions_->::converterd::pb::DeclensionInfo::Clear();
  clear_has_declensions();
}
inline const ::converterd::pb::DeclensionInfo& CurrencyInfo::declensions() const {
  const ::converterd::pb::DeclensionInfo* p = declensions_;
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencyInfo.declensions)
  return p != NULL ? *p : *reinterpret_cast<const ::converterd::pb::DeclensionInfo*>(
      &::converterd::pb::_DeclensionInfo_default_instance_);
}
inline ::converterd::pb::DeclensionInfo* CurrencyInfo::mutable_declensions() {
  set_has_declensions();
  if (declensions_ == NULL) {
    declensions_ = new ::converterd::pb::DeclensionInfo;
  }
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencyInfo.declensions)
  return declensions_;
}
inline ::converterd::pb::DeclensionInfo* CurrencyInfo::release_declensions() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencyInfo.declensions)
  clear_has_declensions();
  ::converterd::pb::DeclensionInfo* temp = declensions_;
  declensions_ = NULL;
  return temp;
}
inline void CurrencyInfo::set_allocated_declensions(::converterd::pb::DeclensionInfo* declensions) {
  delete declensions_;
  declensions_ = declensions;
  if (declensions) {
    set_has_declensions();
  } else {
    clear_has_declensions();
  }
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencyInfo.declensions)
}

// -------------------------------------------------------------------

// CurrencyConvertionInfo

// required string from_id = 1;
inline bool CurrencyConvertionInfo::has_from_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrencyConvertionInfo::set_has_from_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrencyConvertionInfo::clear_has_from_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrencyConvertionInfo::clear_from_id() {
  from_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from_id();
}
inline const ::std::string& CurrencyConvertionInfo::from_id() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencyConvertionInfo.from_id)
  return from_id_.GetNoArena();
}
inline void CurrencyConvertionInfo::set_from_id(const ::std::string& value) {
  set_has_from_id();
  from_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencyConvertionInfo.from_id)
}
#if LANG_CXX11
inline void CurrencyConvertionInfo::set_from_id(::std::string&& value) {
  set_has_from_id();
  from_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.CurrencyConvertionInfo.from_id)
}
#endif
inline void CurrencyConvertionInfo::set_from_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from_id();
  from_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.CurrencyConvertionInfo.from_id)
}
inline void CurrencyConvertionInfo::set_from_id(const char* value, size_t size) {
  set_has_from_id();
  from_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.CurrencyConvertionInfo.from_id)
}
inline ::std::string* CurrencyConvertionInfo::mutable_from_id() {
  set_has_from_id();
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencyConvertionInfo.from_id)
  return from_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrencyConvertionInfo::release_from_id() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencyConvertionInfo.from_id)
  clear_has_from_id();
  return from_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrencyConvertionInfo::set_allocated_from_id(::std::string* from_id) {
  if (from_id != NULL) {
    set_has_from_id();
  } else {
    clear_has_from_id();
  }
  from_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_id);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencyConvertionInfo.from_id)
}

// required string to_id = 2;
inline bool CurrencyConvertionInfo::has_to_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrencyConvertionInfo::set_has_to_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrencyConvertionInfo::clear_has_to_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrencyConvertionInfo::clear_to_id() {
  to_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to_id();
}
inline const ::std::string& CurrencyConvertionInfo::to_id() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencyConvertionInfo.to_id)
  return to_id_.GetNoArena();
}
inline void CurrencyConvertionInfo::set_to_id(const ::std::string& value) {
  set_has_to_id();
  to_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencyConvertionInfo.to_id)
}
#if LANG_CXX11
inline void CurrencyConvertionInfo::set_to_id(::std::string&& value) {
  set_has_to_id();
  to_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.CurrencyConvertionInfo.to_id)
}
#endif
inline void CurrencyConvertionInfo::set_to_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to_id();
  to_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.CurrencyConvertionInfo.to_id)
}
inline void CurrencyConvertionInfo::set_to_id(const char* value, size_t size) {
  set_has_to_id();
  to_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.CurrencyConvertionInfo.to_id)
}
inline ::std::string* CurrencyConvertionInfo::mutable_to_id() {
  set_has_to_id();
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencyConvertionInfo.to_id)
  return to_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrencyConvertionInfo::release_to_id() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencyConvertionInfo.to_id)
  clear_has_to_id();
  return to_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrencyConvertionInfo::set_allocated_to_id(::std::string* to_id) {
  if (to_id != NULL) {
    set_has_to_id();
  } else {
    clear_has_to_id();
  }
  to_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_id);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencyConvertionInfo.to_id)
}

// required string a_coeff_numerator = 3;
inline bool CurrencyConvertionInfo::has_a_coeff_numerator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CurrencyConvertionInfo::set_has_a_coeff_numerator() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CurrencyConvertionInfo::clear_has_a_coeff_numerator() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CurrencyConvertionInfo::clear_a_coeff_numerator() {
  a_coeff_numerator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_a_coeff_numerator();
}
inline const ::std::string& CurrencyConvertionInfo::a_coeff_numerator() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencyConvertionInfo.a_coeff_numerator)
  return a_coeff_numerator_.GetNoArena();
}
inline void CurrencyConvertionInfo::set_a_coeff_numerator(const ::std::string& value) {
  set_has_a_coeff_numerator();
  a_coeff_numerator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencyConvertionInfo.a_coeff_numerator)
}
#if LANG_CXX11
inline void CurrencyConvertionInfo::set_a_coeff_numerator(::std::string&& value) {
  set_has_a_coeff_numerator();
  a_coeff_numerator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.CurrencyConvertionInfo.a_coeff_numerator)
}
#endif
inline void CurrencyConvertionInfo::set_a_coeff_numerator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_a_coeff_numerator();
  a_coeff_numerator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.CurrencyConvertionInfo.a_coeff_numerator)
}
inline void CurrencyConvertionInfo::set_a_coeff_numerator(const char* value, size_t size) {
  set_has_a_coeff_numerator();
  a_coeff_numerator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.CurrencyConvertionInfo.a_coeff_numerator)
}
inline ::std::string* CurrencyConvertionInfo::mutable_a_coeff_numerator() {
  set_has_a_coeff_numerator();
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencyConvertionInfo.a_coeff_numerator)
  return a_coeff_numerator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrencyConvertionInfo::release_a_coeff_numerator() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencyConvertionInfo.a_coeff_numerator)
  clear_has_a_coeff_numerator();
  return a_coeff_numerator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrencyConvertionInfo::set_allocated_a_coeff_numerator(::std::string* a_coeff_numerator) {
  if (a_coeff_numerator != NULL) {
    set_has_a_coeff_numerator();
  } else {
    clear_has_a_coeff_numerator();
  }
  a_coeff_numerator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), a_coeff_numerator);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencyConvertionInfo.a_coeff_numerator)
}

// required string a_coeff_denominator = 4;
inline bool CurrencyConvertionInfo::has_a_coeff_denominator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CurrencyConvertionInfo::set_has_a_coeff_denominator() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CurrencyConvertionInfo::clear_has_a_coeff_denominator() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CurrencyConvertionInfo::clear_a_coeff_denominator() {
  a_coeff_denominator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_a_coeff_denominator();
}
inline const ::std::string& CurrencyConvertionInfo::a_coeff_denominator() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencyConvertionInfo.a_coeff_denominator)
  return a_coeff_denominator_.GetNoArena();
}
inline void CurrencyConvertionInfo::set_a_coeff_denominator(const ::std::string& value) {
  set_has_a_coeff_denominator();
  a_coeff_denominator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencyConvertionInfo.a_coeff_denominator)
}
#if LANG_CXX11
inline void CurrencyConvertionInfo::set_a_coeff_denominator(::std::string&& value) {
  set_has_a_coeff_denominator();
  a_coeff_denominator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.CurrencyConvertionInfo.a_coeff_denominator)
}
#endif
inline void CurrencyConvertionInfo::set_a_coeff_denominator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_a_coeff_denominator();
  a_coeff_denominator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.CurrencyConvertionInfo.a_coeff_denominator)
}
inline void CurrencyConvertionInfo::set_a_coeff_denominator(const char* value, size_t size) {
  set_has_a_coeff_denominator();
  a_coeff_denominator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.CurrencyConvertionInfo.a_coeff_denominator)
}
inline ::std::string* CurrencyConvertionInfo::mutable_a_coeff_denominator() {
  set_has_a_coeff_denominator();
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencyConvertionInfo.a_coeff_denominator)
  return a_coeff_denominator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrencyConvertionInfo::release_a_coeff_denominator() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencyConvertionInfo.a_coeff_denominator)
  clear_has_a_coeff_denominator();
  return a_coeff_denominator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrencyConvertionInfo::set_allocated_a_coeff_denominator(::std::string* a_coeff_denominator) {
  if (a_coeff_denominator != NULL) {
    set_has_a_coeff_denominator();
  } else {
    clear_has_a_coeff_denominator();
  }
  a_coeff_denominator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), a_coeff_denominator);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencyConvertionInfo.a_coeff_denominator)
}

// required uint64 time = 5;
inline bool CurrencyConvertionInfo::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CurrencyConvertionInfo::set_has_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CurrencyConvertionInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CurrencyConvertionInfo::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 CurrencyConvertionInfo::time() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencyConvertionInfo.time)
  return time_;
}
inline void CurrencyConvertionInfo::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencyConvertionInfo.time)
}

// optional string source_id = 6;
inline bool CurrencyConvertionInfo::has_source_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CurrencyConvertionInfo::set_has_source_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CurrencyConvertionInfo::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CurrencyConvertionInfo::clear_source_id() {
  source_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source_id();
}
inline const ::std::string& CurrencyConvertionInfo::source_id() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencyConvertionInfo.source_id)
  return source_id_.GetNoArena();
}
inline void CurrencyConvertionInfo::set_source_id(const ::std::string& value) {
  set_has_source_id();
  source_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencyConvertionInfo.source_id)
}
#if LANG_CXX11
inline void CurrencyConvertionInfo::set_source_id(::std::string&& value) {
  set_has_source_id();
  source_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.CurrencyConvertionInfo.source_id)
}
#endif
inline void CurrencyConvertionInfo::set_source_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_id();
  source_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.CurrencyConvertionInfo.source_id)
}
inline void CurrencyConvertionInfo::set_source_id(const char* value, size_t size) {
  set_has_source_id();
  source_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.CurrencyConvertionInfo.source_id)
}
inline ::std::string* CurrencyConvertionInfo::mutable_source_id() {
  set_has_source_id();
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencyConvertionInfo.source_id)
  return source_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrencyConvertionInfo::release_source_id() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencyConvertionInfo.source_id)
  clear_has_source_id();
  return source_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrencyConvertionInfo::set_allocated_source_id(::std::string* source_id) {
  if (source_id != NULL) {
    set_has_source_id();
  } else {
    clear_has_source_id();
  }
  source_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_id);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencyConvertionInfo.source_id)
}

// optional string link = 7;
inline bool CurrencyConvertionInfo::has_link() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CurrencyConvertionInfo::set_has_link() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CurrencyConvertionInfo::clear_has_link() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CurrencyConvertionInfo::clear_link() {
  link_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link();
}
inline const ::std::string& CurrencyConvertionInfo::link() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencyConvertionInfo.link)
  return link_.GetNoArena();
}
inline void CurrencyConvertionInfo::set_link(const ::std::string& value) {
  set_has_link();
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencyConvertionInfo.link)
}
#if LANG_CXX11
inline void CurrencyConvertionInfo::set_link(::std::string&& value) {
  set_has_link();
  link_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.CurrencyConvertionInfo.link)
}
#endif
inline void CurrencyConvertionInfo::set_link(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_link();
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.CurrencyConvertionInfo.link)
}
inline void CurrencyConvertionInfo::set_link(const char* value, size_t size) {
  set_has_link();
  link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.CurrencyConvertionInfo.link)
}
inline ::std::string* CurrencyConvertionInfo::mutable_link() {
  set_has_link();
  // @@protoc_insertion_point(field_mutable:converterd.pb.CurrencyConvertionInfo.link)
  return link_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrencyConvertionInfo::release_link() {
  // @@protoc_insertion_point(field_release:converterd.pb.CurrencyConvertionInfo.link)
  clear_has_link();
  return link_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrencyConvertionInfo::set_allocated_link(::std::string* link) {
  if (link != NULL) {
    set_has_link();
  } else {
    clear_has_link();
  }
  link_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.CurrencyConvertionInfo.link)
}

// required bool is_live = 8;
inline bool CurrencyConvertionInfo::has_is_live() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CurrencyConvertionInfo::set_has_is_live() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CurrencyConvertionInfo::clear_has_is_live() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CurrencyConvertionInfo::clear_is_live() {
  is_live_ = false;
  clear_has_is_live();
}
inline bool CurrencyConvertionInfo::is_live() const {
  // @@protoc_insertion_point(field_get:converterd.pb.CurrencyConvertionInfo.is_live)
  return is_live_;
}
inline void CurrencyConvertionInfo::set_is_live(bool value) {
  set_has_is_live();
  is_live_ = value;
  // @@protoc_insertion_point(field_set:converterd.pb.CurrencyConvertionInfo.is_live)
}

// -------------------------------------------------------------------

// MeasureTypeInfo

// required string id = 1;
inline bool MeasureTypeInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeasureTypeInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeasureTypeInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeasureTypeInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& MeasureTypeInfo::id() const {
  // @@protoc_insertion_point(field_get:converterd.pb.MeasureTypeInfo.id)
  return id_.GetNoArena();
}
inline void MeasureTypeInfo::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.MeasureTypeInfo.id)
}
#if LANG_CXX11
inline void MeasureTypeInfo::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.MeasureTypeInfo.id)
}
#endif
inline void MeasureTypeInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.MeasureTypeInfo.id)
}
inline void MeasureTypeInfo::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.MeasureTypeInfo.id)
}
inline ::std::string* MeasureTypeInfo::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:converterd.pb.MeasureTypeInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeasureTypeInfo::release_id() {
  // @@protoc_insertion_point(field_release:converterd.pb.MeasureTypeInfo.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeasureTypeInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.MeasureTypeInfo.id)
}

// required string name = 2;
inline bool MeasureTypeInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MeasureTypeInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MeasureTypeInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MeasureTypeInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MeasureTypeInfo::name() const {
  // @@protoc_insertion_point(field_get:converterd.pb.MeasureTypeInfo.name)
  return name_.GetNoArena();
}
inline void MeasureTypeInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.MeasureTypeInfo.name)
}
#if LANG_CXX11
inline void MeasureTypeInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.MeasureTypeInfo.name)
}
#endif
inline void MeasureTypeInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.MeasureTypeInfo.name)
}
inline void MeasureTypeInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.MeasureTypeInfo.name)
}
inline ::std::string* MeasureTypeInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:converterd.pb.MeasureTypeInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeasureTypeInfo::release_name() {
  // @@protoc_insertion_point(field_release:converterd.pb.MeasureTypeInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeasureTypeInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.MeasureTypeInfo.name)
}

// required string base_id = 3;
inline bool MeasureTypeInfo::has_base_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MeasureTypeInfo::set_has_base_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MeasureTypeInfo::clear_has_base_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MeasureTypeInfo::clear_base_id() {
  base_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_base_id();
}
inline const ::std::string& MeasureTypeInfo::base_id() const {
  // @@protoc_insertion_point(field_get:converterd.pb.MeasureTypeInfo.base_id)
  return base_id_.GetNoArena();
}
inline void MeasureTypeInfo::set_base_id(const ::std::string& value) {
  set_has_base_id();
  base_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.MeasureTypeInfo.base_id)
}
#if LANG_CXX11
inline void MeasureTypeInfo::set_base_id(::std::string&& value) {
  set_has_base_id();
  base_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.MeasureTypeInfo.base_id)
}
#endif
inline void MeasureTypeInfo::set_base_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_base_id();
  base_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.MeasureTypeInfo.base_id)
}
inline void MeasureTypeInfo::set_base_id(const char* value, size_t size) {
  set_has_base_id();
  base_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.MeasureTypeInfo.base_id)
}
inline ::std::string* MeasureTypeInfo::mutable_base_id() {
  set_has_base_id();
  // @@protoc_insertion_point(field_mutable:converterd.pb.MeasureTypeInfo.base_id)
  return base_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeasureTypeInfo::release_base_id() {
  // @@protoc_insertion_point(field_release:converterd.pb.MeasureTypeInfo.base_id)
  clear_has_base_id();
  return base_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeasureTypeInfo::set_allocated_base_id(::std::string* base_id) {
  if (base_id != NULL) {
    set_has_base_id();
  } else {
    clear_has_base_id();
  }
  base_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), base_id);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.MeasureTypeInfo.base_id)
}

// -------------------------------------------------------------------

// MeasureInfo

// required string id = 1;
inline bool MeasureInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeasureInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeasureInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeasureInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& MeasureInfo::id() const {
  // @@protoc_insertion_point(field_get:converterd.pb.MeasureInfo.id)
  return id_.GetNoArena();
}
inline void MeasureInfo::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.MeasureInfo.id)
}
#if LANG_CXX11
inline void MeasureInfo::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.MeasureInfo.id)
}
#endif
inline void MeasureInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.MeasureInfo.id)
}
inline void MeasureInfo::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.MeasureInfo.id)
}
inline ::std::string* MeasureInfo::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:converterd.pb.MeasureInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeasureInfo::release_id() {
  // @@protoc_insertion_point(field_release:converterd.pb.MeasureInfo.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeasureInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.MeasureInfo.id)
}

// required .converterd.pb.DeclensionInfo declensions = 2;
inline bool MeasureInfo::has_declensions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MeasureInfo::set_has_declensions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MeasureInfo::clear_has_declensions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MeasureInfo::clear_declensions() {
  if (declensions_ != NULL) declensions_->::converterd::pb::DeclensionInfo::Clear();
  clear_has_declensions();
}
inline const ::converterd::pb::DeclensionInfo& MeasureInfo::declensions() const {
  const ::converterd::pb::DeclensionInfo* p = declensions_;
  // @@protoc_insertion_point(field_get:converterd.pb.MeasureInfo.declensions)
  return p != NULL ? *p : *reinterpret_cast<const ::converterd::pb::DeclensionInfo*>(
      &::converterd::pb::_DeclensionInfo_default_instance_);
}
inline ::converterd::pb::DeclensionInfo* MeasureInfo::mutable_declensions() {
  set_has_declensions();
  if (declensions_ == NULL) {
    declensions_ = new ::converterd::pb::DeclensionInfo;
  }
  // @@protoc_insertion_point(field_mutable:converterd.pb.MeasureInfo.declensions)
  return declensions_;
}
inline ::converterd::pb::DeclensionInfo* MeasureInfo::release_declensions() {
  // @@protoc_insertion_point(field_release:converterd.pb.MeasureInfo.declensions)
  clear_has_declensions();
  ::converterd::pb::DeclensionInfo* temp = declensions_;
  declensions_ = NULL;
  return temp;
}
inline void MeasureInfo::set_allocated_declensions(::converterd::pb::DeclensionInfo* declensions) {
  delete declensions_;
  declensions_ = declensions;
  if (declensions) {
    set_has_declensions();
  } else {
    clear_has_declensions();
  }
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.MeasureInfo.declensions)
}

// required bool is_optional = 3;
inline bool MeasureInfo::has_is_optional() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MeasureInfo::set_has_is_optional() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MeasureInfo::clear_has_is_optional() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MeasureInfo::clear_is_optional() {
  is_optional_ = false;
  clear_has_is_optional();
}
inline bool MeasureInfo::is_optional() const {
  // @@protoc_insertion_point(field_get:converterd.pb.MeasureInfo.is_optional)
  return is_optional_;
}
inline void MeasureInfo::set_is_optional(bool value) {
  set_has_is_optional();
  is_optional_ = value;
  // @@protoc_insertion_point(field_set:converterd.pb.MeasureInfo.is_optional)
}

// -------------------------------------------------------------------

// MeasureConvertionInfo

// required string from_id = 1;
inline bool MeasureConvertionInfo::has_from_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeasureConvertionInfo::set_has_from_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeasureConvertionInfo::clear_has_from_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeasureConvertionInfo::clear_from_id() {
  from_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from_id();
}
inline const ::std::string& MeasureConvertionInfo::from_id() const {
  // @@protoc_insertion_point(field_get:converterd.pb.MeasureConvertionInfo.from_id)
  return from_id_.GetNoArena();
}
inline void MeasureConvertionInfo::set_from_id(const ::std::string& value) {
  set_has_from_id();
  from_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.MeasureConvertionInfo.from_id)
}
#if LANG_CXX11
inline void MeasureConvertionInfo::set_from_id(::std::string&& value) {
  set_has_from_id();
  from_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.MeasureConvertionInfo.from_id)
}
#endif
inline void MeasureConvertionInfo::set_from_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from_id();
  from_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.MeasureConvertionInfo.from_id)
}
inline void MeasureConvertionInfo::set_from_id(const char* value, size_t size) {
  set_has_from_id();
  from_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.MeasureConvertionInfo.from_id)
}
inline ::std::string* MeasureConvertionInfo::mutable_from_id() {
  set_has_from_id();
  // @@protoc_insertion_point(field_mutable:converterd.pb.MeasureConvertionInfo.from_id)
  return from_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeasureConvertionInfo::release_from_id() {
  // @@protoc_insertion_point(field_release:converterd.pb.MeasureConvertionInfo.from_id)
  clear_has_from_id();
  return from_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeasureConvertionInfo::set_allocated_from_id(::std::string* from_id) {
  if (from_id != NULL) {
    set_has_from_id();
  } else {
    clear_has_from_id();
  }
  from_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_id);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.MeasureConvertionInfo.from_id)
}

// required string to_id = 2;
inline bool MeasureConvertionInfo::has_to_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MeasureConvertionInfo::set_has_to_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MeasureConvertionInfo::clear_has_to_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MeasureConvertionInfo::clear_to_id() {
  to_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to_id();
}
inline const ::std::string& MeasureConvertionInfo::to_id() const {
  // @@protoc_insertion_point(field_get:converterd.pb.MeasureConvertionInfo.to_id)
  return to_id_.GetNoArena();
}
inline void MeasureConvertionInfo::set_to_id(const ::std::string& value) {
  set_has_to_id();
  to_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.MeasureConvertionInfo.to_id)
}
#if LANG_CXX11
inline void MeasureConvertionInfo::set_to_id(::std::string&& value) {
  set_has_to_id();
  to_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.MeasureConvertionInfo.to_id)
}
#endif
inline void MeasureConvertionInfo::set_to_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to_id();
  to_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.MeasureConvertionInfo.to_id)
}
inline void MeasureConvertionInfo::set_to_id(const char* value, size_t size) {
  set_has_to_id();
  to_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.MeasureConvertionInfo.to_id)
}
inline ::std::string* MeasureConvertionInfo::mutable_to_id() {
  set_has_to_id();
  // @@protoc_insertion_point(field_mutable:converterd.pb.MeasureConvertionInfo.to_id)
  return to_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeasureConvertionInfo::release_to_id() {
  // @@protoc_insertion_point(field_release:converterd.pb.MeasureConvertionInfo.to_id)
  clear_has_to_id();
  return to_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeasureConvertionInfo::set_allocated_to_id(::std::string* to_id) {
  if (to_id != NULL) {
    set_has_to_id();
  } else {
    clear_has_to_id();
  }
  to_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_id);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.MeasureConvertionInfo.to_id)
}

// required string a_coeff = 3;
inline bool MeasureConvertionInfo::has_a_coeff() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MeasureConvertionInfo::set_has_a_coeff() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MeasureConvertionInfo::clear_has_a_coeff() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MeasureConvertionInfo::clear_a_coeff() {
  a_coeff_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_a_coeff();
}
inline const ::std::string& MeasureConvertionInfo::a_coeff() const {
  // @@protoc_insertion_point(field_get:converterd.pb.MeasureConvertionInfo.a_coeff)
  return a_coeff_.GetNoArena();
}
inline void MeasureConvertionInfo::set_a_coeff(const ::std::string& value) {
  set_has_a_coeff();
  a_coeff_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.MeasureConvertionInfo.a_coeff)
}
#if LANG_CXX11
inline void MeasureConvertionInfo::set_a_coeff(::std::string&& value) {
  set_has_a_coeff();
  a_coeff_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.MeasureConvertionInfo.a_coeff)
}
#endif
inline void MeasureConvertionInfo::set_a_coeff(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_a_coeff();
  a_coeff_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.MeasureConvertionInfo.a_coeff)
}
inline void MeasureConvertionInfo::set_a_coeff(const char* value, size_t size) {
  set_has_a_coeff();
  a_coeff_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.MeasureConvertionInfo.a_coeff)
}
inline ::std::string* MeasureConvertionInfo::mutable_a_coeff() {
  set_has_a_coeff();
  // @@protoc_insertion_point(field_mutable:converterd.pb.MeasureConvertionInfo.a_coeff)
  return a_coeff_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeasureConvertionInfo::release_a_coeff() {
  // @@protoc_insertion_point(field_release:converterd.pb.MeasureConvertionInfo.a_coeff)
  clear_has_a_coeff();
  return a_coeff_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeasureConvertionInfo::set_allocated_a_coeff(::std::string* a_coeff) {
  if (a_coeff != NULL) {
    set_has_a_coeff();
  } else {
    clear_has_a_coeff();
  }
  a_coeff_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), a_coeff);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.MeasureConvertionInfo.a_coeff)
}

// required string b_coeff = 4;
inline bool MeasureConvertionInfo::has_b_coeff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MeasureConvertionInfo::set_has_b_coeff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MeasureConvertionInfo::clear_has_b_coeff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MeasureConvertionInfo::clear_b_coeff() {
  b_coeff_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_b_coeff();
}
inline const ::std::string& MeasureConvertionInfo::b_coeff() const {
  // @@protoc_insertion_point(field_get:converterd.pb.MeasureConvertionInfo.b_coeff)
  return b_coeff_.GetNoArena();
}
inline void MeasureConvertionInfo::set_b_coeff(const ::std::string& value) {
  set_has_b_coeff();
  b_coeff_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:converterd.pb.MeasureConvertionInfo.b_coeff)
}
#if LANG_CXX11
inline void MeasureConvertionInfo::set_b_coeff(::std::string&& value) {
  set_has_b_coeff();
  b_coeff_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:converterd.pb.MeasureConvertionInfo.b_coeff)
}
#endif
inline void MeasureConvertionInfo::set_b_coeff(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_b_coeff();
  b_coeff_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:converterd.pb.MeasureConvertionInfo.b_coeff)
}
inline void MeasureConvertionInfo::set_b_coeff(const char* value, size_t size) {
  set_has_b_coeff();
  b_coeff_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:converterd.pb.MeasureConvertionInfo.b_coeff)
}
inline ::std::string* MeasureConvertionInfo::mutable_b_coeff() {
  set_has_b_coeff();
  // @@protoc_insertion_point(field_mutable:converterd.pb.MeasureConvertionInfo.b_coeff)
  return b_coeff_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeasureConvertionInfo::release_b_coeff() {
  // @@protoc_insertion_point(field_release:converterd.pb.MeasureConvertionInfo.b_coeff)
  clear_has_b_coeff();
  return b_coeff_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeasureConvertionInfo::set_allocated_b_coeff(::std::string* b_coeff) {
  if (b_coeff != NULL) {
    set_has_b_coeff();
  } else {
    clear_has_b_coeff();
  }
  b_coeff_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), b_coeff);
  // @@protoc_insertion_point(field_set_allocated:converterd.pb.MeasureConvertionInfo.b_coeff)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace pb
}  // namespace converterd

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_converter_5fadditive_5fstorage_2eproto__INCLUDED
