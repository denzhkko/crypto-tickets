// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmo_binlog.proto

#ifndef PROTOBUF_cosmo_5fbinlog_2eproto__INCLUDED
#define PROTOBUF_cosmo_5fbinlog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "cosmo.pb.h"
// @@protoc_insertion_point(includes)
namespace cosmo {
namespace pb {
class BinLogEvent;
class BinLogEventDefaultTypeInternal;
extern BinLogEventDefaultTypeInternal _BinLogEvent_default_instance_;
class BinLogEvent_EventData;
class BinLogEvent_EventDataDefaultTypeInternal;
extern BinLogEvent_EventDataDefaultTypeInternal _BinLogEvent_EventData_default_instance_;
class PropertyVersion;
class PropertyVersionDefaultTypeInternal;
extern PropertyVersionDefaultTypeInternal _PropertyVersion_default_instance_;
}  // namespace pb
}  // namespace cosmo

namespace cosmo {
namespace pb {

namespace protobuf_cosmo_5fbinlog_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_cosmo_5fbinlog_2eproto

enum PropertyVersion_Provider {
  PropertyVersion_Provider_UNKNOWN = 0,
  PropertyVersion_Provider_SOURCE = 1,
  PropertyVersion_Provider_DOCUMENT = 2
};
bool PropertyVersion_Provider_IsValid(int value);
const PropertyVersion_Provider PropertyVersion_Provider_Provider_MIN = PropertyVersion_Provider_UNKNOWN;
const PropertyVersion_Provider PropertyVersion_Provider_Provider_MAX = PropertyVersion_Provider_DOCUMENT;
const int PropertyVersion_Provider_Provider_ARRAYSIZE = PropertyVersion_Provider_Provider_MAX + 1;

const ::google::protobuf::EnumDescriptor* PropertyVersion_Provider_descriptor();
inline const ::std::string& PropertyVersion_Provider_Name(PropertyVersion_Provider value) {
  return ::google::protobuf::internal::NameOfEnum(
    PropertyVersion_Provider_descriptor(), value);
}
inline bool PropertyVersion_Provider_Parse(
    const ::std::string& name, PropertyVersion_Provider* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PropertyVersion_Provider>(
    PropertyVersion_Provider_descriptor(), name, value);
}
enum BinLogEvent_EventType {
  BinLogEvent_EventType_UNKNOWN_EVENT = 0,
  BinLogEvent_EventType_LOG_START = 1,
  BinLogEvent_EventType_WRITE_EVENT = 2,
  BinLogEvent_EventType_UPDATE_EVENT = 3,
  BinLogEvent_EventType_START_SNAPSHOT_EVENT = 4,
  BinLogEvent_EventType_FINISH_SNAPSHOT_EVENT = 5,
  BinLogEvent_EventType_DELETE_EVENT = 6
};
bool BinLogEvent_EventType_IsValid(int value);
const BinLogEvent_EventType BinLogEvent_EventType_EventType_MIN = BinLogEvent_EventType_UNKNOWN_EVENT;
const BinLogEvent_EventType BinLogEvent_EventType_EventType_MAX = BinLogEvent_EventType_DELETE_EVENT;
const int BinLogEvent_EventType_EventType_ARRAYSIZE = BinLogEvent_EventType_EventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BinLogEvent_EventType_descriptor();
inline const ::std::string& BinLogEvent_EventType_Name(BinLogEvent_EventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BinLogEvent_EventType_descriptor(), value);
}
inline bool BinLogEvent_EventType_Parse(
    const ::std::string& name, BinLogEvent_EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BinLogEvent_EventType>(
    BinLogEvent_EventType_descriptor(), name, value);
}
// ===================================================================

class PropertyVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cosmo.pb.PropertyVersion) */ {
 public:
  PropertyVersion();
  virtual ~PropertyVersion();

  PropertyVersion(const PropertyVersion& from);

  inline PropertyVersion& operator=(const PropertyVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PropertyVersion(PropertyVersion&& from) noexcept
    : PropertyVersion() {
    *this = ::std::move(from);
  }

  inline PropertyVersion& operator=(PropertyVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PropertyVersion& default_instance();

  static inline const PropertyVersion* internal_default_instance() {
    return reinterpret_cast<const PropertyVersion*>(
               &_PropertyVersion_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(PropertyVersion* other);
  friend void swap(PropertyVersion& a, PropertyVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PropertyVersion* New() const PROTOBUF_FINAL { return New(NULL); }

  PropertyVersion* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PropertyVersion& from);
  void MergeFrom(const PropertyVersion& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PropertyVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PropertyVersion_Provider Provider;
  static const Provider UNKNOWN =
    PropertyVersion_Provider_UNKNOWN;
  static const Provider SOURCE =
    PropertyVersion_Provider_SOURCE;
  static const Provider DOCUMENT =
    PropertyVersion_Provider_DOCUMENT;
  static inline bool Provider_IsValid(int value) {
    return PropertyVersion_Provider_IsValid(value);
  }
  static const Provider Provider_MIN =
    PropertyVersion_Provider_Provider_MIN;
  static const Provider Provider_MAX =
    PropertyVersion_Provider_Provider_MAX;
  static const int Provider_ARRAYSIZE =
    PropertyVersion_Provider_Provider_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Provider_descriptor() {
    return PropertyVersion_Provider_descriptor();
  }
  static inline const ::std::string& Provider_Name(Provider value) {
    return PropertyVersion_Provider_Name(value);
  }
  static inline bool Provider_Parse(const ::std::string& name,
      Provider* value) {
    return PropertyVersion_Provider_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .cosmo.pb.PropertyVersion.Provider provider = 1;
  bool has_provider() const;
  void clear_provider();
  static const int kProviderFieldNumber = 1;
  ::cosmo::pb::PropertyVersion_Provider provider() const;
  void set_provider(::cosmo::pb::PropertyVersion_Provider value);

  // required uint32 version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cosmo.pb.PropertyVersion)
 private:
  void set_has_provider();
  void clear_has_provider();
  void set_has_name();
  void clear_has_name();
  void set_has_version();
  void clear_has_version();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int provider_;
  ::google::protobuf::uint32 version_;
  friend struct protobuf_cosmo_5fbinlog_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinLogEvent_EventData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cosmo.pb.BinLogEvent.EventData) */ {
 public:
  BinLogEvent_EventData();
  virtual ~BinLogEvent_EventData();

  BinLogEvent_EventData(const BinLogEvent_EventData& from);

  inline BinLogEvent_EventData& operator=(const BinLogEvent_EventData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinLogEvent_EventData(BinLogEvent_EventData&& from) noexcept
    : BinLogEvent_EventData() {
    *this = ::std::move(from);
  }

  inline BinLogEvent_EventData& operator=(BinLogEvent_EventData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BinLogEvent_EventData& default_instance();

  static inline const BinLogEvent_EventData* internal_default_instance() {
    return reinterpret_cast<const BinLogEvent_EventData*>(
               &_BinLogEvent_EventData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(BinLogEvent_EventData* other);
  friend void swap(BinLogEvent_EventData& a, BinLogEvent_EventData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinLogEvent_EventData* New() const PROTOBUF_FINAL { return New(NULL); }

  BinLogEvent_EventData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BinLogEvent_EventData& from);
  void MergeFrom(const BinLogEvent_EventData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BinLogEvent_EventData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cosmo.pb.SourceData source_data = 1;
  bool has_source_data() const;
  void clear_source_data();
  static const int kSourceDataFieldNumber = 1;
  const ::cosmo::pb::SourceData& source_data() const;
  ::cosmo::pb::SourceData* mutable_source_data();
  ::cosmo::pb::SourceData* release_source_data();
  void set_allocated_source_data(::cosmo::pb::SourceData* source_data);

  // optional .cosmo.pb.DocumentData document_data = 2;
  bool has_document_data() const;
  void clear_document_data();
  static const int kDocumentDataFieldNumber = 2;
  const ::cosmo::pb::DocumentData& document_data() const;
  ::cosmo::pb::DocumentData* mutable_document_data();
  ::cosmo::pb::DocumentData* release_document_data();
  void set_allocated_document_data(::cosmo::pb::DocumentData* document_data);

  // optional .cosmo.pb.DocumentSourceLink document_source_link = 3;
  bool has_document_source_link() const;
  void clear_document_source_link();
  static const int kDocumentSourceLinkFieldNumber = 3;
  const ::cosmo::pb::DocumentSourceLink& document_source_link() const;
  ::cosmo::pb::DocumentSourceLink* mutable_document_source_link();
  ::cosmo::pb::DocumentSourceLink* release_document_source_link();
  void set_allocated_document_source_link(::cosmo::pb::DocumentSourceLink* document_source_link);

  // optional .cosmo.pb.PropertyVersion property_version = 4;
  bool has_property_version() const;
  void clear_property_version();
  static const int kPropertyVersionFieldNumber = 4;
  const ::cosmo::pb::PropertyVersion& property_version() const;
  ::cosmo::pb::PropertyVersion* mutable_property_version();
  ::cosmo::pb::PropertyVersion* release_property_version();
  void set_allocated_property_version(::cosmo::pb::PropertyVersion* property_version);

  // @@protoc_insertion_point(class_scope:cosmo.pb.BinLogEvent.EventData)
 private:
  void set_has_source_data();
  void clear_has_source_data();
  void set_has_document_data();
  void clear_has_document_data();
  void set_has_document_source_link();
  void clear_has_document_source_link();
  void set_has_property_version();
  void clear_has_property_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::cosmo::pb::SourceData* source_data_;
  ::cosmo::pb::DocumentData* document_data_;
  ::cosmo::pb::DocumentSourceLink* document_source_link_;
  ::cosmo::pb::PropertyVersion* property_version_;
  friend struct protobuf_cosmo_5fbinlog_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinLogEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cosmo.pb.BinLogEvent) */ {
 public:
  BinLogEvent();
  virtual ~BinLogEvent();

  BinLogEvent(const BinLogEvent& from);

  inline BinLogEvent& operator=(const BinLogEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinLogEvent(BinLogEvent&& from) noexcept
    : BinLogEvent() {
    *this = ::std::move(from);
  }

  inline BinLogEvent& operator=(BinLogEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BinLogEvent& default_instance();

  static inline const BinLogEvent* internal_default_instance() {
    return reinterpret_cast<const BinLogEvent*>(
               &_BinLogEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(BinLogEvent* other);
  friend void swap(BinLogEvent& a, BinLogEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinLogEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  BinLogEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BinLogEvent& from);
  void MergeFrom(const BinLogEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BinLogEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef BinLogEvent_EventData EventData;

  typedef BinLogEvent_EventType EventType;
  static const EventType UNKNOWN_EVENT =
    BinLogEvent_EventType_UNKNOWN_EVENT;
  static const EventType LOG_START =
    BinLogEvent_EventType_LOG_START;
  static const EventType WRITE_EVENT =
    BinLogEvent_EventType_WRITE_EVENT;
  static const EventType UPDATE_EVENT =
    BinLogEvent_EventType_UPDATE_EVENT;
  static const EventType START_SNAPSHOT_EVENT =
    BinLogEvent_EventType_START_SNAPSHOT_EVENT;
  static const EventType FINISH_SNAPSHOT_EVENT =
    BinLogEvent_EventType_FINISH_SNAPSHOT_EVENT;
  static const EventType DELETE_EVENT =
    BinLogEvent_EventType_DELETE_EVENT;
  static inline bool EventType_IsValid(int value) {
    return BinLogEvent_EventType_IsValid(value);
  }
  static const EventType EventType_MIN =
    BinLogEvent_EventType_EventType_MIN;
  static const EventType EventType_MAX =
    BinLogEvent_EventType_EventType_MAX;
  static const int EventType_ARRAYSIZE =
    BinLogEvent_EventType_EventType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EventType_descriptor() {
    return BinLogEvent_EventType_descriptor();
  }
  static inline const ::std::string& EventType_Name(EventType value) {
    return BinLogEvent_EventType_Name(value);
  }
  static inline bool EventType_Parse(const ::std::string& name,
      EventType* value) {
    return BinLogEvent_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .cosmo.pb.BinLogEvent.EventData data = 5;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::cosmo::pb::BinLogEvent_EventData& data() const;
  ::cosmo::pb::BinLogEvent_EventData* mutable_data();
  ::cosmo::pb::BinLogEvent_EventData* release_data();
  void set_allocated_data(::cosmo::pb::BinLogEvent_EventData* data);

  // required int64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // required int64 epoch = 2;
  bool has_epoch() const;
  void clear_epoch();
  static const int kEpochFieldNumber = 2;
  ::google::protobuf::int64 epoch() const;
  void set_epoch(::google::protobuf::int64 value);

  // required int32 shard = 3;
  bool has_shard() const;
  void clear_shard();
  static const int kShardFieldNumber = 3;
  ::google::protobuf::int32 shard() const;
  void set_shard(::google::protobuf::int32 value);

  // required .cosmo.pb.BinLogEvent.EventType type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::cosmo::pb::BinLogEvent_EventType type() const;
  void set_type(::cosmo::pb::BinLogEvent_EventType value);

  // @@protoc_insertion_point(class_scope:cosmo.pb.BinLogEvent)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_epoch();
  void clear_has_epoch();
  void set_has_shard();
  void clear_has_shard();
  void set_has_type();
  void clear_has_type();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::cosmo::pb::BinLogEvent_EventData* data_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 epoch_;
  ::google::protobuf::int32 shard_;
  int type_;
  friend struct protobuf_cosmo_5fbinlog_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PropertyVersion

// required .cosmo.pb.PropertyVersion.Provider provider = 1;
inline bool PropertyVersion::has_provider() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyVersion::set_has_provider() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PropertyVersion::clear_has_provider() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PropertyVersion::clear_provider() {
  provider_ = 0;
  clear_has_provider();
}
inline ::cosmo::pb::PropertyVersion_Provider PropertyVersion::provider() const {
  // @@protoc_insertion_point(field_get:cosmo.pb.PropertyVersion.provider)
  return static_cast< ::cosmo::pb::PropertyVersion_Provider >(provider_);
}
inline void PropertyVersion::set_provider(::cosmo::pb::PropertyVersion_Provider value) {
  assert(::cosmo::pb::PropertyVersion_Provider_IsValid(value));
  set_has_provider();
  provider_ = value;
  // @@protoc_insertion_point(field_set:cosmo.pb.PropertyVersion.provider)
}

// required string name = 2;
inline bool PropertyVersion::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyVersion::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertyVersion::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertyVersion::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& PropertyVersion::name() const {
  // @@protoc_insertion_point(field_get:cosmo.pb.PropertyVersion.name)
  return name_.GetNoArena();
}
inline void PropertyVersion::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cosmo.pb.PropertyVersion.name)
}
#if LANG_CXX11
inline void PropertyVersion::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cosmo.pb.PropertyVersion.name)
}
#endif
inline void PropertyVersion::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cosmo.pb.PropertyVersion.name)
}
inline void PropertyVersion::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cosmo.pb.PropertyVersion.name)
}
inline ::std::string* PropertyVersion::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:cosmo.pb.PropertyVersion.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PropertyVersion::release_name() {
  // @@protoc_insertion_point(field_release:cosmo.pb.PropertyVersion.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyVersion::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:cosmo.pb.PropertyVersion.name)
}

// required uint32 version = 3;
inline bool PropertyVersion::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PropertyVersion::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PropertyVersion::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PropertyVersion::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 PropertyVersion::version() const {
  // @@protoc_insertion_point(field_get:cosmo.pb.PropertyVersion.version)
  return version_;
}
inline void PropertyVersion::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:cosmo.pb.PropertyVersion.version)
}

// -------------------------------------------------------------------

// BinLogEvent_EventData

// optional .cosmo.pb.SourceData source_data = 1;
inline bool BinLogEvent_EventData::has_source_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinLogEvent_EventData::set_has_source_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BinLogEvent_EventData::clear_has_source_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BinLogEvent_EventData::clear_source_data() {
  if (source_data_ != NULL) source_data_->::cosmo::pb::SourceData::Clear();
  clear_has_source_data();
}
inline const ::cosmo::pb::SourceData& BinLogEvent_EventData::source_data() const {
  const ::cosmo::pb::SourceData* p = source_data_;
  // @@protoc_insertion_point(field_get:cosmo.pb.BinLogEvent.EventData.source_data)
  return p != NULL ? *p : *reinterpret_cast<const ::cosmo::pb::SourceData*>(
      &::cosmo::pb::_SourceData_default_instance_);
}
inline ::cosmo::pb::SourceData* BinLogEvent_EventData::mutable_source_data() {
  set_has_source_data();
  if (source_data_ == NULL) {
    source_data_ = new ::cosmo::pb::SourceData;
  }
  // @@protoc_insertion_point(field_mutable:cosmo.pb.BinLogEvent.EventData.source_data)
  return source_data_;
}
inline ::cosmo::pb::SourceData* BinLogEvent_EventData::release_source_data() {
  // @@protoc_insertion_point(field_release:cosmo.pb.BinLogEvent.EventData.source_data)
  clear_has_source_data();
  ::cosmo::pb::SourceData* temp = source_data_;
  source_data_ = NULL;
  return temp;
}
inline void BinLogEvent_EventData::set_allocated_source_data(::cosmo::pb::SourceData* source_data) {
  delete source_data_;
  if (source_data != NULL && source_data->GetArena() != NULL) {
    ::cosmo::pb::SourceData* new_source_data = new ::cosmo::pb::SourceData;
    new_source_data->CopyFrom(*source_data);
    source_data = new_source_data;
  }
  source_data_ = source_data;
  if (source_data) {
    set_has_source_data();
  } else {
    clear_has_source_data();
  }
  // @@protoc_insertion_point(field_set_allocated:cosmo.pb.BinLogEvent.EventData.source_data)
}

// optional .cosmo.pb.DocumentData document_data = 2;
inline bool BinLogEvent_EventData::has_document_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinLogEvent_EventData::set_has_document_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BinLogEvent_EventData::clear_has_document_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BinLogEvent_EventData::clear_document_data() {
  if (document_data_ != NULL) document_data_->::cosmo::pb::DocumentData::Clear();
  clear_has_document_data();
}
inline const ::cosmo::pb::DocumentData& BinLogEvent_EventData::document_data() const {
  const ::cosmo::pb::DocumentData* p = document_data_;
  // @@protoc_insertion_point(field_get:cosmo.pb.BinLogEvent.EventData.document_data)
  return p != NULL ? *p : *reinterpret_cast<const ::cosmo::pb::DocumentData*>(
      &::cosmo::pb::_DocumentData_default_instance_);
}
inline ::cosmo::pb::DocumentData* BinLogEvent_EventData::mutable_document_data() {
  set_has_document_data();
  if (document_data_ == NULL) {
    document_data_ = new ::cosmo::pb::DocumentData;
  }
  // @@protoc_insertion_point(field_mutable:cosmo.pb.BinLogEvent.EventData.document_data)
  return document_data_;
}
inline ::cosmo::pb::DocumentData* BinLogEvent_EventData::release_document_data() {
  // @@protoc_insertion_point(field_release:cosmo.pb.BinLogEvent.EventData.document_data)
  clear_has_document_data();
  ::cosmo::pb::DocumentData* temp = document_data_;
  document_data_ = NULL;
  return temp;
}
inline void BinLogEvent_EventData::set_allocated_document_data(::cosmo::pb::DocumentData* document_data) {
  delete document_data_;
  if (document_data != NULL && document_data->GetArena() != NULL) {
    ::cosmo::pb::DocumentData* new_document_data = new ::cosmo::pb::DocumentData;
    new_document_data->CopyFrom(*document_data);
    document_data = new_document_data;
  }
  document_data_ = document_data;
  if (document_data) {
    set_has_document_data();
  } else {
    clear_has_document_data();
  }
  // @@protoc_insertion_point(field_set_allocated:cosmo.pb.BinLogEvent.EventData.document_data)
}

// optional .cosmo.pb.DocumentSourceLink document_source_link = 3;
inline bool BinLogEvent_EventData::has_document_source_link() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BinLogEvent_EventData::set_has_document_source_link() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BinLogEvent_EventData::clear_has_document_source_link() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BinLogEvent_EventData::clear_document_source_link() {
  if (document_source_link_ != NULL) document_source_link_->::cosmo::pb::DocumentSourceLink::Clear();
  clear_has_document_source_link();
}
inline const ::cosmo::pb::DocumentSourceLink& BinLogEvent_EventData::document_source_link() const {
  const ::cosmo::pb::DocumentSourceLink* p = document_source_link_;
  // @@protoc_insertion_point(field_get:cosmo.pb.BinLogEvent.EventData.document_source_link)
  return p != NULL ? *p : *reinterpret_cast<const ::cosmo::pb::DocumentSourceLink*>(
      &::cosmo::pb::_DocumentSourceLink_default_instance_);
}
inline ::cosmo::pb::DocumentSourceLink* BinLogEvent_EventData::mutable_document_source_link() {
  set_has_document_source_link();
  if (document_source_link_ == NULL) {
    document_source_link_ = new ::cosmo::pb::DocumentSourceLink;
  }
  // @@protoc_insertion_point(field_mutable:cosmo.pb.BinLogEvent.EventData.document_source_link)
  return document_source_link_;
}
inline ::cosmo::pb::DocumentSourceLink* BinLogEvent_EventData::release_document_source_link() {
  // @@protoc_insertion_point(field_release:cosmo.pb.BinLogEvent.EventData.document_source_link)
  clear_has_document_source_link();
  ::cosmo::pb::DocumentSourceLink* temp = document_source_link_;
  document_source_link_ = NULL;
  return temp;
}
inline void BinLogEvent_EventData::set_allocated_document_source_link(::cosmo::pb::DocumentSourceLink* document_source_link) {
  delete document_source_link_;
  if (document_source_link != NULL && document_source_link->GetArena() != NULL) {
    ::cosmo::pb::DocumentSourceLink* new_document_source_link = new ::cosmo::pb::DocumentSourceLink;
    new_document_source_link->CopyFrom(*document_source_link);
    document_source_link = new_document_source_link;
  }
  document_source_link_ = document_source_link;
  if (document_source_link) {
    set_has_document_source_link();
  } else {
    clear_has_document_source_link();
  }
  // @@protoc_insertion_point(field_set_allocated:cosmo.pb.BinLogEvent.EventData.document_source_link)
}

// optional .cosmo.pb.PropertyVersion property_version = 4;
inline bool BinLogEvent_EventData::has_property_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BinLogEvent_EventData::set_has_property_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BinLogEvent_EventData::clear_has_property_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BinLogEvent_EventData::clear_property_version() {
  if (property_version_ != NULL) property_version_->::cosmo::pb::PropertyVersion::Clear();
  clear_has_property_version();
}
inline const ::cosmo::pb::PropertyVersion& BinLogEvent_EventData::property_version() const {
  const ::cosmo::pb::PropertyVersion* p = property_version_;
  // @@protoc_insertion_point(field_get:cosmo.pb.BinLogEvent.EventData.property_version)
  return p != NULL ? *p : *reinterpret_cast<const ::cosmo::pb::PropertyVersion*>(
      &::cosmo::pb::_PropertyVersion_default_instance_);
}
inline ::cosmo::pb::PropertyVersion* BinLogEvent_EventData::mutable_property_version() {
  set_has_property_version();
  if (property_version_ == NULL) {
    property_version_ = new ::cosmo::pb::PropertyVersion;
  }
  // @@protoc_insertion_point(field_mutable:cosmo.pb.BinLogEvent.EventData.property_version)
  return property_version_;
}
inline ::cosmo::pb::PropertyVersion* BinLogEvent_EventData::release_property_version() {
  // @@protoc_insertion_point(field_release:cosmo.pb.BinLogEvent.EventData.property_version)
  clear_has_property_version();
  ::cosmo::pb::PropertyVersion* temp = property_version_;
  property_version_ = NULL;
  return temp;
}
inline void BinLogEvent_EventData::set_allocated_property_version(::cosmo::pb::PropertyVersion* property_version) {
  delete property_version_;
  property_version_ = property_version;
  if (property_version) {
    set_has_property_version();
  } else {
    clear_has_property_version();
  }
  // @@protoc_insertion_point(field_set_allocated:cosmo.pb.BinLogEvent.EventData.property_version)
}

// -------------------------------------------------------------------

// BinLogEvent

// required int64 timestamp = 1;
inline bool BinLogEvent::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinLogEvent::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BinLogEvent::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BinLogEvent::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 BinLogEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:cosmo.pb.BinLogEvent.timestamp)
  return timestamp_;
}
inline void BinLogEvent::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:cosmo.pb.BinLogEvent.timestamp)
}

// required int64 epoch = 2;
inline bool BinLogEvent::has_epoch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BinLogEvent::set_has_epoch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BinLogEvent::clear_has_epoch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BinLogEvent::clear_epoch() {
  epoch_ = GOOGLE_LONGLONG(0);
  clear_has_epoch();
}
inline ::google::protobuf::int64 BinLogEvent::epoch() const {
  // @@protoc_insertion_point(field_get:cosmo.pb.BinLogEvent.epoch)
  return epoch_;
}
inline void BinLogEvent::set_epoch(::google::protobuf::int64 value) {
  set_has_epoch();
  epoch_ = value;
  // @@protoc_insertion_point(field_set:cosmo.pb.BinLogEvent.epoch)
}

// required int32 shard = 3;
inline bool BinLogEvent::has_shard() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BinLogEvent::set_has_shard() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BinLogEvent::clear_has_shard() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BinLogEvent::clear_shard() {
  shard_ = 0;
  clear_has_shard();
}
inline ::google::protobuf::int32 BinLogEvent::shard() const {
  // @@protoc_insertion_point(field_get:cosmo.pb.BinLogEvent.shard)
  return shard_;
}
inline void BinLogEvent::set_shard(::google::protobuf::int32 value) {
  set_has_shard();
  shard_ = value;
  // @@protoc_insertion_point(field_set:cosmo.pb.BinLogEvent.shard)
}

// required .cosmo.pb.BinLogEvent.EventType type = 4;
inline bool BinLogEvent::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BinLogEvent::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BinLogEvent::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BinLogEvent::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::cosmo::pb::BinLogEvent_EventType BinLogEvent::type() const {
  // @@protoc_insertion_point(field_get:cosmo.pb.BinLogEvent.type)
  return static_cast< ::cosmo::pb::BinLogEvent_EventType >(type_);
}
inline void BinLogEvent::set_type(::cosmo::pb::BinLogEvent_EventType value) {
  assert(::cosmo::pb::BinLogEvent_EventType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:cosmo.pb.BinLogEvent.type)
}

// optional .cosmo.pb.BinLogEvent.EventData data = 5;
inline bool BinLogEvent::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinLogEvent::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BinLogEvent::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BinLogEvent::clear_data() {
  if (data_ != NULL) data_->::cosmo::pb::BinLogEvent_EventData::Clear();
  clear_has_data();
}
inline const ::cosmo::pb::BinLogEvent_EventData& BinLogEvent::data() const {
  const ::cosmo::pb::BinLogEvent_EventData* p = data_;
  // @@protoc_insertion_point(field_get:cosmo.pb.BinLogEvent.data)
  return p != NULL ? *p : *reinterpret_cast<const ::cosmo::pb::BinLogEvent_EventData*>(
      &::cosmo::pb::_BinLogEvent_EventData_default_instance_);
}
inline ::cosmo::pb::BinLogEvent_EventData* BinLogEvent::mutable_data() {
  set_has_data();
  if (data_ == NULL) {
    data_ = new ::cosmo::pb::BinLogEvent_EventData;
  }
  // @@protoc_insertion_point(field_mutable:cosmo.pb.BinLogEvent.data)
  return data_;
}
inline ::cosmo::pb::BinLogEvent_EventData* BinLogEvent::release_data() {
  // @@protoc_insertion_point(field_release:cosmo.pb.BinLogEvent.data)
  clear_has_data();
  ::cosmo::pb::BinLogEvent_EventData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void BinLogEvent::set_allocated_data(::cosmo::pb::BinLogEvent_EventData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:cosmo.pb.BinLogEvent.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace pb
}  // namespace cosmo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cosmo::pb::PropertyVersion_Provider> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cosmo::pb::PropertyVersion_Provider>() {
  return ::cosmo::pb::PropertyVersion_Provider_descriptor();
}
template <> struct is_proto_enum< ::cosmo::pb::BinLogEvent_EventType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cosmo::pb::BinLogEvent_EventType>() {
  return ::cosmo::pb::BinLogEvent_EventType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cosmo_5fbinlog_2eproto__INCLUDED
