// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: doc_parser.proto

#ifndef PROTOBUF_doc_5fparser_2eproto__INCLUDED
#define PROTOBUF_doc_5fparser_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "document_enums.pb.h"
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {
class AdditionalParsingData;
class AdditionalParsingDataDefaultTypeInternal;
extern AdditionalParsingDataDefaultTypeInternal _AdditionalParsingData_default_instance_;
class ChromeImageInfo;
class ChromeImageInfoDefaultTypeInternal;
extern ChromeImageInfoDefaultTypeInternal _ChromeImageInfo_default_instance_;
class ContactInfo;
class ContactInfoDefaultTypeInternal;
extern ContactInfoDefaultTypeInternal _ContactInfo_default_instance_;
class ContactInfoList;
class ContactInfoListDefaultTypeInternal;
extern ContactInfoListDefaultTypeInternal _ContactInfoList_default_instance_;
class DetectedLangArray;
class DetectedLangArrayDefaultTypeInternal;
extern DetectedLangArrayDefaultTypeInternal _DetectedLangArray_default_instance_;
class DetectedLanguage;
class DetectedLanguageDefaultTypeInternal;
extern DetectedLanguageDefaultTypeInternal _DetectedLanguage_default_instance_;
class FeatureKV;
class FeatureKVDefaultTypeInternal;
extern FeatureKVDefaultTypeInternal _FeatureKV_default_instance_;
class FeatureList;
class FeatureListDefaultTypeInternal;
extern FeatureListDefaultTypeInternal _FeatureList_default_instance_;
class Features;
class FeaturesDefaultTypeInternal;
extern FeaturesDefaultTypeInternal _Features_default_instance_;
class ImageInfo;
class ImageInfoDefaultTypeInternal;
extern ImageInfoDefaultTypeInternal _ImageInfo_default_instance_;
class Links;
class LinksDefaultTypeInternal;
extern LinksDefaultTypeInternal _Links_default_instance_;
class MetaDescription;
class MetaDescriptionDefaultTypeInternal;
extern MetaDescriptionDefaultTypeInternal _MetaDescription_default_instance_;
class OriginalDoc;
class OriginalDocDefaultTypeInternal;
extern OriginalDocDefaultTypeInternal _OriginalDoc_default_instance_;
class ParsedDoc;
class ParsedDocDefaultTypeInternal;
extern ParsedDocDefaultTypeInternal _ParsedDoc_default_instance_;
class ParsedHtml;
class ParsedHtmlDefaultTypeInternal;
extern ParsedHtmlDefaultTypeInternal _ParsedHtml_default_instance_;
class ProfileInfo;
class ProfileInfoDefaultTypeInternal;
extern ProfileInfoDefaultTypeInternal _ProfileInfo_default_instance_;
class Region;
class RegionDefaultTypeInternal;
extern RegionDefaultTypeInternal _Region_default_instance_;
class RegionBlob;
class RegionBlobDefaultTypeInternal;
extern RegionBlobDefaultTypeInternal _RegionBlob_default_instance_;
class RegionKV;
class RegionKVDefaultTypeInternal;
extern RegionKVDefaultTypeInternal _RegionKV_default_instance_;
class RegionList;
class RegionListDefaultTypeInternal;
extern RegionListDefaultTypeInternal _RegionList_default_instance_;
class SiteLanguage;
class SiteLanguageDefaultTypeInternal;
extern SiteLanguageDefaultTypeInternal _SiteLanguage_default_instance_;
class SiteLanguageArray;
class SiteLanguageArrayDefaultTypeInternal;
extern SiteLanguageArrayDefaultTypeInternal _SiteLanguageArray_default_instance_;
class StubDoc;
class StubDocDefaultTypeInternal;
extern StubDocDefaultTypeInternal _StubDoc_default_instance_;
class SubjContext;
class SubjContextDefaultTypeInternal;
extern SubjContextDefaultTypeInternal _SubjContext_default_instance_;
class SubjContextList;
class SubjContextListDefaultTypeInternal;
extern SubjContextListDefaultTypeInternal _SubjContextList_default_instance_;
class SubjParsed;
class SubjParsedDefaultTypeInternal;
extern SubjParsedDefaultTypeInternal _SubjParsed_default_instance_;
class SubjParsed_KeyValue;
class SubjParsed_KeyValueDefaultTypeInternal;
extern SubjParsed_KeyValueDefaultTypeInternal _SubjParsed_KeyValue_default_instance_;
}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {

namespace protobuf_doc_5fparser_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_doc_5fparser_2eproto

enum Links_typeFlag {
  Links_typeFlag_no_mark = 1,
  Links_typeFlag_wiki_nofollow = 2,
  Links_typeFlag_from_iframe = 3
};
bool Links_typeFlag_IsValid(int value);
const Links_typeFlag Links_typeFlag_typeFlag_MIN = Links_typeFlag_no_mark;
const Links_typeFlag Links_typeFlag_typeFlag_MAX = Links_typeFlag_from_iframe;
const int Links_typeFlag_typeFlag_ARRAYSIZE = Links_typeFlag_typeFlag_MAX + 1;

const ::google::protobuf::EnumDescriptor* Links_typeFlag_descriptor();
inline const ::std::string& Links_typeFlag_Name(Links_typeFlag value) {
  return ::google::protobuf::internal::NameOfEnum(
    Links_typeFlag_descriptor(), value);
}
inline bool Links_typeFlag_Parse(
    const ::std::string& name, Links_typeFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Links_typeFlag>(
    Links_typeFlag_descriptor(), name, value);
}
enum Features_spam_t {
  Features_spam_t_unknown = 0,
  Features_spam_t_spam = 1,
  Features_spam_t_not_spam = 2,
  Features_spam_t_bad = 3
};
bool Features_spam_t_IsValid(int value);
const Features_spam_t Features_spam_t_spam_t_MIN = Features_spam_t_unknown;
const Features_spam_t Features_spam_t_spam_t_MAX = Features_spam_t_bad;
const int Features_spam_t_spam_t_ARRAYSIZE = Features_spam_t_spam_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* Features_spam_t_descriptor();
inline const ::std::string& Features_spam_t_Name(Features_spam_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    Features_spam_t_descriptor(), value);
}
inline bool Features_spam_t_Parse(
    const ::std::string& name, Features_spam_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Features_spam_t>(
    Features_spam_t_descriptor(), name, value);
}
enum Features_subj_t {
  Features_subj_t_not_related = 0,
  Features_subj_t_url_passed = 1,
  Features_subj_t_url_matched = 2,
  Features_subj_t_url_parsed = 3
};
bool Features_subj_t_IsValid(int value);
const Features_subj_t Features_subj_t_subj_t_MIN = Features_subj_t_not_related;
const Features_subj_t Features_subj_t_subj_t_MAX = Features_subj_t_url_parsed;
const int Features_subj_t_subj_t_ARRAYSIZE = Features_subj_t_subj_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* Features_subj_t_descriptor();
inline const ::std::string& Features_subj_t_Name(Features_subj_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    Features_subj_t_descriptor(), value);
}
inline bool Features_subj_t_Parse(
    const ::std::string& name, Features_subj_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Features_subj_t>(
    Features_subj_t_descriptor(), name, value);
}
enum ParsedHtml_page_errors {
  ParsedHtml_page_errors_is_ok = 1,
  ParsedHtml_page_errors_is_spam = 2,
  ParsedHtml_page_errors_bad_url_normalize = 3,
  ParsedHtml_page_errors_has_refresh = 4,
  ParsedHtml_page_errors_has_canonical = 5,
  ParsedHtml_page_errors_bad_parsing = 6
};
bool ParsedHtml_page_errors_IsValid(int value);
const ParsedHtml_page_errors ParsedHtml_page_errors_page_errors_MIN = ParsedHtml_page_errors_is_ok;
const ParsedHtml_page_errors ParsedHtml_page_errors_page_errors_MAX = ParsedHtml_page_errors_bad_parsing;
const int ParsedHtml_page_errors_page_errors_ARRAYSIZE = ParsedHtml_page_errors_page_errors_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParsedHtml_page_errors_descriptor();
inline const ::std::string& ParsedHtml_page_errors_Name(ParsedHtml_page_errors value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParsedHtml_page_errors_descriptor(), value);
}
inline bool ParsedHtml_page_errors_Parse(
    const ::std::string& name, ParsedHtml_page_errors* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParsedHtml_page_errors>(
    ParsedHtml_page_errors_descriptor(), name, value);
}
// ===================================================================

class AdditionalParsingData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.AdditionalParsingData) */ {
 public:
  AdditionalParsingData();
  virtual ~AdditionalParsingData();

  AdditionalParsingData(const AdditionalParsingData& from);

  inline AdditionalParsingData& operator=(const AdditionalParsingData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AdditionalParsingData(AdditionalParsingData&& from) noexcept
    : AdditionalParsingData() {
    *this = ::std::move(from);
  }

  inline AdditionalParsingData& operator=(AdditionalParsingData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdditionalParsingData& default_instance();

  static inline const AdditionalParsingData* internal_default_instance() {
    return reinterpret_cast<const AdditionalParsingData*>(
               &_AdditionalParsingData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AdditionalParsingData* other);
  friend void swap(AdditionalParsingData& a, AdditionalParsingData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AdditionalParsingData* New() const PROTOBUF_FINAL { return New(NULL); }

  AdditionalParsingData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AdditionalParsingData& from);
  void MergeFrom(const AdditionalParsingData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AdditionalParsingData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool ignore_nofollow = 1 [default = false];
  bool has_ignore_nofollow() const;
  void clear_ignore_nofollow();
  static const int kIgnoreNofollowFieldNumber = 1;
  bool ignore_nofollow() const;
  void set_ignore_nofollow(bool value);

  // optional .ru.mail.go.webbase.blobs.ForumType forumType = 3;
  bool has_forumtype() const;
  void clear_forumtype();
  static const int kForumTypeFieldNumber = 3;
  ::ru::mail::go::webbase::blobs::ForumType forumtype() const;
  void set_forumtype(::ru::mail::go::webbase::blobs::ForumType value);

  // optional uint64 downloadTime = 4;
  bool has_downloadtime() const;
  void clear_downloadtime();
  static const int kDownloadTimeFieldNumber = 4;
  ::google::protobuf::uint64 downloadtime() const;
  void set_downloadtime(::google::protobuf::uint64 value);

  // optional int32 flag_meta_robots = 6;
  bool has_flag_meta_robots() const;
  void clear_flag_meta_robots();
  static const int kFlagMetaRobotsFieldNumber = 6;
  ::google::protobuf::int32 flag_meta_robots() const;
  void set_flag_meta_robots(::google::protobuf::int32 value);

  // optional .ru.mail.go.webbase.blobs.Encoding forced_encoding = 7 [default = enc_undefined];
  bool has_forced_encoding() const;
  void clear_forced_encoding();
  static const int kForcedEncodingFieldNumber = 7;
  ::ru::mail::go::webbase::blobs::Encoding forced_encoding() const;
  void set_forced_encoding(::ru::mail::go::webbase::blobs::Encoding value);

  // optional .ru.mail.go.webbase.blobs.Encoding encoding = 2 [default = enc_undefined];
  bool has_encoding() const;
  void clear_encoding();
  static const int kEncodingFieldNumber = 2;
  ::ru::mail::go::webbase::blobs::Encoding encoding() const;
  void set_encoding(::ru::mail::go::webbase::blobs::Encoding value);

  // optional .ru.mail.go.webbase.blobs.Encoding bom_encoding = 5 [default = enc_undefined];
  bool has_bom_encoding() const;
  void clear_bom_encoding();
  static const int kBomEncodingFieldNumber = 5;
  ::ru::mail::go::webbase::blobs::Encoding bom_encoding() const;
  void set_bom_encoding(::ru::mail::go::webbase::blobs::Encoding value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.AdditionalParsingData)
 private:
  void set_has_ignore_nofollow();
  void clear_has_ignore_nofollow();
  void set_has_encoding();
  void clear_has_encoding();
  void set_has_forumtype();
  void clear_has_forumtype();
  void set_has_downloadtime();
  void clear_has_downloadtime();
  void set_has_bom_encoding();
  void clear_has_bom_encoding();
  void set_has_flag_meta_robots();
  void clear_has_flag_meta_robots();
  void set_has_forced_encoding();
  void clear_has_forced_encoding();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool ignore_nofollow_;
  int forumtype_;
  ::google::protobuf::uint64 downloadtime_;
  ::google::protobuf::int32 flag_meta_robots_;
  int forced_encoding_;
  int encoding_;
  int bom_encoding_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Links : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.Links) */ {
 public:
  Links();
  virtual ~Links();

  Links(const Links& from);

  inline Links& operator=(const Links& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Links(Links&& from) noexcept
    : Links() {
    *this = ::std::move(from);
  }

  inline Links& operator=(Links&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Links& default_instance();

  static inline const Links* internal_default_instance() {
    return reinterpret_cast<const Links*>(
               &_Links_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Links* other);
  friend void swap(Links& a, Links& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Links* New() const PROTOBUF_FINAL { return New(NULL); }

  Links* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Links& from);
  void MergeFrom(const Links& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Links* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Links_typeFlag typeFlag;
  static const typeFlag no_mark =
    Links_typeFlag_no_mark;
  static const typeFlag wiki_nofollow =
    Links_typeFlag_wiki_nofollow;
  static const typeFlag from_iframe =
    Links_typeFlag_from_iframe;
  static inline bool typeFlag_IsValid(int value) {
    return Links_typeFlag_IsValid(value);
  }
  static const typeFlag typeFlag_MIN =
    Links_typeFlag_typeFlag_MIN;
  static const typeFlag typeFlag_MAX =
    Links_typeFlag_typeFlag_MAX;
  static const int typeFlag_ARRAYSIZE =
    Links_typeFlag_typeFlag_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  typeFlag_descriptor() {
    return Links_typeFlag_descriptor();
  }
  static inline const ::std::string& typeFlag_Name(typeFlag value) {
    return Links_typeFlag_Name(value);
  }
  static inline bool typeFlag_Parse(const ::std::string& name,
      typeFlag* value) {
    return Links_typeFlag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional bytes text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const void* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional .ru.mail.go.webbase.blobs.Links.typeFlag flag = 3;
  bool has_flag() const;
  void clear_flag();
  static const int kFlagFieldNumber = 3;
  ::ru::mail::go::webbase::blobs::Links_typeFlag flag() const;
  void set_flag(::ru::mail::go::webbase::blobs::Links_typeFlag value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.Links)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_text();
  void clear_has_text();
  void set_has_flag();
  void clear_has_flag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  int flag_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FeatureKV : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.FeatureKV) */ {
 public:
  FeatureKV();
  virtual ~FeatureKV();

  FeatureKV(const FeatureKV& from);

  inline FeatureKV& operator=(const FeatureKV& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeatureKV(FeatureKV&& from) noexcept
    : FeatureKV() {
    *this = ::std::move(from);
  }

  inline FeatureKV& operator=(FeatureKV&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureKV& default_instance();

  static inline const FeatureKV* internal_default_instance() {
    return reinterpret_cast<const FeatureKV*>(
               &_FeatureKV_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(FeatureKV* other);
  friend void swap(FeatureKV& a, FeatureKV& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeatureKV* New() const PROTOBUF_FINAL { return New(NULL); }

  FeatureKV* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FeatureKV& from);
  void MergeFrom(const FeatureKV& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FeatureKV* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required float value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.FeatureKV)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  float value_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FeatureList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.FeatureList) */ {
 public:
  FeatureList();
  virtual ~FeatureList();

  FeatureList(const FeatureList& from);

  inline FeatureList& operator=(const FeatureList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FeatureList(FeatureList&& from) noexcept
    : FeatureList() {
    *this = ::std::move(from);
  }

  inline FeatureList& operator=(FeatureList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureList& default_instance();

  static inline const FeatureList* internal_default_instance() {
    return reinterpret_cast<const FeatureList*>(
               &_FeatureList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FeatureList* other);
  friend void swap(FeatureList& a, FeatureList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FeatureList* New() const PROTOBUF_FINAL { return New(NULL); }

  FeatureList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FeatureList& from);
  void MergeFrom(const FeatureList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FeatureList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.FeatureKV features = 1;
  int features_size() const;
  void clear_features();
  static const int kFeaturesFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::FeatureKV& features(int index) const;
  ::ru::mail::go::webbase::blobs::FeatureKV* mutable_features(int index);
  ::ru::mail::go::webbase::blobs::FeatureKV* add_features();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::FeatureKV >*
      mutable_features();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::FeatureKV >&
      features() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.FeatureList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::FeatureKV > features_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegionKV : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.RegionKV) */ {
 public:
  RegionKV();
  virtual ~RegionKV();

  RegionKV(const RegionKV& from);

  inline RegionKV& operator=(const RegionKV& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegionKV(RegionKV&& from) noexcept
    : RegionKV() {
    *this = ::std::move(from);
  }

  inline RegionKV& operator=(RegionKV&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionKV& default_instance();

  static inline const RegionKV* internal_default_instance() {
    return reinterpret_cast<const RegionKV*>(
               &_RegionKV_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RegionKV* other);
  friend void swap(RegionKV& a, RegionKV& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionKV* New() const PROTOBUF_FINAL { return New(NULL); }

  RegionKV* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegionKV& from);
  void MergeFrom(const RegionKV& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegionKV* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::int32 key() const;
  void set_key(::google::protobuf::int32 value);

  // required int32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.RegionKV)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 key_;
  ::google::protobuf::int32 value_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegionList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.RegionList) */ {
 public:
  RegionList();
  virtual ~RegionList();

  RegionList(const RegionList& from);

  inline RegionList& operator=(const RegionList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegionList(RegionList&& from) noexcept
    : RegionList() {
    *this = ::std::move(from);
  }

  inline RegionList& operator=(RegionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionList& default_instance();

  static inline const RegionList* internal_default_instance() {
    return reinterpret_cast<const RegionList*>(
               &_RegionList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RegionList* other);
  friend void swap(RegionList& a, RegionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionList* New() const PROTOBUF_FINAL { return New(NULL); }

  RegionList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegionList& from);
  void MergeFrom(const RegionList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.RegionKV region_info = 1;
  int region_info_size() const;
  void clear_region_info();
  static const int kRegionInfoFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::RegionKV& region_info(int index) const;
  ::ru::mail::go::webbase::blobs::RegionKV* mutable_region_info(int index);
  ::ru::mail::go::webbase::blobs::RegionKV* add_region_info();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::RegionKV >*
      mutable_region_info();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::RegionKV >&
      region_info() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.RegionList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::RegionKV > region_info_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ContactInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ContactInfo) */ {
 public:
  ContactInfo();
  virtual ~ContactInfo();

  ContactInfo(const ContactInfo& from);

  inline ContactInfo& operator=(const ContactInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContactInfo(ContactInfo&& from) noexcept
    : ContactInfo() {
    *this = ::std::move(from);
  }

  inline ContactInfo& operator=(ContactInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactInfo& default_instance();

  static inline const ContactInfo* internal_default_instance() {
    return reinterpret_cast<const ContactInfo*>(
               &_ContactInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ContactInfo* other);
  friend void swap(ContactInfo& a, ContactInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContactInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ContactInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContactInfo& from);
  void MergeFrom(const ContactInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContactInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string phone = 1;
  bool has_phone() const;
  void clear_phone();
  static const int kPhoneFieldNumber = 1;
  const ::std::string& phone() const;
  void set_phone(const ::std::string& value);
  #if LANG_CXX11
  void set_phone(::std::string&& value);
  #endif
  void set_phone(const char* value);
  void set_phone(const char* value, size_t size);
  ::std::string* mutable_phone();
  ::std::string* release_phone();
  void set_allocated_phone(::std::string* phone);

  // required string address = 2;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ContactInfo)
 private:
  void set_has_phone();
  void clear_has_phone();
  void set_has_address();
  void clear_has_address();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr phone_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ContactInfoList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ContactInfoList) */ {
 public:
  ContactInfoList();
  virtual ~ContactInfoList();

  ContactInfoList(const ContactInfoList& from);

  inline ContactInfoList& operator=(const ContactInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContactInfoList(ContactInfoList&& from) noexcept
    : ContactInfoList() {
    *this = ::std::move(from);
  }

  inline ContactInfoList& operator=(ContactInfoList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactInfoList& default_instance();

  static inline const ContactInfoList* internal_default_instance() {
    return reinterpret_cast<const ContactInfoList*>(
               &_ContactInfoList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ContactInfoList* other);
  friend void swap(ContactInfoList& a, ContactInfoList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContactInfoList* New() const PROTOBUF_FINAL { return New(NULL); }

  ContactInfoList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ContactInfoList& from);
  void MergeFrom(const ContactInfoList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ContactInfoList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.ContactInfo contacts = 1;
  int contacts_size() const;
  void clear_contacts();
  static const int kContactsFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::ContactInfo& contacts(int index) const;
  ::ru::mail::go::webbase::blobs::ContactInfo* mutable_contacts(int index);
  ::ru::mail::go::webbase::blobs::ContactInfo* add_contacts();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ContactInfo >*
      mutable_contacts();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ContactInfo >&
      contacts() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ContactInfoList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ContactInfo > contacts_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubjContext : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.SubjContext) */ {
 public:
  SubjContext();
  virtual ~SubjContext();

  SubjContext(const SubjContext& from);

  inline SubjContext& operator=(const SubjContext& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubjContext(SubjContext&& from) noexcept
    : SubjContext() {
    *this = ::std::move(from);
  }

  inline SubjContext& operator=(SubjContext&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubjContext& default_instance();

  static inline const SubjContext* internal_default_instance() {
    return reinterpret_cast<const SubjContext*>(
               &_SubjContext_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SubjContext* other);
  friend void swap(SubjContext& a, SubjContext& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubjContext* New() const PROTOBUF_FINAL { return New(NULL); }

  SubjContext* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubjContext& from);
  void MergeFrom(const SubjContext& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubjContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.SubjContext)
 private:
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubjContextList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.SubjContextList) */ {
 public:
  SubjContextList();
  virtual ~SubjContextList();

  SubjContextList(const SubjContextList& from);

  inline SubjContextList& operator=(const SubjContextList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubjContextList(SubjContextList&& from) noexcept
    : SubjContextList() {
    *this = ::std::move(from);
  }

  inline SubjContextList& operator=(SubjContextList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubjContextList& default_instance();

  static inline const SubjContextList* internal_default_instance() {
    return reinterpret_cast<const SubjContextList*>(
               &_SubjContextList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(SubjContextList* other);
  friend void swap(SubjContextList& a, SubjContextList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubjContextList* New() const PROTOBUF_FINAL { return New(NULL); }

  SubjContextList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubjContextList& from);
  void MergeFrom(const SubjContextList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubjContextList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.SubjContext contexts = 1;
  int contexts_size() const;
  void clear_contexts();
  static const int kContextsFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::SubjContext& contexts(int index) const;
  ::ru::mail::go::webbase::blobs::SubjContext* mutable_contexts(int index);
  ::ru::mail::go::webbase::blobs::SubjContext* add_contexts();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SubjContext >*
      mutable_contexts();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SubjContext >&
      contexts() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.SubjContextList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SubjContext > contexts_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProfileInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ProfileInfo) */ {
 public:
  ProfileInfo();
  virtual ~ProfileInfo();

  ProfileInfo(const ProfileInfo& from);

  inline ProfileInfo& operator=(const ProfileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProfileInfo(ProfileInfo&& from) noexcept
    : ProfileInfo() {
    *this = ::std::move(from);
  }

  inline ProfileInfo& operator=(ProfileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProfileInfo& default_instance();

  static inline const ProfileInfo* internal_default_instance() {
    return reinterpret_cast<const ProfileInfo*>(
               &_ProfileInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ProfileInfo* other);
  friend void swap(ProfileInfo& a, ProfileInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProfileInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ProfileInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProfileInfo& from);
  void MergeFrom(const ProfileInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProfileInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string counter = 2;
  bool has_counter() const;
  void clear_counter();
  static const int kCounterFieldNumber = 2;
  const ::std::string& counter() const;
  void set_counter(const ::std::string& value);
  #if LANG_CXX11
  void set_counter(::std::string&& value);
  #endif
  void set_counter(const char* value);
  void set_counter(const char* value, size_t size);
  ::std::string* mutable_counter();
  ::std::string* release_counter();
  void set_allocated_counter(::std::string* counter);

  // required int64 time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ProfileInfo)
 private:
  void set_has_time();
  void clear_has_time();
  void set_has_counter();
  void clear_has_counter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr counter_;
  ::google::protobuf::int64 time_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubjParsed_KeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.SubjParsed.KeyValue) */ {
 public:
  SubjParsed_KeyValue();
  virtual ~SubjParsed_KeyValue();

  SubjParsed_KeyValue(const SubjParsed_KeyValue& from);

  inline SubjParsed_KeyValue& operator=(const SubjParsed_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubjParsed_KeyValue(SubjParsed_KeyValue&& from) noexcept
    : SubjParsed_KeyValue() {
    *this = ::std::move(from);
  }

  inline SubjParsed_KeyValue& operator=(SubjParsed_KeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubjParsed_KeyValue& default_instance();

  static inline const SubjParsed_KeyValue* internal_default_instance() {
    return reinterpret_cast<const SubjParsed_KeyValue*>(
               &_SubjParsed_KeyValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(SubjParsed_KeyValue* other);
  friend void swap(SubjParsed_KeyValue& a, SubjParsed_KeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubjParsed_KeyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  SubjParsed_KeyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubjParsed_KeyValue& from);
  void MergeFrom(const SubjParsed_KeyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubjParsed_KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // repeated bytes bvalues = 3;
  int bvalues_size() const;
  void clear_bvalues();
  static const int kBvaluesFieldNumber = 3;
  const ::std::string& bvalues(int index) const;
  ::std::string* mutable_bvalues(int index);
  void set_bvalues(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_bvalues(int index, ::std::string&& value);
  #endif
  void set_bvalues(int index, const char* value);
  void set_bvalues(int index, const void* value, size_t size);
  ::std::string* add_bvalues();
  void add_bvalues(const ::std::string& value);
  #if LANG_CXX11
  void add_bvalues(::std::string&& value);
  #endif
  void add_bvalues(const char* value);
  void add_bvalues(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& bvalues() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bvalues();

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.SubjParsed.KeyValue)
 private:
  void set_has_key();
  void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  ::google::protobuf::RepeatedPtrField< ::std::string> bvalues_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubjParsed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.SubjParsed) */ {
 public:
  SubjParsed();
  virtual ~SubjParsed();

  SubjParsed(const SubjParsed& from);

  inline SubjParsed& operator=(const SubjParsed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubjParsed(SubjParsed&& from) noexcept
    : SubjParsed() {
    *this = ::std::move(from);
  }

  inline SubjParsed& operator=(SubjParsed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubjParsed& default_instance();

  static inline const SubjParsed* internal_default_instance() {
    return reinterpret_cast<const SubjParsed*>(
               &_SubjParsed_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(SubjParsed* other);
  friend void swap(SubjParsed& a, SubjParsed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubjParsed* New() const PROTOBUF_FINAL { return New(NULL); }

  SubjParsed* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubjParsed& from);
  void MergeFrom(const SubjParsed& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubjParsed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SubjParsed_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.SubjParsed.KeyValue values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::SubjParsed_KeyValue& values(int index) const;
  ::ru::mail::go::webbase::blobs::SubjParsed_KeyValue* mutable_values(int index);
  ::ru::mail::go::webbase::blobs::SubjParsed_KeyValue* add_values();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SubjParsed_KeyValue >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SubjParsed_KeyValue >&
      values() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.SubjParsed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SubjParsed_KeyValue > values_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageInfo) */ {
 public:
  ImageInfo();
  virtual ~ImageInfo();

  ImageInfo(const ImageInfo& from);

  inline ImageInfo& operator=(const ImageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageInfo(ImageInfo&& from) noexcept
    : ImageInfo() {
    *this = ::std::move(from);
  }

  inline ImageInfo& operator=(ImageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageInfo& default_instance();

  static inline const ImageInfo* internal_default_instance() {
    return reinterpret_cast<const ImageInfo*>(
               &_ImageInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ImageInfo* other);
  friend void swap(ImageInfo& a, ImageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageInfo& from);
  void MergeFrom(const ImageInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required bytes content = 2;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 2;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // required bytes head = 3;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 3;
  const ::std::string& head() const;
  void set_head(const ::std::string& value);
  #if LANG_CXX11
  void set_head(::std::string&& value);
  #endif
  void set_head(const char* value);
  void set_head(const void* value, size_t size);
  ::std::string* mutable_head();
  ::std::string* release_head();
  void set_allocated_head(::std::string* head);

  // optional string fullUrl = 6;
  bool has_fullurl() const;
  void clear_fullurl();
  static const int kFullUrlFieldNumber = 6;
  const ::std::string& fullurl() const;
  void set_fullurl(const ::std::string& value);
  #if LANG_CXX11
  void set_fullurl(::std::string&& value);
  #endif
  void set_fullurl(const char* value);
  void set_fullurl(const char* value, size_t size);
  ::std::string* mutable_fullurl();
  ::std::string* release_fullurl();
  void set_allocated_fullurl(::std::string* fullurl);

  // optional uint64 download_time = 5;
  bool has_download_time() const;
  void clear_download_time();
  static const int kDownloadTimeFieldNumber = 5;
  ::google::protobuf::uint64 download_time() const;
  void set_download_time(::google::protobuf::uint64 value);

  // required .ru.mail.go.webbase.blobs.ContentType ctype = 4;
  bool has_ctype() const;
  void clear_ctype();
  static const int kCtypeFieldNumber = 4;
  ::ru::mail::go::webbase::blobs::ContentType ctype() const;
  void set_ctype(::ru::mail::go::webbase::blobs::ContentType value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageInfo)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_content();
  void clear_has_content();
  void set_has_head();
  void clear_has_head();
  void set_has_ctype();
  void clear_has_ctype();
  void set_has_download_time();
  void clear_has_download_time();
  void set_has_fullurl();
  void clear_has_fullurl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr head_;
  ::google::protobuf::internal::ArenaStringPtr fullurl_;
  ::google::protobuf::uint64 download_time_;
  int ctype_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChromeImageInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ChromeImageInfo) */ {
 public:
  ChromeImageInfo();
  virtual ~ChromeImageInfo();

  ChromeImageInfo(const ChromeImageInfo& from);

  inline ChromeImageInfo& operator=(const ChromeImageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChromeImageInfo(ChromeImageInfo&& from) noexcept
    : ChromeImageInfo() {
    *this = ::std::move(from);
  }

  inline ChromeImageInfo& operator=(ChromeImageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChromeImageInfo& default_instance();

  static inline const ChromeImageInfo* internal_default_instance() {
    return reinterpret_cast<const ChromeImageInfo*>(
               &_ChromeImageInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(ChromeImageInfo* other);
  friend void swap(ChromeImageInfo& a, ChromeImageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChromeImageInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ChromeImageInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChromeImageInfo& from);
  void MergeFrom(const ChromeImageInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChromeImageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ru.mail.go.webbase.blobs.ImageInfo imageInfo = 1;
  bool has_imageinfo() const;
  void clear_imageinfo();
  static const int kImageInfoFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::ImageInfo& imageinfo() const;
  ::ru::mail::go::webbase::blobs::ImageInfo* mutable_imageinfo();
  ::ru::mail::go::webbase::blobs::ImageInfo* release_imageinfo();
  void set_allocated_imageinfo(::ru::mail::go::webbase::blobs::ImageInfo* imageinfo);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ChromeImageInfo)
 private:
  void set_has_imageinfo();
  void clear_has_imageinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ru::mail::go::webbase::blobs::ImageInfo* imageinfo_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Features : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.Features) */ {
 public:
  Features();
  virtual ~Features();

  Features(const Features& from);

  inline Features& operator=(const Features& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Features(Features&& from) noexcept
    : Features() {
    *this = ::std::move(from);
  }

  inline Features& operator=(Features&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Features& default_instance();

  static inline const Features* internal_default_instance() {
    return reinterpret_cast<const Features*>(
               &_Features_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Features* other);
  friend void swap(Features& a, Features& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Features* New() const PROTOBUF_FINAL { return New(NULL); }

  Features* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Features& from);
  void MergeFrom(const Features& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Features* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Features_spam_t spam_t;
  static const spam_t unknown =
    Features_spam_t_unknown;
  static const spam_t spam =
    Features_spam_t_spam;
  static const spam_t not_spam =
    Features_spam_t_not_spam;
  static const spam_t bad =
    Features_spam_t_bad;
  static inline bool spam_t_IsValid(int value) {
    return Features_spam_t_IsValid(value);
  }
  static const spam_t spam_t_MIN =
    Features_spam_t_spam_t_MIN;
  static const spam_t spam_t_MAX =
    Features_spam_t_spam_t_MAX;
  static const int spam_t_ARRAYSIZE =
    Features_spam_t_spam_t_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  spam_t_descriptor() {
    return Features_spam_t_descriptor();
  }
  static inline const ::std::string& spam_t_Name(spam_t value) {
    return Features_spam_t_Name(value);
  }
  static inline bool spam_t_Parse(const ::std::string& name,
      spam_t* value) {
    return Features_spam_t_Parse(name, value);
  }

  typedef Features_subj_t subj_t;
  static const subj_t not_related =
    Features_subj_t_not_related;
  static const subj_t url_passed =
    Features_subj_t_url_passed;
  static const subj_t url_matched =
    Features_subj_t_url_matched;
  static const subj_t url_parsed =
    Features_subj_t_url_parsed;
  static inline bool subj_t_IsValid(int value) {
    return Features_subj_t_IsValid(value);
  }
  static const subj_t subj_t_MIN =
    Features_subj_t_subj_t_MIN;
  static const subj_t subj_t_MAX =
    Features_subj_t_subj_t_MAX;
  static const int subj_t_ARRAYSIZE =
    Features_subj_t_subj_t_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  subj_t_descriptor() {
    return Features_subj_t_descriptor();
  }
  static inline const ::std::string& subj_t_Name(subj_t value) {
    return Features_subj_t_Name(value);
  }
  static inline bool subj_t_Parse(const ::std::string& name,
      subj_t* value) {
    return Features_subj_t_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string contact_url = 5;
  bool has_contact_url() const;
  void clear_contact_url();
  static const int kContactUrlFieldNumber = 5;
  const ::std::string& contact_url() const;
  void set_contact_url(const ::std::string& value);
  #if LANG_CXX11
  void set_contact_url(::std::string&& value);
  #endif
  void set_contact_url(const char* value);
  void set_contact_url(const char* value, size_t size);
  ::std::string* mutable_contact_url();
  ::std::string* release_contact_url();
  void set_allocated_contact_url(::std::string* contact_url);

  // optional string subj_name = 8;
  bool has_subj_name() const;
  void clear_subj_name();
  static const int kSubjNameFieldNumber = 8;
  const ::std::string& subj_name() const;
  void set_subj_name(const ::std::string& value);
  #if LANG_CXX11
  void set_subj_name(::std::string&& value);
  #endif
  void set_subj_name(const char* value);
  void set_subj_name(const char* value, size_t size);
  ::std::string* mutable_subj_name();
  ::std::string* release_subj_name();
  void set_allocated_subj_name(::std::string* subj_name);

  // optional string subj_type = 12;
  bool has_subj_type() const;
  void clear_subj_type();
  static const int kSubjTypeFieldNumber = 12;
  const ::std::string& subj_type() const;
  void set_subj_type(const ::std::string& value);
  #if LANG_CXX11
  void set_subj_type(::std::string&& value);
  #endif
  void set_subj_type(const char* value);
  void set_subj_type(const char* value, size_t size);
  ::std::string* mutable_subj_type();
  ::std::string* release_subj_type();
  void set_allocated_subj_type(::std::string* subj_type);

  // optional .ru.mail.go.webbase.blobs.FeatureList porn_features = 2;
  bool has_porn_features() const;
  void clear_porn_features();
  static const int kPornFeaturesFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::FeatureList& porn_features() const;
  ::ru::mail::go::webbase::blobs::FeatureList* mutable_porn_features();
  ::ru::mail::go::webbase::blobs::FeatureList* release_porn_features();
  void set_allocated_porn_features(::ru::mail::go::webbase::blobs::FeatureList* porn_features);

  // optional .ru.mail.go.webbase.blobs.FeatureList spam_features = 4;
  bool has_spam_features() const;
  void clear_spam_features();
  static const int kSpamFeaturesFieldNumber = 4;
  const ::ru::mail::go::webbase::blobs::FeatureList& spam_features() const;
  ::ru::mail::go::webbase::blobs::FeatureList* mutable_spam_features();
  ::ru::mail::go::webbase::blobs::FeatureList* release_spam_features();
  void set_allocated_spam_features(::ru::mail::go::webbase::blobs::FeatureList* spam_features);

  // optional .ru.mail.go.webbase.blobs.ContactInfoList contacts = 6;
  bool has_contacts() const;
  void clear_contacts();
  static const int kContactsFieldNumber = 6;
  const ::ru::mail::go::webbase::blobs::ContactInfoList& contacts() const;
  ::ru::mail::go::webbase::blobs::ContactInfoList* mutable_contacts();
  ::ru::mail::go::webbase::blobs::ContactInfoList* release_contacts();
  void set_allocated_contacts(::ru::mail::go::webbase::blobs::ContactInfoList* contacts);

  // optional .ru.mail.go.webbase.blobs.SubjContextList subj_ctxs = 9;
  bool has_subj_ctxs() const;
  void clear_subj_ctxs();
  static const int kSubjCtxsFieldNumber = 9;
  const ::ru::mail::go::webbase::blobs::SubjContextList& subj_ctxs() const;
  ::ru::mail::go::webbase::blobs::SubjContextList* mutable_subj_ctxs();
  ::ru::mail::go::webbase::blobs::SubjContextList* release_subj_ctxs();
  void set_allocated_subj_ctxs(::ru::mail::go::webbase::blobs::SubjContextList* subj_ctxs);

  // optional .ru.mail.go.webbase.blobs.FeatureList soft_features = 11;
  bool has_soft_features() const;
  void clear_soft_features();
  static const int kSoftFeaturesFieldNumber = 11;
  const ::ru::mail::go::webbase::blobs::FeatureList& soft_features() const;
  ::ru::mail::go::webbase::blobs::FeatureList* mutable_soft_features();
  ::ru::mail::go::webbase::blobs::FeatureList* release_soft_features();
  void set_allocated_soft_features(::ru::mail::go::webbase::blobs::FeatureList* soft_features);

  // optional .ru.mail.go.webbase.blobs.FeatureList market_features = 14;
  bool has_market_features() const;
  void clear_market_features();
  static const int kMarketFeaturesFieldNumber = 14;
  const ::ru::mail::go::webbase::blobs::FeatureList& market_features() const;
  ::ru::mail::go::webbase::blobs::FeatureList* mutable_market_features();
  ::ru::mail::go::webbase::blobs::FeatureList* release_market_features();
  void set_allocated_market_features(::ru::mail::go::webbase::blobs::FeatureList* market_features);

  // optional .ru.mail.go.webbase.blobs.SubjParsed subj_values = 15;
  bool has_subj_values() const;
  void clear_subj_values();
  static const int kSubjValuesFieldNumber = 15;
  const ::ru::mail::go::webbase::blobs::SubjParsed& subj_values() const;
  ::ru::mail::go::webbase::blobs::SubjParsed* mutable_subj_values();
  ::ru::mail::go::webbase::blobs::SubjParsed* release_subj_values();
  void set_allocated_subj_values(::ru::mail::go::webbase::blobs::SubjParsed* subj_values);

  // optional .ru.mail.go.webbase.blobs.FeatureList porn_features2 = 20;
  bool has_porn_features2() const;
  void clear_porn_features2();
  static const int kPornFeatures2FieldNumber = 20;
  const ::ru::mail::go::webbase::blobs::FeatureList& porn_features2() const;
  ::ru::mail::go::webbase::blobs::FeatureList* mutable_porn_features2();
  ::ru::mail::go::webbase::blobs::FeatureList* release_porn_features2();
  void set_allocated_porn_features2(::ru::mail::go::webbase::blobs::FeatureList* porn_features2);

  // optional uint32 porn_score = 1;
  bool has_porn_score() const;
  void clear_porn_score();
  static const int kPornScoreFieldNumber = 1;
  ::google::protobuf::uint32 porn_score() const;
  void set_porn_score(::google::protobuf::uint32 value);

  // optional .ru.mail.go.webbase.blobs.Features.spam_t spam_score = 3;
  bool has_spam_score() const;
  void clear_spam_score();
  static const int kSpamScoreFieldNumber = 3;
  ::ru::mail::go::webbase::blobs::Features_spam_t spam_score() const;
  void set_spam_score(::ru::mail::go::webbase::blobs::Features_spam_t value);

  // optional .ru.mail.go.webbase.blobs.Features.subj_t subj_stage = 7;
  bool has_subj_stage() const;
  void clear_subj_stage();
  static const int kSubjStageFieldNumber = 7;
  ::ru::mail::go::webbase::blobs::Features_subj_t subj_stage() const;
  void set_subj_stage(::ru::mail::go::webbase::blobs::Features_subj_t value);

  // optional float soft_score = 10;
  bool has_soft_score() const;
  void clear_soft_score();
  static const int kSoftScoreFieldNumber = 10;
  float soft_score() const;
  void set_soft_score(float value);

  // optional float market_score = 13;
  bool has_market_score() const;
  void clear_market_score();
  static const int kMarketScoreFieldNumber = 13;
  float market_score() const;
  void set_market_score(float value);

  // optional float porn_score_raw = 16;
  bool has_porn_score_raw() const;
  void clear_porn_score_raw();
  static const int kPornScoreRawFieldNumber = 16;
  float porn_score_raw() const;
  void set_porn_score_raw(float value);

  // optional float spam_score_raw = 17;
  bool has_spam_score_raw() const;
  void clear_spam_score_raw();
  static const int kSpamScoreRawFieldNumber = 17;
  float spam_score_raw() const;
  void set_spam_score_raw(float value);

  // optional uint32 porn_score2 = 18;
  bool has_porn_score2() const;
  void clear_porn_score2();
  static const int kPornScore2FieldNumber = 18;
  ::google::protobuf::uint32 porn_score2() const;
  void set_porn_score2(::google::protobuf::uint32 value);

  // optional float porn_score2_raw = 19;
  bool has_porn_score2_raw() const;
  void clear_porn_score2_raw();
  static const int kPornScore2RawFieldNumber = 19;
  float porn_score2_raw() const;
  void set_porn_score2_raw(float value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.Features)
 private:
  void set_has_porn_score();
  void clear_has_porn_score();
  void set_has_porn_features();
  void clear_has_porn_features();
  void set_has_spam_score();
  void clear_has_spam_score();
  void set_has_spam_features();
  void clear_has_spam_features();
  void set_has_contact_url();
  void clear_has_contact_url();
  void set_has_contacts();
  void clear_has_contacts();
  void set_has_subj_stage();
  void clear_has_subj_stage();
  void set_has_subj_name();
  void clear_has_subj_name();
  void set_has_subj_ctxs();
  void clear_has_subj_ctxs();
  void set_has_soft_score();
  void clear_has_soft_score();
  void set_has_soft_features();
  void clear_has_soft_features();
  void set_has_subj_type();
  void clear_has_subj_type();
  void set_has_market_score();
  void clear_has_market_score();
  void set_has_market_features();
  void clear_has_market_features();
  void set_has_subj_values();
  void clear_has_subj_values();
  void set_has_porn_score_raw();
  void clear_has_porn_score_raw();
  void set_has_spam_score_raw();
  void clear_has_spam_score_raw();
  void set_has_porn_score2();
  void clear_has_porn_score2();
  void set_has_porn_score2_raw();
  void clear_has_porn_score2_raw();
  void set_has_porn_features2();
  void clear_has_porn_features2();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr contact_url_;
  ::google::protobuf::internal::ArenaStringPtr subj_name_;
  ::google::protobuf::internal::ArenaStringPtr subj_type_;
  ::ru::mail::go::webbase::blobs::FeatureList* porn_features_;
  ::ru::mail::go::webbase::blobs::FeatureList* spam_features_;
  ::ru::mail::go::webbase::blobs::ContactInfoList* contacts_;
  ::ru::mail::go::webbase::blobs::SubjContextList* subj_ctxs_;
  ::ru::mail::go::webbase::blobs::FeatureList* soft_features_;
  ::ru::mail::go::webbase::blobs::FeatureList* market_features_;
  ::ru::mail::go::webbase::blobs::SubjParsed* subj_values_;
  ::ru::mail::go::webbase::blobs::FeatureList* porn_features2_;
  ::google::protobuf::uint32 porn_score_;
  int spam_score_;
  int subj_stage_;
  float soft_score_;
  float market_score_;
  float porn_score_raw_;
  float spam_score_raw_;
  ::google::protobuf::uint32 porn_score2_;
  float porn_score2_raw_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DetectedLanguage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.DetectedLanguage) */ {
 public:
  DetectedLanguage();
  virtual ~DetectedLanguage();

  DetectedLanguage(const DetectedLanguage& from);

  inline DetectedLanguage& operator=(const DetectedLanguage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DetectedLanguage(DetectedLanguage&& from) noexcept
    : DetectedLanguage() {
    *this = ::std::move(from);
  }

  inline DetectedLanguage& operator=(DetectedLanguage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectedLanguage& default_instance();

  static inline const DetectedLanguage* internal_default_instance() {
    return reinterpret_cast<const DetectedLanguage*>(
               &_DetectedLanguage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(DetectedLanguage* other);
  friend void swap(DetectedLanguage& a, DetectedLanguage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DetectedLanguage* New() const PROTOBUF_FINAL { return New(NULL); }

  DetectedLanguage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DetectedLanguage& from);
  void MergeFrom(const DetectedLanguage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DetectedLanguage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double estimation = 2;
  bool has_estimation() const;
  void clear_estimation();
  static const int kEstimationFieldNumber = 2;
  double estimation() const;
  void set_estimation(double value);

  // required .ru.mail.go.webbase.blobs.Language language = 1;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::Language language() const;
  void set_language(::ru::mail::go::webbase::blobs::Language value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.DetectedLanguage)
 private:
  void set_has_language();
  void clear_has_language();
  void set_has_estimation();
  void clear_has_estimation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double estimation_;
  int language_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DetectedLangArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.DetectedLangArray) */ {
 public:
  DetectedLangArray();
  virtual ~DetectedLangArray();

  DetectedLangArray(const DetectedLangArray& from);

  inline DetectedLangArray& operator=(const DetectedLangArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DetectedLangArray(DetectedLangArray&& from) noexcept
    : DetectedLangArray() {
    *this = ::std::move(from);
  }

  inline DetectedLangArray& operator=(DetectedLangArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectedLangArray& default_instance();

  static inline const DetectedLangArray* internal_default_instance() {
    return reinterpret_cast<const DetectedLangArray*>(
               &_DetectedLangArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(DetectedLangArray* other);
  friend void swap(DetectedLangArray& a, DetectedLangArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DetectedLangArray* New() const PROTOBUF_FINAL { return New(NULL); }

  DetectedLangArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DetectedLangArray& from);
  void MergeFrom(const DetectedLangArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DetectedLangArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.DetectedLanguage detected_lang = 1;
  int detected_lang_size() const;
  void clear_detected_lang();
  static const int kDetectedLangFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::DetectedLanguage& detected_lang(int index) const;
  ::ru::mail::go::webbase::blobs::DetectedLanguage* mutable_detected_lang(int index);
  ::ru::mail::go::webbase::blobs::DetectedLanguage* add_detected_lang();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::DetectedLanguage >*
      mutable_detected_lang();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::DetectedLanguage >&
      detected_lang() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.DetectedLangArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::DetectedLanguage > detected_lang_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SiteLanguage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.SiteLanguage) */ {
 public:
  SiteLanguage();
  virtual ~SiteLanguage();

  SiteLanguage(const SiteLanguage& from);

  inline SiteLanguage& operator=(const SiteLanguage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SiteLanguage(SiteLanguage&& from) noexcept
    : SiteLanguage() {
    *this = ::std::move(from);
  }

  inline SiteLanguage& operator=(SiteLanguage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SiteLanguage& default_instance();

  static inline const SiteLanguage* internal_default_instance() {
    return reinterpret_cast<const SiteLanguage*>(
               &_SiteLanguage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(SiteLanguage* other);
  friend void swap(SiteLanguage& a, SiteLanguage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SiteLanguage* New() const PROTOBUF_FINAL { return New(NULL); }

  SiteLanguage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SiteLanguage& from);
  void MergeFrom(const SiteLanguage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SiteLanguage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ru.mail.go.webbase.blobs.Language language = 1;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::Language language() const;
  void set_language(::ru::mail::go::webbase::blobs::Language value);

  // required int32 page_num = 2;
  bool has_page_num() const;
  void clear_page_num();
  static const int kPageNumFieldNumber = 2;
  ::google::protobuf::int32 page_num() const;
  void set_page_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.SiteLanguage)
 private:
  void set_has_language();
  void clear_has_language();
  void set_has_page_num();
  void clear_has_page_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int language_;
  ::google::protobuf::int32 page_num_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SiteLanguageArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.SiteLanguageArray) */ {
 public:
  SiteLanguageArray();
  virtual ~SiteLanguageArray();

  SiteLanguageArray(const SiteLanguageArray& from);

  inline SiteLanguageArray& operator=(const SiteLanguageArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SiteLanguageArray(SiteLanguageArray&& from) noexcept
    : SiteLanguageArray() {
    *this = ::std::move(from);
  }

  inline SiteLanguageArray& operator=(SiteLanguageArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SiteLanguageArray& default_instance();

  static inline const SiteLanguageArray* internal_default_instance() {
    return reinterpret_cast<const SiteLanguageArray*>(
               &_SiteLanguageArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(SiteLanguageArray* other);
  friend void swap(SiteLanguageArray& a, SiteLanguageArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SiteLanguageArray* New() const PROTOBUF_FINAL { return New(NULL); }

  SiteLanguageArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SiteLanguageArray& from);
  void MergeFrom(const SiteLanguageArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SiteLanguageArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.SiteLanguage site_languages = 1;
  int site_languages_size() const;
  void clear_site_languages();
  static const int kSiteLanguagesFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::SiteLanguage& site_languages(int index) const;
  ::ru::mail::go::webbase::blobs::SiteLanguage* mutable_site_languages(int index);
  ::ru::mail::go::webbase::blobs::SiteLanguage* add_site_languages();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SiteLanguage >*
      mutable_site_languages();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SiteLanguage >&
      site_languages() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.SiteLanguageArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SiteLanguage > site_languages_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParsedHtml : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ParsedHtml) */ {
 public:
  ParsedHtml();
  virtual ~ParsedHtml();

  ParsedHtml(const ParsedHtml& from);

  inline ParsedHtml& operator=(const ParsedHtml& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParsedHtml(ParsedHtml&& from) noexcept
    : ParsedHtml() {
    *this = ::std::move(from);
  }

  inline ParsedHtml& operator=(ParsedHtml&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParsedHtml& default_instance();

  static inline const ParsedHtml* internal_default_instance() {
    return reinterpret_cast<const ParsedHtml*>(
               &_ParsedHtml_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(ParsedHtml* other);
  friend void swap(ParsedHtml& a, ParsedHtml& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParsedHtml* New() const PROTOBUF_FINAL { return New(NULL); }

  ParsedHtml* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParsedHtml& from);
  void MergeFrom(const ParsedHtml& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParsedHtml* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ParsedHtml_page_errors page_errors;
  static const page_errors is_ok =
    ParsedHtml_page_errors_is_ok;
  static const page_errors is_spam =
    ParsedHtml_page_errors_is_spam;
  static const page_errors bad_url_normalize =
    ParsedHtml_page_errors_bad_url_normalize;
  static const page_errors has_refresh =
    ParsedHtml_page_errors_has_refresh;
  static const page_errors has_canonical =
    ParsedHtml_page_errors_has_canonical;
  static const page_errors bad_parsing =
    ParsedHtml_page_errors_bad_parsing;
  static inline bool page_errors_IsValid(int value) {
    return ParsedHtml_page_errors_IsValid(value);
  }
  static const page_errors page_errors_MIN =
    ParsedHtml_page_errors_page_errors_MIN;
  static const page_errors page_errors_MAX =
    ParsedHtml_page_errors_page_errors_MAX;
  static const int page_errors_ARRAYSIZE =
    ParsedHtml_page_errors_page_errors_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  page_errors_descriptor() {
    return ParsedHtml_page_errors_descriptor();
  }
  static inline const ::std::string& page_errors_Name(page_errors value) {
    return ParsedHtml_page_errors_Name(value);
  }
  static inline bool page_errors_Parse(const ::std::string& name,
      page_errors* value) {
    return ParsedHtml_page_errors_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.Links links = 6;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 6;
  const ::ru::mail::go::webbase::blobs::Links& links(int index) const;
  ::ru::mail::go::webbase::blobs::Links* mutable_links(int index);
  ::ru::mail::go::webbase::blobs::Links* add_links();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Links >*
      mutable_links();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Links >&
      links() const;

  // optional string canonical_link = 3;
  bool has_canonical_link() const;
  void clear_canonical_link();
  static const int kCanonicalLinkFieldNumber = 3;
  const ::std::string& canonical_link() const;
  void set_canonical_link(const ::std::string& value);
  #if LANG_CXX11
  void set_canonical_link(::std::string&& value);
  #endif
  void set_canonical_link(const char* value);
  void set_canonical_link(const char* value, size_t size);
  ::std::string* mutable_canonical_link();
  ::std::string* release_canonical_link();
  void set_allocated_canonical_link(::std::string* canonical_link);

  // optional string refresh_link = 7;
  bool has_refresh_link() const;
  void clear_refresh_link();
  static const int kRefreshLinkFieldNumber = 7;
  const ::std::string& refresh_link() const;
  void set_refresh_link(const ::std::string& value);
  #if LANG_CXX11
  void set_refresh_link(::std::string&& value);
  #endif
  void set_refresh_link(const char* value);
  void set_refresh_link(const char* value, size_t size);
  ::std::string* mutable_refresh_link();
  ::std::string* release_refresh_link();
  void set_allocated_refresh_link(::std::string* refresh_link);

  // optional string refresh_time = 8;
  bool has_refresh_time() const;
  void clear_refresh_time();
  static const int kRefreshTimeFieldNumber = 8;
  const ::std::string& refresh_time() const;
  void set_refresh_time(const ::std::string& value);
  #if LANG_CXX11
  void set_refresh_time(::std::string&& value);
  #endif
  void set_refresh_time(const char* value);
  void set_refresh_time(const char* value, size_t size);
  ::std::string* mutable_refresh_time();
  ::std::string* release_refresh_time();
  void set_allocated_refresh_time(::std::string* refresh_time);

  // optional string base_link = 9;
  bool has_base_link() const;
  void clear_base_link();
  static const int kBaseLinkFieldNumber = 9;
  const ::std::string& base_link() const;
  void set_base_link(const ::std::string& value);
  #if LANG_CXX11
  void set_base_link(::std::string&& value);
  #endif
  void set_base_link(const char* value);
  void set_base_link(const char* value, size_t size);
  ::std::string* mutable_base_link();
  ::std::string* release_base_link();
  void set_allocated_base_link(::std::string* base_link);

  // optional bytes text = 11;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 11;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const void* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional bytes title = 13;
  bool has_title() const;
  void clear_title();
  static const int kTitleFieldNumber = 13;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const void* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // optional bytes description = 14;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 14;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const void* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional bytes og_description = 17;
  bool has_og_description() const;
  void clear_og_description();
  static const int kOgDescriptionFieldNumber = 17;
  const ::std::string& og_description() const;
  void set_og_description(const ::std::string& value);
  #if LANG_CXX11
  void set_og_description(::std::string&& value);
  #endif
  void set_og_description(const char* value);
  void set_og_description(const void* value, size_t size);
  ::std::string* mutable_og_description();
  ::std::string* release_og_description();
  void set_allocated_og_description(::std::string* og_description);

  // optional bytes og_image = 20;
  bool has_og_image() const;
  void clear_og_image();
  static const int kOgImageFieldNumber = 20;
  const ::std::string& og_image() const;
  void set_og_image(const ::std::string& value);
  #if LANG_CXX11
  void set_og_image(::std::string&& value);
  #endif
  void set_og_image(const char* value);
  void set_og_image(const void* value, size_t size);
  ::std::string* mutable_og_image();
  ::std::string* release_og_image();
  void set_allocated_og_image(::std::string* og_image);

  // optional bytes og_title = 21;
  bool has_og_title() const;
  void clear_og_title();
  static const int kOgTitleFieldNumber = 21;
  const ::std::string& og_title() const;
  void set_og_title(const ::std::string& value);
  #if LANG_CXX11
  void set_og_title(::std::string&& value);
  #endif
  void set_og_title(const char* value);
  void set_og_title(const void* value, size_t size);
  ::std::string* mutable_og_title();
  ::std::string* release_og_title();
  void set_allocated_og_title(::std::string* og_title);

  // optional .ru.mail.go.webbase.blobs.Features features = 10;
  bool has_features() const;
  void clear_features();
  static const int kFeaturesFieldNumber = 10;
  const ::ru::mail::go::webbase::blobs::Features& features() const;
  ::ru::mail::go::webbase::blobs::Features* mutable_features();
  ::ru::mail::go::webbase::blobs::Features* release_features();
  void set_allocated_features(::ru::mail::go::webbase::blobs::Features* features);

  // optional .ru.mail.go.webbase.blobs.DetectedLangArray detLang = 12;
  bool has_detlang() const;
  void clear_detlang();
  static const int kDetLangFieldNumber = 12;
  const ::ru::mail::go::webbase::blobs::DetectedLangArray& detlang() const;
  ::ru::mail::go::webbase::blobs::DetectedLangArray* mutable_detlang();
  ::ru::mail::go::webbase::blobs::DetectedLangArray* release_detlang();
  void set_allocated_detlang(::ru::mail::go::webbase::blobs::DetectedLangArray* detlang);

  // optional .ru.mail.go.webbase.blobs.Language language = 1;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::Language language() const;
  void set_language(::ru::mail::go::webbase::blobs::Language value);

  // optional .ru.mail.go.webbase.blobs.Encoding encoding = 2;
  bool has_encoding() const;
  void clear_encoding();
  static const int kEncodingFieldNumber = 2;
  ::ru::mail::go::webbase::blobs::Encoding encoding() const;
  void set_encoding(::ru::mail::go::webbase::blobs::Encoding value);

  // optional int32 flag_meta_robots = 4;
  bool has_flag_meta_robots() const;
  void clear_flag_meta_robots();
  static const int kFlagMetaRobotsFieldNumber = 4;
  ::google::protobuf::int32 flag_meta_robots() const;
  void set_flag_meta_robots(::google::protobuf::int32 value);

  // optional bool description_quality = 15;
  bool has_description_quality() const;
  void clear_description_quality();
  static const int kDescriptionQualityFieldNumber = 15;
  bool description_quality() const;
  void set_description_quality(bool value);

  // optional bool flag_ajax_fragment = 16;
  bool has_flag_ajax_fragment() const;
  void clear_flag_ajax_fragment();
  static const int kFlagAjaxFragmentFieldNumber = 16;
  bool flag_ajax_fragment() const;
  void set_flag_ajax_fragment(bool value);

  // optional bool og_description_quality = 18;
  bool has_og_description_quality() const;
  void clear_og_description_quality();
  static const int kOgDescriptionQualityFieldNumber = 18;
  bool og_description_quality() const;
  void set_og_description_quality(bool value);

  // optional bool is_meta_content = 19 [default = false];
  bool has_is_meta_content() const;
  void clear_is_meta_content();
  static const int kIsMetaContentFieldNumber = 19;
  bool is_meta_content() const;
  void set_is_meta_content(bool value);

  // optional .ru.mail.go.webbase.blobs.ParsedHtml.page_errors page_error = 5;
  bool has_page_error() const;
  void clear_page_error();
  static const int kPageErrorFieldNumber = 5;
  ::ru::mail::go::webbase::blobs::ParsedHtml_page_errors page_error() const;
  void set_page_error(::ru::mail::go::webbase::blobs::ParsedHtml_page_errors value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ParsedHtml)
 private:
  void set_has_language();
  void clear_has_language();
  void set_has_encoding();
  void clear_has_encoding();
  void set_has_canonical_link();
  void clear_has_canonical_link();
  void set_has_flag_meta_robots();
  void clear_has_flag_meta_robots();
  void set_has_page_error();
  void clear_has_page_error();
  void set_has_refresh_link();
  void clear_has_refresh_link();
  void set_has_refresh_time();
  void clear_has_refresh_time();
  void set_has_base_link();
  void clear_has_base_link();
  void set_has_features();
  void clear_has_features();
  void set_has_text();
  void clear_has_text();
  void set_has_detlang();
  void clear_has_detlang();
  void set_has_title();
  void clear_has_title();
  void set_has_description();
  void clear_has_description();
  void set_has_description_quality();
  void clear_has_description_quality();
  void set_has_flag_ajax_fragment();
  void clear_has_flag_ajax_fragment();
  void set_has_og_description();
  void clear_has_og_description();
  void set_has_og_description_quality();
  void clear_has_og_description_quality();
  void set_has_is_meta_content();
  void clear_has_is_meta_content();
  void set_has_og_image();
  void clear_has_og_image();
  void set_has_og_title();
  void clear_has_og_title();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Links > links_;
  ::google::protobuf::internal::ArenaStringPtr canonical_link_;
  ::google::protobuf::internal::ArenaStringPtr refresh_link_;
  ::google::protobuf::internal::ArenaStringPtr refresh_time_;
  ::google::protobuf::internal::ArenaStringPtr base_link_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr og_description_;
  ::google::protobuf::internal::ArenaStringPtr og_image_;
  ::google::protobuf::internal::ArenaStringPtr og_title_;
  ::ru::mail::go::webbase::blobs::Features* features_;
  ::ru::mail::go::webbase::blobs::DetectedLangArray* detlang_;
  int language_;
  int encoding_;
  ::google::protobuf::int32 flag_meta_robots_;
  bool description_quality_;
  bool flag_ajax_fragment_;
  bool og_description_quality_;
  bool is_meta_content_;
  int page_error_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MetaDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.MetaDescription) */ {
 public:
  MetaDescription();
  virtual ~MetaDescription();

  MetaDescription(const MetaDescription& from);

  inline MetaDescription& operator=(const MetaDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetaDescription(MetaDescription&& from) noexcept
    : MetaDescription() {
    *this = ::std::move(from);
  }

  inline MetaDescription& operator=(MetaDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaDescription& default_instance();

  static inline const MetaDescription* internal_default_instance() {
    return reinterpret_cast<const MetaDescription*>(
               &_MetaDescription_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(MetaDescription* other);
  friend void swap(MetaDescription& a, MetaDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetaDescription* New() const PROTOBUF_FINAL { return New(NULL); }

  MetaDescription* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MetaDescription& from);
  void MergeFrom(const MetaDescription& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MetaDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes descritption = 1;
  bool has_descritption() const;
  void clear_descritption();
  static const int kDescritptionFieldNumber = 1;
  const ::std::string& descritption() const;
  void set_descritption(const ::std::string& value);
  #if LANG_CXX11
  void set_descritption(::std::string&& value);
  #endif
  void set_descritption(const char* value);
  void set_descritption(const void* value, size_t size);
  ::std::string* mutable_descritption();
  ::std::string* release_descritption();
  void set_allocated_descritption(::std::string* descritption);

  // optional bool description_quality = 2;
  bool has_description_quality() const;
  void clear_description_quality();
  static const int kDescriptionQualityFieldNumber = 2;
  bool description_quality() const;
  void set_description_quality(bool value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.MetaDescription)
 private:
  void set_has_descritption();
  void clear_has_descritption();
  void set_has_description_quality();
  void clear_has_description_quality();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr descritption_;
  bool description_quality_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParsedDoc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ParsedDoc) */ {
 public:
  ParsedDoc();
  virtual ~ParsedDoc();

  ParsedDoc(const ParsedDoc& from);

  inline ParsedDoc& operator=(const ParsedDoc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParsedDoc(ParsedDoc&& from) noexcept
    : ParsedDoc() {
    *this = ::std::move(from);
  }

  inline ParsedDoc& operator=(ParsedDoc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParsedDoc& default_instance();

  static inline const ParsedDoc* internal_default_instance() {
    return reinterpret_cast<const ParsedDoc*>(
               &_ParsedDoc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(ParsedDoc* other);
  friend void swap(ParsedDoc& a, ParsedDoc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParsedDoc* New() const PROTOBUF_FINAL { return New(NULL); }

  ParsedDoc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParsedDoc& from);
  void MergeFrom(const ParsedDoc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParsedDoc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.ProfileInfo profiling = 3;
  int profiling_size() const;
  void clear_profiling();
  static const int kProfilingFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::ProfileInfo& profiling(int index) const;
  ::ru::mail::go::webbase::blobs::ProfileInfo* mutable_profiling(int index);
  ::ru::mail::go::webbase::blobs::ProfileInfo* add_profiling();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ProfileInfo >*
      mutable_profiling();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ProfileInfo >&
      profiling() const;

  // optional .ru.mail.go.webbase.blobs.ParsedHtml html_info = 2;
  bool has_html_info() const;
  void clear_html_info();
  static const int kHtmlInfoFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::ParsedHtml& html_info() const;
  ::ru::mail::go::webbase::blobs::ParsedHtml* mutable_html_info();
  ::ru::mail::go::webbase::blobs::ParsedHtml* release_html_info();
  void set_allocated_html_info(::ru::mail::go::webbase::blobs::ParsedHtml* html_info);

  // required .ru.mail.go.webbase.blobs.ContentType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::ContentType type() const;
  void set_type(::ru::mail::go::webbase::blobs::ContentType value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ParsedDoc)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_html_info();
  void clear_has_html_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ProfileInfo > profiling_;
  ::ru::mail::go::webbase::blobs::ParsedHtml* html_info_;
  int type_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StubDoc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.StubDoc) */ {
 public:
  StubDoc();
  virtual ~StubDoc();

  StubDoc(const StubDoc& from);

  inline StubDoc& operator=(const StubDoc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StubDoc(StubDoc&& from) noexcept
    : StubDoc() {
    *this = ::std::move(from);
  }

  inline StubDoc& operator=(StubDoc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StubDoc& default_instance();

  static inline const StubDoc* internal_default_instance() {
    return reinterpret_cast<const StubDoc*>(
               &_StubDoc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(StubDoc* other);
  friend void swap(StubDoc& a, StubDoc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StubDoc* New() const PROTOBUF_FINAL { return New(NULL); }

  StubDoc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StubDoc& from);
  void MergeFrom(const StubDoc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StubDoc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional bytes content = 6;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 6;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // optional .ru.mail.go.webbase.blobs.ContentType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::ru::mail::go::webbase::blobs::ContentType type() const;
  void set_type(::ru::mail::go::webbase::blobs::ContentType value);

  // optional .ru.mail.go.webbase.blobs.Language language = 3;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 3;
  ::ru::mail::go::webbase::blobs::Language language() const;
  void set_language(::ru::mail::go::webbase::blobs::Language value);

  // optional uint64 download_time = 5;
  bool has_download_time() const;
  void clear_download_time();
  static const int kDownloadTimeFieldNumber = 5;
  ::google::protobuf::uint64 download_time() const;
  void set_download_time(::google::protobuf::uint64 value);

  // optional .ru.mail.go.webbase.blobs.Encoding encoding = 4;
  bool has_encoding() const;
  void clear_encoding();
  static const int kEncodingFieldNumber = 4;
  ::ru::mail::go::webbase::blobs::Encoding encoding() const;
  void set_encoding(::ru::mail::go::webbase::blobs::Encoding value);

  // optional bool scriptRemoved = 7;
  bool has_scriptremoved() const;
  void clear_scriptremoved();
  static const int kScriptRemovedFieldNumber = 7;
  bool scriptremoved() const;
  void set_scriptremoved(bool value);

  // optional uint32 content_size = 8;
  bool has_content_size() const;
  void clear_content_size();
  static const int kContentSizeFieldNumber = 8;
  ::google::protobuf::uint32 content_size() const;
  void set_content_size(::google::protobuf::uint32 value);

  // optional uint32 clean_size = 9;
  bool has_clean_size() const;
  void clear_clean_size();
  static const int kCleanSizeFieldNumber = 9;
  ::google::protobuf::uint32 clean_size() const;
  void set_clean_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.StubDoc)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_type();
  void clear_has_type();
  void set_has_language();
  void clear_has_language();
  void set_has_encoding();
  void clear_has_encoding();
  void set_has_download_time();
  void clear_has_download_time();
  void set_has_content();
  void clear_has_content();
  void set_has_scriptremoved();
  void clear_has_scriptremoved();
  void set_has_content_size();
  void clear_has_content_size();
  void set_has_clean_size();
  void clear_has_clean_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  int type_;
  int language_;
  ::google::protobuf::uint64 download_time_;
  int encoding_;
  bool scriptremoved_;
  ::google::protobuf::uint32 content_size_;
  ::google::protobuf::uint32 clean_size_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Region : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.Region) */ {
 public:
  Region();
  virtual ~Region();

  Region(const Region& from);

  inline Region& operator=(const Region& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Region(Region&& from) noexcept
    : Region() {
    *this = ::std::move(from);
  }

  inline Region& operator=(Region&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Region& default_instance();

  static inline const Region* internal_default_instance() {
    return reinterpret_cast<const Region*>(
               &_Region_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(Region* other);
  friend void swap(Region& a, Region& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Region* New() const PROTOBUF_FINAL { return New(NULL); }

  Region* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Region& from);
  void MergeFrom(const Region& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Region* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // required int32 end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.Region)
 private:
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegionBlob : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.RegionBlob) */ {
 public:
  RegionBlob();
  virtual ~RegionBlob();

  RegionBlob(const RegionBlob& from);

  inline RegionBlob& operator=(const RegionBlob& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegionBlob(RegionBlob&& from) noexcept
    : RegionBlob() {
    *this = ::std::move(from);
  }

  inline RegionBlob& operator=(RegionBlob&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionBlob& default_instance();

  static inline const RegionBlob* internal_default_instance() {
    return reinterpret_cast<const RegionBlob*>(
               &_RegionBlob_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(RegionBlob* other);
  friend void swap(RegionBlob& a, RegionBlob& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionBlob* New() const PROTOBUF_FINAL { return New(NULL); }

  RegionBlob* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegionBlob& from);
  void MergeFrom(const RegionBlob& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegionBlob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.Region data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::Region& data(int index) const;
  ::ru::mail::go::webbase::blobs::Region* mutable_data(int index);
  ::ru::mail::go::webbase::blobs::Region* add_data();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Region >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Region >&
      data() const;

  // required int32 num = 1;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.RegionBlob)
 private:
  void set_has_num();
  void clear_has_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Region > data_;
  ::google::protobuf::int32 num_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OriginalDoc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.OriginalDoc) */ {
 public:
  OriginalDoc();
  virtual ~OriginalDoc();

  OriginalDoc(const OriginalDoc& from);

  inline OriginalDoc& operator=(const OriginalDoc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OriginalDoc(OriginalDoc&& from) noexcept
    : OriginalDoc() {
    *this = ::std::move(from);
  }

  inline OriginalDoc& operator=(OriginalDoc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OriginalDoc& default_instance();

  static inline const OriginalDoc* internal_default_instance() {
    return reinterpret_cast<const OriginalDoc*>(
               &_OriginalDoc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(OriginalDoc* other);
  friend void swap(OriginalDoc& a, OriginalDoc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OriginalDoc* New() const PROTOBUF_FINAL { return New(NULL); }

  OriginalDoc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OriginalDoc& from);
  void MergeFrom(const OriginalDoc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OriginalDoc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional bytes content = 3;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 3;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // optional .ru.mail.go.webbase.blobs.RegionBlob cuttedBlob = 9;
  bool has_cuttedblob() const;
  void clear_cuttedblob();
  static const int kCuttedBlobFieldNumber = 9;
  const ::ru::mail::go::webbase::blobs::RegionBlob& cuttedblob() const;
  ::ru::mail::go::webbase::blobs::RegionBlob* mutable_cuttedblob();
  ::ru::mail::go::webbase::blobs::RegionBlob* release_cuttedblob();
  void set_allocated_cuttedblob(::ru::mail::go::webbase::blobs::RegionBlob* cuttedblob);

  // required uint64 download_time = 2;
  bool has_download_time() const;
  void clear_download_time();
  static const int kDownloadTimeFieldNumber = 2;
  ::google::protobuf::uint64 download_time() const;
  void set_download_time(::google::protobuf::uint64 value);

  // optional .ru.mail.go.webbase.blobs.ContentType type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::ru::mail::go::webbase::blobs::ContentType type() const;
  void set_type(::ru::mail::go::webbase::blobs::ContentType value);

  // optional .ru.mail.go.webbase.blobs.Language language = 5;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 5;
  ::ru::mail::go::webbase::blobs::Language language() const;
  void set_language(::ru::mail::go::webbase::blobs::Language value);

  // optional .ru.mail.go.webbase.blobs.Encoding encoding = 6;
  bool has_encoding() const;
  void clear_encoding();
  static const int kEncodingFieldNumber = 6;
  ::ru::mail::go::webbase::blobs::Encoding encoding() const;
  void set_encoding(::ru::mail::go::webbase::blobs::Encoding value);

  // optional uint32 porno_level = 7;
  bool has_porno_level() const;
  void clear_porno_level();
  static const int kPornoLevelFieldNumber = 7;
  ::google::protobuf::uint32 porno_level() const;
  void set_porno_level(::google::protobuf::uint32 value);

  // optional uint32 spam_level = 8;
  bool has_spam_level() const;
  void clear_spam_level();
  static const int kSpamLevelFieldNumber = 8;
  ::google::protobuf::uint32 spam_level() const;
  void set_spam_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.OriginalDoc)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_download_time();
  void clear_has_download_time();
  void set_has_content();
  void clear_has_content();
  void set_has_type();
  void clear_has_type();
  void set_has_language();
  void clear_has_language();
  void set_has_encoding();
  void clear_has_encoding();
  void set_has_porno_level();
  void clear_has_porno_level();
  void set_has_spam_level();
  void clear_has_spam_level();
  void set_has_cuttedblob();
  void clear_has_cuttedblob();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::ru::mail::go::webbase::blobs::RegionBlob* cuttedblob_;
  ::google::protobuf::uint64 download_time_;
  int type_;
  int language_;
  int encoding_;
  ::google::protobuf::uint32 porno_level_;
  ::google::protobuf::uint32 spam_level_;
  friend struct protobuf_doc_5fparser_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AdditionalParsingData

// optional bool ignore_nofollow = 1 [default = false];
inline bool AdditionalParsingData::has_ignore_nofollow() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdditionalParsingData::set_has_ignore_nofollow() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdditionalParsingData::clear_has_ignore_nofollow() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdditionalParsingData::clear_ignore_nofollow() {
  ignore_nofollow_ = false;
  clear_has_ignore_nofollow();
}
inline bool AdditionalParsingData::ignore_nofollow() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.AdditionalParsingData.ignore_nofollow)
  return ignore_nofollow_;
}
inline void AdditionalParsingData::set_ignore_nofollow(bool value) {
  set_has_ignore_nofollow();
  ignore_nofollow_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.AdditionalParsingData.ignore_nofollow)
}

// optional .ru.mail.go.webbase.blobs.Encoding encoding = 2 [default = enc_undefined];
inline bool AdditionalParsingData::has_encoding() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdditionalParsingData::set_has_encoding() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdditionalParsingData::clear_has_encoding() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdditionalParsingData::clear_encoding() {
  encoding_ = 99;
  clear_has_encoding();
}
inline ::ru::mail::go::webbase::blobs::Encoding AdditionalParsingData::encoding() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.AdditionalParsingData.encoding)
  return static_cast< ::ru::mail::go::webbase::blobs::Encoding >(encoding_);
}
inline void AdditionalParsingData::set_encoding(::ru::mail::go::webbase::blobs::Encoding value) {
  assert(::ru::mail::go::webbase::blobs::Encoding_IsValid(value));
  set_has_encoding();
  encoding_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.AdditionalParsingData.encoding)
}

// optional .ru.mail.go.webbase.blobs.ForumType forumType = 3;
inline bool AdditionalParsingData::has_forumtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdditionalParsingData::set_has_forumtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdditionalParsingData::clear_has_forumtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdditionalParsingData::clear_forumtype() {
  forumtype_ = 0;
  clear_has_forumtype();
}
inline ::ru::mail::go::webbase::blobs::ForumType AdditionalParsingData::forumtype() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.AdditionalParsingData.forumType)
  return static_cast< ::ru::mail::go::webbase::blobs::ForumType >(forumtype_);
}
inline void AdditionalParsingData::set_forumtype(::ru::mail::go::webbase::blobs::ForumType value) {
  assert(::ru::mail::go::webbase::blobs::ForumType_IsValid(value));
  set_has_forumtype();
  forumtype_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.AdditionalParsingData.forumType)
}

// optional uint64 downloadTime = 4;
inline bool AdditionalParsingData::has_downloadtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdditionalParsingData::set_has_downloadtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdditionalParsingData::clear_has_downloadtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdditionalParsingData::clear_downloadtime() {
  downloadtime_ = GOOGLE_ULONGLONG(0);
  clear_has_downloadtime();
}
inline ::google::protobuf::uint64 AdditionalParsingData::downloadtime() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.AdditionalParsingData.downloadTime)
  return downloadtime_;
}
inline void AdditionalParsingData::set_downloadtime(::google::protobuf::uint64 value) {
  set_has_downloadtime();
  downloadtime_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.AdditionalParsingData.downloadTime)
}

// optional .ru.mail.go.webbase.blobs.Encoding bom_encoding = 5 [default = enc_undefined];
inline bool AdditionalParsingData::has_bom_encoding() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AdditionalParsingData::set_has_bom_encoding() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AdditionalParsingData::clear_has_bom_encoding() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AdditionalParsingData::clear_bom_encoding() {
  bom_encoding_ = 99;
  clear_has_bom_encoding();
}
inline ::ru::mail::go::webbase::blobs::Encoding AdditionalParsingData::bom_encoding() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.AdditionalParsingData.bom_encoding)
  return static_cast< ::ru::mail::go::webbase::blobs::Encoding >(bom_encoding_);
}
inline void AdditionalParsingData::set_bom_encoding(::ru::mail::go::webbase::blobs::Encoding value) {
  assert(::ru::mail::go::webbase::blobs::Encoding_IsValid(value));
  set_has_bom_encoding();
  bom_encoding_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.AdditionalParsingData.bom_encoding)
}

// optional int32 flag_meta_robots = 6;
inline bool AdditionalParsingData::has_flag_meta_robots() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdditionalParsingData::set_has_flag_meta_robots() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdditionalParsingData::clear_has_flag_meta_robots() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdditionalParsingData::clear_flag_meta_robots() {
  flag_meta_robots_ = 0;
  clear_has_flag_meta_robots();
}
inline ::google::protobuf::int32 AdditionalParsingData::flag_meta_robots() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.AdditionalParsingData.flag_meta_robots)
  return flag_meta_robots_;
}
inline void AdditionalParsingData::set_flag_meta_robots(::google::protobuf::int32 value) {
  set_has_flag_meta_robots();
  flag_meta_robots_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.AdditionalParsingData.flag_meta_robots)
}

// optional .ru.mail.go.webbase.blobs.Encoding forced_encoding = 7 [default = enc_undefined];
inline bool AdditionalParsingData::has_forced_encoding() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdditionalParsingData::set_has_forced_encoding() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdditionalParsingData::clear_has_forced_encoding() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdditionalParsingData::clear_forced_encoding() {
  forced_encoding_ = 99;
  clear_has_forced_encoding();
}
inline ::ru::mail::go::webbase::blobs::Encoding AdditionalParsingData::forced_encoding() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.AdditionalParsingData.forced_encoding)
  return static_cast< ::ru::mail::go::webbase::blobs::Encoding >(forced_encoding_);
}
inline void AdditionalParsingData::set_forced_encoding(::ru::mail::go::webbase::blobs::Encoding value) {
  assert(::ru::mail::go::webbase::blobs::Encoding_IsValid(value));
  set_has_forced_encoding();
  forced_encoding_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.AdditionalParsingData.forced_encoding)
}

// -------------------------------------------------------------------

// Links

// required string url = 1;
inline bool Links::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Links::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Links::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Links::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& Links::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Links.url)
  return url_.GetNoArena();
}
inline void Links::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Links.url)
}
#if LANG_CXX11
inline void Links::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Links.url)
}
#endif
inline void Links::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Links.url)
}
inline void Links::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Links.url)
}
inline ::std::string* Links::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Links.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Links::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Links.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Links::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Links.url)
}

// optional bytes text = 2;
inline bool Links::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Links::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Links::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Links::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Links::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Links.text)
  return text_.GetNoArena();
}
inline void Links::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Links.text)
}
#if LANG_CXX11
inline void Links::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Links.text)
}
#endif
inline void Links::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Links.text)
}
inline void Links::set_text(const void* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Links.text)
}
inline ::std::string* Links::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Links.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Links::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Links.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Links::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Links.text)
}

// optional .ru.mail.go.webbase.blobs.Links.typeFlag flag = 3;
inline bool Links::has_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Links::set_has_flag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Links::clear_has_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Links::clear_flag() {
  flag_ = 1;
  clear_has_flag();
}
inline ::ru::mail::go::webbase::blobs::Links_typeFlag Links::flag() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Links.flag)
  return static_cast< ::ru::mail::go::webbase::blobs::Links_typeFlag >(flag_);
}
inline void Links::set_flag(::ru::mail::go::webbase::blobs::Links_typeFlag value) {
  assert(::ru::mail::go::webbase::blobs::Links_typeFlag_IsValid(value));
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Links.flag)
}

// -------------------------------------------------------------------

// FeatureKV

// required string key = 1;
inline bool FeatureKV::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureKV::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureKV::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeatureKV::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& FeatureKV::key() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FeatureKV.key)
  return key_.GetNoArena();
}
inline void FeatureKV::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FeatureKV.key)
}
#if LANG_CXX11
inline void FeatureKV::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.FeatureKV.key)
}
#endif
inline void FeatureKV::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FeatureKV.key)
}
inline void FeatureKV::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FeatureKV.key)
}
inline ::std::string* FeatureKV::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FeatureKV.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FeatureKV::release_key() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FeatureKV.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FeatureKV::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FeatureKV.key)
}

// required float value = 2;
inline bool FeatureKV::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureKV::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureKV::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeatureKV::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float FeatureKV::value() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FeatureKV.value)
  return value_;
}
inline void FeatureKV::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FeatureKV.value)
}

// -------------------------------------------------------------------

// FeatureList

// repeated .ru.mail.go.webbase.blobs.FeatureKV features = 1;
inline int FeatureList::features_size() const {
  return features_.size();
}
inline void FeatureList::clear_features() {
  features_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::FeatureKV& FeatureList::features(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FeatureList.features)
  return features_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::FeatureKV* FeatureList::mutable_features(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FeatureList.features)
  return features_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::FeatureKV* FeatureList::add_features() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.FeatureList.features)
  return features_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::FeatureKV >*
FeatureList::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.FeatureList.features)
  return &features_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::FeatureKV >&
FeatureList::features() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.FeatureList.features)
  return features_;
}

// -------------------------------------------------------------------

// RegionKV

// required int32 key = 1;
inline bool RegionKV::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionKV::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionKV::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionKV::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 RegionKV::key() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.RegionKV.key)
  return key_;
}
inline void RegionKV::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.RegionKV.key)
}

// required int32 value = 2;
inline bool RegionKV::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionKV::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegionKV::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegionKV::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 RegionKV::value() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.RegionKV.value)
  return value_;
}
inline void RegionKV::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.RegionKV.value)
}

// -------------------------------------------------------------------

// RegionList

// repeated .ru.mail.go.webbase.blobs.RegionKV region_info = 1;
inline int RegionList::region_info_size() const {
  return region_info_.size();
}
inline void RegionList::clear_region_info() {
  region_info_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::RegionKV& RegionList::region_info(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.RegionList.region_info)
  return region_info_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::RegionKV* RegionList::mutable_region_info(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.RegionList.region_info)
  return region_info_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::RegionKV* RegionList::add_region_info() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.RegionList.region_info)
  return region_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::RegionKV >*
RegionList::mutable_region_info() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.RegionList.region_info)
  return &region_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::RegionKV >&
RegionList::region_info() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.RegionList.region_info)
  return region_info_;
}

// -------------------------------------------------------------------

// ContactInfo

// required string phone = 1;
inline bool ContactInfo::has_phone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactInfo::set_has_phone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactInfo::clear_has_phone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactInfo::clear_phone() {
  phone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_phone();
}
inline const ::std::string& ContactInfo::phone() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ContactInfo.phone)
  return phone_.GetNoArena();
}
inline void ContactInfo::set_phone(const ::std::string& value) {
  set_has_phone();
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ContactInfo.phone)
}
#if LANG_CXX11
inline void ContactInfo::set_phone(::std::string&& value) {
  set_has_phone();
  phone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ContactInfo.phone)
}
#endif
inline void ContactInfo::set_phone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_phone();
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ContactInfo.phone)
}
inline void ContactInfo::set_phone(const char* value, size_t size) {
  set_has_phone();
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ContactInfo.phone)
}
inline ::std::string* ContactInfo::mutable_phone() {
  set_has_phone();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ContactInfo.phone)
  return phone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContactInfo::release_phone() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ContactInfo.phone)
  clear_has_phone();
  return phone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContactInfo::set_allocated_phone(::std::string* phone) {
  if (phone != NULL) {
    set_has_phone();
  } else {
    clear_has_phone();
  }
  phone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phone);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ContactInfo.phone)
}

// required string address = 2;
inline bool ContactInfo::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactInfo::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactInfo::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& ContactInfo::address() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ContactInfo.address)
  return address_.GetNoArena();
}
inline void ContactInfo::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ContactInfo.address)
}
#if LANG_CXX11
inline void ContactInfo::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ContactInfo.address)
}
#endif
inline void ContactInfo::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ContactInfo.address)
}
inline void ContactInfo::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ContactInfo.address)
}
inline ::std::string* ContactInfo::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ContactInfo.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContactInfo::release_address() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ContactInfo.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContactInfo::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ContactInfo.address)
}

// -------------------------------------------------------------------

// ContactInfoList

// repeated .ru.mail.go.webbase.blobs.ContactInfo contacts = 1;
inline int ContactInfoList::contacts_size() const {
  return contacts_.size();
}
inline void ContactInfoList::clear_contacts() {
  contacts_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::ContactInfo& ContactInfoList::contacts(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ContactInfoList.contacts)
  return contacts_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::ContactInfo* ContactInfoList::mutable_contacts(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ContactInfoList.contacts)
  return contacts_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::ContactInfo* ContactInfoList::add_contacts() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ContactInfoList.contacts)
  return contacts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ContactInfo >*
ContactInfoList::mutable_contacts() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ContactInfoList.contacts)
  return &contacts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ContactInfo >&
ContactInfoList::contacts() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ContactInfoList.contacts)
  return contacts_;
}

// -------------------------------------------------------------------

// SubjContext

// required string text = 1;
inline bool SubjContext::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubjContext::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubjContext::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubjContext::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& SubjContext::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SubjContext.text)
  return text_.GetNoArena();
}
inline void SubjContext::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.SubjContext.text)
}
#if LANG_CXX11
inline void SubjContext::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.SubjContext.text)
}
#endif
inline void SubjContext::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.SubjContext.text)
}
inline void SubjContext::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.SubjContext.text)
}
inline ::std::string* SubjContext::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.SubjContext.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubjContext::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.SubjContext.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubjContext::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.SubjContext.text)
}

// -------------------------------------------------------------------

// SubjContextList

// repeated .ru.mail.go.webbase.blobs.SubjContext contexts = 1;
inline int SubjContextList::contexts_size() const {
  return contexts_.size();
}
inline void SubjContextList::clear_contexts() {
  contexts_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::SubjContext& SubjContextList::contexts(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SubjContextList.contexts)
  return contexts_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::SubjContext* SubjContextList::mutable_contexts(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.SubjContextList.contexts)
  return contexts_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::SubjContext* SubjContextList::add_contexts() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.SubjContextList.contexts)
  return contexts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SubjContext >*
SubjContextList::mutable_contexts() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.SubjContextList.contexts)
  return &contexts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SubjContext >&
SubjContextList::contexts() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.SubjContextList.contexts)
  return contexts_;
}

// -------------------------------------------------------------------

// ProfileInfo

// required int64 time = 1;
inline bool ProfileInfo::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProfileInfo::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProfileInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProfileInfo::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 ProfileInfo::time() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ProfileInfo.time)
  return time_;
}
inline void ProfileInfo::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ProfileInfo.time)
}

// optional string counter = 2;
inline bool ProfileInfo::has_counter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProfileInfo::set_has_counter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProfileInfo::clear_has_counter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProfileInfo::clear_counter() {
  counter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_counter();
}
inline const ::std::string& ProfileInfo::counter() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ProfileInfo.counter)
  return counter_.GetNoArena();
}
inline void ProfileInfo::set_counter(const ::std::string& value) {
  set_has_counter();
  counter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ProfileInfo.counter)
}
#if LANG_CXX11
inline void ProfileInfo::set_counter(::std::string&& value) {
  set_has_counter();
  counter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ProfileInfo.counter)
}
#endif
inline void ProfileInfo::set_counter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_counter();
  counter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ProfileInfo.counter)
}
inline void ProfileInfo::set_counter(const char* value, size_t size) {
  set_has_counter();
  counter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ProfileInfo.counter)
}
inline ::std::string* ProfileInfo::mutable_counter() {
  set_has_counter();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ProfileInfo.counter)
  return counter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProfileInfo::release_counter() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ProfileInfo.counter)
  clear_has_counter();
  return counter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProfileInfo::set_allocated_counter(::std::string* counter) {
  if (counter != NULL) {
    set_has_counter();
  } else {
    clear_has_counter();
  }
  counter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), counter);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ProfileInfo.counter)
}

// -------------------------------------------------------------------

// SubjParsed_KeyValue

// required string key = 1;
inline bool SubjParsed_KeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubjParsed_KeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubjParsed_KeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubjParsed_KeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& SubjParsed_KeyValue::key() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.key)
  return key_.GetNoArena();
}
inline void SubjParsed_KeyValue::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.key)
}
#if LANG_CXX11
inline void SubjParsed_KeyValue::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.key)
}
#endif
inline void SubjParsed_KeyValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.key)
}
inline void SubjParsed_KeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.key)
}
inline ::std::string* SubjParsed_KeyValue::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubjParsed_KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubjParsed_KeyValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.key)
}

// repeated string values = 2;
inline int SubjParsed_KeyValue::values_size() const {
  return values_.size();
}
inline void SubjParsed_KeyValue::clear_values() {
  values_.Clear();
}
inline const ::std::string& SubjParsed_KeyValue::values(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
  return values_.Get(index);
}
inline ::std::string* SubjParsed_KeyValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
  return values_.Mutable(index);
}
inline void SubjParsed_KeyValue::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SubjParsed_KeyValue::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SubjParsed_KeyValue::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
}
inline void SubjParsed_KeyValue::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
}
inline ::std::string* SubjParsed_KeyValue::add_values() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
  return values_.Add();
}
inline void SubjParsed_KeyValue::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
}
#if LANG_CXX11
inline void SubjParsed_KeyValue::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
}
#endif
inline void SubjParsed_KeyValue::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
}
inline void SubjParsed_KeyValue::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SubjParsed_KeyValue::values() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SubjParsed_KeyValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.values)
  return &values_;
}

// repeated bytes bvalues = 3;
inline int SubjParsed_KeyValue::bvalues_size() const {
  return bvalues_.size();
}
inline void SubjParsed_KeyValue::clear_bvalues() {
  bvalues_.Clear();
}
inline const ::std::string& SubjParsed_KeyValue::bvalues(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
  return bvalues_.Get(index);
}
inline ::std::string* SubjParsed_KeyValue::mutable_bvalues(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
  return bvalues_.Mutable(index);
}
inline void SubjParsed_KeyValue::set_bvalues(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
  bvalues_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SubjParsed_KeyValue::set_bvalues(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
  bvalues_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SubjParsed_KeyValue::set_bvalues(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  bvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
}
inline void SubjParsed_KeyValue::set_bvalues(int index, const void* value, size_t size) {
  bvalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
}
inline ::std::string* SubjParsed_KeyValue::add_bvalues() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
  return bvalues_.Add();
}
inline void SubjParsed_KeyValue::add_bvalues(const ::std::string& value) {
  bvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
}
#if LANG_CXX11
inline void SubjParsed_KeyValue::add_bvalues(::std::string&& value) {
  bvalues_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
}
#endif
inline void SubjParsed_KeyValue::add_bvalues(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  bvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
}
inline void SubjParsed_KeyValue::add_bvalues(const void* value, size_t size) {
  bvalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SubjParsed_KeyValue::bvalues() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
  return bvalues_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SubjParsed_KeyValue::mutable_bvalues() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.SubjParsed.KeyValue.bvalues)
  return &bvalues_;
}

// -------------------------------------------------------------------

// SubjParsed

// repeated .ru.mail.go.webbase.blobs.SubjParsed.KeyValue values = 1;
inline int SubjParsed::values_size() const {
  return values_.size();
}
inline void SubjParsed::clear_values() {
  values_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::SubjParsed_KeyValue& SubjParsed::values(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SubjParsed.values)
  return values_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::SubjParsed_KeyValue* SubjParsed::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.SubjParsed.values)
  return values_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::SubjParsed_KeyValue* SubjParsed::add_values() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.SubjParsed.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SubjParsed_KeyValue >*
SubjParsed::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.SubjParsed.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SubjParsed_KeyValue >&
SubjParsed::values() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.SubjParsed.values)
  return values_;
}

// -------------------------------------------------------------------

// ImageInfo

// required bytes key = 1;
inline bool ImageInfo::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageInfo::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageInfo::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageInfo::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& ImageInfo::key() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageInfo.key)
  return key_.GetNoArena();
}
inline void ImageInfo::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageInfo.key)
}
#if LANG_CXX11
inline void ImageInfo::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageInfo.key)
}
#endif
inline void ImageInfo::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageInfo.key)
}
inline void ImageInfo::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageInfo.key)
}
inline ::std::string* ImageInfo::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageInfo.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageInfo::release_key() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageInfo.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageInfo.key)
}

// required bytes content = 2;
inline bool ImageInfo::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageInfo::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageInfo::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageInfo::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& ImageInfo::content() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageInfo.content)
  return content_.GetNoArena();
}
inline void ImageInfo::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageInfo.content)
}
#if LANG_CXX11
inline void ImageInfo::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageInfo.content)
}
#endif
inline void ImageInfo::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageInfo.content)
}
inline void ImageInfo::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageInfo.content)
}
inline ::std::string* ImageInfo::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageInfo.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageInfo::release_content() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageInfo.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageInfo.content)
}

// required bytes head = 3;
inline bool ImageInfo::has_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageInfo::set_has_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageInfo::clear_has_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageInfo::clear_head() {
  head_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_head();
}
inline const ::std::string& ImageInfo::head() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageInfo.head)
  return head_.GetNoArena();
}
inline void ImageInfo::set_head(const ::std::string& value) {
  set_has_head();
  head_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageInfo.head)
}
#if LANG_CXX11
inline void ImageInfo::set_head(::std::string&& value) {
  set_has_head();
  head_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageInfo.head)
}
#endif
inline void ImageInfo::set_head(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_head();
  head_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageInfo.head)
}
inline void ImageInfo::set_head(const void* value, size_t size) {
  set_has_head();
  head_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageInfo.head)
}
inline ::std::string* ImageInfo::mutable_head() {
  set_has_head();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageInfo.head)
  return head_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageInfo::release_head() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageInfo.head)
  clear_has_head();
  return head_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_head(::std::string* head) {
  if (head != NULL) {
    set_has_head();
  } else {
    clear_has_head();
  }
  head_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), head);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageInfo.head)
}

// required .ru.mail.go.webbase.blobs.ContentType ctype = 4;
inline bool ImageInfo::has_ctype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageInfo::set_has_ctype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageInfo::clear_has_ctype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageInfo::clear_ctype() {
  ctype_ = 0;
  clear_has_ctype();
}
inline ::ru::mail::go::webbase::blobs::ContentType ImageInfo::ctype() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageInfo.ctype)
  return static_cast< ::ru::mail::go::webbase::blobs::ContentType >(ctype_);
}
inline void ImageInfo::set_ctype(::ru::mail::go::webbase::blobs::ContentType value) {
  assert(::ru::mail::go::webbase::blobs::ContentType_IsValid(value));
  set_has_ctype();
  ctype_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageInfo.ctype)
}

// optional uint64 download_time = 5;
inline bool ImageInfo::has_download_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageInfo::set_has_download_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageInfo::clear_has_download_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageInfo::clear_download_time() {
  download_time_ = GOOGLE_ULONGLONG(0);
  clear_has_download_time();
}
inline ::google::protobuf::uint64 ImageInfo::download_time() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageInfo.download_time)
  return download_time_;
}
inline void ImageInfo::set_download_time(::google::protobuf::uint64 value) {
  set_has_download_time();
  download_time_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageInfo.download_time)
}

// optional string fullUrl = 6;
inline bool ImageInfo::has_fullurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageInfo::set_has_fullurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageInfo::clear_has_fullurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageInfo::clear_fullurl() {
  fullurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fullurl();
}
inline const ::std::string& ImageInfo::fullurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageInfo.fullUrl)
  return fullurl_.GetNoArena();
}
inline void ImageInfo::set_fullurl(const ::std::string& value) {
  set_has_fullurl();
  fullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageInfo.fullUrl)
}
#if LANG_CXX11
inline void ImageInfo::set_fullurl(::std::string&& value) {
  set_has_fullurl();
  fullurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageInfo.fullUrl)
}
#endif
inline void ImageInfo::set_fullurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fullurl();
  fullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageInfo.fullUrl)
}
inline void ImageInfo::set_fullurl(const char* value, size_t size) {
  set_has_fullurl();
  fullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageInfo.fullUrl)
}
inline ::std::string* ImageInfo::mutable_fullurl() {
  set_has_fullurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageInfo.fullUrl)
  return fullurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageInfo::release_fullurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageInfo.fullUrl)
  clear_has_fullurl();
  return fullurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_fullurl(::std::string* fullurl) {
  if (fullurl != NULL) {
    set_has_fullurl();
  } else {
    clear_has_fullurl();
  }
  fullurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fullurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageInfo.fullUrl)
}

// -------------------------------------------------------------------

// ChromeImageInfo

// required .ru.mail.go.webbase.blobs.ImageInfo imageInfo = 1;
inline bool ChromeImageInfo::has_imageinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromeImageInfo::set_has_imageinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChromeImageInfo::clear_has_imageinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChromeImageInfo::clear_imageinfo() {
  if (imageinfo_ != NULL) imageinfo_->::ru::mail::go::webbase::blobs::ImageInfo::Clear();
  clear_has_imageinfo();
}
inline const ::ru::mail::go::webbase::blobs::ImageInfo& ChromeImageInfo::imageinfo() const {
  const ::ru::mail::go::webbase::blobs::ImageInfo* p = imageinfo_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ChromeImageInfo.imageInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ImageInfo*>(
      &::ru::mail::go::webbase::blobs::_ImageInfo_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ImageInfo* ChromeImageInfo::mutable_imageinfo() {
  set_has_imageinfo();
  if (imageinfo_ == NULL) {
    imageinfo_ = new ::ru::mail::go::webbase::blobs::ImageInfo;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ChromeImageInfo.imageInfo)
  return imageinfo_;
}
inline ::ru::mail::go::webbase::blobs::ImageInfo* ChromeImageInfo::release_imageinfo() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ChromeImageInfo.imageInfo)
  clear_has_imageinfo();
  ::ru::mail::go::webbase::blobs::ImageInfo* temp = imageinfo_;
  imageinfo_ = NULL;
  return temp;
}
inline void ChromeImageInfo::set_allocated_imageinfo(::ru::mail::go::webbase::blobs::ImageInfo* imageinfo) {
  delete imageinfo_;
  imageinfo_ = imageinfo;
  if (imageinfo) {
    set_has_imageinfo();
  } else {
    clear_has_imageinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ChromeImageInfo.imageInfo)
}

// -------------------------------------------------------------------

// Features

// optional uint32 porn_score = 1;
inline bool Features::has_porn_score() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Features::set_has_porn_score() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Features::clear_has_porn_score() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Features::clear_porn_score() {
  porn_score_ = 0u;
  clear_has_porn_score();
}
inline ::google::protobuf::uint32 Features::porn_score() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.porn_score)
  return porn_score_;
}
inline void Features::set_porn_score(::google::protobuf::uint32 value) {
  set_has_porn_score();
  porn_score_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.porn_score)
}

// optional .ru.mail.go.webbase.blobs.FeatureList porn_features = 2;
inline bool Features::has_porn_features() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Features::set_has_porn_features() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Features::clear_has_porn_features() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Features::clear_porn_features() {
  if (porn_features_ != NULL) porn_features_->::ru::mail::go::webbase::blobs::FeatureList::Clear();
  clear_has_porn_features();
}
inline const ::ru::mail::go::webbase::blobs::FeatureList& Features::porn_features() const {
  const ::ru::mail::go::webbase::blobs::FeatureList* p = porn_features_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.porn_features)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::FeatureList*>(
      &::ru::mail::go::webbase::blobs::_FeatureList_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::FeatureList* Features::mutable_porn_features() {
  set_has_porn_features();
  if (porn_features_ == NULL) {
    porn_features_ = new ::ru::mail::go::webbase::blobs::FeatureList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Features.porn_features)
  return porn_features_;
}
inline ::ru::mail::go::webbase::blobs::FeatureList* Features::release_porn_features() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Features.porn_features)
  clear_has_porn_features();
  ::ru::mail::go::webbase::blobs::FeatureList* temp = porn_features_;
  porn_features_ = NULL;
  return temp;
}
inline void Features::set_allocated_porn_features(::ru::mail::go::webbase::blobs::FeatureList* porn_features) {
  delete porn_features_;
  porn_features_ = porn_features;
  if (porn_features) {
    set_has_porn_features();
  } else {
    clear_has_porn_features();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Features.porn_features)
}

// optional .ru.mail.go.webbase.blobs.Features.spam_t spam_score = 3;
inline bool Features::has_spam_score() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Features::set_has_spam_score() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Features::clear_has_spam_score() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Features::clear_spam_score() {
  spam_score_ = 0;
  clear_has_spam_score();
}
inline ::ru::mail::go::webbase::blobs::Features_spam_t Features::spam_score() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.spam_score)
  return static_cast< ::ru::mail::go::webbase::blobs::Features_spam_t >(spam_score_);
}
inline void Features::set_spam_score(::ru::mail::go::webbase::blobs::Features_spam_t value) {
  assert(::ru::mail::go::webbase::blobs::Features_spam_t_IsValid(value));
  set_has_spam_score();
  spam_score_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.spam_score)
}

// optional .ru.mail.go.webbase.blobs.FeatureList spam_features = 4;
inline bool Features::has_spam_features() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Features::set_has_spam_features() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Features::clear_has_spam_features() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Features::clear_spam_features() {
  if (spam_features_ != NULL) spam_features_->::ru::mail::go::webbase::blobs::FeatureList::Clear();
  clear_has_spam_features();
}
inline const ::ru::mail::go::webbase::blobs::FeatureList& Features::spam_features() const {
  const ::ru::mail::go::webbase::blobs::FeatureList* p = spam_features_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.spam_features)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::FeatureList*>(
      &::ru::mail::go::webbase::blobs::_FeatureList_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::FeatureList* Features::mutable_spam_features() {
  set_has_spam_features();
  if (spam_features_ == NULL) {
    spam_features_ = new ::ru::mail::go::webbase::blobs::FeatureList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Features.spam_features)
  return spam_features_;
}
inline ::ru::mail::go::webbase::blobs::FeatureList* Features::release_spam_features() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Features.spam_features)
  clear_has_spam_features();
  ::ru::mail::go::webbase::blobs::FeatureList* temp = spam_features_;
  spam_features_ = NULL;
  return temp;
}
inline void Features::set_allocated_spam_features(::ru::mail::go::webbase::blobs::FeatureList* spam_features) {
  delete spam_features_;
  spam_features_ = spam_features;
  if (spam_features) {
    set_has_spam_features();
  } else {
    clear_has_spam_features();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Features.spam_features)
}

// optional string contact_url = 5;
inline bool Features::has_contact_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Features::set_has_contact_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Features::clear_has_contact_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Features::clear_contact_url() {
  contact_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_contact_url();
}
inline const ::std::string& Features::contact_url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.contact_url)
  return contact_url_.GetNoArena();
}
inline void Features::set_contact_url(const ::std::string& value) {
  set_has_contact_url();
  contact_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.contact_url)
}
#if LANG_CXX11
inline void Features::set_contact_url(::std::string&& value) {
  set_has_contact_url();
  contact_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Features.contact_url)
}
#endif
inline void Features::set_contact_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_contact_url();
  contact_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Features.contact_url)
}
inline void Features::set_contact_url(const char* value, size_t size) {
  set_has_contact_url();
  contact_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Features.contact_url)
}
inline ::std::string* Features::mutable_contact_url() {
  set_has_contact_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Features.contact_url)
  return contact_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Features::release_contact_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Features.contact_url)
  clear_has_contact_url();
  return contact_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Features::set_allocated_contact_url(::std::string* contact_url) {
  if (contact_url != NULL) {
    set_has_contact_url();
  } else {
    clear_has_contact_url();
  }
  contact_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contact_url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Features.contact_url)
}

// optional .ru.mail.go.webbase.blobs.ContactInfoList contacts = 6;
inline bool Features::has_contacts() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Features::set_has_contacts() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Features::clear_has_contacts() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Features::clear_contacts() {
  if (contacts_ != NULL) contacts_->::ru::mail::go::webbase::blobs::ContactInfoList::Clear();
  clear_has_contacts();
}
inline const ::ru::mail::go::webbase::blobs::ContactInfoList& Features::contacts() const {
  const ::ru::mail::go::webbase::blobs::ContactInfoList* p = contacts_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.contacts)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ContactInfoList*>(
      &::ru::mail::go::webbase::blobs::_ContactInfoList_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ContactInfoList* Features::mutable_contacts() {
  set_has_contacts();
  if (contacts_ == NULL) {
    contacts_ = new ::ru::mail::go::webbase::blobs::ContactInfoList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Features.contacts)
  return contacts_;
}
inline ::ru::mail::go::webbase::blobs::ContactInfoList* Features::release_contacts() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Features.contacts)
  clear_has_contacts();
  ::ru::mail::go::webbase::blobs::ContactInfoList* temp = contacts_;
  contacts_ = NULL;
  return temp;
}
inline void Features::set_allocated_contacts(::ru::mail::go::webbase::blobs::ContactInfoList* contacts) {
  delete contacts_;
  contacts_ = contacts;
  if (contacts) {
    set_has_contacts();
  } else {
    clear_has_contacts();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Features.contacts)
}

// optional .ru.mail.go.webbase.blobs.Features.subj_t subj_stage = 7;
inline bool Features::has_subj_stage() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Features::set_has_subj_stage() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Features::clear_has_subj_stage() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Features::clear_subj_stage() {
  subj_stage_ = 0;
  clear_has_subj_stage();
}
inline ::ru::mail::go::webbase::blobs::Features_subj_t Features::subj_stage() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.subj_stage)
  return static_cast< ::ru::mail::go::webbase::blobs::Features_subj_t >(subj_stage_);
}
inline void Features::set_subj_stage(::ru::mail::go::webbase::blobs::Features_subj_t value) {
  assert(::ru::mail::go::webbase::blobs::Features_subj_t_IsValid(value));
  set_has_subj_stage();
  subj_stage_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.subj_stage)
}

// optional string subj_name = 8;
inline bool Features::has_subj_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Features::set_has_subj_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Features::clear_has_subj_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Features::clear_subj_name() {
  subj_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_subj_name();
}
inline const ::std::string& Features::subj_name() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.subj_name)
  return subj_name_.GetNoArena();
}
inline void Features::set_subj_name(const ::std::string& value) {
  set_has_subj_name();
  subj_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.subj_name)
}
#if LANG_CXX11
inline void Features::set_subj_name(::std::string&& value) {
  set_has_subj_name();
  subj_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Features.subj_name)
}
#endif
inline void Features::set_subj_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_subj_name();
  subj_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Features.subj_name)
}
inline void Features::set_subj_name(const char* value, size_t size) {
  set_has_subj_name();
  subj_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Features.subj_name)
}
inline ::std::string* Features::mutable_subj_name() {
  set_has_subj_name();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Features.subj_name)
  return subj_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Features::release_subj_name() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Features.subj_name)
  clear_has_subj_name();
  return subj_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Features::set_allocated_subj_name(::std::string* subj_name) {
  if (subj_name != NULL) {
    set_has_subj_name();
  } else {
    clear_has_subj_name();
  }
  subj_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subj_name);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Features.subj_name)
}

// optional .ru.mail.go.webbase.blobs.SubjContextList subj_ctxs = 9;
inline bool Features::has_subj_ctxs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Features::set_has_subj_ctxs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Features::clear_has_subj_ctxs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Features::clear_subj_ctxs() {
  if (subj_ctxs_ != NULL) subj_ctxs_->::ru::mail::go::webbase::blobs::SubjContextList::Clear();
  clear_has_subj_ctxs();
}
inline const ::ru::mail::go::webbase::blobs::SubjContextList& Features::subj_ctxs() const {
  const ::ru::mail::go::webbase::blobs::SubjContextList* p = subj_ctxs_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.subj_ctxs)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::SubjContextList*>(
      &::ru::mail::go::webbase::blobs::_SubjContextList_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::SubjContextList* Features::mutable_subj_ctxs() {
  set_has_subj_ctxs();
  if (subj_ctxs_ == NULL) {
    subj_ctxs_ = new ::ru::mail::go::webbase::blobs::SubjContextList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Features.subj_ctxs)
  return subj_ctxs_;
}
inline ::ru::mail::go::webbase::blobs::SubjContextList* Features::release_subj_ctxs() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Features.subj_ctxs)
  clear_has_subj_ctxs();
  ::ru::mail::go::webbase::blobs::SubjContextList* temp = subj_ctxs_;
  subj_ctxs_ = NULL;
  return temp;
}
inline void Features::set_allocated_subj_ctxs(::ru::mail::go::webbase::blobs::SubjContextList* subj_ctxs) {
  delete subj_ctxs_;
  subj_ctxs_ = subj_ctxs;
  if (subj_ctxs) {
    set_has_subj_ctxs();
  } else {
    clear_has_subj_ctxs();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Features.subj_ctxs)
}

// optional float soft_score = 10;
inline bool Features::has_soft_score() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Features::set_has_soft_score() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Features::clear_has_soft_score() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Features::clear_soft_score() {
  soft_score_ = 0;
  clear_has_soft_score();
}
inline float Features::soft_score() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.soft_score)
  return soft_score_;
}
inline void Features::set_soft_score(float value) {
  set_has_soft_score();
  soft_score_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.soft_score)
}

// optional .ru.mail.go.webbase.blobs.FeatureList soft_features = 11;
inline bool Features::has_soft_features() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Features::set_has_soft_features() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Features::clear_has_soft_features() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Features::clear_soft_features() {
  if (soft_features_ != NULL) soft_features_->::ru::mail::go::webbase::blobs::FeatureList::Clear();
  clear_has_soft_features();
}
inline const ::ru::mail::go::webbase::blobs::FeatureList& Features::soft_features() const {
  const ::ru::mail::go::webbase::blobs::FeatureList* p = soft_features_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.soft_features)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::FeatureList*>(
      &::ru::mail::go::webbase::blobs::_FeatureList_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::FeatureList* Features::mutable_soft_features() {
  set_has_soft_features();
  if (soft_features_ == NULL) {
    soft_features_ = new ::ru::mail::go::webbase::blobs::FeatureList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Features.soft_features)
  return soft_features_;
}
inline ::ru::mail::go::webbase::blobs::FeatureList* Features::release_soft_features() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Features.soft_features)
  clear_has_soft_features();
  ::ru::mail::go::webbase::blobs::FeatureList* temp = soft_features_;
  soft_features_ = NULL;
  return temp;
}
inline void Features::set_allocated_soft_features(::ru::mail::go::webbase::blobs::FeatureList* soft_features) {
  delete soft_features_;
  soft_features_ = soft_features;
  if (soft_features) {
    set_has_soft_features();
  } else {
    clear_has_soft_features();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Features.soft_features)
}

// optional string subj_type = 12;
inline bool Features::has_subj_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Features::set_has_subj_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Features::clear_has_subj_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Features::clear_subj_type() {
  subj_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_subj_type();
}
inline const ::std::string& Features::subj_type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.subj_type)
  return subj_type_.GetNoArena();
}
inline void Features::set_subj_type(const ::std::string& value) {
  set_has_subj_type();
  subj_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.subj_type)
}
#if LANG_CXX11
inline void Features::set_subj_type(::std::string&& value) {
  set_has_subj_type();
  subj_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Features.subj_type)
}
#endif
inline void Features::set_subj_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_subj_type();
  subj_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Features.subj_type)
}
inline void Features::set_subj_type(const char* value, size_t size) {
  set_has_subj_type();
  subj_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Features.subj_type)
}
inline ::std::string* Features::mutable_subj_type() {
  set_has_subj_type();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Features.subj_type)
  return subj_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Features::release_subj_type() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Features.subj_type)
  clear_has_subj_type();
  return subj_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Features::set_allocated_subj_type(::std::string* subj_type) {
  if (subj_type != NULL) {
    set_has_subj_type();
  } else {
    clear_has_subj_type();
  }
  subj_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subj_type);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Features.subj_type)
}

// optional float market_score = 13;
inline bool Features::has_market_score() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Features::set_has_market_score() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Features::clear_has_market_score() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Features::clear_market_score() {
  market_score_ = 0;
  clear_has_market_score();
}
inline float Features::market_score() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.market_score)
  return market_score_;
}
inline void Features::set_market_score(float value) {
  set_has_market_score();
  market_score_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.market_score)
}

// optional .ru.mail.go.webbase.blobs.FeatureList market_features = 14;
inline bool Features::has_market_features() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Features::set_has_market_features() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Features::clear_has_market_features() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Features::clear_market_features() {
  if (market_features_ != NULL) market_features_->::ru::mail::go::webbase::blobs::FeatureList::Clear();
  clear_has_market_features();
}
inline const ::ru::mail::go::webbase::blobs::FeatureList& Features::market_features() const {
  const ::ru::mail::go::webbase::blobs::FeatureList* p = market_features_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.market_features)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::FeatureList*>(
      &::ru::mail::go::webbase::blobs::_FeatureList_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::FeatureList* Features::mutable_market_features() {
  set_has_market_features();
  if (market_features_ == NULL) {
    market_features_ = new ::ru::mail::go::webbase::blobs::FeatureList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Features.market_features)
  return market_features_;
}
inline ::ru::mail::go::webbase::blobs::FeatureList* Features::release_market_features() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Features.market_features)
  clear_has_market_features();
  ::ru::mail::go::webbase::blobs::FeatureList* temp = market_features_;
  market_features_ = NULL;
  return temp;
}
inline void Features::set_allocated_market_features(::ru::mail::go::webbase::blobs::FeatureList* market_features) {
  delete market_features_;
  market_features_ = market_features;
  if (market_features) {
    set_has_market_features();
  } else {
    clear_has_market_features();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Features.market_features)
}

// optional .ru.mail.go.webbase.blobs.SubjParsed subj_values = 15;
inline bool Features::has_subj_values() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Features::set_has_subj_values() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Features::clear_has_subj_values() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Features::clear_subj_values() {
  if (subj_values_ != NULL) subj_values_->::ru::mail::go::webbase::blobs::SubjParsed::Clear();
  clear_has_subj_values();
}
inline const ::ru::mail::go::webbase::blobs::SubjParsed& Features::subj_values() const {
  const ::ru::mail::go::webbase::blobs::SubjParsed* p = subj_values_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.subj_values)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::SubjParsed*>(
      &::ru::mail::go::webbase::blobs::_SubjParsed_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::SubjParsed* Features::mutable_subj_values() {
  set_has_subj_values();
  if (subj_values_ == NULL) {
    subj_values_ = new ::ru::mail::go::webbase::blobs::SubjParsed;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Features.subj_values)
  return subj_values_;
}
inline ::ru::mail::go::webbase::blobs::SubjParsed* Features::release_subj_values() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Features.subj_values)
  clear_has_subj_values();
  ::ru::mail::go::webbase::blobs::SubjParsed* temp = subj_values_;
  subj_values_ = NULL;
  return temp;
}
inline void Features::set_allocated_subj_values(::ru::mail::go::webbase::blobs::SubjParsed* subj_values) {
  delete subj_values_;
  subj_values_ = subj_values;
  if (subj_values) {
    set_has_subj_values();
  } else {
    clear_has_subj_values();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Features.subj_values)
}

// optional float porn_score_raw = 16;
inline bool Features::has_porn_score_raw() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Features::set_has_porn_score_raw() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Features::clear_has_porn_score_raw() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Features::clear_porn_score_raw() {
  porn_score_raw_ = 0;
  clear_has_porn_score_raw();
}
inline float Features::porn_score_raw() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.porn_score_raw)
  return porn_score_raw_;
}
inline void Features::set_porn_score_raw(float value) {
  set_has_porn_score_raw();
  porn_score_raw_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.porn_score_raw)
}

// optional float spam_score_raw = 17;
inline bool Features::has_spam_score_raw() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Features::set_has_spam_score_raw() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Features::clear_has_spam_score_raw() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Features::clear_spam_score_raw() {
  spam_score_raw_ = 0;
  clear_has_spam_score_raw();
}
inline float Features::spam_score_raw() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.spam_score_raw)
  return spam_score_raw_;
}
inline void Features::set_spam_score_raw(float value) {
  set_has_spam_score_raw();
  spam_score_raw_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.spam_score_raw)
}

// optional uint32 porn_score2 = 18;
inline bool Features::has_porn_score2() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Features::set_has_porn_score2() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Features::clear_has_porn_score2() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Features::clear_porn_score2() {
  porn_score2_ = 0u;
  clear_has_porn_score2();
}
inline ::google::protobuf::uint32 Features::porn_score2() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.porn_score2)
  return porn_score2_;
}
inline void Features::set_porn_score2(::google::protobuf::uint32 value) {
  set_has_porn_score2();
  porn_score2_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.porn_score2)
}

// optional float porn_score2_raw = 19;
inline bool Features::has_porn_score2_raw() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Features::set_has_porn_score2_raw() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Features::clear_has_porn_score2_raw() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Features::clear_porn_score2_raw() {
  porn_score2_raw_ = 0;
  clear_has_porn_score2_raw();
}
inline float Features::porn_score2_raw() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.porn_score2_raw)
  return porn_score2_raw_;
}
inline void Features::set_porn_score2_raw(float value) {
  set_has_porn_score2_raw();
  porn_score2_raw_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Features.porn_score2_raw)
}

// optional .ru.mail.go.webbase.blobs.FeatureList porn_features2 = 20;
inline bool Features::has_porn_features2() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Features::set_has_porn_features2() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Features::clear_has_porn_features2() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Features::clear_porn_features2() {
  if (porn_features2_ != NULL) porn_features2_->::ru::mail::go::webbase::blobs::FeatureList::Clear();
  clear_has_porn_features2();
}
inline const ::ru::mail::go::webbase::blobs::FeatureList& Features::porn_features2() const {
  const ::ru::mail::go::webbase::blobs::FeatureList* p = porn_features2_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Features.porn_features2)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::FeatureList*>(
      &::ru::mail::go::webbase::blobs::_FeatureList_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::FeatureList* Features::mutable_porn_features2() {
  set_has_porn_features2();
  if (porn_features2_ == NULL) {
    porn_features2_ = new ::ru::mail::go::webbase::blobs::FeatureList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Features.porn_features2)
  return porn_features2_;
}
inline ::ru::mail::go::webbase::blobs::FeatureList* Features::release_porn_features2() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Features.porn_features2)
  clear_has_porn_features2();
  ::ru::mail::go::webbase::blobs::FeatureList* temp = porn_features2_;
  porn_features2_ = NULL;
  return temp;
}
inline void Features::set_allocated_porn_features2(::ru::mail::go::webbase::blobs::FeatureList* porn_features2) {
  delete porn_features2_;
  porn_features2_ = porn_features2;
  if (porn_features2) {
    set_has_porn_features2();
  } else {
    clear_has_porn_features2();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Features.porn_features2)
}

// -------------------------------------------------------------------

// DetectedLanguage

// required .ru.mail.go.webbase.blobs.Language language = 1;
inline bool DetectedLanguage::has_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DetectedLanguage::set_has_language() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DetectedLanguage::clear_has_language() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DetectedLanguage::clear_language() {
  language_ = 0;
  clear_has_language();
}
inline ::ru::mail::go::webbase::blobs::Language DetectedLanguage::language() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DetectedLanguage.language)
  return static_cast< ::ru::mail::go::webbase::blobs::Language >(language_);
}
inline void DetectedLanguage::set_language(::ru::mail::go::webbase::blobs::Language value) {
  assert(::ru::mail::go::webbase::blobs::Language_IsValid(value));
  set_has_language();
  language_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DetectedLanguage.language)
}

// optional double estimation = 2;
inline bool DetectedLanguage::has_estimation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetectedLanguage::set_has_estimation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetectedLanguage::clear_has_estimation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetectedLanguage::clear_estimation() {
  estimation_ = 0;
  clear_has_estimation();
}
inline double DetectedLanguage::estimation() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DetectedLanguage.estimation)
  return estimation_;
}
inline void DetectedLanguage::set_estimation(double value) {
  set_has_estimation();
  estimation_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DetectedLanguage.estimation)
}

// -------------------------------------------------------------------

// DetectedLangArray

// repeated .ru.mail.go.webbase.blobs.DetectedLanguage detected_lang = 1;
inline int DetectedLangArray::detected_lang_size() const {
  return detected_lang_.size();
}
inline void DetectedLangArray::clear_detected_lang() {
  detected_lang_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::DetectedLanguage& DetectedLangArray::detected_lang(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DetectedLangArray.detected_lang)
  return detected_lang_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::DetectedLanguage* DetectedLangArray::mutable_detected_lang(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.DetectedLangArray.detected_lang)
  return detected_lang_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::DetectedLanguage* DetectedLangArray::add_detected_lang() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.DetectedLangArray.detected_lang)
  return detected_lang_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::DetectedLanguage >*
DetectedLangArray::mutable_detected_lang() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.DetectedLangArray.detected_lang)
  return &detected_lang_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::DetectedLanguage >&
DetectedLangArray::detected_lang() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.DetectedLangArray.detected_lang)
  return detected_lang_;
}

// -------------------------------------------------------------------

// SiteLanguage

// required .ru.mail.go.webbase.blobs.Language language = 1;
inline bool SiteLanguage::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SiteLanguage::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SiteLanguage::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SiteLanguage::clear_language() {
  language_ = 0;
  clear_has_language();
}
inline ::ru::mail::go::webbase::blobs::Language SiteLanguage::language() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SiteLanguage.language)
  return static_cast< ::ru::mail::go::webbase::blobs::Language >(language_);
}
inline void SiteLanguage::set_language(::ru::mail::go::webbase::blobs::Language value) {
  assert(::ru::mail::go::webbase::blobs::Language_IsValid(value));
  set_has_language();
  language_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.SiteLanguage.language)
}

// required int32 page_num = 2;
inline bool SiteLanguage::has_page_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SiteLanguage::set_has_page_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SiteLanguage::clear_has_page_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SiteLanguage::clear_page_num() {
  page_num_ = 0;
  clear_has_page_num();
}
inline ::google::protobuf::int32 SiteLanguage::page_num() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SiteLanguage.page_num)
  return page_num_;
}
inline void SiteLanguage::set_page_num(::google::protobuf::int32 value) {
  set_has_page_num();
  page_num_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.SiteLanguage.page_num)
}

// -------------------------------------------------------------------

// SiteLanguageArray

// repeated .ru.mail.go.webbase.blobs.SiteLanguage site_languages = 1;
inline int SiteLanguageArray::site_languages_size() const {
  return site_languages_.size();
}
inline void SiteLanguageArray::clear_site_languages() {
  site_languages_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::SiteLanguage& SiteLanguageArray::site_languages(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SiteLanguageArray.site_languages)
  return site_languages_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::SiteLanguage* SiteLanguageArray::mutable_site_languages(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.SiteLanguageArray.site_languages)
  return site_languages_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::SiteLanguage* SiteLanguageArray::add_site_languages() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.SiteLanguageArray.site_languages)
  return site_languages_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SiteLanguage >*
SiteLanguageArray::mutable_site_languages() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.SiteLanguageArray.site_languages)
  return &site_languages_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::SiteLanguage >&
SiteLanguageArray::site_languages() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.SiteLanguageArray.site_languages)
  return site_languages_;
}

// -------------------------------------------------------------------

// ParsedHtml

// optional .ru.mail.go.webbase.blobs.Language language = 1;
inline bool ParsedHtml::has_language() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ParsedHtml::set_has_language() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ParsedHtml::clear_has_language() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ParsedHtml::clear_language() {
  language_ = 0;
  clear_has_language();
}
inline ::ru::mail::go::webbase::blobs::Language ParsedHtml::language() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.language)
  return static_cast< ::ru::mail::go::webbase::blobs::Language >(language_);
}
inline void ParsedHtml::set_language(::ru::mail::go::webbase::blobs::Language value) {
  assert(::ru::mail::go::webbase::blobs::Language_IsValid(value));
  set_has_language();
  language_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.language)
}

// optional .ru.mail.go.webbase.blobs.Encoding encoding = 2;
inline bool ParsedHtml::has_encoding() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ParsedHtml::set_has_encoding() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ParsedHtml::clear_has_encoding() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ParsedHtml::clear_encoding() {
  encoding_ = 0;
  clear_has_encoding();
}
inline ::ru::mail::go::webbase::blobs::Encoding ParsedHtml::encoding() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.encoding)
  return static_cast< ::ru::mail::go::webbase::blobs::Encoding >(encoding_);
}
inline void ParsedHtml::set_encoding(::ru::mail::go::webbase::blobs::Encoding value) {
  assert(::ru::mail::go::webbase::blobs::Encoding_IsValid(value));
  set_has_encoding();
  encoding_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.encoding)
}

// optional string canonical_link = 3;
inline bool ParsedHtml::has_canonical_link() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParsedHtml::set_has_canonical_link() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParsedHtml::clear_has_canonical_link() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParsedHtml::clear_canonical_link() {
  canonical_link_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_canonical_link();
}
inline const ::std::string& ParsedHtml::canonical_link() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.canonical_link)
  return canonical_link_.GetNoArena();
}
inline void ParsedHtml::set_canonical_link(const ::std::string& value) {
  set_has_canonical_link();
  canonical_link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.canonical_link)
}
#if LANG_CXX11
inline void ParsedHtml::set_canonical_link(::std::string&& value) {
  set_has_canonical_link();
  canonical_link_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParsedHtml.canonical_link)
}
#endif
inline void ParsedHtml::set_canonical_link(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_canonical_link();
  canonical_link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParsedHtml.canonical_link)
}
inline void ParsedHtml::set_canonical_link(const char* value, size_t size) {
  set_has_canonical_link();
  canonical_link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParsedHtml.canonical_link)
}
inline ::std::string* ParsedHtml::mutable_canonical_link() {
  set_has_canonical_link();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.canonical_link)
  return canonical_link_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParsedHtml::release_canonical_link() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.canonical_link)
  clear_has_canonical_link();
  return canonical_link_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParsedHtml::set_allocated_canonical_link(::std::string* canonical_link) {
  if (canonical_link != NULL) {
    set_has_canonical_link();
  } else {
    clear_has_canonical_link();
  }
  canonical_link_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), canonical_link);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.canonical_link)
}

// optional int32 flag_meta_robots = 4;
inline bool ParsedHtml::has_flag_meta_robots() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ParsedHtml::set_has_flag_meta_robots() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ParsedHtml::clear_has_flag_meta_robots() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ParsedHtml::clear_flag_meta_robots() {
  flag_meta_robots_ = 0;
  clear_has_flag_meta_robots();
}
inline ::google::protobuf::int32 ParsedHtml::flag_meta_robots() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.flag_meta_robots)
  return flag_meta_robots_;
}
inline void ParsedHtml::set_flag_meta_robots(::google::protobuf::int32 value) {
  set_has_flag_meta_robots();
  flag_meta_robots_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.flag_meta_robots)
}

// optional .ru.mail.go.webbase.blobs.ParsedHtml.page_errors page_error = 5;
inline bool ParsedHtml::has_page_error() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ParsedHtml::set_has_page_error() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ParsedHtml::clear_has_page_error() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ParsedHtml::clear_page_error() {
  page_error_ = 1;
  clear_has_page_error();
}
inline ::ru::mail::go::webbase::blobs::ParsedHtml_page_errors ParsedHtml::page_error() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.page_error)
  return static_cast< ::ru::mail::go::webbase::blobs::ParsedHtml_page_errors >(page_error_);
}
inline void ParsedHtml::set_page_error(::ru::mail::go::webbase::blobs::ParsedHtml_page_errors value) {
  assert(::ru::mail::go::webbase::blobs::ParsedHtml_page_errors_IsValid(value));
  set_has_page_error();
  page_error_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.page_error)
}

// repeated .ru.mail.go.webbase.blobs.Links links = 6;
inline int ParsedHtml::links_size() const {
  return links_.size();
}
inline void ParsedHtml::clear_links() {
  links_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::Links& ParsedHtml::links(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.links)
  return links_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::Links* ParsedHtml::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.links)
  return links_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::Links* ParsedHtml::add_links() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ParsedHtml.links)
  return links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Links >*
ParsedHtml::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ParsedHtml.links)
  return &links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Links >&
ParsedHtml::links() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ParsedHtml.links)
  return links_;
}

// optional string refresh_link = 7;
inline bool ParsedHtml::has_refresh_link() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParsedHtml::set_has_refresh_link() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParsedHtml::clear_has_refresh_link() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParsedHtml::clear_refresh_link() {
  refresh_link_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_refresh_link();
}
inline const ::std::string& ParsedHtml::refresh_link() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.refresh_link)
  return refresh_link_.GetNoArena();
}
inline void ParsedHtml::set_refresh_link(const ::std::string& value) {
  set_has_refresh_link();
  refresh_link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.refresh_link)
}
#if LANG_CXX11
inline void ParsedHtml::set_refresh_link(::std::string&& value) {
  set_has_refresh_link();
  refresh_link_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParsedHtml.refresh_link)
}
#endif
inline void ParsedHtml::set_refresh_link(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_refresh_link();
  refresh_link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParsedHtml.refresh_link)
}
inline void ParsedHtml::set_refresh_link(const char* value, size_t size) {
  set_has_refresh_link();
  refresh_link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParsedHtml.refresh_link)
}
inline ::std::string* ParsedHtml::mutable_refresh_link() {
  set_has_refresh_link();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.refresh_link)
  return refresh_link_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParsedHtml::release_refresh_link() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.refresh_link)
  clear_has_refresh_link();
  return refresh_link_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParsedHtml::set_allocated_refresh_link(::std::string* refresh_link) {
  if (refresh_link != NULL) {
    set_has_refresh_link();
  } else {
    clear_has_refresh_link();
  }
  refresh_link_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), refresh_link);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.refresh_link)
}

// optional string refresh_time = 8;
inline bool ParsedHtml::has_refresh_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParsedHtml::set_has_refresh_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParsedHtml::clear_has_refresh_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParsedHtml::clear_refresh_time() {
  refresh_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_refresh_time();
}
inline const ::std::string& ParsedHtml::refresh_time() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.refresh_time)
  return refresh_time_.GetNoArena();
}
inline void ParsedHtml::set_refresh_time(const ::std::string& value) {
  set_has_refresh_time();
  refresh_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.refresh_time)
}
#if LANG_CXX11
inline void ParsedHtml::set_refresh_time(::std::string&& value) {
  set_has_refresh_time();
  refresh_time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParsedHtml.refresh_time)
}
#endif
inline void ParsedHtml::set_refresh_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_refresh_time();
  refresh_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParsedHtml.refresh_time)
}
inline void ParsedHtml::set_refresh_time(const char* value, size_t size) {
  set_has_refresh_time();
  refresh_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParsedHtml.refresh_time)
}
inline ::std::string* ParsedHtml::mutable_refresh_time() {
  set_has_refresh_time();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.refresh_time)
  return refresh_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParsedHtml::release_refresh_time() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.refresh_time)
  clear_has_refresh_time();
  return refresh_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParsedHtml::set_allocated_refresh_time(::std::string* refresh_time) {
  if (refresh_time != NULL) {
    set_has_refresh_time();
  } else {
    clear_has_refresh_time();
  }
  refresh_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), refresh_time);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.refresh_time)
}

// optional string base_link = 9;
inline bool ParsedHtml::has_base_link() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParsedHtml::set_has_base_link() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParsedHtml::clear_has_base_link() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParsedHtml::clear_base_link() {
  base_link_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_base_link();
}
inline const ::std::string& ParsedHtml::base_link() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.base_link)
  return base_link_.GetNoArena();
}
inline void ParsedHtml::set_base_link(const ::std::string& value) {
  set_has_base_link();
  base_link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.base_link)
}
#if LANG_CXX11
inline void ParsedHtml::set_base_link(::std::string&& value) {
  set_has_base_link();
  base_link_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParsedHtml.base_link)
}
#endif
inline void ParsedHtml::set_base_link(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_base_link();
  base_link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParsedHtml.base_link)
}
inline void ParsedHtml::set_base_link(const char* value, size_t size) {
  set_has_base_link();
  base_link_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParsedHtml.base_link)
}
inline ::std::string* ParsedHtml::mutable_base_link() {
  set_has_base_link();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.base_link)
  return base_link_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParsedHtml::release_base_link() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.base_link)
  clear_has_base_link();
  return base_link_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParsedHtml::set_allocated_base_link(::std::string* base_link) {
  if (base_link != NULL) {
    set_has_base_link();
  } else {
    clear_has_base_link();
  }
  base_link_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), base_link);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.base_link)
}

// optional .ru.mail.go.webbase.blobs.Features features = 10;
inline bool ParsedHtml::has_features() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ParsedHtml::set_has_features() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ParsedHtml::clear_has_features() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ParsedHtml::clear_features() {
  if (features_ != NULL) features_->::ru::mail::go::webbase::blobs::Features::Clear();
  clear_has_features();
}
inline const ::ru::mail::go::webbase::blobs::Features& ParsedHtml::features() const {
  const ::ru::mail::go::webbase::blobs::Features* p = features_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.features)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::Features*>(
      &::ru::mail::go::webbase::blobs::_Features_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::Features* ParsedHtml::mutable_features() {
  set_has_features();
  if (features_ == NULL) {
    features_ = new ::ru::mail::go::webbase::blobs::Features;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.features)
  return features_;
}
inline ::ru::mail::go::webbase::blobs::Features* ParsedHtml::release_features() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.features)
  clear_has_features();
  ::ru::mail::go::webbase::blobs::Features* temp = features_;
  features_ = NULL;
  return temp;
}
inline void ParsedHtml::set_allocated_features(::ru::mail::go::webbase::blobs::Features* features) {
  delete features_;
  features_ = features;
  if (features) {
    set_has_features();
  } else {
    clear_has_features();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.features)
}

// optional bytes text = 11;
inline bool ParsedHtml::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ParsedHtml::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ParsedHtml::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ParsedHtml::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& ParsedHtml::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.text)
  return text_.GetNoArena();
}
inline void ParsedHtml::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.text)
}
#if LANG_CXX11
inline void ParsedHtml::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParsedHtml.text)
}
#endif
inline void ParsedHtml::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParsedHtml.text)
}
inline void ParsedHtml::set_text(const void* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParsedHtml.text)
}
inline ::std::string* ParsedHtml::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParsedHtml::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParsedHtml::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.text)
}

// optional .ru.mail.go.webbase.blobs.DetectedLangArray detLang = 12;
inline bool ParsedHtml::has_detlang() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ParsedHtml::set_has_detlang() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ParsedHtml::clear_has_detlang() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ParsedHtml::clear_detlang() {
  if (detlang_ != NULL) detlang_->::ru::mail::go::webbase::blobs::DetectedLangArray::Clear();
  clear_has_detlang();
}
inline const ::ru::mail::go::webbase::blobs::DetectedLangArray& ParsedHtml::detlang() const {
  const ::ru::mail::go::webbase::blobs::DetectedLangArray* p = detlang_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.detLang)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::DetectedLangArray*>(
      &::ru::mail::go::webbase::blobs::_DetectedLangArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::DetectedLangArray* ParsedHtml::mutable_detlang() {
  set_has_detlang();
  if (detlang_ == NULL) {
    detlang_ = new ::ru::mail::go::webbase::blobs::DetectedLangArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.detLang)
  return detlang_;
}
inline ::ru::mail::go::webbase::blobs::DetectedLangArray* ParsedHtml::release_detlang() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.detLang)
  clear_has_detlang();
  ::ru::mail::go::webbase::blobs::DetectedLangArray* temp = detlang_;
  detlang_ = NULL;
  return temp;
}
inline void ParsedHtml::set_allocated_detlang(::ru::mail::go::webbase::blobs::DetectedLangArray* detlang) {
  delete detlang_;
  detlang_ = detlang;
  if (detlang) {
    set_has_detlang();
  } else {
    clear_has_detlang();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.detLang)
}

// optional bytes title = 13;
inline bool ParsedHtml::has_title() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ParsedHtml::set_has_title() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ParsedHtml::clear_has_title() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ParsedHtml::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_title();
}
inline const ::std::string& ParsedHtml::title() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.title)
  return title_.GetNoArena();
}
inline void ParsedHtml::set_title(const ::std::string& value) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.title)
}
#if LANG_CXX11
inline void ParsedHtml::set_title(::std::string&& value) {
  set_has_title();
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParsedHtml.title)
}
#endif
inline void ParsedHtml::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParsedHtml.title)
}
inline void ParsedHtml::set_title(const void* value, size_t size) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParsedHtml.title)
}
inline ::std::string* ParsedHtml::mutable_title() {
  set_has_title();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParsedHtml::release_title() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.title)
  clear_has_title();
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParsedHtml::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    set_has_title();
  } else {
    clear_has_title();
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.title)
}

// optional bytes description = 14;
inline bool ParsedHtml::has_description() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ParsedHtml::set_has_description() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ParsedHtml::clear_has_description() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ParsedHtml::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& ParsedHtml::description() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.description)
  return description_.GetNoArena();
}
inline void ParsedHtml::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.description)
}
#if LANG_CXX11
inline void ParsedHtml::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParsedHtml.description)
}
#endif
inline void ParsedHtml::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParsedHtml.description)
}
inline void ParsedHtml::set_description(const void* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParsedHtml.description)
}
inline ::std::string* ParsedHtml::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParsedHtml::release_description() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParsedHtml::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.description)
}

// optional bool description_quality = 15;
inline bool ParsedHtml::has_description_quality() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ParsedHtml::set_has_description_quality() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ParsedHtml::clear_has_description_quality() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ParsedHtml::clear_description_quality() {
  description_quality_ = false;
  clear_has_description_quality();
}
inline bool ParsedHtml::description_quality() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.description_quality)
  return description_quality_;
}
inline void ParsedHtml::set_description_quality(bool value) {
  set_has_description_quality();
  description_quality_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.description_quality)
}

// optional bool flag_ajax_fragment = 16;
inline bool ParsedHtml::has_flag_ajax_fragment() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ParsedHtml::set_has_flag_ajax_fragment() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ParsedHtml::clear_has_flag_ajax_fragment() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ParsedHtml::clear_flag_ajax_fragment() {
  flag_ajax_fragment_ = false;
  clear_has_flag_ajax_fragment();
}
inline bool ParsedHtml::flag_ajax_fragment() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.flag_ajax_fragment)
  return flag_ajax_fragment_;
}
inline void ParsedHtml::set_flag_ajax_fragment(bool value) {
  set_has_flag_ajax_fragment();
  flag_ajax_fragment_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.flag_ajax_fragment)
}

// optional bytes og_description = 17;
inline bool ParsedHtml::has_og_description() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ParsedHtml::set_has_og_description() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ParsedHtml::clear_has_og_description() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ParsedHtml::clear_og_description() {
  og_description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_og_description();
}
inline const ::std::string& ParsedHtml::og_description() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.og_description)
  return og_description_.GetNoArena();
}
inline void ParsedHtml::set_og_description(const ::std::string& value) {
  set_has_og_description();
  og_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.og_description)
}
#if LANG_CXX11
inline void ParsedHtml::set_og_description(::std::string&& value) {
  set_has_og_description();
  og_description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParsedHtml.og_description)
}
#endif
inline void ParsedHtml::set_og_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_og_description();
  og_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParsedHtml.og_description)
}
inline void ParsedHtml::set_og_description(const void* value, size_t size) {
  set_has_og_description();
  og_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParsedHtml.og_description)
}
inline ::std::string* ParsedHtml::mutable_og_description() {
  set_has_og_description();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.og_description)
  return og_description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParsedHtml::release_og_description() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.og_description)
  clear_has_og_description();
  return og_description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParsedHtml::set_allocated_og_description(::std::string* og_description) {
  if (og_description != NULL) {
    set_has_og_description();
  } else {
    clear_has_og_description();
  }
  og_description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), og_description);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.og_description)
}

// optional bool og_description_quality = 18;
inline bool ParsedHtml::has_og_description_quality() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ParsedHtml::set_has_og_description_quality() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ParsedHtml::clear_has_og_description_quality() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ParsedHtml::clear_og_description_quality() {
  og_description_quality_ = false;
  clear_has_og_description_quality();
}
inline bool ParsedHtml::og_description_quality() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.og_description_quality)
  return og_description_quality_;
}
inline void ParsedHtml::set_og_description_quality(bool value) {
  set_has_og_description_quality();
  og_description_quality_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.og_description_quality)
}

// optional bool is_meta_content = 19 [default = false];
inline bool ParsedHtml::has_is_meta_content() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ParsedHtml::set_has_is_meta_content() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ParsedHtml::clear_has_is_meta_content() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ParsedHtml::clear_is_meta_content() {
  is_meta_content_ = false;
  clear_has_is_meta_content();
}
inline bool ParsedHtml::is_meta_content() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.is_meta_content)
  return is_meta_content_;
}
inline void ParsedHtml::set_is_meta_content(bool value) {
  set_has_is_meta_content();
  is_meta_content_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.is_meta_content)
}

// optional bytes og_image = 20;
inline bool ParsedHtml::has_og_image() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ParsedHtml::set_has_og_image() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ParsedHtml::clear_has_og_image() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ParsedHtml::clear_og_image() {
  og_image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_og_image();
}
inline const ::std::string& ParsedHtml::og_image() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.og_image)
  return og_image_.GetNoArena();
}
inline void ParsedHtml::set_og_image(const ::std::string& value) {
  set_has_og_image();
  og_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.og_image)
}
#if LANG_CXX11
inline void ParsedHtml::set_og_image(::std::string&& value) {
  set_has_og_image();
  og_image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParsedHtml.og_image)
}
#endif
inline void ParsedHtml::set_og_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_og_image();
  og_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParsedHtml.og_image)
}
inline void ParsedHtml::set_og_image(const void* value, size_t size) {
  set_has_og_image();
  og_image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParsedHtml.og_image)
}
inline ::std::string* ParsedHtml::mutable_og_image() {
  set_has_og_image();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.og_image)
  return og_image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParsedHtml::release_og_image() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.og_image)
  clear_has_og_image();
  return og_image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParsedHtml::set_allocated_og_image(::std::string* og_image) {
  if (og_image != NULL) {
    set_has_og_image();
  } else {
    clear_has_og_image();
  }
  og_image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), og_image);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.og_image)
}

// optional bytes og_title = 21;
inline bool ParsedHtml::has_og_title() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ParsedHtml::set_has_og_title() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ParsedHtml::clear_has_og_title() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ParsedHtml::clear_og_title() {
  og_title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_og_title();
}
inline const ::std::string& ParsedHtml::og_title() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedHtml.og_title)
  return og_title_.GetNoArena();
}
inline void ParsedHtml::set_og_title(const ::std::string& value) {
  set_has_og_title();
  og_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedHtml.og_title)
}
#if LANG_CXX11
inline void ParsedHtml::set_og_title(::std::string&& value) {
  set_has_og_title();
  og_title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParsedHtml.og_title)
}
#endif
inline void ParsedHtml::set_og_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_og_title();
  og_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParsedHtml.og_title)
}
inline void ParsedHtml::set_og_title(const void* value, size_t size) {
  set_has_og_title();
  og_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParsedHtml.og_title)
}
inline ::std::string* ParsedHtml::mutable_og_title() {
  set_has_og_title();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedHtml.og_title)
  return og_title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParsedHtml::release_og_title() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedHtml.og_title)
  clear_has_og_title();
  return og_title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParsedHtml::set_allocated_og_title(::std::string* og_title) {
  if (og_title != NULL) {
    set_has_og_title();
  } else {
    clear_has_og_title();
  }
  og_title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), og_title);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedHtml.og_title)
}

// -------------------------------------------------------------------

// MetaDescription

// optional bytes descritption = 1;
inline bool MetaDescription::has_descritption() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaDescription::set_has_descritption() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaDescription::clear_has_descritption() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaDescription::clear_descritption() {
  descritption_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_descritption();
}
inline const ::std::string& MetaDescription::descritption() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MetaDescription.descritption)
  return descritption_.GetNoArena();
}
inline void MetaDescription::set_descritption(const ::std::string& value) {
  set_has_descritption();
  descritption_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.MetaDescription.descritption)
}
#if LANG_CXX11
inline void MetaDescription::set_descritption(::std::string&& value) {
  set_has_descritption();
  descritption_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.MetaDescription.descritption)
}
#endif
inline void MetaDescription::set_descritption(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_descritption();
  descritption_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.MetaDescription.descritption)
}
inline void MetaDescription::set_descritption(const void* value, size_t size) {
  set_has_descritption();
  descritption_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.MetaDescription.descritption)
}
inline ::std::string* MetaDescription::mutable_descritption() {
  set_has_descritption();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.MetaDescription.descritption)
  return descritption_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetaDescription::release_descritption() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.MetaDescription.descritption)
  clear_has_descritption();
  return descritption_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetaDescription::set_allocated_descritption(::std::string* descritption) {
  if (descritption != NULL) {
    set_has_descritption();
  } else {
    clear_has_descritption();
  }
  descritption_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), descritption);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.MetaDescription.descritption)
}

// optional bool description_quality = 2;
inline bool MetaDescription::has_description_quality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaDescription::set_has_description_quality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaDescription::clear_has_description_quality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaDescription::clear_description_quality() {
  description_quality_ = false;
  clear_has_description_quality();
}
inline bool MetaDescription::description_quality() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MetaDescription.description_quality)
  return description_quality_;
}
inline void MetaDescription::set_description_quality(bool value) {
  set_has_description_quality();
  description_quality_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.MetaDescription.description_quality)
}

// -------------------------------------------------------------------

// ParsedDoc

// required .ru.mail.go.webbase.blobs.ContentType type = 1;
inline bool ParsedDoc::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParsedDoc::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParsedDoc::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParsedDoc::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ru::mail::go::webbase::blobs::ContentType ParsedDoc::type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedDoc.type)
  return static_cast< ::ru::mail::go::webbase::blobs::ContentType >(type_);
}
inline void ParsedDoc::set_type(::ru::mail::go::webbase::blobs::ContentType value) {
  assert(::ru::mail::go::webbase::blobs::ContentType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedDoc.type)
}

// optional .ru.mail.go.webbase.blobs.ParsedHtml html_info = 2;
inline bool ParsedDoc::has_html_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParsedDoc::set_has_html_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParsedDoc::clear_has_html_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParsedDoc::clear_html_info() {
  if (html_info_ != NULL) html_info_->::ru::mail::go::webbase::blobs::ParsedHtml::Clear();
  clear_has_html_info();
}
inline const ::ru::mail::go::webbase::blobs::ParsedHtml& ParsedDoc::html_info() const {
  const ::ru::mail::go::webbase::blobs::ParsedHtml* p = html_info_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedDoc.html_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ParsedHtml*>(
      &::ru::mail::go::webbase::blobs::_ParsedHtml_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ParsedHtml* ParsedDoc::mutable_html_info() {
  set_has_html_info();
  if (html_info_ == NULL) {
    html_info_ = new ::ru::mail::go::webbase::blobs::ParsedHtml;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedDoc.html_info)
  return html_info_;
}
inline ::ru::mail::go::webbase::blobs::ParsedHtml* ParsedDoc::release_html_info() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedDoc.html_info)
  clear_has_html_info();
  ::ru::mail::go::webbase::blobs::ParsedHtml* temp = html_info_;
  html_info_ = NULL;
  return temp;
}
inline void ParsedDoc::set_allocated_html_info(::ru::mail::go::webbase::blobs::ParsedHtml* html_info) {
  delete html_info_;
  html_info_ = html_info;
  if (html_info) {
    set_has_html_info();
  } else {
    clear_has_html_info();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedDoc.html_info)
}

// repeated .ru.mail.go.webbase.blobs.ProfileInfo profiling = 3;
inline int ParsedDoc::profiling_size() const {
  return profiling_.size();
}
inline void ParsedDoc::clear_profiling() {
  profiling_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::ProfileInfo& ParsedDoc::profiling(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedDoc.profiling)
  return profiling_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::ProfileInfo* ParsedDoc::mutable_profiling(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedDoc.profiling)
  return profiling_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::ProfileInfo* ParsedDoc::add_profiling() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ParsedDoc.profiling)
  return profiling_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ProfileInfo >*
ParsedDoc::mutable_profiling() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ParsedDoc.profiling)
  return &profiling_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ProfileInfo >&
ParsedDoc::profiling() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ParsedDoc.profiling)
  return profiling_;
}

// -------------------------------------------------------------------

// StubDoc

// required string url = 1;
inline bool StubDoc::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StubDoc::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StubDoc::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StubDoc::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& StubDoc::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.StubDoc.url)
  return url_.GetNoArena();
}
inline void StubDoc::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.StubDoc.url)
}
#if LANG_CXX11
inline void StubDoc::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.StubDoc.url)
}
#endif
inline void StubDoc::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.StubDoc.url)
}
inline void StubDoc::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.StubDoc.url)
}
inline ::std::string* StubDoc::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.StubDoc.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StubDoc::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.StubDoc.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StubDoc::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.StubDoc.url)
}

// optional .ru.mail.go.webbase.blobs.ContentType type = 2;
inline bool StubDoc::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StubDoc::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StubDoc::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StubDoc::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ru::mail::go::webbase::blobs::ContentType StubDoc::type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.StubDoc.type)
  return static_cast< ::ru::mail::go::webbase::blobs::ContentType >(type_);
}
inline void StubDoc::set_type(::ru::mail::go::webbase::blobs::ContentType value) {
  assert(::ru::mail::go::webbase::blobs::ContentType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.StubDoc.type)
}

// optional .ru.mail.go.webbase.blobs.Language language = 3;
inline bool StubDoc::has_language() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StubDoc::set_has_language() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StubDoc::clear_has_language() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StubDoc::clear_language() {
  language_ = 0;
  clear_has_language();
}
inline ::ru::mail::go::webbase::blobs::Language StubDoc::language() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.StubDoc.language)
  return static_cast< ::ru::mail::go::webbase::blobs::Language >(language_);
}
inline void StubDoc::set_language(::ru::mail::go::webbase::blobs::Language value) {
  assert(::ru::mail::go::webbase::blobs::Language_IsValid(value));
  set_has_language();
  language_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.StubDoc.language)
}

// optional .ru.mail.go.webbase.blobs.Encoding encoding = 4;
inline bool StubDoc::has_encoding() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StubDoc::set_has_encoding() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StubDoc::clear_has_encoding() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StubDoc::clear_encoding() {
  encoding_ = 0;
  clear_has_encoding();
}
inline ::ru::mail::go::webbase::blobs::Encoding StubDoc::encoding() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.StubDoc.encoding)
  return static_cast< ::ru::mail::go::webbase::blobs::Encoding >(encoding_);
}
inline void StubDoc::set_encoding(::ru::mail::go::webbase::blobs::Encoding value) {
  assert(::ru::mail::go::webbase::blobs::Encoding_IsValid(value));
  set_has_encoding();
  encoding_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.StubDoc.encoding)
}

// optional uint64 download_time = 5;
inline bool StubDoc::has_download_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StubDoc::set_has_download_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StubDoc::clear_has_download_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StubDoc::clear_download_time() {
  download_time_ = GOOGLE_ULONGLONG(0);
  clear_has_download_time();
}
inline ::google::protobuf::uint64 StubDoc::download_time() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.StubDoc.download_time)
  return download_time_;
}
inline void StubDoc::set_download_time(::google::protobuf::uint64 value) {
  set_has_download_time();
  download_time_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.StubDoc.download_time)
}

// optional bytes content = 6;
inline bool StubDoc::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StubDoc::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StubDoc::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StubDoc::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& StubDoc::content() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.StubDoc.content)
  return content_.GetNoArena();
}
inline void StubDoc::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.StubDoc.content)
}
#if LANG_CXX11
inline void StubDoc::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.StubDoc.content)
}
#endif
inline void StubDoc::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.StubDoc.content)
}
inline void StubDoc::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.StubDoc.content)
}
inline ::std::string* StubDoc::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.StubDoc.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StubDoc::release_content() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.StubDoc.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StubDoc::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.StubDoc.content)
}

// optional bool scriptRemoved = 7;
inline bool StubDoc::has_scriptremoved() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StubDoc::set_has_scriptremoved() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StubDoc::clear_has_scriptremoved() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StubDoc::clear_scriptremoved() {
  scriptremoved_ = false;
  clear_has_scriptremoved();
}
inline bool StubDoc::scriptremoved() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.StubDoc.scriptRemoved)
  return scriptremoved_;
}
inline void StubDoc::set_scriptremoved(bool value) {
  set_has_scriptremoved();
  scriptremoved_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.StubDoc.scriptRemoved)
}

// optional uint32 content_size = 8;
inline bool StubDoc::has_content_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StubDoc::set_has_content_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StubDoc::clear_has_content_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StubDoc::clear_content_size() {
  content_size_ = 0u;
  clear_has_content_size();
}
inline ::google::protobuf::uint32 StubDoc::content_size() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.StubDoc.content_size)
  return content_size_;
}
inline void StubDoc::set_content_size(::google::protobuf::uint32 value) {
  set_has_content_size();
  content_size_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.StubDoc.content_size)
}

// optional uint32 clean_size = 9;
inline bool StubDoc::has_clean_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StubDoc::set_has_clean_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StubDoc::clear_has_clean_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StubDoc::clear_clean_size() {
  clean_size_ = 0u;
  clear_has_clean_size();
}
inline ::google::protobuf::uint32 StubDoc::clean_size() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.StubDoc.clean_size)
  return clean_size_;
}
inline void StubDoc::set_clean_size(::google::protobuf::uint32 value) {
  set_has_clean_size();
  clean_size_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.StubDoc.clean_size)
}

// -------------------------------------------------------------------

// Region

// required int32 start = 1;
inline bool Region::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Region::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Region::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Region::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 Region::start() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Region.start)
  return start_;
}
inline void Region::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Region.start)
}

// required int32 end = 2;
inline bool Region::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Region::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Region::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Region::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 Region::end() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Region.end)
  return end_;
}
inline void Region::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Region.end)
}

// -------------------------------------------------------------------

// RegionBlob

// required int32 num = 1;
inline bool RegionBlob::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionBlob::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionBlob::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionBlob::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 RegionBlob::num() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.RegionBlob.num)
  return num_;
}
inline void RegionBlob::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.RegionBlob.num)
}

// repeated .ru.mail.go.webbase.blobs.Region data = 2;
inline int RegionBlob::data_size() const {
  return data_.size();
}
inline void RegionBlob::clear_data() {
  data_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::Region& RegionBlob::data(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.RegionBlob.data)
  return data_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::Region* RegionBlob::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.RegionBlob.data)
  return data_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::Region* RegionBlob::add_data() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.RegionBlob.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Region >*
RegionBlob::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.RegionBlob.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Region >&
RegionBlob::data() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.RegionBlob.data)
  return data_;
}

// -------------------------------------------------------------------

// OriginalDoc

// required string url = 1;
inline bool OriginalDoc::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OriginalDoc::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OriginalDoc::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OriginalDoc::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& OriginalDoc::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OriginalDoc.url)
  return url_.GetNoArena();
}
inline void OriginalDoc::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OriginalDoc.url)
}
#if LANG_CXX11
inline void OriginalDoc::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.OriginalDoc.url)
}
#endif
inline void OriginalDoc::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.OriginalDoc.url)
}
inline void OriginalDoc::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.OriginalDoc.url)
}
inline ::std::string* OriginalDoc::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.OriginalDoc.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OriginalDoc::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.OriginalDoc.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OriginalDoc::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.OriginalDoc.url)
}

// required uint64 download_time = 2;
inline bool OriginalDoc::has_download_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OriginalDoc::set_has_download_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OriginalDoc::clear_has_download_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OriginalDoc::clear_download_time() {
  download_time_ = GOOGLE_ULONGLONG(0);
  clear_has_download_time();
}
inline ::google::protobuf::uint64 OriginalDoc::download_time() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OriginalDoc.download_time)
  return download_time_;
}
inline void OriginalDoc::set_download_time(::google::protobuf::uint64 value) {
  set_has_download_time();
  download_time_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OriginalDoc.download_time)
}

// optional bytes content = 3;
inline bool OriginalDoc::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OriginalDoc::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OriginalDoc::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OriginalDoc::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& OriginalDoc::content() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OriginalDoc.content)
  return content_.GetNoArena();
}
inline void OriginalDoc::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OriginalDoc.content)
}
#if LANG_CXX11
inline void OriginalDoc::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.OriginalDoc.content)
}
#endif
inline void OriginalDoc::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.OriginalDoc.content)
}
inline void OriginalDoc::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.OriginalDoc.content)
}
inline ::std::string* OriginalDoc::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.OriginalDoc.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OriginalDoc::release_content() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.OriginalDoc.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OriginalDoc::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.OriginalDoc.content)
}

// optional .ru.mail.go.webbase.blobs.ContentType type = 4;
inline bool OriginalDoc::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OriginalDoc::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OriginalDoc::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OriginalDoc::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ru::mail::go::webbase::blobs::ContentType OriginalDoc::type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OriginalDoc.type)
  return static_cast< ::ru::mail::go::webbase::blobs::ContentType >(type_);
}
inline void OriginalDoc::set_type(::ru::mail::go::webbase::blobs::ContentType value) {
  assert(::ru::mail::go::webbase::blobs::ContentType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OriginalDoc.type)
}

// optional .ru.mail.go.webbase.blobs.Language language = 5;
inline bool OriginalDoc::has_language() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OriginalDoc::set_has_language() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OriginalDoc::clear_has_language() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OriginalDoc::clear_language() {
  language_ = 0;
  clear_has_language();
}
inline ::ru::mail::go::webbase::blobs::Language OriginalDoc::language() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OriginalDoc.language)
  return static_cast< ::ru::mail::go::webbase::blobs::Language >(language_);
}
inline void OriginalDoc::set_language(::ru::mail::go::webbase::blobs::Language value) {
  assert(::ru::mail::go::webbase::blobs::Language_IsValid(value));
  set_has_language();
  language_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OriginalDoc.language)
}

// optional .ru.mail.go.webbase.blobs.Encoding encoding = 6;
inline bool OriginalDoc::has_encoding() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OriginalDoc::set_has_encoding() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OriginalDoc::clear_has_encoding() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OriginalDoc::clear_encoding() {
  encoding_ = 0;
  clear_has_encoding();
}
inline ::ru::mail::go::webbase::blobs::Encoding OriginalDoc::encoding() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OriginalDoc.encoding)
  return static_cast< ::ru::mail::go::webbase::blobs::Encoding >(encoding_);
}
inline void OriginalDoc::set_encoding(::ru::mail::go::webbase::blobs::Encoding value) {
  assert(::ru::mail::go::webbase::blobs::Encoding_IsValid(value));
  set_has_encoding();
  encoding_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OriginalDoc.encoding)
}

// optional uint32 porno_level = 7;
inline bool OriginalDoc::has_porno_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OriginalDoc::set_has_porno_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OriginalDoc::clear_has_porno_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OriginalDoc::clear_porno_level() {
  porno_level_ = 0u;
  clear_has_porno_level();
}
inline ::google::protobuf::uint32 OriginalDoc::porno_level() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OriginalDoc.porno_level)
  return porno_level_;
}
inline void OriginalDoc::set_porno_level(::google::protobuf::uint32 value) {
  set_has_porno_level();
  porno_level_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OriginalDoc.porno_level)
}

// optional uint32 spam_level = 8;
inline bool OriginalDoc::has_spam_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OriginalDoc::set_has_spam_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OriginalDoc::clear_has_spam_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OriginalDoc::clear_spam_level() {
  spam_level_ = 0u;
  clear_has_spam_level();
}
inline ::google::protobuf::uint32 OriginalDoc::spam_level() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OriginalDoc.spam_level)
  return spam_level_;
}
inline void OriginalDoc::set_spam_level(::google::protobuf::uint32 value) {
  set_has_spam_level();
  spam_level_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OriginalDoc.spam_level)
}

// optional .ru.mail.go.webbase.blobs.RegionBlob cuttedBlob = 9;
inline bool OriginalDoc::has_cuttedblob() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OriginalDoc::set_has_cuttedblob() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OriginalDoc::clear_has_cuttedblob() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OriginalDoc::clear_cuttedblob() {
  if (cuttedblob_ != NULL) cuttedblob_->::ru::mail::go::webbase::blobs::RegionBlob::Clear();
  clear_has_cuttedblob();
}
inline const ::ru::mail::go::webbase::blobs::RegionBlob& OriginalDoc::cuttedblob() const {
  const ::ru::mail::go::webbase::blobs::RegionBlob* p = cuttedblob_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OriginalDoc.cuttedBlob)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::RegionBlob*>(
      &::ru::mail::go::webbase::blobs::_RegionBlob_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::RegionBlob* OriginalDoc::mutable_cuttedblob() {
  set_has_cuttedblob();
  if (cuttedblob_ == NULL) {
    cuttedblob_ = new ::ru::mail::go::webbase::blobs::RegionBlob;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.OriginalDoc.cuttedBlob)
  return cuttedblob_;
}
inline ::ru::mail::go::webbase::blobs::RegionBlob* OriginalDoc::release_cuttedblob() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.OriginalDoc.cuttedBlob)
  clear_has_cuttedblob();
  ::ru::mail::go::webbase::blobs::RegionBlob* temp = cuttedblob_;
  cuttedblob_ = NULL;
  return temp;
}
inline void OriginalDoc::set_allocated_cuttedblob(::ru::mail::go::webbase::blobs::RegionBlob* cuttedblob) {
  delete cuttedblob_;
  cuttedblob_ = cuttedblob;
  if (cuttedblob) {
    set_has_cuttedblob();
  } else {
    clear_has_cuttedblob();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.OriginalDoc.cuttedBlob)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::Links_typeFlag> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::Links_typeFlag>() {
  return ::ru::mail::go::webbase::blobs::Links_typeFlag_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::Features_spam_t> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::Features_spam_t>() {
  return ::ru::mail::go::webbase::blobs::Features_spam_t_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::Features_subj_t> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::Features_subj_t>() {
  return ::ru::mail::go::webbase::blobs::Features_subj_t_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::ParsedHtml_page_errors> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::ParsedHtml_page_errors>() {
  return ::ru::mail::go::webbase::blobs::ParsedHtml_page_errors_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_doc_5fparser_2eproto__INCLUDED
