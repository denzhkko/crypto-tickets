// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fetch_list.proto

#ifndef PROTOBUF_fetch_5flist_2eproto__INCLUDED
#define PROTOBUF_fetch_5flist_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "crawl_state.pb.h"
#include "document_enums.pb.h"
#include "silicon_data.pb.h"
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {
class BaseSplitInfo;
class BaseSplitInfoDefaultTypeInternal;
extern BaseSplitInfoDefaultTypeInternal _BaseSplitInfo_default_instance_;
class CrawlHistory;
class CrawlHistoryDefaultTypeInternal;
extern CrawlHistoryDefaultTypeInternal _CrawlHistory_default_instance_;
class FetchBanResult;
class FetchBanResultDefaultTypeInternal;
extern FetchBanResultDefaultTypeInternal _FetchBanResult_default_instance_;
class FetchResult;
class FetchResultDefaultTypeInternal;
extern FetchResultDefaultTypeInternal _FetchResult_default_instance_;
class FetchUrl;
class FetchUrlDefaultTypeInternal;
extern FetchUrlDefaultTypeInternal _FetchUrl_default_instance_;
class OkApiMessage;
class OkApiMessageDefaultTypeInternal;
extern OkApiMessageDefaultTypeInternal _OkApiMessage_default_instance_;
class OkIdToUrlMapping;
class OkIdToUrlMappingDefaultTypeInternal;
extern OkIdToUrlMappingDefaultTypeInternal _OkIdToUrlMapping_default_instance_;
class PublicationMarkup;
class PublicationMarkupDefaultTypeInternal;
extern PublicationMarkupDefaultTypeInternal _PublicationMarkup_default_instance_;
class PublicationMarkupRecord;
class PublicationMarkupRecordDefaultTypeInternal;
extern PublicationMarkupRecordDefaultTypeInternal _PublicationMarkupRecord_default_instance_;
class SplitFlags;
class SplitFlagsDefaultTypeInternal;
extern SplitFlagsDefaultTypeInternal _SplitFlags_default_instance_;
class YouTubeCommon;
class YouTubeCommonDefaultTypeInternal;
extern YouTubeCommonDefaultTypeInternal _YouTubeCommon_default_instance_;
class YouTubeIdUrlMapping;
class YouTubeIdUrlMappingDefaultTypeInternal;
extern YouTubeIdUrlMappingDefaultTypeInternal _YouTubeIdUrlMapping_default_instance_;
class YouTubeWebSearch;
class YouTubeWebSearchDefaultTypeInternal;
extern YouTubeWebSearchDefaultTypeInternal _YouTubeWebSearch_default_instance_;
}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {

namespace protobuf_fetch_5flist_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_fetch_5flist_2eproto

enum FetchUrl_Fastbases {
  FetchUrl_Fastbases_INFO_BASE = 0,
  FetchUrl_Fastbases_NAVIG_BASE = 1,
  FetchUrl_Fastbases_SITEMAP_BASE = 2,
  FetchUrl_Fastbases_BAN_BASE = 3,
  FetchUrl_Fastbases_NAIL_BASE = 4,
  FetchUrl_Fastbases_INTERLEAVING_BASE = 5,
  FetchUrl_Fastbases_BEHAVIORAL_BASE = 6
};
bool FetchUrl_Fastbases_IsValid(int value);
const FetchUrl_Fastbases FetchUrl_Fastbases_Fastbases_MIN = FetchUrl_Fastbases_INFO_BASE;
const FetchUrl_Fastbases FetchUrl_Fastbases_Fastbases_MAX = FetchUrl_Fastbases_BEHAVIORAL_BASE;
const int FetchUrl_Fastbases_Fastbases_ARRAYSIZE = FetchUrl_Fastbases_Fastbases_MAX + 1;

const ::google::protobuf::EnumDescriptor* FetchUrl_Fastbases_descriptor();
inline const ::std::string& FetchUrl_Fastbases_Name(FetchUrl_Fastbases value) {
  return ::google::protobuf::internal::NameOfEnum(
    FetchUrl_Fastbases_descriptor(), value);
}
inline bool FetchUrl_Fastbases_Parse(
    const ::std::string& name, FetchUrl_Fastbases* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FetchUrl_Fastbases>(
    FetchUrl_Fastbases_descriptor(), name, value);
}
enum PublicationMarkupRecord_Source {
  PublicationMarkupRecord_Source_ya_ovs_upload_date = 0,
  PublicationMarkupRecord_Source_meta_date_published = 1,
  PublicationMarkupRecord_Source_meta_upload_date = 2,
  PublicationMarkupRecord_Source_span_date_published = 3,
  PublicationMarkupRecord_Source_span_upload_date = 4,
  PublicationMarkupRecord_Source_script_date_published = 5,
  PublicationMarkupRecord_Source_article_published_time = 6,
  PublicationMarkupRecord_Source_time_date_published = 7,
  PublicationMarkupRecord_Source_div_date_published = 8
};
bool PublicationMarkupRecord_Source_IsValid(int value);
const PublicationMarkupRecord_Source PublicationMarkupRecord_Source_Source_MIN = PublicationMarkupRecord_Source_ya_ovs_upload_date;
const PublicationMarkupRecord_Source PublicationMarkupRecord_Source_Source_MAX = PublicationMarkupRecord_Source_div_date_published;
const int PublicationMarkupRecord_Source_Source_ARRAYSIZE = PublicationMarkupRecord_Source_Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* PublicationMarkupRecord_Source_descriptor();
inline const ::std::string& PublicationMarkupRecord_Source_Name(PublicationMarkupRecord_Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    PublicationMarkupRecord_Source_descriptor(), value);
}
inline bool PublicationMarkupRecord_Source_Parse(
    const ::std::string& name, PublicationMarkupRecord_Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PublicationMarkupRecord_Source>(
    PublicationMarkupRecord_Source_descriptor(), name, value);
}
enum FetcherType {
  FAST_FETCHER = 0,
  DARK_FETCHER = 1,
  DARK_AFTER_FAST_FETCHER = 2
};
bool FetcherType_IsValid(int value);
const FetcherType FetcherType_MIN = FAST_FETCHER;
const FetcherType FetcherType_MAX = DARK_AFTER_FAST_FETCHER;
const int FetcherType_ARRAYSIZE = FetcherType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FetcherType_descriptor();
inline const ::std::string& FetcherType_Name(FetcherType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FetcherType_descriptor(), value);
}
inline bool FetcherType_Parse(
    const ::std::string& name, FetcherType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FetcherType>(
    FetcherType_descriptor(), name, value);
}
enum BatchingResult {
  not_needed_result = 0,
  skipped_result = 1,
  rotten_result = 2,
  batched_result = 3
};
bool BatchingResult_IsValid(int value);
const BatchingResult BatchingResult_MIN = not_needed_result;
const BatchingResult BatchingResult_MAX = batched_result;
const int BatchingResult_ARRAYSIZE = BatchingResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* BatchingResult_descriptor();
inline const ::std::string& BatchingResult_Name(BatchingResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    BatchingResult_descriptor(), value);
}
inline bool BatchingResult_Parse(
    const ::std::string& name, BatchingResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BatchingResult>(
    BatchingResult_descriptor(), name, value);
}
enum VideoBanSource {
  from_dead_video_ban = 0,
  from_dead_video_checker = 1
};
bool VideoBanSource_IsValid(int value);
const VideoBanSource VideoBanSource_MIN = from_dead_video_ban;
const VideoBanSource VideoBanSource_MAX = from_dead_video_checker;
const int VideoBanSource_ARRAYSIZE = VideoBanSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* VideoBanSource_descriptor();
inline const ::std::string& VideoBanSource_Name(VideoBanSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    VideoBanSource_descriptor(), value);
}
inline bool VideoBanSource_Parse(
    const ::std::string& name, VideoBanSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoBanSource>(
    VideoBanSource_descriptor(), name, value);
}
// ===================================================================

class SplitFlags : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.SplitFlags) */ {
 public:
  SplitFlags();
  virtual ~SplitFlags();

  SplitFlags(const SplitFlags& from);

  inline SplitFlags& operator=(const SplitFlags& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SplitFlags(SplitFlags&& from) noexcept
    : SplitFlags() {
    *this = ::std::move(from);
  }

  inline SplitFlags& operator=(SplitFlags&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SplitFlags& default_instance();

  static inline const SplitFlags* internal_default_instance() {
    return reinterpret_cast<const SplitFlags*>(
               &_SplitFlags_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(SplitFlags* other);
  friend void swap(SplitFlags& a, SplitFlags& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SplitFlags* New() const PROTOBUF_FINAL { return New(NULL); }

  SplitFlags* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SplitFlags& from);
  void MergeFrom(const SplitFlags& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SplitFlags* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool SplitA = 1 [default = false];
  bool has_splita() const;
  void clear_splita();
  static const int kSplitAFieldNumber = 1;
  bool splita() const;
  void set_splita(bool value);

  // optional bool SplitB = 2 [default = false];
  bool has_splitb() const;
  void clear_splitb();
  static const int kSplitBFieldNumber = 2;
  bool splitb() const;
  void set_splitb(bool value);

  // optional bool SplitC = 3 [default = false];
  bool has_splitc() const;
  void clear_splitc();
  static const int kSplitCFieldNumber = 3;
  bool splitc() const;
  void set_splitc(bool value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.SplitFlags)
 private:
  void set_has_splita();
  void clear_has_splita();
  void set_has_splitb();
  void clear_has_splitb();
  void set_has_splitc();
  void clear_has_splitc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool splita_;
  bool splitb_;
  bool splitc_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FetchUrl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.FetchUrl) */ {
 public:
  FetchUrl();
  virtual ~FetchUrl();

  FetchUrl(const FetchUrl& from);

  inline FetchUrl& operator=(const FetchUrl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FetchUrl(FetchUrl&& from) noexcept
    : FetchUrl() {
    *this = ::std::move(from);
  }

  inline FetchUrl& operator=(FetchUrl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FetchUrl& default_instance();

  static inline const FetchUrl* internal_default_instance() {
    return reinterpret_cast<const FetchUrl*>(
               &_FetchUrl_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(FetchUrl* other);
  friend void swap(FetchUrl& a, FetchUrl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FetchUrl* New() const PROTOBUF_FINAL { return New(NULL); }

  FetchUrl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FetchUrl& from);
  void MergeFrom(const FetchUrl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FetchUrl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef FetchUrl_Fastbases Fastbases;
  static const Fastbases INFO_BASE =
    FetchUrl_Fastbases_INFO_BASE;
  static const Fastbases NAVIG_BASE =
    FetchUrl_Fastbases_NAVIG_BASE;
  static const Fastbases SITEMAP_BASE =
    FetchUrl_Fastbases_SITEMAP_BASE;
  static const Fastbases BAN_BASE =
    FetchUrl_Fastbases_BAN_BASE;
  static const Fastbases NAIL_BASE =
    FetchUrl_Fastbases_NAIL_BASE;
  static const Fastbases INTERLEAVING_BASE =
    FetchUrl_Fastbases_INTERLEAVING_BASE;
  static const Fastbases BEHAVIORAL_BASE =
    FetchUrl_Fastbases_BEHAVIORAL_BASE;
  static inline bool Fastbases_IsValid(int value) {
    return FetchUrl_Fastbases_IsValid(value);
  }
  static const Fastbases Fastbases_MIN =
    FetchUrl_Fastbases_Fastbases_MIN;
  static const Fastbases Fastbases_MAX =
    FetchUrl_Fastbases_Fastbases_MAX;
  static const int Fastbases_ARRAYSIZE =
    FetchUrl_Fastbases_Fastbases_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Fastbases_descriptor() {
    return FetchUrl_Fastbases_descriptor();
  }
  static inline const ::std::string& Fastbases_Name(Fastbases value) {
    return FetchUrl_Fastbases_Name(value);
  }
  static inline bool Fastbases_Parse(const ::std::string& name,
      Fastbases* value) {
    return FetchUrl_Fastbases_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.FetchUrl.Fastbases targetBases = 5;
  int targetbases_size() const;
  void clear_targetbases();
  static const int kTargetBasesFieldNumber = 5;
  ::ru::mail::go::webbase::blobs::FetchUrl_Fastbases targetbases(int index) const;
  void set_targetbases(int index, ::ru::mail::go::webbase::blobs::FetchUrl_Fastbases value);
  void add_targetbases(::ru::mail::go::webbase::blobs::FetchUrl_Fastbases value);
  const ::google::protobuf::RepeatedField<int>& targetbases() const;
  ::google::protobuf::RepeatedField<int>* mutable_targetbases();

  // repeated string redirects = 10;
  int redirects_size() const;
  void clear_redirects();
  static const int kRedirectsFieldNumber = 10;
  const ::std::string& redirects(int index) const;
  ::std::string* mutable_redirects(int index);
  void set_redirects(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_redirects(int index, ::std::string&& value);
  #endif
  void set_redirects(int index, const char* value);
  void set_redirects(int index, const char* value, size_t size);
  ::std::string* add_redirects();
  void add_redirects(const ::std::string& value);
  #if LANG_CXX11
  void add_redirects(::std::string&& value);
  #endif
  void add_redirects(const char* value);
  void add_redirects(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& redirects() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_redirects();

  // repeated .ru.mail.go.webbase.blobs.BaseSplitInfo baseSplitInfo = 18;
  int basesplitinfo_size() const;
  void clear_basesplitinfo();
  static const int kBaseSplitInfoFieldNumber = 18;
  const ::ru::mail::go::webbase::blobs::BaseSplitInfo& basesplitinfo(int index) const;
  ::ru::mail::go::webbase::blobs::BaseSplitInfo* mutable_basesplitinfo(int index);
  ::ru::mail::go::webbase::blobs::BaseSplitInfo* add_basesplitinfo();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::BaseSplitInfo >*
      mutable_basesplitinfo();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::BaseSplitInfo >&
      basesplitinfo() const;

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional string eTag = 4;
  bool has_etag() const;
  void clear_etag();
  static const int kETagFieldNumber = 4;
  const ::std::string& etag() const;
  void set_etag(const ::std::string& value);
  #if LANG_CXX11
  void set_etag(::std::string&& value);
  #endif
  void set_etag(const char* value);
  void set_etag(const char* value, size_t size);
  ::std::string* mutable_etag();
  ::std::string* release_etag();
  void set_allocated_etag(::std::string* etag);

  // optional string originalUrl = 14;
  bool has_originalurl() const;
  void clear_originalurl();
  static const int kOriginalUrlFieldNumber = 14;
  const ::std::string& originalurl() const;
  void set_originalurl(const ::std::string& value);
  #if LANG_CXX11
  void set_originalurl(::std::string&& value);
  #endif
  void set_originalurl(const char* value);
  void set_originalurl(const char* value, size_t size);
  ::std::string* mutable_originalurl();
  ::std::string* release_originalurl();
  void set_allocated_originalurl(::std::string* originalurl);

  // optional string referer = 19;
  bool has_referer() const;
  void clear_referer();
  static const int kRefererFieldNumber = 19;
  const ::std::string& referer() const;
  void set_referer(const ::std::string& value);
  #if LANG_CXX11
  void set_referer(::std::string&& value);
  #endif
  void set_referer(const char* value);
  void set_referer(const char* value, size_t size);
  ::std::string* mutable_referer();
  ::std::string* release_referer();
  void set_allocated_referer(::std::string* referer);

  // optional string schedulerName = 20;
  bool has_schedulername() const;
  void clear_schedulername();
  static const int kSchedulerNameFieldNumber = 20;
  const ::std::string& schedulername() const;
  void set_schedulername(const ::std::string& value);
  #if LANG_CXX11
  void set_schedulername(::std::string&& value);
  #endif
  void set_schedulername(const char* value);
  void set_schedulername(const char* value, size_t size);
  ::std::string* mutable_schedulername();
  ::std::string* release_schedulername();
  void set_allocated_schedulername(::std::string* schedulername);

  // optional .ru.mail.go.webbase.blobs.SplitFlags splitFlags = 13;
  bool has_splitflags() const;
  void clear_splitflags();
  static const int kSplitFlagsFieldNumber = 13;
  const ::ru::mail::go::webbase::blobs::SplitFlags& splitflags() const;
  ::ru::mail::go::webbase::blobs::SplitFlags* mutable_splitflags();
  ::ru::mail::go::webbase::blobs::SplitFlags* release_splitflags();
  void set_allocated_splitflags(::ru::mail::go::webbase::blobs::SplitFlags* splitflags);

  // optional int64 lastModified = 3;
  bool has_lastmodified() const;
  void clear_lastmodified();
  static const int kLastModifiedFieldNumber = 3;
  ::google::protobuf::int64 lastmodified() const;
  void set_lastmodified(::google::protobuf::int64 value);

  // optional int32 flag = 2;
  bool has_flag() const;
  void clear_flag();
  static const int kFlagFieldNumber = 2;
  ::google::protobuf::int32 flag() const;
  void set_flag(::google::protobuf::int32 value);

  // optional int32 attemptsToFetch = 6;
  bool has_attemptstofetch() const;
  void clear_attemptstofetch();
  static const int kAttemptsToFetchFieldNumber = 6;
  ::google::protobuf::int32 attemptstofetch() const;
  void set_attemptstofetch(::google::protobuf::int32 value);

  // optional int64 meetDate = 7;
  bool has_meetdate() const;
  void clear_meetdate();
  static const int kMeetDateFieldNumber = 7;
  ::google::protobuf::int64 meetdate() const;
  void set_meetdate(::google::protobuf::int64 value);

  // optional int64 minDateToFetch = 8;
  bool has_mindatetofetch() const;
  void clear_mindatetofetch();
  static const int kMinDateToFetchFieldNumber = 8;
  ::google::protobuf::int64 mindatetofetch() const;
  void set_mindatetofetch(::google::protobuf::int64 value);

  // optional int32 minutesToRedownload = 9;
  bool has_minutestoredownload() const;
  void clear_minutestoredownload();
  static const int kMinutesToRedownloadFieldNumber = 9;
  ::google::protobuf::int32 minutestoredownload() const;
  void set_minutestoredownload(::google::protobuf::int32 value);

  // optional .ru.mail.go.webbase.blobs.FetcherType fetcherType = 12;
  bool has_fetchertype() const;
  void clear_fetchertype();
  static const int kFetcherTypeFieldNumber = 12;
  ::ru::mail::go::webbase::blobs::FetcherType fetchertype() const;
  void set_fetchertype(::ru::mail::go::webbase::blobs::FetcherType value);

  // optional int64 publicationDate = 11;
  bool has_publicationdate() const;
  void clear_publicationdate();
  static const int kPublicationDateFieldNumber = 11;
  ::google::protobuf::int64 publicationdate() const;
  void set_publicationdate(::google::protobuf::int64 value);

  // optional .ru.mail.go.webbase.blobs.ForumType forumType = 15;
  bool has_forumtype() const;
  void clear_forumtype();
  static const int kForumTypeFieldNumber = 15;
  ::ru::mail::go::webbase::blobs::ForumType forumtype() const;
  void set_forumtype(::ru::mail::go::webbase::blobs::ForumType value);

  // optional int32 mainPriority = 16;
  bool has_mainpriority() const;
  void clear_mainpriority();
  static const int kMainPriorityFieldNumber = 16;
  ::google::protobuf::int32 mainpriority() const;
  void set_mainpriority(::google::protobuf::int32 value);

  // optional int32 schedulerPriority = 21;
  bool has_schedulerpriority() const;
  void clear_schedulerpriority();
  static const int kSchedulerPriorityFieldNumber = 21;
  ::google::protobuf::int32 schedulerpriority() const;
  void set_schedulerpriority(::google::protobuf::int32 value);

  // optional bool isNew = 17;
  bool has_isnew() const;
  void clear_isnew();
  static const int kIsNewFieldNumber = 17;
  bool isnew() const;
  void set_isnew(bool value);

  // optional bool isPostscheduled = 25;
  bool has_ispostscheduled() const;
  void clear_ispostscheduled();
  static const int kIsPostscheduledFieldNumber = 25;
  bool ispostscheduled() const;
  void set_ispostscheduled(bool value);

  // optional int64 schedulerTimestamp = 22;
  bool has_schedulertimestamp() const;
  void clear_schedulertimestamp();
  static const int kSchedulerTimestampFieldNumber = 22;
  ::google::protobuf::int64 schedulertimestamp() const;
  void set_schedulertimestamp(::google::protobuf::int64 value);

  // optional int64 batchTimestamp = 23;
  bool has_batchtimestamp() const;
  void clear_batchtimestamp();
  static const int kBatchTimestampFieldNumber = 23;
  ::google::protobuf::int64 batchtimestamp() const;
  void set_batchtimestamp(::google::protobuf::int64 value);

  // optional int64 schedulerJobEndTimestamp = 24;
  bool has_schedulerjobendtimestamp() const;
  void clear_schedulerjobendtimestamp();
  static const int kSchedulerJobEndTimestampFieldNumber = 24;
  ::google::protobuf::int64 schedulerjobendtimestamp() const;
  void set_schedulerjobendtimestamp(::google::protobuf::int64 value);

  // optional int64 batchGeneratorTimestamp = 26;
  bool has_batchgeneratortimestamp() const;
  void clear_batchgeneratortimestamp();
  static const int kBatchGeneratorTimestampFieldNumber = 26;
  ::google::protobuf::int64 batchgeneratortimestamp() const;
  void set_batchgeneratortimestamp(::google::protobuf::int64 value);

  // optional int64 parserTimestamp = 27;
  bool has_parsertimestamp() const;
  void clear_parsertimestamp();
  static const int kParserTimestampFieldNumber = 27;
  ::google::protobuf::int64 parsertimestamp() const;
  void set_parsertimestamp(::google::protobuf::int64 value);

  // optional int64 discoveryBatchingTimestamp = 28;
  bool has_discoverybatchingtimestamp() const;
  void clear_discoverybatchingtimestamp();
  static const int kDiscoveryBatchingTimestampFieldNumber = 28;
  ::google::protobuf::int64 discoverybatchingtimestamp() const;
  void set_discoverybatchingtimestamp(::google::protobuf::int64 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(FetchUrl)
  static const int kBatchingResultFieldNumber = 1000;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::EnumTypeTraits< ::ru::mail::go::webbase::blobs::BatchingResult, ::ru::mail::go::webbase::blobs::BatchingResult_IsValid>, 14, false >
    batchingResult;
  static const int kBatchingTsFieldNumber = 1001;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int64 >, 3, false >
    batchingTs;
  static const int kCheckSumFieldNumber = 1002;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int64 >, 3, false >
    checkSum;
  static const int kCheckSumTsFieldNumber = 1003;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int64 >, 3, false >
    checkSumTs;
  static const int kVideoBanSourceFieldNumber = 1004;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::EnumTypeTraits< ::ru::mail::go::webbase::blobs::VideoBanSource, ::ru::mail::go::webbase::blobs::VideoBanSource_IsValid>, 14, false >
    videoBanSource;
  static const int kYoutubeForVideoSearchFieldNumber = 1005;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
    youtubeForVideoSearch;
  static const int kYouTubeWebSearchFieldNumber = 1006;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::MessageTypeTraits< ::ru::mail::go::webbase::blobs::YouTubeWebSearch >, 11, false >
    youTubeWebSearch;
  static const int kYouTubeCommonFieldNumber = 1007;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::MessageTypeTraits< ::ru::mail::go::webbase::blobs::YouTubeCommon >, 11, false >
    youTubeCommon;
  static const int kMicrobaseIDFieldNumber = 1008;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int32 >, 5, false >
    microbaseID;
  static const int kRouteKeyFieldNumber = 1009;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::StringTypeTraits, 9, false >
    routeKey;
  static const int kCrawlHistoryFieldNumber = 1010;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::MessageTypeTraits< ::ru::mail::go::webbase::blobs::CrawlHistory >, 11, false >
    crawlHistory;
  static const int kReleaseDateFieldNumber = 1011;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int64 >, 3, false >
    releaseDate;
  static const int kDepthFieldNumber = 1012;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int32 >, 5, false >
    depth;
  static const int kSourceUrlFieldNumber = 1013;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::StringTypeTraits, 9, false >
    sourceUrl;
  static const int kSiliconUrlsFieldNumber = 1014;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::RepeatedMessageTypeTraits< ::ru::mail::go::webbase::blobs::SiliconFetchUrl >, 11, false >
    siliconUrls;
  static const int kOkApiFieldNumber = 1015;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::MessageTypeTraits< ::ru::mail::go::webbase::blobs::OkApiMessage >, 11, false >
    okApi;
  static const int kBatchPoolFieldNumber = 1016;
  static ::google::protobuf::internal::ExtensionIdentifier< ::ru::mail::go::webbase::blobs::FetchUrl,
      ::google::protobuf::internal::StringTypeTraits, 9, false >
    batchPool;
  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.FetchUrl)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_flag();
  void clear_has_flag();
  void set_has_lastmodified();
  void clear_has_lastmodified();
  void set_has_etag();
  void clear_has_etag();
  void set_has_attemptstofetch();
  void clear_has_attemptstofetch();
  void set_has_meetdate();
  void clear_has_meetdate();
  void set_has_mindatetofetch();
  void clear_has_mindatetofetch();
  void set_has_minutestoredownload();
  void clear_has_minutestoredownload();
  void set_has_publicationdate();
  void clear_has_publicationdate();
  void set_has_fetchertype();
  void clear_has_fetchertype();
  void set_has_splitflags();
  void clear_has_splitflags();
  void set_has_originalurl();
  void clear_has_originalurl();
  void set_has_forumtype();
  void clear_has_forumtype();
  void set_has_mainpriority();
  void clear_has_mainpriority();
  void set_has_isnew();
  void clear_has_isnew();
  void set_has_referer();
  void clear_has_referer();
  void set_has_schedulername();
  void clear_has_schedulername();
  void set_has_schedulerpriority();
  void clear_has_schedulerpriority();
  void set_has_schedulertimestamp();
  void clear_has_schedulertimestamp();
  void set_has_batchtimestamp();
  void clear_has_batchtimestamp();
  void set_has_schedulerjobendtimestamp();
  void clear_has_schedulerjobendtimestamp();
  void set_has_ispostscheduled();
  void clear_has_ispostscheduled();
  void set_has_batchgeneratortimestamp();
  void clear_has_batchgeneratortimestamp();
  void set_has_parsertimestamp();
  void clear_has_parsertimestamp();
  void set_has_discoverybatchingtimestamp();
  void clear_has_discoverybatchingtimestamp();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> targetbases_;
  ::google::protobuf::RepeatedPtrField< ::std::string> redirects_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::BaseSplitInfo > basesplitinfo_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr etag_;
  ::google::protobuf::internal::ArenaStringPtr originalurl_;
  ::google::protobuf::internal::ArenaStringPtr referer_;
  ::google::protobuf::internal::ArenaStringPtr schedulername_;
  ::ru::mail::go::webbase::blobs::SplitFlags* splitflags_;
  ::google::protobuf::int64 lastmodified_;
  ::google::protobuf::int32 flag_;
  ::google::protobuf::int32 attemptstofetch_;
  ::google::protobuf::int64 meetdate_;
  ::google::protobuf::int64 mindatetofetch_;
  ::google::protobuf::int32 minutestoredownload_;
  int fetchertype_;
  ::google::protobuf::int64 publicationdate_;
  int forumtype_;
  ::google::protobuf::int32 mainpriority_;
  ::google::protobuf::int32 schedulerpriority_;
  bool isnew_;
  bool ispostscheduled_;
  ::google::protobuf::int64 schedulertimestamp_;
  ::google::protobuf::int64 batchtimestamp_;
  ::google::protobuf::int64 schedulerjobendtimestamp_;
  ::google::protobuf::int64 batchgeneratortimestamp_;
  ::google::protobuf::int64 parsertimestamp_;
  ::google::protobuf::int64 discoverybatchingtimestamp_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BaseSplitInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.BaseSplitInfo) */ {
 public:
  BaseSplitInfo();
  virtual ~BaseSplitInfo();

  BaseSplitInfo(const BaseSplitInfo& from);

  inline BaseSplitInfo& operator=(const BaseSplitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BaseSplitInfo(BaseSplitInfo&& from) noexcept
    : BaseSplitInfo() {
    *this = ::std::move(from);
  }

  inline BaseSplitInfo& operator=(BaseSplitInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseSplitInfo& default_instance();

  static inline const BaseSplitInfo* internal_default_instance() {
    return reinterpret_cast<const BaseSplitInfo*>(
               &_BaseSplitInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(BaseSplitInfo* other);
  friend void swap(BaseSplitInfo& a, BaseSplitInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BaseSplitInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  BaseSplitInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BaseSplitInfo& from);
  void MergeFrom(const BaseSplitInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BaseSplitInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ru.mail.go.webbase.blobs.SplitFlags splitFlags = 2;
  bool has_splitflags() const;
  void clear_splitflags();
  static const int kSplitFlagsFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::SplitFlags& splitflags() const;
  ::ru::mail::go::webbase::blobs::SplitFlags* mutable_splitflags();
  ::ru::mail::go::webbase::blobs::SplitFlags* release_splitflags();
  void set_allocated_splitflags(::ru::mail::go::webbase::blobs::SplitFlags* splitflags);

  // required .ru.mail.go.webbase.blobs.FetchUrl.Fastbases base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::FetchUrl_Fastbases base() const;
  void set_base(::ru::mail::go::webbase::blobs::FetchUrl_Fastbases value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.BaseSplitInfo)
 private:
  void set_has_base();
  void clear_has_base();
  void set_has_splitflags();
  void clear_has_splitflags();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ru::mail::go::webbase::blobs::SplitFlags* splitflags_;
  int base_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class YouTubeWebSearch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.YouTubeWebSearch) */ {
 public:
  YouTubeWebSearch();
  virtual ~YouTubeWebSearch();

  YouTubeWebSearch(const YouTubeWebSearch& from);

  inline YouTubeWebSearch& operator=(const YouTubeWebSearch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  YouTubeWebSearch(YouTubeWebSearch&& from) noexcept
    : YouTubeWebSearch() {
    *this = ::std::move(from);
  }

  inline YouTubeWebSearch& operator=(YouTubeWebSearch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YouTubeWebSearch& default_instance();

  static inline const YouTubeWebSearch* internal_default_instance() {
    return reinterpret_cast<const YouTubeWebSearch*>(
               &_YouTubeWebSearch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(YouTubeWebSearch* other);
  friend void swap(YouTubeWebSearch& a, YouTubeWebSearch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline YouTubeWebSearch* New() const PROTOBUF_FINAL { return New(NULL); }

  YouTubeWebSearch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YouTubeWebSearch& from);
  void MergeFrom(const YouTubeWebSearch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YouTubeWebSearch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string originalUrl = 1;
  bool has_originalurl() const;
  void clear_originalurl();
  static const int kOriginalUrlFieldNumber = 1;
  const ::std::string& originalurl() const;
  void set_originalurl(const ::std::string& value);
  #if LANG_CXX11
  void set_originalurl(::std::string&& value);
  #endif
  void set_originalurl(const char* value);
  void set_originalurl(const char* value, size_t size);
  ::std::string* mutable_originalurl();
  ::std::string* release_originalurl();
  void set_allocated_originalurl(::std::string* originalurl);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.YouTubeWebSearch)
 private:
  void set_has_originalurl();
  void clear_has_originalurl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr originalurl_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class YouTubeCommon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.YouTubeCommon) */ {
 public:
  YouTubeCommon();
  virtual ~YouTubeCommon();

  YouTubeCommon(const YouTubeCommon& from);

  inline YouTubeCommon& operator=(const YouTubeCommon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  YouTubeCommon(YouTubeCommon&& from) noexcept
    : YouTubeCommon() {
    *this = ::std::move(from);
  }

  inline YouTubeCommon& operator=(YouTubeCommon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YouTubeCommon& default_instance();

  static inline const YouTubeCommon* internal_default_instance() {
    return reinterpret_cast<const YouTubeCommon*>(
               &_YouTubeCommon_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(YouTubeCommon* other);
  friend void swap(YouTubeCommon& a, YouTubeCommon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline YouTubeCommon* New() const PROTOBUF_FINAL { return New(NULL); }

  YouTubeCommon* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YouTubeCommon& from);
  void MergeFrom(const YouTubeCommon& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YouTubeCommon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.YouTubeIdUrlMapping idUrlMapping = 1;
  int idurlmapping_size() const;
  void clear_idurlmapping();
  static const int kIdUrlMappingFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::YouTubeIdUrlMapping& idurlmapping(int index) const;
  ::ru::mail::go::webbase::blobs::YouTubeIdUrlMapping* mutable_idurlmapping(int index);
  ::ru::mail::go::webbase::blobs::YouTubeIdUrlMapping* add_idurlmapping();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::YouTubeIdUrlMapping >*
      mutable_idurlmapping();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::YouTubeIdUrlMapping >&
      idurlmapping() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.YouTubeCommon)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::YouTubeIdUrlMapping > idurlmapping_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class YouTubeIdUrlMapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping) */ {
 public:
  YouTubeIdUrlMapping();
  virtual ~YouTubeIdUrlMapping();

  YouTubeIdUrlMapping(const YouTubeIdUrlMapping& from);

  inline YouTubeIdUrlMapping& operator=(const YouTubeIdUrlMapping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  YouTubeIdUrlMapping(YouTubeIdUrlMapping&& from) noexcept
    : YouTubeIdUrlMapping() {
    *this = ::std::move(from);
  }

  inline YouTubeIdUrlMapping& operator=(YouTubeIdUrlMapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YouTubeIdUrlMapping& default_instance();

  static inline const YouTubeIdUrlMapping* internal_default_instance() {
    return reinterpret_cast<const YouTubeIdUrlMapping*>(
               &_YouTubeIdUrlMapping_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(YouTubeIdUrlMapping* other);
  friend void swap(YouTubeIdUrlMapping& a, YouTubeIdUrlMapping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline YouTubeIdUrlMapping* New() const PROTOBUF_FINAL { return New(NULL); }

  YouTubeIdUrlMapping* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const YouTubeIdUrlMapping& from);
  void MergeFrom(const YouTubeIdUrlMapping& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(YouTubeIdUrlMapping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_url();
  void clear_has_url();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OkApiMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.OkApiMessage) */ {
 public:
  OkApiMessage();
  virtual ~OkApiMessage();

  OkApiMessage(const OkApiMessage& from);

  inline OkApiMessage& operator=(const OkApiMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OkApiMessage(OkApiMessage&& from) noexcept
    : OkApiMessage() {
    *this = ::std::move(from);
  }

  inline OkApiMessage& operator=(OkApiMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OkApiMessage& default_instance();

  static inline const OkApiMessage* internal_default_instance() {
    return reinterpret_cast<const OkApiMessage*>(
               &_OkApiMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(OkApiMessage* other);
  friend void swap(OkApiMessage& a, OkApiMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OkApiMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  OkApiMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OkApiMessage& from);
  void MergeFrom(const OkApiMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OkApiMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.OkIdToUrlMapping idToUrlMapping = 1;
  int idtourlmapping_size() const;
  void clear_idtourlmapping();
  static const int kIdToUrlMappingFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::OkIdToUrlMapping& idtourlmapping(int index) const;
  ::ru::mail::go::webbase::blobs::OkIdToUrlMapping* mutable_idtourlmapping(int index);
  ::ru::mail::go::webbase::blobs::OkIdToUrlMapping* add_idtourlmapping();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::OkIdToUrlMapping >*
      mutable_idtourlmapping();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::OkIdToUrlMapping >&
      idtourlmapping() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.OkApiMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::OkIdToUrlMapping > idtourlmapping_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OkIdToUrlMapping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.OkIdToUrlMapping) */ {
 public:
  OkIdToUrlMapping();
  virtual ~OkIdToUrlMapping();

  OkIdToUrlMapping(const OkIdToUrlMapping& from);

  inline OkIdToUrlMapping& operator=(const OkIdToUrlMapping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OkIdToUrlMapping(OkIdToUrlMapping&& from) noexcept
    : OkIdToUrlMapping() {
    *this = ::std::move(from);
  }

  inline OkIdToUrlMapping& operator=(OkIdToUrlMapping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OkIdToUrlMapping& default_instance();

  static inline const OkIdToUrlMapping* internal_default_instance() {
    return reinterpret_cast<const OkIdToUrlMapping*>(
               &_OkIdToUrlMapping_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(OkIdToUrlMapping* other);
  friend void swap(OkIdToUrlMapping& a, OkIdToUrlMapping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OkIdToUrlMapping* New() const PROTOBUF_FINAL { return New(NULL); }

  OkIdToUrlMapping* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OkIdToUrlMapping& from);
  void MergeFrom(const OkIdToUrlMapping& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OkIdToUrlMapping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required int64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.OkIdToUrlMapping)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_url();
  void clear_has_url();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::int64 id_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CrawlHistory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.CrawlHistory) */ {
 public:
  CrawlHistory();
  virtual ~CrawlHistory();

  CrawlHistory(const CrawlHistory& from);

  inline CrawlHistory& operator=(const CrawlHistory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrawlHistory(CrawlHistory&& from) noexcept
    : CrawlHistory() {
    *this = ::std::move(from);
  }

  inline CrawlHistory& operator=(CrawlHistory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrawlHistory& default_instance();

  static inline const CrawlHistory* internal_default_instance() {
    return reinterpret_cast<const CrawlHistory*>(
               &_CrawlHistory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(CrawlHistory* other);
  friend void swap(CrawlHistory& a, CrawlHistory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrawlHistory* New() const PROTOBUF_FINAL { return New(NULL); }

  CrawlHistory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CrawlHistory& from);
  void MergeFrom(const CrawlHistory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CrawlHistory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 firstCrawlTs = 1;
  bool has_firstcrawlts() const;
  void clear_firstcrawlts();
  static const int kFirstCrawlTsFieldNumber = 1;
  ::google::protobuf::int64 firstcrawlts() const;
  void set_firstcrawlts(::google::protobuf::int64 value);

  // required int64 lastChangeTs = 3;
  bool has_lastchangets() const;
  void clear_lastchangets();
  static const int kLastChangeTsFieldNumber = 3;
  ::google::protobuf::int64 lastchangets() const;
  void set_lastchangets(::google::protobuf::int64 value);

  // required int32 changesNumber = 2;
  bool has_changesnumber() const;
  void clear_changesnumber();
  static const int kChangesNumberFieldNumber = 2;
  ::google::protobuf::int32 changesnumber() const;
  void set_changesnumber(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.CrawlHistory)
 private:
  void set_has_firstcrawlts();
  void clear_has_firstcrawlts();
  void set_has_changesnumber();
  void clear_has_changesnumber();
  void set_has_lastchangets();
  void clear_has_lastchangets();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 firstcrawlts_;
  ::google::protobuf::int64 lastchangets_;
  ::google::protobuf::int32 changesnumber_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FetchResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.FetchResult) */ {
 public:
  FetchResult();
  virtual ~FetchResult();

  FetchResult(const FetchResult& from);

  inline FetchResult& operator=(const FetchResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FetchResult(FetchResult&& from) noexcept
    : FetchResult() {
    *this = ::std::move(from);
  }

  inline FetchResult& operator=(FetchResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FetchResult& default_instance();

  static inline const FetchResult* internal_default_instance() {
    return reinterpret_cast<const FetchResult*>(
               &_FetchResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(FetchResult* other);
  friend void swap(FetchResult& a, FetchResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FetchResult* New() const PROTOBUF_FINAL { return New(NULL); }

  FetchResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FetchResult& from);
  void MergeFrom(const FetchResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FetchResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string redirects = 4;
  int redirects_size() const;
  void clear_redirects();
  static const int kRedirectsFieldNumber = 4;
  const ::std::string& redirects(int index) const;
  ::std::string* mutable_redirects(int index);
  void set_redirects(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_redirects(int index, ::std::string&& value);
  #endif
  void set_redirects(int index, const char* value);
  void set_redirects(int index, const char* value, size_t size);
  ::std::string* add_redirects();
  void add_redirects(const ::std::string& value);
  #if LANG_CXX11
  void add_redirects(::std::string&& value);
  #endif
  void add_redirects(const char* value);
  void add_redirects(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& redirects() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_redirects();

  // optional .ru.mail.go.webbase.blobs.CrawlDetails crawlStatus = 1;
  bool has_crawlstatus() const;
  void clear_crawlstatus();
  static const int kCrawlStatusFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::CrawlDetails& crawlstatus() const;
  ::ru::mail::go::webbase::blobs::CrawlDetails* mutable_crawlstatus();
  ::ru::mail::go::webbase::blobs::CrawlDetails* release_crawlstatus();
  void set_allocated_crawlstatus(::ru::mail::go::webbase::blobs::CrawlDetails* crawlstatus);

  // optional int64 minDateToFetch = 3;
  bool has_mindatetofetch() const;
  void clear_mindatetofetch();
  static const int kMinDateToFetchFieldNumber = 3;
  ::google::protobuf::int64 mindatetofetch() const;
  void set_mindatetofetch(::google::protobuf::int64 value);

  // optional int32 attemptsToFetch = 2;
  bool has_attemptstofetch() const;
  void clear_attemptstofetch();
  static const int kAttemptsToFetchFieldNumber = 2;
  ::google::protobuf::int32 attemptstofetch() const;
  void set_attemptstofetch(::google::protobuf::int32 value);

  // optional .ru.mail.go.webbase.blobs.FetcherType fetcherType = 5;
  bool has_fetchertype() const;
  void clear_fetchertype();
  static const int kFetcherTypeFieldNumber = 5;
  ::ru::mail::go::webbase::blobs::FetcherType fetchertype() const;
  void set_fetchertype(::ru::mail::go::webbase::blobs::FetcherType value);

  // optional bool isRotten = 6 [default = false];
  bool has_isrotten() const;
  void clear_isrotten();
  static const int kIsRottenFieldNumber = 6;
  bool isrotten() const;
  void set_isrotten(bool value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.FetchResult)
 private:
  void set_has_crawlstatus();
  void clear_has_crawlstatus();
  void set_has_attemptstofetch();
  void clear_has_attemptstofetch();
  void set_has_mindatetofetch();
  void clear_has_mindatetofetch();
  void set_has_fetchertype();
  void clear_has_fetchertype();
  void set_has_isrotten();
  void clear_has_isrotten();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> redirects_;
  ::ru::mail::go::webbase::blobs::CrawlDetails* crawlstatus_;
  ::google::protobuf::int64 mindatetofetch_;
  ::google::protobuf::int32 attemptstofetch_;
  int fetchertype_;
  bool isrotten_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FetchBanResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.FetchBanResult) */ {
 public:
  FetchBanResult();
  virtual ~FetchBanResult();

  FetchBanResult(const FetchBanResult& from);

  inline FetchBanResult& operator=(const FetchBanResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FetchBanResult(FetchBanResult&& from) noexcept
    : FetchBanResult() {
    *this = ::std::move(from);
  }

  inline FetchBanResult& operator=(FetchBanResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FetchBanResult& default_instance();

  static inline const FetchBanResult* internal_default_instance() {
    return reinterpret_cast<const FetchBanResult*>(
               &_FetchBanResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(FetchBanResult* other);
  friend void swap(FetchBanResult& a, FetchBanResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FetchBanResult* New() const PROTOBUF_FINAL { return New(NULL); }

  FetchBanResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FetchBanResult& from);
  void MergeFrom(const FetchBanResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FetchBanResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string redirects = 4;
  int redirects_size() const;
  void clear_redirects();
  static const int kRedirectsFieldNumber = 4;
  const ::std::string& redirects(int index) const;
  ::std::string* mutable_redirects(int index);
  void set_redirects(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_redirects(int index, ::std::string&& value);
  #endif
  void set_redirects(int index, const char* value);
  void set_redirects(int index, const char* value, size_t size);
  ::std::string* add_redirects();
  void add_redirects(const ::std::string& value);
  #if LANG_CXX11
  void add_redirects(::std::string&& value);
  #endif
  void add_redirects(const char* value);
  void add_redirects(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& redirects() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_redirects();

  // required string sourceUrl = 1;
  bool has_sourceurl() const;
  void clear_sourceurl();
  static const int kSourceUrlFieldNumber = 1;
  const ::std::string& sourceurl() const;
  void set_sourceurl(const ::std::string& value);
  #if LANG_CXX11
  void set_sourceurl(::std::string&& value);
  #endif
  void set_sourceurl(const char* value);
  void set_sourceurl(const char* value, size_t size);
  ::std::string* mutable_sourceurl();
  ::std::string* release_sourceurl();
  void set_allocated_sourceurl(::std::string* sourceurl);

  // optional bytes fetchStatus = 2;
  bool has_fetchstatus() const;
  void clear_fetchstatus();
  static const int kFetchStatusFieldNumber = 2;
  const ::std::string& fetchstatus() const;
  void set_fetchstatus(const ::std::string& value);
  #if LANG_CXX11
  void set_fetchstatus(::std::string&& value);
  #endif
  void set_fetchstatus(const char* value);
  void set_fetchstatus(const void* value, size_t size);
  ::std::string* mutable_fetchstatus();
  ::std::string* release_fetchstatus();
  void set_allocated_fetchstatus(::std::string* fetchstatus);

  // optional .ru.mail.go.webbase.blobs.CrawlDetails crawlStatus = 3;
  bool has_crawlstatus() const;
  void clear_crawlstatus();
  static const int kCrawlStatusFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::CrawlDetails& crawlstatus() const;
  ::ru::mail::go::webbase::blobs::CrawlDetails* mutable_crawlstatus();
  ::ru::mail::go::webbase::blobs::CrawlDetails* release_crawlstatus();
  void set_allocated_crawlstatus(::ru::mail::go::webbase::blobs::CrawlDetails* crawlstatus);

  // optional int32 httpStatusCode = 5;
  bool has_httpstatuscode() const;
  void clear_httpstatuscode();
  static const int kHttpStatusCodeFieldNumber = 5;
  ::google::protobuf::int32 httpstatuscode() const;
  void set_httpstatuscode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.FetchBanResult)
 private:
  void set_has_sourceurl();
  void clear_has_sourceurl();
  void set_has_fetchstatus();
  void clear_has_fetchstatus();
  void set_has_crawlstatus();
  void clear_has_crawlstatus();
  void set_has_httpstatuscode();
  void clear_has_httpstatuscode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> redirects_;
  ::google::protobuf::internal::ArenaStringPtr sourceurl_;
  ::google::protobuf::internal::ArenaStringPtr fetchstatus_;
  ::ru::mail::go::webbase::blobs::CrawlDetails* crawlstatus_;
  ::google::protobuf::int32 httpstatuscode_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PublicationMarkupRecord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.PublicationMarkupRecord) */ {
 public:
  PublicationMarkupRecord();
  virtual ~PublicationMarkupRecord();

  PublicationMarkupRecord(const PublicationMarkupRecord& from);

  inline PublicationMarkupRecord& operator=(const PublicationMarkupRecord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PublicationMarkupRecord(PublicationMarkupRecord&& from) noexcept
    : PublicationMarkupRecord() {
    *this = ::std::move(from);
  }

  inline PublicationMarkupRecord& operator=(PublicationMarkupRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicationMarkupRecord& default_instance();

  static inline const PublicationMarkupRecord* internal_default_instance() {
    return reinterpret_cast<const PublicationMarkupRecord*>(
               &_PublicationMarkupRecord_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(PublicationMarkupRecord* other);
  friend void swap(PublicationMarkupRecord& a, PublicationMarkupRecord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PublicationMarkupRecord* New() const PROTOBUF_FINAL { return New(NULL); }

  PublicationMarkupRecord* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PublicationMarkupRecord& from);
  void MergeFrom(const PublicationMarkupRecord& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PublicationMarkupRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PublicationMarkupRecord_Source Source;
  static const Source ya_ovs_upload_date =
    PublicationMarkupRecord_Source_ya_ovs_upload_date;
  static const Source meta_date_published =
    PublicationMarkupRecord_Source_meta_date_published;
  static const Source meta_upload_date =
    PublicationMarkupRecord_Source_meta_upload_date;
  static const Source span_date_published =
    PublicationMarkupRecord_Source_span_date_published;
  static const Source span_upload_date =
    PublicationMarkupRecord_Source_span_upload_date;
  static const Source script_date_published =
    PublicationMarkupRecord_Source_script_date_published;
  static const Source article_published_time =
    PublicationMarkupRecord_Source_article_published_time;
  static const Source time_date_published =
    PublicationMarkupRecord_Source_time_date_published;
  static const Source div_date_published =
    PublicationMarkupRecord_Source_div_date_published;
  static inline bool Source_IsValid(int value) {
    return PublicationMarkupRecord_Source_IsValid(value);
  }
  static const Source Source_MIN =
    PublicationMarkupRecord_Source_Source_MIN;
  static const Source Source_MAX =
    PublicationMarkupRecord_Source_Source_MAX;
  static const int Source_ARRAYSIZE =
    PublicationMarkupRecord_Source_Source_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Source_descriptor() {
    return PublicationMarkupRecord_Source_descriptor();
  }
  static inline const ::std::string& Source_Name(Source value) {
    return PublicationMarkupRecord_Source_Name(value);
  }
  static inline bool Source_Parse(const ::std::string& name,
      Source* value) {
    return PublicationMarkupRecord_Source_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional string content_type = 4;
  bool has_content_type() const;
  void clear_content_type();
  static const int kContentTypeFieldNumber = 4;
  const ::std::string& content_type() const;
  void set_content_type(const ::std::string& value);
  #if LANG_CXX11
  void set_content_type(::std::string&& value);
  #endif
  void set_content_type(const char* value);
  void set_content_type(const char* value, size_t size);
  ::std::string* mutable_content_type();
  ::std::string* release_content_type();
  void set_allocated_content_type(::std::string* content_type);

  // required int64 parsed_date = 3;
  bool has_parsed_date() const;
  void clear_parsed_date();
  static const int kParsedDateFieldNumber = 3;
  ::google::protobuf::int64 parsed_date() const;
  void set_parsed_date(::google::protobuf::int64 value);

  // required .ru.mail.go.webbase.blobs.PublicationMarkupRecord.Source source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::PublicationMarkupRecord_Source source() const;
  void set_source(::ru::mail::go::webbase::blobs::PublicationMarkupRecord_Source value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.PublicationMarkupRecord)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_value();
  void clear_has_value();
  void set_has_parsed_date();
  void clear_has_parsed_date();
  void set_has_content_type();
  void clear_has_content_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr content_type_;
  ::google::protobuf::int64 parsed_date_;
  int source_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PublicationMarkup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.PublicationMarkup) */ {
 public:
  PublicationMarkup();
  virtual ~PublicationMarkup();

  PublicationMarkup(const PublicationMarkup& from);

  inline PublicationMarkup& operator=(const PublicationMarkup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PublicationMarkup(PublicationMarkup&& from) noexcept
    : PublicationMarkup() {
    *this = ::std::move(from);
  }

  inline PublicationMarkup& operator=(PublicationMarkup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicationMarkup& default_instance();

  static inline const PublicationMarkup* internal_default_instance() {
    return reinterpret_cast<const PublicationMarkup*>(
               &_PublicationMarkup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(PublicationMarkup* other);
  friend void swap(PublicationMarkup& a, PublicationMarkup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PublicationMarkup* New() const PROTOBUF_FINAL { return New(NULL); }

  PublicationMarkup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PublicationMarkup& from);
  void MergeFrom(const PublicationMarkup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PublicationMarkup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.PublicationMarkupRecord records = 1;
  int records_size() const;
  void clear_records();
  static const int kRecordsFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::PublicationMarkupRecord& records(int index) const;
  ::ru::mail::go::webbase::blobs::PublicationMarkupRecord* mutable_records(int index);
  ::ru::mail::go::webbase::blobs::PublicationMarkupRecord* add_records();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::PublicationMarkupRecord >*
      mutable_records();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::PublicationMarkupRecord >&
      records() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.PublicationMarkup)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::PublicationMarkupRecord > records_;
  friend struct protobuf_fetch_5flist_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SplitFlags

// optional bool SplitA = 1 [default = false];
inline bool SplitFlags::has_splita() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SplitFlags::set_has_splita() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SplitFlags::clear_has_splita() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SplitFlags::clear_splita() {
  splita_ = false;
  clear_has_splita();
}
inline bool SplitFlags::splita() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SplitFlags.SplitA)
  return splita_;
}
inline void SplitFlags::set_splita(bool value) {
  set_has_splita();
  splita_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.SplitFlags.SplitA)
}

// optional bool SplitB = 2 [default = false];
inline bool SplitFlags::has_splitb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SplitFlags::set_has_splitb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SplitFlags::clear_has_splitb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SplitFlags::clear_splitb() {
  splitb_ = false;
  clear_has_splitb();
}
inline bool SplitFlags::splitb() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SplitFlags.SplitB)
  return splitb_;
}
inline void SplitFlags::set_splitb(bool value) {
  set_has_splitb();
  splitb_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.SplitFlags.SplitB)
}

// optional bool SplitC = 3 [default = false];
inline bool SplitFlags::has_splitc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SplitFlags::set_has_splitc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SplitFlags::clear_has_splitc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SplitFlags::clear_splitc() {
  splitc_ = false;
  clear_has_splitc();
}
inline bool SplitFlags::splitc() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.SplitFlags.SplitC)
  return splitc_;
}
inline void SplitFlags::set_splitc(bool value) {
  set_has_splitc();
  splitc_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.SplitFlags.SplitC)
}

// -------------------------------------------------------------------

// FetchUrl

// required string url = 1;
inline bool FetchUrl::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchUrl::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchUrl::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchUrl::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& FetchUrl::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.url)
  return url_.GetNoArena();
}
inline void FetchUrl::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.url)
}
#if LANG_CXX11
inline void FetchUrl::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.FetchUrl.url)
}
#endif
inline void FetchUrl::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FetchUrl.url)
}
inline void FetchUrl::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FetchUrl.url)
}
inline ::std::string* FetchUrl::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchUrl.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FetchUrl::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FetchUrl.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FetchUrl::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FetchUrl.url)
}

// optional int32 flag = 2;
inline bool FetchUrl::has_flag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FetchUrl::set_has_flag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FetchUrl::clear_has_flag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FetchUrl::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 FetchUrl::flag() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.flag)
  return flag_;
}
inline void FetchUrl::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.flag)
}

// optional int64 lastModified = 3;
inline bool FetchUrl::has_lastmodified() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FetchUrl::set_has_lastmodified() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FetchUrl::clear_has_lastmodified() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FetchUrl::clear_lastmodified() {
  lastmodified_ = GOOGLE_LONGLONG(0);
  clear_has_lastmodified();
}
inline ::google::protobuf::int64 FetchUrl::lastmodified() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.lastModified)
  return lastmodified_;
}
inline void FetchUrl::set_lastmodified(::google::protobuf::int64 value) {
  set_has_lastmodified();
  lastmodified_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.lastModified)
}

// optional string eTag = 4;
inline bool FetchUrl::has_etag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchUrl::set_has_etag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchUrl::clear_has_etag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchUrl::clear_etag() {
  etag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_etag();
}
inline const ::std::string& FetchUrl::etag() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.eTag)
  return etag_.GetNoArena();
}
inline void FetchUrl::set_etag(const ::std::string& value) {
  set_has_etag();
  etag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.eTag)
}
#if LANG_CXX11
inline void FetchUrl::set_etag(::std::string&& value) {
  set_has_etag();
  etag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.FetchUrl.eTag)
}
#endif
inline void FetchUrl::set_etag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_etag();
  etag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FetchUrl.eTag)
}
inline void FetchUrl::set_etag(const char* value, size_t size) {
  set_has_etag();
  etag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FetchUrl.eTag)
}
inline ::std::string* FetchUrl::mutable_etag() {
  set_has_etag();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchUrl.eTag)
  return etag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FetchUrl::release_etag() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FetchUrl.eTag)
  clear_has_etag();
  return etag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FetchUrl::set_allocated_etag(::std::string* etag) {
  if (etag != NULL) {
    set_has_etag();
  } else {
    clear_has_etag();
  }
  etag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), etag);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FetchUrl.eTag)
}

// repeated .ru.mail.go.webbase.blobs.FetchUrl.Fastbases targetBases = 5;
inline int FetchUrl::targetbases_size() const {
  return targetbases_.size();
}
inline void FetchUrl::clear_targetbases() {
  targetbases_.Clear();
}
inline ::ru::mail::go::webbase::blobs::FetchUrl_Fastbases FetchUrl::targetbases(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.targetBases)
  return static_cast< ::ru::mail::go::webbase::blobs::FetchUrl_Fastbases >(targetbases_.Get(index));
}
inline void FetchUrl::set_targetbases(int index, ::ru::mail::go::webbase::blobs::FetchUrl_Fastbases value) {
  assert(::ru::mail::go::webbase::blobs::FetchUrl_Fastbases_IsValid(value));
  targetbases_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.targetBases)
}
inline void FetchUrl::add_targetbases(::ru::mail::go::webbase::blobs::FetchUrl_Fastbases value) {
  assert(::ru::mail::go::webbase::blobs::FetchUrl_Fastbases_IsValid(value));
  targetbases_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.FetchUrl.targetBases)
}
inline const ::google::protobuf::RepeatedField<int>&
FetchUrl::targetbases() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.FetchUrl.targetBases)
  return targetbases_;
}
inline ::google::protobuf::RepeatedField<int>*
FetchUrl::mutable_targetbases() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.FetchUrl.targetBases)
  return &targetbases_;
}

// optional int32 attemptsToFetch = 6;
inline bool FetchUrl::has_attemptstofetch() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FetchUrl::set_has_attemptstofetch() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FetchUrl::clear_has_attemptstofetch() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FetchUrl::clear_attemptstofetch() {
  attemptstofetch_ = 0;
  clear_has_attemptstofetch();
}
inline ::google::protobuf::int32 FetchUrl::attemptstofetch() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.attemptsToFetch)
  return attemptstofetch_;
}
inline void FetchUrl::set_attemptstofetch(::google::protobuf::int32 value) {
  set_has_attemptstofetch();
  attemptstofetch_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.attemptsToFetch)
}

// optional int64 meetDate = 7;
inline bool FetchUrl::has_meetdate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FetchUrl::set_has_meetdate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FetchUrl::clear_has_meetdate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FetchUrl::clear_meetdate() {
  meetdate_ = GOOGLE_LONGLONG(0);
  clear_has_meetdate();
}
inline ::google::protobuf::int64 FetchUrl::meetdate() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.meetDate)
  return meetdate_;
}
inline void FetchUrl::set_meetdate(::google::protobuf::int64 value) {
  set_has_meetdate();
  meetdate_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.meetDate)
}

// optional int64 minDateToFetch = 8;
inline bool FetchUrl::has_mindatetofetch() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FetchUrl::set_has_mindatetofetch() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FetchUrl::clear_has_mindatetofetch() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FetchUrl::clear_mindatetofetch() {
  mindatetofetch_ = GOOGLE_LONGLONG(0);
  clear_has_mindatetofetch();
}
inline ::google::protobuf::int64 FetchUrl::mindatetofetch() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.minDateToFetch)
  return mindatetofetch_;
}
inline void FetchUrl::set_mindatetofetch(::google::protobuf::int64 value) {
  set_has_mindatetofetch();
  mindatetofetch_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.minDateToFetch)
}

// optional int32 minutesToRedownload = 9;
inline bool FetchUrl::has_minutestoredownload() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FetchUrl::set_has_minutestoredownload() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FetchUrl::clear_has_minutestoredownload() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FetchUrl::clear_minutestoredownload() {
  minutestoredownload_ = 0;
  clear_has_minutestoredownload();
}
inline ::google::protobuf::int32 FetchUrl::minutestoredownload() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.minutesToRedownload)
  return minutestoredownload_;
}
inline void FetchUrl::set_minutestoredownload(::google::protobuf::int32 value) {
  set_has_minutestoredownload();
  minutestoredownload_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.minutesToRedownload)
}

// repeated string redirects = 10;
inline int FetchUrl::redirects_size() const {
  return redirects_.size();
}
inline void FetchUrl::clear_redirects() {
  redirects_.Clear();
}
inline const ::std::string& FetchUrl::redirects(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.redirects)
  return redirects_.Get(index);
}
inline ::std::string* FetchUrl::mutable_redirects(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchUrl.redirects)
  return redirects_.Mutable(index);
}
inline void FetchUrl::set_redirects(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.redirects)
  redirects_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FetchUrl::set_redirects(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.redirects)
  redirects_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FetchUrl::set_redirects(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  redirects_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FetchUrl.redirects)
}
inline void FetchUrl::set_redirects(int index, const char* value, size_t size) {
  redirects_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FetchUrl.redirects)
}
inline ::std::string* FetchUrl::add_redirects() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.FetchUrl.redirects)
  return redirects_.Add();
}
inline void FetchUrl::add_redirects(const ::std::string& value) {
  redirects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.FetchUrl.redirects)
}
#if LANG_CXX11
inline void FetchUrl::add_redirects(::std::string&& value) {
  redirects_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.FetchUrl.redirects)
}
#endif
inline void FetchUrl::add_redirects(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  redirects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.FetchUrl.redirects)
}
inline void FetchUrl::add_redirects(const char* value, size_t size) {
  redirects_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.FetchUrl.redirects)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FetchUrl::redirects() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.FetchUrl.redirects)
  return redirects_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FetchUrl::mutable_redirects() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.FetchUrl.redirects)
  return &redirects_;
}

// optional int64 publicationDate = 11;
inline bool FetchUrl::has_publicationdate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FetchUrl::set_has_publicationdate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FetchUrl::clear_has_publicationdate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FetchUrl::clear_publicationdate() {
  publicationdate_ = GOOGLE_LONGLONG(0);
  clear_has_publicationdate();
}
inline ::google::protobuf::int64 FetchUrl::publicationdate() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.publicationDate)
  return publicationdate_;
}
inline void FetchUrl::set_publicationdate(::google::protobuf::int64 value) {
  set_has_publicationdate();
  publicationdate_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.publicationDate)
}

// optional .ru.mail.go.webbase.blobs.FetcherType fetcherType = 12;
inline bool FetchUrl::has_fetchertype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FetchUrl::set_has_fetchertype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FetchUrl::clear_has_fetchertype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FetchUrl::clear_fetchertype() {
  fetchertype_ = 0;
  clear_has_fetchertype();
}
inline ::ru::mail::go::webbase::blobs::FetcherType FetchUrl::fetchertype() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.fetcherType)
  return static_cast< ::ru::mail::go::webbase::blobs::FetcherType >(fetchertype_);
}
inline void FetchUrl::set_fetchertype(::ru::mail::go::webbase::blobs::FetcherType value) {
  assert(::ru::mail::go::webbase::blobs::FetcherType_IsValid(value));
  set_has_fetchertype();
  fetchertype_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.fetcherType)
}

// optional .ru.mail.go.webbase.blobs.SplitFlags splitFlags = 13;
inline bool FetchUrl::has_splitflags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FetchUrl::set_has_splitflags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FetchUrl::clear_has_splitflags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FetchUrl::clear_splitflags() {
  if (splitflags_ != NULL) splitflags_->::ru::mail::go::webbase::blobs::SplitFlags::Clear();
  clear_has_splitflags();
}
inline const ::ru::mail::go::webbase::blobs::SplitFlags& FetchUrl::splitflags() const {
  const ::ru::mail::go::webbase::blobs::SplitFlags* p = splitflags_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.splitFlags)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::SplitFlags*>(
      &::ru::mail::go::webbase::blobs::_SplitFlags_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::SplitFlags* FetchUrl::mutable_splitflags() {
  set_has_splitflags();
  if (splitflags_ == NULL) {
    splitflags_ = new ::ru::mail::go::webbase::blobs::SplitFlags;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchUrl.splitFlags)
  return splitflags_;
}
inline ::ru::mail::go::webbase::blobs::SplitFlags* FetchUrl::release_splitflags() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FetchUrl.splitFlags)
  clear_has_splitflags();
  ::ru::mail::go::webbase::blobs::SplitFlags* temp = splitflags_;
  splitflags_ = NULL;
  return temp;
}
inline void FetchUrl::set_allocated_splitflags(::ru::mail::go::webbase::blobs::SplitFlags* splitflags) {
  delete splitflags_;
  splitflags_ = splitflags;
  if (splitflags) {
    set_has_splitflags();
  } else {
    clear_has_splitflags();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FetchUrl.splitFlags)
}

// optional string originalUrl = 14;
inline bool FetchUrl::has_originalurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchUrl::set_has_originalurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchUrl::clear_has_originalurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchUrl::clear_originalurl() {
  originalurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_originalurl();
}
inline const ::std::string& FetchUrl::originalurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.originalUrl)
  return originalurl_.GetNoArena();
}
inline void FetchUrl::set_originalurl(const ::std::string& value) {
  set_has_originalurl();
  originalurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.originalUrl)
}
#if LANG_CXX11
inline void FetchUrl::set_originalurl(::std::string&& value) {
  set_has_originalurl();
  originalurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.FetchUrl.originalUrl)
}
#endif
inline void FetchUrl::set_originalurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_originalurl();
  originalurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FetchUrl.originalUrl)
}
inline void FetchUrl::set_originalurl(const char* value, size_t size) {
  set_has_originalurl();
  originalurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FetchUrl.originalUrl)
}
inline ::std::string* FetchUrl::mutable_originalurl() {
  set_has_originalurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchUrl.originalUrl)
  return originalurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FetchUrl::release_originalurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FetchUrl.originalUrl)
  clear_has_originalurl();
  return originalurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FetchUrl::set_allocated_originalurl(::std::string* originalurl) {
  if (originalurl != NULL) {
    set_has_originalurl();
  } else {
    clear_has_originalurl();
  }
  originalurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), originalurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FetchUrl.originalUrl)
}

// optional .ru.mail.go.webbase.blobs.ForumType forumType = 15;
inline bool FetchUrl::has_forumtype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void FetchUrl::set_has_forumtype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void FetchUrl::clear_has_forumtype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void FetchUrl::clear_forumtype() {
  forumtype_ = 0;
  clear_has_forumtype();
}
inline ::ru::mail::go::webbase::blobs::ForumType FetchUrl::forumtype() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.forumType)
  return static_cast< ::ru::mail::go::webbase::blobs::ForumType >(forumtype_);
}
inline void FetchUrl::set_forumtype(::ru::mail::go::webbase::blobs::ForumType value) {
  assert(::ru::mail::go::webbase::blobs::ForumType_IsValid(value));
  set_has_forumtype();
  forumtype_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.forumType)
}

// optional int32 mainPriority = 16;
inline bool FetchUrl::has_mainpriority() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void FetchUrl::set_has_mainpriority() {
  _has_bits_[0] |= 0x00008000u;
}
inline void FetchUrl::clear_has_mainpriority() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void FetchUrl::clear_mainpriority() {
  mainpriority_ = 0;
  clear_has_mainpriority();
}
inline ::google::protobuf::int32 FetchUrl::mainpriority() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.mainPriority)
  return mainpriority_;
}
inline void FetchUrl::set_mainpriority(::google::protobuf::int32 value) {
  set_has_mainpriority();
  mainpriority_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.mainPriority)
}

// optional bool isNew = 17;
inline bool FetchUrl::has_isnew() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void FetchUrl::set_has_isnew() {
  _has_bits_[0] |= 0x00020000u;
}
inline void FetchUrl::clear_has_isnew() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void FetchUrl::clear_isnew() {
  isnew_ = false;
  clear_has_isnew();
}
inline bool FetchUrl::isnew() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.isNew)
  return isnew_;
}
inline void FetchUrl::set_isnew(bool value) {
  set_has_isnew();
  isnew_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.isNew)
}

// repeated .ru.mail.go.webbase.blobs.BaseSplitInfo baseSplitInfo = 18;
inline int FetchUrl::basesplitinfo_size() const {
  return basesplitinfo_.size();
}
inline void FetchUrl::clear_basesplitinfo() {
  basesplitinfo_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::BaseSplitInfo& FetchUrl::basesplitinfo(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.baseSplitInfo)
  return basesplitinfo_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::BaseSplitInfo* FetchUrl::mutable_basesplitinfo(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchUrl.baseSplitInfo)
  return basesplitinfo_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::BaseSplitInfo* FetchUrl::add_basesplitinfo() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.FetchUrl.baseSplitInfo)
  return basesplitinfo_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::BaseSplitInfo >*
FetchUrl::mutable_basesplitinfo() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.FetchUrl.baseSplitInfo)
  return &basesplitinfo_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::BaseSplitInfo >&
FetchUrl::basesplitinfo() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.FetchUrl.baseSplitInfo)
  return basesplitinfo_;
}

// optional string referer = 19;
inline bool FetchUrl::has_referer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FetchUrl::set_has_referer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FetchUrl::clear_has_referer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FetchUrl::clear_referer() {
  referer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_referer();
}
inline const ::std::string& FetchUrl::referer() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.referer)
  return referer_.GetNoArena();
}
inline void FetchUrl::set_referer(const ::std::string& value) {
  set_has_referer();
  referer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.referer)
}
#if LANG_CXX11
inline void FetchUrl::set_referer(::std::string&& value) {
  set_has_referer();
  referer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.FetchUrl.referer)
}
#endif
inline void FetchUrl::set_referer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_referer();
  referer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FetchUrl.referer)
}
inline void FetchUrl::set_referer(const char* value, size_t size) {
  set_has_referer();
  referer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FetchUrl.referer)
}
inline ::std::string* FetchUrl::mutable_referer() {
  set_has_referer();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchUrl.referer)
  return referer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FetchUrl::release_referer() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FetchUrl.referer)
  clear_has_referer();
  return referer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FetchUrl::set_allocated_referer(::std::string* referer) {
  if (referer != NULL) {
    set_has_referer();
  } else {
    clear_has_referer();
  }
  referer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), referer);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FetchUrl.referer)
}

// optional string schedulerName = 20;
inline bool FetchUrl::has_schedulername() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FetchUrl::set_has_schedulername() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FetchUrl::clear_has_schedulername() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FetchUrl::clear_schedulername() {
  schedulername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_schedulername();
}
inline const ::std::string& FetchUrl::schedulername() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.schedulerName)
  return schedulername_.GetNoArena();
}
inline void FetchUrl::set_schedulername(const ::std::string& value) {
  set_has_schedulername();
  schedulername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.schedulerName)
}
#if LANG_CXX11
inline void FetchUrl::set_schedulername(::std::string&& value) {
  set_has_schedulername();
  schedulername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.FetchUrl.schedulerName)
}
#endif
inline void FetchUrl::set_schedulername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_schedulername();
  schedulername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FetchUrl.schedulerName)
}
inline void FetchUrl::set_schedulername(const char* value, size_t size) {
  set_has_schedulername();
  schedulername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FetchUrl.schedulerName)
}
inline ::std::string* FetchUrl::mutable_schedulername() {
  set_has_schedulername();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchUrl.schedulerName)
  return schedulername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FetchUrl::release_schedulername() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FetchUrl.schedulerName)
  clear_has_schedulername();
  return schedulername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FetchUrl::set_allocated_schedulername(::std::string* schedulername) {
  if (schedulername != NULL) {
    set_has_schedulername();
  } else {
    clear_has_schedulername();
  }
  schedulername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schedulername);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FetchUrl.schedulerName)
}

// optional int32 schedulerPriority = 21;
inline bool FetchUrl::has_schedulerpriority() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void FetchUrl::set_has_schedulerpriority() {
  _has_bits_[0] |= 0x00010000u;
}
inline void FetchUrl::clear_has_schedulerpriority() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void FetchUrl::clear_schedulerpriority() {
  schedulerpriority_ = 0;
  clear_has_schedulerpriority();
}
inline ::google::protobuf::int32 FetchUrl::schedulerpriority() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.schedulerPriority)
  return schedulerpriority_;
}
inline void FetchUrl::set_schedulerpriority(::google::protobuf::int32 value) {
  set_has_schedulerpriority();
  schedulerpriority_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.schedulerPriority)
}

// optional int64 schedulerTimestamp = 22;
inline bool FetchUrl::has_schedulertimestamp() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void FetchUrl::set_has_schedulertimestamp() {
  _has_bits_[0] |= 0x00080000u;
}
inline void FetchUrl::clear_has_schedulertimestamp() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void FetchUrl::clear_schedulertimestamp() {
  schedulertimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_schedulertimestamp();
}
inline ::google::protobuf::int64 FetchUrl::schedulertimestamp() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.schedulerTimestamp)
  return schedulertimestamp_;
}
inline void FetchUrl::set_schedulertimestamp(::google::protobuf::int64 value) {
  set_has_schedulertimestamp();
  schedulertimestamp_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.schedulerTimestamp)
}

// optional int64 batchTimestamp = 23;
inline bool FetchUrl::has_batchtimestamp() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void FetchUrl::set_has_batchtimestamp() {
  _has_bits_[0] |= 0x00100000u;
}
inline void FetchUrl::clear_has_batchtimestamp() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void FetchUrl::clear_batchtimestamp() {
  batchtimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_batchtimestamp();
}
inline ::google::protobuf::int64 FetchUrl::batchtimestamp() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.batchTimestamp)
  return batchtimestamp_;
}
inline void FetchUrl::set_batchtimestamp(::google::protobuf::int64 value) {
  set_has_batchtimestamp();
  batchtimestamp_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.batchTimestamp)
}

// optional int64 schedulerJobEndTimestamp = 24;
inline bool FetchUrl::has_schedulerjobendtimestamp() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void FetchUrl::set_has_schedulerjobendtimestamp() {
  _has_bits_[0] |= 0x00200000u;
}
inline void FetchUrl::clear_has_schedulerjobendtimestamp() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void FetchUrl::clear_schedulerjobendtimestamp() {
  schedulerjobendtimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_schedulerjobendtimestamp();
}
inline ::google::protobuf::int64 FetchUrl::schedulerjobendtimestamp() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.schedulerJobEndTimestamp)
  return schedulerjobendtimestamp_;
}
inline void FetchUrl::set_schedulerjobendtimestamp(::google::protobuf::int64 value) {
  set_has_schedulerjobendtimestamp();
  schedulerjobendtimestamp_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.schedulerJobEndTimestamp)
}

// optional bool isPostscheduled = 25;
inline bool FetchUrl::has_ispostscheduled() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void FetchUrl::set_has_ispostscheduled() {
  _has_bits_[0] |= 0x00040000u;
}
inline void FetchUrl::clear_has_ispostscheduled() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void FetchUrl::clear_ispostscheduled() {
  ispostscheduled_ = false;
  clear_has_ispostscheduled();
}
inline bool FetchUrl::ispostscheduled() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.isPostscheduled)
  return ispostscheduled_;
}
inline void FetchUrl::set_ispostscheduled(bool value) {
  set_has_ispostscheduled();
  ispostscheduled_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.isPostscheduled)
}

// optional int64 batchGeneratorTimestamp = 26;
inline bool FetchUrl::has_batchgeneratortimestamp() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void FetchUrl::set_has_batchgeneratortimestamp() {
  _has_bits_[0] |= 0x00400000u;
}
inline void FetchUrl::clear_has_batchgeneratortimestamp() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void FetchUrl::clear_batchgeneratortimestamp() {
  batchgeneratortimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_batchgeneratortimestamp();
}
inline ::google::protobuf::int64 FetchUrl::batchgeneratortimestamp() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.batchGeneratorTimestamp)
  return batchgeneratortimestamp_;
}
inline void FetchUrl::set_batchgeneratortimestamp(::google::protobuf::int64 value) {
  set_has_batchgeneratortimestamp();
  batchgeneratortimestamp_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.batchGeneratorTimestamp)
}

// optional int64 parserTimestamp = 27;
inline bool FetchUrl::has_parsertimestamp() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void FetchUrl::set_has_parsertimestamp() {
  _has_bits_[0] |= 0x00800000u;
}
inline void FetchUrl::clear_has_parsertimestamp() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void FetchUrl::clear_parsertimestamp() {
  parsertimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_parsertimestamp();
}
inline ::google::protobuf::int64 FetchUrl::parsertimestamp() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.parserTimestamp)
  return parsertimestamp_;
}
inline void FetchUrl::set_parsertimestamp(::google::protobuf::int64 value) {
  set_has_parsertimestamp();
  parsertimestamp_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.parserTimestamp)
}

// optional int64 discoveryBatchingTimestamp = 28;
inline bool FetchUrl::has_discoverybatchingtimestamp() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void FetchUrl::set_has_discoverybatchingtimestamp() {
  _has_bits_[0] |= 0x01000000u;
}
inline void FetchUrl::clear_has_discoverybatchingtimestamp() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void FetchUrl::clear_discoverybatchingtimestamp() {
  discoverybatchingtimestamp_ = GOOGLE_LONGLONG(0);
  clear_has_discoverybatchingtimestamp();
}
inline ::google::protobuf::int64 FetchUrl::discoverybatchingtimestamp() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchUrl.discoveryBatchingTimestamp)
  return discoverybatchingtimestamp_;
}
inline void FetchUrl::set_discoverybatchingtimestamp(::google::protobuf::int64 value) {
  set_has_discoverybatchingtimestamp();
  discoverybatchingtimestamp_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchUrl.discoveryBatchingTimestamp)
}

// -------------------------------------------------------------------

// BaseSplitInfo

// required .ru.mail.go.webbase.blobs.FetchUrl.Fastbases base = 1;
inline bool BaseSplitInfo::has_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseSplitInfo::set_has_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseSplitInfo::clear_has_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseSplitInfo::clear_base() {
  base_ = 0;
  clear_has_base();
}
inline ::ru::mail::go::webbase::blobs::FetchUrl_Fastbases BaseSplitInfo::base() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BaseSplitInfo.base)
  return static_cast< ::ru::mail::go::webbase::blobs::FetchUrl_Fastbases >(base_);
}
inline void BaseSplitInfo::set_base(::ru::mail::go::webbase::blobs::FetchUrl_Fastbases value) {
  assert(::ru::mail::go::webbase::blobs::FetchUrl_Fastbases_IsValid(value));
  set_has_base();
  base_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BaseSplitInfo.base)
}

// optional .ru.mail.go.webbase.blobs.SplitFlags splitFlags = 2;
inline bool BaseSplitInfo::has_splitflags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseSplitInfo::set_has_splitflags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseSplitInfo::clear_has_splitflags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseSplitInfo::clear_splitflags() {
  if (splitflags_ != NULL) splitflags_->::ru::mail::go::webbase::blobs::SplitFlags::Clear();
  clear_has_splitflags();
}
inline const ::ru::mail::go::webbase::blobs::SplitFlags& BaseSplitInfo::splitflags() const {
  const ::ru::mail::go::webbase::blobs::SplitFlags* p = splitflags_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BaseSplitInfo.splitFlags)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::SplitFlags*>(
      &::ru::mail::go::webbase::blobs::_SplitFlags_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::SplitFlags* BaseSplitInfo::mutable_splitflags() {
  set_has_splitflags();
  if (splitflags_ == NULL) {
    splitflags_ = new ::ru::mail::go::webbase::blobs::SplitFlags;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.BaseSplitInfo.splitFlags)
  return splitflags_;
}
inline ::ru::mail::go::webbase::blobs::SplitFlags* BaseSplitInfo::release_splitflags() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.BaseSplitInfo.splitFlags)
  clear_has_splitflags();
  ::ru::mail::go::webbase::blobs::SplitFlags* temp = splitflags_;
  splitflags_ = NULL;
  return temp;
}
inline void BaseSplitInfo::set_allocated_splitflags(::ru::mail::go::webbase::blobs::SplitFlags* splitflags) {
  delete splitflags_;
  splitflags_ = splitflags;
  if (splitflags) {
    set_has_splitflags();
  } else {
    clear_has_splitflags();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.BaseSplitInfo.splitFlags)
}

// -------------------------------------------------------------------

// YouTubeWebSearch

// optional string originalUrl = 1;
inline bool YouTubeWebSearch::has_originalurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YouTubeWebSearch::set_has_originalurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YouTubeWebSearch::clear_has_originalurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YouTubeWebSearch::clear_originalurl() {
  originalurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_originalurl();
}
inline const ::std::string& YouTubeWebSearch::originalurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.YouTubeWebSearch.originalUrl)
  return originalurl_.GetNoArena();
}
inline void YouTubeWebSearch::set_originalurl(const ::std::string& value) {
  set_has_originalurl();
  originalurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.YouTubeWebSearch.originalUrl)
}
#if LANG_CXX11
inline void YouTubeWebSearch::set_originalurl(::std::string&& value) {
  set_has_originalurl();
  originalurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.YouTubeWebSearch.originalUrl)
}
#endif
inline void YouTubeWebSearch::set_originalurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_originalurl();
  originalurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.YouTubeWebSearch.originalUrl)
}
inline void YouTubeWebSearch::set_originalurl(const char* value, size_t size) {
  set_has_originalurl();
  originalurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.YouTubeWebSearch.originalUrl)
}
inline ::std::string* YouTubeWebSearch::mutable_originalurl() {
  set_has_originalurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.YouTubeWebSearch.originalUrl)
  return originalurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YouTubeWebSearch::release_originalurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.YouTubeWebSearch.originalUrl)
  clear_has_originalurl();
  return originalurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YouTubeWebSearch::set_allocated_originalurl(::std::string* originalurl) {
  if (originalurl != NULL) {
    set_has_originalurl();
  } else {
    clear_has_originalurl();
  }
  originalurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), originalurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.YouTubeWebSearch.originalUrl)
}

// -------------------------------------------------------------------

// YouTubeCommon

// repeated .ru.mail.go.webbase.blobs.YouTubeIdUrlMapping idUrlMapping = 1;
inline int YouTubeCommon::idurlmapping_size() const {
  return idurlmapping_.size();
}
inline void YouTubeCommon::clear_idurlmapping() {
  idurlmapping_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::YouTubeIdUrlMapping& YouTubeCommon::idurlmapping(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.YouTubeCommon.idUrlMapping)
  return idurlmapping_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::YouTubeIdUrlMapping* YouTubeCommon::mutable_idurlmapping(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.YouTubeCommon.idUrlMapping)
  return idurlmapping_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::YouTubeIdUrlMapping* YouTubeCommon::add_idurlmapping() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.YouTubeCommon.idUrlMapping)
  return idurlmapping_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::YouTubeIdUrlMapping >*
YouTubeCommon::mutable_idurlmapping() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.YouTubeCommon.idUrlMapping)
  return &idurlmapping_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::YouTubeIdUrlMapping >&
YouTubeCommon::idurlmapping() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.YouTubeCommon.idUrlMapping)
  return idurlmapping_;
}

// -------------------------------------------------------------------

// YouTubeIdUrlMapping

// required string id = 1;
inline bool YouTubeIdUrlMapping::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YouTubeIdUrlMapping::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YouTubeIdUrlMapping::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YouTubeIdUrlMapping::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& YouTubeIdUrlMapping::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.id)
  return id_.GetNoArena();
}
inline void YouTubeIdUrlMapping::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.id)
}
#if LANG_CXX11
inline void YouTubeIdUrlMapping::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.id)
}
#endif
inline void YouTubeIdUrlMapping::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.id)
}
inline void YouTubeIdUrlMapping::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.id)
}
inline ::std::string* YouTubeIdUrlMapping::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YouTubeIdUrlMapping::release_id() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YouTubeIdUrlMapping::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.id)
}

// required string url = 2;
inline bool YouTubeIdUrlMapping::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YouTubeIdUrlMapping::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YouTubeIdUrlMapping::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YouTubeIdUrlMapping::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& YouTubeIdUrlMapping::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.url)
  return url_.GetNoArena();
}
inline void YouTubeIdUrlMapping::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.url)
}
#if LANG_CXX11
inline void YouTubeIdUrlMapping::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.url)
}
#endif
inline void YouTubeIdUrlMapping::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.url)
}
inline void YouTubeIdUrlMapping::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.url)
}
inline ::std::string* YouTubeIdUrlMapping::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* YouTubeIdUrlMapping::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void YouTubeIdUrlMapping::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.YouTubeIdUrlMapping.url)
}

// -------------------------------------------------------------------

// OkApiMessage

// repeated .ru.mail.go.webbase.blobs.OkIdToUrlMapping idToUrlMapping = 1;
inline int OkApiMessage::idtourlmapping_size() const {
  return idtourlmapping_.size();
}
inline void OkApiMessage::clear_idtourlmapping() {
  idtourlmapping_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::OkIdToUrlMapping& OkApiMessage::idtourlmapping(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OkApiMessage.idToUrlMapping)
  return idtourlmapping_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::OkIdToUrlMapping* OkApiMessage::mutable_idtourlmapping(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.OkApiMessage.idToUrlMapping)
  return idtourlmapping_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::OkIdToUrlMapping* OkApiMessage::add_idtourlmapping() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.OkApiMessage.idToUrlMapping)
  return idtourlmapping_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::OkIdToUrlMapping >*
OkApiMessage::mutable_idtourlmapping() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.OkApiMessage.idToUrlMapping)
  return &idtourlmapping_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::OkIdToUrlMapping >&
OkApiMessage::idtourlmapping() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.OkApiMessage.idToUrlMapping)
  return idtourlmapping_;
}

// -------------------------------------------------------------------

// OkIdToUrlMapping

// required int64 id = 1;
inline bool OkIdToUrlMapping::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OkIdToUrlMapping::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OkIdToUrlMapping::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OkIdToUrlMapping::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 OkIdToUrlMapping::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OkIdToUrlMapping.id)
  return id_;
}
inline void OkIdToUrlMapping::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OkIdToUrlMapping.id)
}

// required string url = 2;
inline bool OkIdToUrlMapping::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OkIdToUrlMapping::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OkIdToUrlMapping::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OkIdToUrlMapping::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& OkIdToUrlMapping::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OkIdToUrlMapping.url)
  return url_.GetNoArena();
}
inline void OkIdToUrlMapping::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OkIdToUrlMapping.url)
}
#if LANG_CXX11
inline void OkIdToUrlMapping::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.OkIdToUrlMapping.url)
}
#endif
inline void OkIdToUrlMapping::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.OkIdToUrlMapping.url)
}
inline void OkIdToUrlMapping::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.OkIdToUrlMapping.url)
}
inline ::std::string* OkIdToUrlMapping::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.OkIdToUrlMapping.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OkIdToUrlMapping::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.OkIdToUrlMapping.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OkIdToUrlMapping::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.OkIdToUrlMapping.url)
}

// -------------------------------------------------------------------

// CrawlHistory

// required int64 firstCrawlTs = 1;
inline bool CrawlHistory::has_firstcrawlts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrawlHistory::set_has_firstcrawlts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrawlHistory::clear_has_firstcrawlts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrawlHistory::clear_firstcrawlts() {
  firstcrawlts_ = GOOGLE_LONGLONG(0);
  clear_has_firstcrawlts();
}
inline ::google::protobuf::int64 CrawlHistory::firstcrawlts() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CrawlHistory.firstCrawlTs)
  return firstcrawlts_;
}
inline void CrawlHistory::set_firstcrawlts(::google::protobuf::int64 value) {
  set_has_firstcrawlts();
  firstcrawlts_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CrawlHistory.firstCrawlTs)
}

// required int32 changesNumber = 2;
inline bool CrawlHistory::has_changesnumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CrawlHistory::set_has_changesnumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CrawlHistory::clear_has_changesnumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CrawlHistory::clear_changesnumber() {
  changesnumber_ = 0;
  clear_has_changesnumber();
}
inline ::google::protobuf::int32 CrawlHistory::changesnumber() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CrawlHistory.changesNumber)
  return changesnumber_;
}
inline void CrawlHistory::set_changesnumber(::google::protobuf::int32 value) {
  set_has_changesnumber();
  changesnumber_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CrawlHistory.changesNumber)
}

// required int64 lastChangeTs = 3;
inline bool CrawlHistory::has_lastchangets() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CrawlHistory::set_has_lastchangets() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CrawlHistory::clear_has_lastchangets() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CrawlHistory::clear_lastchangets() {
  lastchangets_ = GOOGLE_LONGLONG(0);
  clear_has_lastchangets();
}
inline ::google::protobuf::int64 CrawlHistory::lastchangets() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CrawlHistory.lastChangeTs)
  return lastchangets_;
}
inline void CrawlHistory::set_lastchangets(::google::protobuf::int64 value) {
  set_has_lastchangets();
  lastchangets_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CrawlHistory.lastChangeTs)
}

// -------------------------------------------------------------------

// FetchResult

// optional .ru.mail.go.webbase.blobs.CrawlDetails crawlStatus = 1;
inline bool FetchResult::has_crawlstatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchResult::set_has_crawlstatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchResult::clear_has_crawlstatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchResult::clear_crawlstatus() {
  if (crawlstatus_ != NULL) crawlstatus_->::ru::mail::go::webbase::blobs::CrawlDetails::Clear();
  clear_has_crawlstatus();
}
inline const ::ru::mail::go::webbase::blobs::CrawlDetails& FetchResult::crawlstatus() const {
  const ::ru::mail::go::webbase::blobs::CrawlDetails* p = crawlstatus_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchResult.crawlStatus)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::CrawlDetails*>(
      &::ru::mail::go::webbase::blobs::_CrawlDetails_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::CrawlDetails* FetchResult::mutable_crawlstatus() {
  set_has_crawlstatus();
  if (crawlstatus_ == NULL) {
    crawlstatus_ = new ::ru::mail::go::webbase::blobs::CrawlDetails;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchResult.crawlStatus)
  return crawlstatus_;
}
inline ::ru::mail::go::webbase::blobs::CrawlDetails* FetchResult::release_crawlstatus() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FetchResult.crawlStatus)
  clear_has_crawlstatus();
  ::ru::mail::go::webbase::blobs::CrawlDetails* temp = crawlstatus_;
  crawlstatus_ = NULL;
  return temp;
}
inline void FetchResult::set_allocated_crawlstatus(::ru::mail::go::webbase::blobs::CrawlDetails* crawlstatus) {
  delete crawlstatus_;
  crawlstatus_ = crawlstatus;
  if (crawlstatus) {
    set_has_crawlstatus();
  } else {
    clear_has_crawlstatus();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FetchResult.crawlStatus)
}

// optional int32 attemptsToFetch = 2;
inline bool FetchResult::has_attemptstofetch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchResult::set_has_attemptstofetch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchResult::clear_has_attemptstofetch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchResult::clear_attemptstofetch() {
  attemptstofetch_ = 0;
  clear_has_attemptstofetch();
}
inline ::google::protobuf::int32 FetchResult::attemptstofetch() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchResult.attemptsToFetch)
  return attemptstofetch_;
}
inline void FetchResult::set_attemptstofetch(::google::protobuf::int32 value) {
  set_has_attemptstofetch();
  attemptstofetch_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchResult.attemptsToFetch)
}

// optional int64 minDateToFetch = 3;
inline bool FetchResult::has_mindatetofetch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchResult::set_has_mindatetofetch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchResult::clear_has_mindatetofetch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchResult::clear_mindatetofetch() {
  mindatetofetch_ = GOOGLE_LONGLONG(0);
  clear_has_mindatetofetch();
}
inline ::google::protobuf::int64 FetchResult::mindatetofetch() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchResult.minDateToFetch)
  return mindatetofetch_;
}
inline void FetchResult::set_mindatetofetch(::google::protobuf::int64 value) {
  set_has_mindatetofetch();
  mindatetofetch_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchResult.minDateToFetch)
}

// repeated string redirects = 4;
inline int FetchResult::redirects_size() const {
  return redirects_.size();
}
inline void FetchResult::clear_redirects() {
  redirects_.Clear();
}
inline const ::std::string& FetchResult::redirects(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchResult.redirects)
  return redirects_.Get(index);
}
inline ::std::string* FetchResult::mutable_redirects(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchResult.redirects)
  return redirects_.Mutable(index);
}
inline void FetchResult::set_redirects(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchResult.redirects)
  redirects_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FetchResult::set_redirects(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchResult.redirects)
  redirects_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FetchResult::set_redirects(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  redirects_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FetchResult.redirects)
}
inline void FetchResult::set_redirects(int index, const char* value, size_t size) {
  redirects_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FetchResult.redirects)
}
inline ::std::string* FetchResult::add_redirects() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.FetchResult.redirects)
  return redirects_.Add();
}
inline void FetchResult::add_redirects(const ::std::string& value) {
  redirects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.FetchResult.redirects)
}
#if LANG_CXX11
inline void FetchResult::add_redirects(::std::string&& value) {
  redirects_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.FetchResult.redirects)
}
#endif
inline void FetchResult::add_redirects(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  redirects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.FetchResult.redirects)
}
inline void FetchResult::add_redirects(const char* value, size_t size) {
  redirects_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.FetchResult.redirects)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FetchResult::redirects() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.FetchResult.redirects)
  return redirects_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FetchResult::mutable_redirects() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.FetchResult.redirects)
  return &redirects_;
}

// optional .ru.mail.go.webbase.blobs.FetcherType fetcherType = 5;
inline bool FetchResult::has_fetchertype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FetchResult::set_has_fetchertype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FetchResult::clear_has_fetchertype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FetchResult::clear_fetchertype() {
  fetchertype_ = 0;
  clear_has_fetchertype();
}
inline ::ru::mail::go::webbase::blobs::FetcherType FetchResult::fetchertype() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchResult.fetcherType)
  return static_cast< ::ru::mail::go::webbase::blobs::FetcherType >(fetchertype_);
}
inline void FetchResult::set_fetchertype(::ru::mail::go::webbase::blobs::FetcherType value) {
  assert(::ru::mail::go::webbase::blobs::FetcherType_IsValid(value));
  set_has_fetchertype();
  fetchertype_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchResult.fetcherType)
}

// optional bool isRotten = 6 [default = false];
inline bool FetchResult::has_isrotten() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FetchResult::set_has_isrotten() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FetchResult::clear_has_isrotten() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FetchResult::clear_isrotten() {
  isrotten_ = false;
  clear_has_isrotten();
}
inline bool FetchResult::isrotten() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchResult.isRotten)
  return isrotten_;
}
inline void FetchResult::set_isrotten(bool value) {
  set_has_isrotten();
  isrotten_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchResult.isRotten)
}

// -------------------------------------------------------------------

// FetchBanResult

// required string sourceUrl = 1;
inline bool FetchBanResult::has_sourceurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchBanResult::set_has_sourceurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchBanResult::clear_has_sourceurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchBanResult::clear_sourceurl() {
  sourceurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sourceurl();
}
inline const ::std::string& FetchBanResult::sourceurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchBanResult.sourceUrl)
  return sourceurl_.GetNoArena();
}
inline void FetchBanResult::set_sourceurl(const ::std::string& value) {
  set_has_sourceurl();
  sourceurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchBanResult.sourceUrl)
}
#if LANG_CXX11
inline void FetchBanResult::set_sourceurl(::std::string&& value) {
  set_has_sourceurl();
  sourceurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.FetchBanResult.sourceUrl)
}
#endif
inline void FetchBanResult::set_sourceurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sourceurl();
  sourceurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FetchBanResult.sourceUrl)
}
inline void FetchBanResult::set_sourceurl(const char* value, size_t size) {
  set_has_sourceurl();
  sourceurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FetchBanResult.sourceUrl)
}
inline ::std::string* FetchBanResult::mutable_sourceurl() {
  set_has_sourceurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchBanResult.sourceUrl)
  return sourceurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FetchBanResult::release_sourceurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FetchBanResult.sourceUrl)
  clear_has_sourceurl();
  return sourceurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FetchBanResult::set_allocated_sourceurl(::std::string* sourceurl) {
  if (sourceurl != NULL) {
    set_has_sourceurl();
  } else {
    clear_has_sourceurl();
  }
  sourceurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sourceurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FetchBanResult.sourceUrl)
}

// optional bytes fetchStatus = 2;
inline bool FetchBanResult::has_fetchstatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchBanResult::set_has_fetchstatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchBanResult::clear_has_fetchstatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchBanResult::clear_fetchstatus() {
  fetchstatus_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fetchstatus();
}
inline const ::std::string& FetchBanResult::fetchstatus() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchBanResult.fetchStatus)
  return fetchstatus_.GetNoArena();
}
inline void FetchBanResult::set_fetchstatus(const ::std::string& value) {
  set_has_fetchstatus();
  fetchstatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchBanResult.fetchStatus)
}
#if LANG_CXX11
inline void FetchBanResult::set_fetchstatus(::std::string&& value) {
  set_has_fetchstatus();
  fetchstatus_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.FetchBanResult.fetchStatus)
}
#endif
inline void FetchBanResult::set_fetchstatus(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fetchstatus();
  fetchstatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FetchBanResult.fetchStatus)
}
inline void FetchBanResult::set_fetchstatus(const void* value, size_t size) {
  set_has_fetchstatus();
  fetchstatus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FetchBanResult.fetchStatus)
}
inline ::std::string* FetchBanResult::mutable_fetchstatus() {
  set_has_fetchstatus();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchBanResult.fetchStatus)
  return fetchstatus_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FetchBanResult::release_fetchstatus() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FetchBanResult.fetchStatus)
  clear_has_fetchstatus();
  return fetchstatus_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FetchBanResult::set_allocated_fetchstatus(::std::string* fetchstatus) {
  if (fetchstatus != NULL) {
    set_has_fetchstatus();
  } else {
    clear_has_fetchstatus();
  }
  fetchstatus_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fetchstatus);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FetchBanResult.fetchStatus)
}

// optional .ru.mail.go.webbase.blobs.CrawlDetails crawlStatus = 3;
inline bool FetchBanResult::has_crawlstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchBanResult::set_has_crawlstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchBanResult::clear_has_crawlstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchBanResult::clear_crawlstatus() {
  if (crawlstatus_ != NULL) crawlstatus_->::ru::mail::go::webbase::blobs::CrawlDetails::Clear();
  clear_has_crawlstatus();
}
inline const ::ru::mail::go::webbase::blobs::CrawlDetails& FetchBanResult::crawlstatus() const {
  const ::ru::mail::go::webbase::blobs::CrawlDetails* p = crawlstatus_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchBanResult.crawlStatus)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::CrawlDetails*>(
      &::ru::mail::go::webbase::blobs::_CrawlDetails_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::CrawlDetails* FetchBanResult::mutable_crawlstatus() {
  set_has_crawlstatus();
  if (crawlstatus_ == NULL) {
    crawlstatus_ = new ::ru::mail::go::webbase::blobs::CrawlDetails;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchBanResult.crawlStatus)
  return crawlstatus_;
}
inline ::ru::mail::go::webbase::blobs::CrawlDetails* FetchBanResult::release_crawlstatus() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FetchBanResult.crawlStatus)
  clear_has_crawlstatus();
  ::ru::mail::go::webbase::blobs::CrawlDetails* temp = crawlstatus_;
  crawlstatus_ = NULL;
  return temp;
}
inline void FetchBanResult::set_allocated_crawlstatus(::ru::mail::go::webbase::blobs::CrawlDetails* crawlstatus) {
  delete crawlstatus_;
  crawlstatus_ = crawlstatus;
  if (crawlstatus) {
    set_has_crawlstatus();
  } else {
    clear_has_crawlstatus();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FetchBanResult.crawlStatus)
}

// repeated string redirects = 4;
inline int FetchBanResult::redirects_size() const {
  return redirects_.size();
}
inline void FetchBanResult::clear_redirects() {
  redirects_.Clear();
}
inline const ::std::string& FetchBanResult::redirects(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
  return redirects_.Get(index);
}
inline ::std::string* FetchBanResult::mutable_redirects(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
  return redirects_.Mutable(index);
}
inline void FetchBanResult::set_redirects(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
  redirects_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FetchBanResult::set_redirects(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
  redirects_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FetchBanResult::set_redirects(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  redirects_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
}
inline void FetchBanResult::set_redirects(int index, const char* value, size_t size) {
  redirects_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
}
inline ::std::string* FetchBanResult::add_redirects() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
  return redirects_.Add();
}
inline void FetchBanResult::add_redirects(const ::std::string& value) {
  redirects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
}
#if LANG_CXX11
inline void FetchBanResult::add_redirects(::std::string&& value) {
  redirects_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
}
#endif
inline void FetchBanResult::add_redirects(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  redirects_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
}
inline void FetchBanResult::add_redirects(const char* value, size_t size) {
  redirects_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FetchBanResult::redirects() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
  return redirects_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FetchBanResult::mutable_redirects() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.FetchBanResult.redirects)
  return &redirects_;
}

// optional int32 httpStatusCode = 5;
inline bool FetchBanResult::has_httpstatuscode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FetchBanResult::set_has_httpstatuscode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FetchBanResult::clear_has_httpstatuscode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FetchBanResult::clear_httpstatuscode() {
  httpstatuscode_ = 0;
  clear_has_httpstatuscode();
}
inline ::google::protobuf::int32 FetchBanResult::httpstatuscode() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FetchBanResult.httpStatusCode)
  return httpstatuscode_;
}
inline void FetchBanResult::set_httpstatuscode(::google::protobuf::int32 value) {
  set_has_httpstatuscode();
  httpstatuscode_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FetchBanResult.httpStatusCode)
}

// -------------------------------------------------------------------

// PublicationMarkupRecord

// required .ru.mail.go.webbase.blobs.PublicationMarkupRecord.Source source = 1;
inline bool PublicationMarkupRecord::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PublicationMarkupRecord::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PublicationMarkupRecord::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PublicationMarkupRecord::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::ru::mail::go::webbase::blobs::PublicationMarkupRecord_Source PublicationMarkupRecord::source() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PublicationMarkupRecord.source)
  return static_cast< ::ru::mail::go::webbase::blobs::PublicationMarkupRecord_Source >(source_);
}
inline void PublicationMarkupRecord::set_source(::ru::mail::go::webbase::blobs::PublicationMarkupRecord_Source value) {
  assert(::ru::mail::go::webbase::blobs::PublicationMarkupRecord_Source_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.PublicationMarkupRecord.source)
}

// required string value = 2;
inline bool PublicationMarkupRecord::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicationMarkupRecord::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PublicationMarkupRecord::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PublicationMarkupRecord::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& PublicationMarkupRecord::value() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PublicationMarkupRecord.value)
  return value_.GetNoArena();
}
inline void PublicationMarkupRecord::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.PublicationMarkupRecord.value)
}
#if LANG_CXX11
inline void PublicationMarkupRecord::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.PublicationMarkupRecord.value)
}
#endif
inline void PublicationMarkupRecord::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.PublicationMarkupRecord.value)
}
inline void PublicationMarkupRecord::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.PublicationMarkupRecord.value)
}
inline ::std::string* PublicationMarkupRecord::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.PublicationMarkupRecord.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicationMarkupRecord::release_value() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.PublicationMarkupRecord.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicationMarkupRecord::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.PublicationMarkupRecord.value)
}

// required int64 parsed_date = 3;
inline bool PublicationMarkupRecord::has_parsed_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PublicationMarkupRecord::set_has_parsed_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PublicationMarkupRecord::clear_has_parsed_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PublicationMarkupRecord::clear_parsed_date() {
  parsed_date_ = GOOGLE_LONGLONG(0);
  clear_has_parsed_date();
}
inline ::google::protobuf::int64 PublicationMarkupRecord::parsed_date() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PublicationMarkupRecord.parsed_date)
  return parsed_date_;
}
inline void PublicationMarkupRecord::set_parsed_date(::google::protobuf::int64 value) {
  set_has_parsed_date();
  parsed_date_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.PublicationMarkupRecord.parsed_date)
}

// optional string content_type = 4;
inline bool PublicationMarkupRecord::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublicationMarkupRecord::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PublicationMarkupRecord::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PublicationMarkupRecord::clear_content_type() {
  content_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content_type();
}
inline const ::std::string& PublicationMarkupRecord::content_type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PublicationMarkupRecord.content_type)
  return content_type_.GetNoArena();
}
inline void PublicationMarkupRecord::set_content_type(const ::std::string& value) {
  set_has_content_type();
  content_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.PublicationMarkupRecord.content_type)
}
#if LANG_CXX11
inline void PublicationMarkupRecord::set_content_type(::std::string&& value) {
  set_has_content_type();
  content_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.PublicationMarkupRecord.content_type)
}
#endif
inline void PublicationMarkupRecord::set_content_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content_type();
  content_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.PublicationMarkupRecord.content_type)
}
inline void PublicationMarkupRecord::set_content_type(const char* value, size_t size) {
  set_has_content_type();
  content_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.PublicationMarkupRecord.content_type)
}
inline ::std::string* PublicationMarkupRecord::mutable_content_type() {
  set_has_content_type();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.PublicationMarkupRecord.content_type)
  return content_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicationMarkupRecord::release_content_type() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.PublicationMarkupRecord.content_type)
  clear_has_content_type();
  return content_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicationMarkupRecord::set_allocated_content_type(::std::string* content_type) {
  if (content_type != NULL) {
    set_has_content_type();
  } else {
    clear_has_content_type();
  }
  content_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content_type);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.PublicationMarkupRecord.content_type)
}

// -------------------------------------------------------------------

// PublicationMarkup

// repeated .ru.mail.go.webbase.blobs.PublicationMarkupRecord records = 1;
inline int PublicationMarkup::records_size() const {
  return records_.size();
}
inline void PublicationMarkup::clear_records() {
  records_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::PublicationMarkupRecord& PublicationMarkup::records(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PublicationMarkup.records)
  return records_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::PublicationMarkupRecord* PublicationMarkup::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.PublicationMarkup.records)
  return records_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::PublicationMarkupRecord* PublicationMarkup::add_records() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.PublicationMarkup.records)
  return records_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::PublicationMarkupRecord >*
PublicationMarkup::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.PublicationMarkup.records)
  return &records_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::PublicationMarkupRecord >&
PublicationMarkup::records() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.PublicationMarkup.records)
  return records_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::FetchUrl_Fastbases> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::FetchUrl_Fastbases>() {
  return ::ru::mail::go::webbase::blobs::FetchUrl_Fastbases_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::PublicationMarkupRecord_Source> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::PublicationMarkupRecord_Source>() {
  return ::ru::mail::go::webbase::blobs::PublicationMarkupRecord_Source_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::FetcherType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::FetcherType>() {
  return ::ru::mail::go::webbase::blobs::FetcherType_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::BatchingResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::BatchingResult>() {
  return ::ru::mail::go::webbase::blobs::BatchingResult_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::VideoBanSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::VideoBanSource>() {
  return ::ru::mail::go::webbase::blobs::VideoBanSource_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fetch_5flist_2eproto__INCLUDED
