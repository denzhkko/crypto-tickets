// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: image_defs.proto

#ifndef PROTOBUF_image_5fdefs_2eproto__INCLUDED
#define PROTOBUF_image_5fdefs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace parsing {
namespace img {
class Cluster;
class ClusterDefaultTypeInternal;
extern ClusterDefaultTypeInternal _Cluster_default_instance_;
class ClusterSeed;
class ClusterSeedDefaultTypeInternal;
extern ClusterSeedDefaultTypeInternal _ClusterSeed_default_instance_;
class Colors;
class ColorsDefaultTypeInternal;
extern ColorsDefaultTypeInternal _Colors_default_instance_;
class CvFeatures;
class CvFeaturesDefaultTypeInternal;
extern CvFeaturesDefaultTypeInternal _CvFeatures_default_instance_;
class Duplicate;
class DuplicateDefaultTypeInternal;
extern DuplicateDefaultTypeInternal _Duplicate_default_instance_;
class Exif;
class ExifDefaultTypeInternal;
extern ExifDefaultTypeInternal _Exif_default_instance_;
class HashId;
class HashIdDefaultTypeInternal;
extern HashIdDefaultTypeInternal _HashId_default_instance_;
class IdOrRow;
class IdOrRowDefaultTypeInternal;
extern IdOrRowDefaultTypeInternal _IdOrRow_default_instance_;
class Rect;
class RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class RectArray;
class RectArrayDefaultTypeInternal;
extern RectArrayDefaultTypeInternal _RectArray_default_instance_;
class RowCluster;
class RowClusterDefaultTypeInternal;
extern RowClusterDefaultTypeInternal _RowCluster_default_instance_;
class SerpSimilar;
class SerpSimilarDefaultTypeInternal;
extern SerpSimilarDefaultTypeInternal _SerpSimilar_default_instance_;
class Thumb;
class ThumbDefaultTypeInternal;
extern ThumbDefaultTypeInternal _Thumb_default_instance_;
class ThumbWithQueries;
class ThumbWithQueriesDefaultTypeInternal;
extern ThumbWithQueriesDefaultTypeInternal _ThumbWithQueries_default_instance_;
class VideoClip;
class VideoClipDefaultTypeInternal;
extern VideoClipDefaultTypeInternal _VideoClip_default_instance_;
}  // namespace img
}  // namespace parsing
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace parsing {
namespace img {

namespace protobuf_image_5fdefs_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_image_5fdefs_2eproto

enum VideoClip_VideoCodec {
  VideoClip_VideoCodec_VE_H264 = 0,
  VideoClip_VideoCodec_VE_UNKNOWN = 255
};
bool VideoClip_VideoCodec_IsValid(int value);
const VideoClip_VideoCodec VideoClip_VideoCodec_VideoCodec_MIN = VideoClip_VideoCodec_VE_H264;
const VideoClip_VideoCodec VideoClip_VideoCodec_VideoCodec_MAX = VideoClip_VideoCodec_VE_UNKNOWN;
const int VideoClip_VideoCodec_VideoCodec_ARRAYSIZE = VideoClip_VideoCodec_VideoCodec_MAX + 1;

const ::google::protobuf::EnumDescriptor* VideoClip_VideoCodec_descriptor();
inline const ::std::string& VideoClip_VideoCodec_Name(VideoClip_VideoCodec value) {
  return ::google::protobuf::internal::NameOfEnum(
    VideoClip_VideoCodec_descriptor(), value);
}
inline bool VideoClip_VideoCodec_Parse(
    const ::std::string& name, VideoClip_VideoCodec* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoClip_VideoCodec>(
    VideoClip_VideoCodec_descriptor(), name, value);
}
enum VideoClip_VideoContainer {
  VideoClip_VideoContainer_VC_MP4 = 0,
  VideoClip_VideoContainer_VC_UNKNOWN = 255
};
bool VideoClip_VideoContainer_IsValid(int value);
const VideoClip_VideoContainer VideoClip_VideoContainer_VideoContainer_MIN = VideoClip_VideoContainer_VC_MP4;
const VideoClip_VideoContainer VideoClip_VideoContainer_VideoContainer_MAX = VideoClip_VideoContainer_VC_UNKNOWN;
const int VideoClip_VideoContainer_VideoContainer_ARRAYSIZE = VideoClip_VideoContainer_VideoContainer_MAX + 1;

const ::google::protobuf::EnumDescriptor* VideoClip_VideoContainer_descriptor();
inline const ::std::string& VideoClip_VideoContainer_Name(VideoClip_VideoContainer value) {
  return ::google::protobuf::internal::NameOfEnum(
    VideoClip_VideoContainer_descriptor(), value);
}
inline bool VideoClip_VideoContainer_Parse(
    const ::std::string& name, VideoClip_VideoContainer* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoClip_VideoContainer>(
    VideoClip_VideoContainer_descriptor(), name, value);
}
enum ImageFormat {
  IF_JPEG = 0,
  IF_PNG = 1,
  IF_GIF = 2,
  IF_UNKNOWN = 3,
  IF_ICO = 4,
  IF_BMP = 5,
  IF_WEBP = 6,
  IF_SVG = 7
};
bool ImageFormat_IsValid(int value);
const ImageFormat ImageFormat_MIN = IF_JPEG;
const ImageFormat ImageFormat_MAX = IF_SVG;
const int ImageFormat_ARRAYSIZE = ImageFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageFormat_descriptor();
inline const ::std::string& ImageFormat_Name(ImageFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageFormat_descriptor(), value);
}
inline bool ImageFormat_Parse(
    const ::std::string& name, ImageFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageFormat>(
    ImageFormat_descriptor(), name, value);
}
enum ImageClass {
  IC_UNKNOWN = 0,
  IC_PHOTO = 2,
  IC_CLIPART = 3,
  IC_LINEART = 4
};
bool ImageClass_IsValid(int value);
const ImageClass ImageClass_MIN = IC_UNKNOWN;
const ImageClass ImageClass_MAX = IC_LINEART;
const int ImageClass_ARRAYSIZE = ImageClass_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageClass_descriptor();
inline const ::std::string& ImageClass_Name(ImageClass value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageClass_descriptor(), value);
}
inline bool ImageClass_Parse(
    const ::std::string& name, ImageClass* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageClass>(
    ImageClass_descriptor(), name, value);
}
enum Interpolation {
  ITP_NEAREST = 1,
  ITP_LINEAR = 2,
  ITP_CUBIC = 3
};
bool Interpolation_IsValid(int value);
const Interpolation Interpolation_MIN = ITP_NEAREST;
const Interpolation Interpolation_MAX = ITP_CUBIC;
const int Interpolation_ARRAYSIZE = Interpolation_MAX + 1;

const ::google::protobuf::EnumDescriptor* Interpolation_descriptor();
inline const ::std::string& Interpolation_Name(Interpolation value) {
  return ::google::protobuf::internal::NameOfEnum(
    Interpolation_descriptor(), value);
}
inline bool Interpolation_Parse(
    const ::std::string& name, Interpolation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Interpolation>(
    Interpolation_descriptor(), name, value);
}
enum BorderType {
  REPLICATE = 1,
  CONSTANT = 2,
  REFLECT = 3,
  WRAP = 4,
  REFLECT_101 = 5,
  TRANSPARENT = 6,
  ISOLATED = 7
};
bool BorderType_IsValid(int value);
const BorderType BorderType_MIN = REPLICATE;
const BorderType BorderType_MAX = ISOLATED;
const int BorderType_ARRAYSIZE = BorderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BorderType_descriptor();
inline const ::std::string& BorderType_Name(BorderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BorderType_descriptor(), value);
}
inline bool BorderType_Parse(
    const ::std::string& name, BorderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BorderType>(
    BorderType_descriptor(), name, value);
}
// ===================================================================

class Exif : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.Exif) */ {
 public:
  Exif();
  virtual ~Exif();

  Exif(const Exif& from);

  inline Exif& operator=(const Exif& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Exif(Exif&& from) noexcept
    : Exif() {
    *this = ::std::move(from);
  }

  inline Exif& operator=(Exif&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Exif& default_instance();

  static inline const Exif* internal_default_instance() {
    return reinterpret_cast<const Exif*>(
               &_Exif_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Exif* other);
  friend void swap(Exif& a, Exif& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Exif* New() const PROTOBUF_FINAL { return New(NULL); }

  Exif* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Exif& from);
  void MergeFrom(const Exif& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Exif* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double longitude = 1;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  double longitude() const;
  void set_longitude(double value);

  // optional double lattitude = 2;
  bool has_lattitude() const;
  void clear_lattitude();
  static const int kLattitudeFieldNumber = 2;
  double lattitude() const;
  void set_lattitude(double value);

  // optional uint64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.Exif)
 private:
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_lattitude();
  void clear_has_lattitude();
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double longitude_;
  double lattitude_;
  ::google::protobuf::uint64 timestamp_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Colors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.Colors) */ {
 public:
  Colors();
  virtual ~Colors();

  Colors(const Colors& from);

  inline Colors& operator=(const Colors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Colors(Colors&& from) noexcept
    : Colors() {
    *this = ::std::move(from);
  }

  inline Colors& operator=(Colors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Colors& default_instance();

  static inline const Colors* internal_default_instance() {
    return reinterpret_cast<const Colors*>(
               &_Colors_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Colors* other);
  friend void swap(Colors& a, Colors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Colors* New() const PROTOBUF_FINAL { return New(NULL); }

  Colors* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Colors& from);
  void MergeFrom(const Colors& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Colors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 CLR_MULTI = 1 [default = 1];
  bool has_clr_multi() const;
  void clear_clr_multi();
  static const int kCLRMULTIFieldNumber = 1;
  ::google::protobuf::uint32 clr_multi() const;
  void set_clr_multi(::google::protobuf::uint32 value);

  // optional uint32 CLR_BW = 2 [default = 2];
  bool has_clr_bw() const;
  void clear_clr_bw();
  static const int kCLRBWFieldNumber = 2;
  ::google::protobuf::uint32 clr_bw() const;
  void set_clr_bw(::google::protobuf::uint32 value);

  // optional uint32 CLR_RED = 3 [default = 4];
  bool has_clr_red() const;
  void clear_clr_red();
  static const int kCLRREDFieldNumber = 3;
  ::google::protobuf::uint32 clr_red() const;
  void set_clr_red(::google::protobuf::uint32 value);

  // optional uint32 CLR_ORANGE = 4 [default = 8];
  bool has_clr_orange() const;
  void clear_clr_orange();
  static const int kCLRORANGEFieldNumber = 4;
  ::google::protobuf::uint32 clr_orange() const;
  void set_clr_orange(::google::protobuf::uint32 value);

  // optional uint32 CLR_YELLOW = 5 [default = 16];
  bool has_clr_yellow() const;
  void clear_clr_yellow();
  static const int kCLRYELLOWFieldNumber = 5;
  ::google::protobuf::uint32 clr_yellow() const;
  void set_clr_yellow(::google::protobuf::uint32 value);

  // optional uint32 CLR_GREEN = 6 [default = 32];
  bool has_clr_green() const;
  void clear_clr_green();
  static const int kCLRGREENFieldNumber = 6;
  ::google::protobuf::uint32 clr_green() const;
  void set_clr_green(::google::protobuf::uint32 value);

  // optional uint32 CLR_BLUE = 7 [default = 64];
  bool has_clr_blue() const;
  void clear_clr_blue();
  static const int kCLRBLUEFieldNumber = 7;
  ::google::protobuf::uint32 clr_blue() const;
  void set_clr_blue(::google::protobuf::uint32 value);

  // optional uint32 CLR_CYAN = 8 [default = 128];
  bool has_clr_cyan() const;
  void clear_clr_cyan();
  static const int kCLRCYANFieldNumber = 8;
  ::google::protobuf::uint32 clr_cyan() const;
  void set_clr_cyan(::google::protobuf::uint32 value);

  // optional uint32 CLR_PURPLE = 9 [default = 256];
  bool has_clr_purple() const;
  void clear_clr_purple();
  static const int kCLRPURPLEFieldNumber = 9;
  ::google::protobuf::uint32 clr_purple() const;
  void set_clr_purple(::google::protobuf::uint32 value);

  // optional uint32 CLR_BLACK = 10 [default = 512];
  bool has_clr_black() const;
  void clear_clr_black();
  static const int kCLRBLACKFieldNumber = 10;
  ::google::protobuf::uint32 clr_black() const;
  void set_clr_black(::google::protobuf::uint32 value);

  // optional uint32 CLR_WHITE = 11 [default = 1024];
  bool has_clr_white() const;
  void clear_clr_white();
  static const int kCLRWHITEFieldNumber = 11;
  ::google::protobuf::uint32 clr_white() const;
  void set_clr_white(::google::protobuf::uint32 value);

  // optional uint32 CLR_SEPIA = 12 [default = 2048];
  bool has_clr_sepia() const;
  void clear_clr_sepia();
  static const int kCLRSEPIAFieldNumber = 12;
  ::google::protobuf::uint32 clr_sepia() const;
  void set_clr_sepia(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.Colors)
 private:
  void set_has_clr_multi();
  void clear_has_clr_multi();
  void set_has_clr_bw();
  void clear_has_clr_bw();
  void set_has_clr_red();
  void clear_has_clr_red();
  void set_has_clr_orange();
  void clear_has_clr_orange();
  void set_has_clr_yellow();
  void clear_has_clr_yellow();
  void set_has_clr_green();
  void clear_has_clr_green();
  void set_has_clr_blue();
  void clear_has_clr_blue();
  void set_has_clr_cyan();
  void clear_has_clr_cyan();
  void set_has_clr_purple();
  void clear_has_clr_purple();
  void set_has_clr_black();
  void clear_has_clr_black();
  void set_has_clr_white();
  void clear_has_clr_white();
  void set_has_clr_sepia();
  void clear_has_clr_sepia();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 clr_multi_;
  ::google::protobuf::uint32 clr_bw_;
  ::google::protobuf::uint32 clr_red_;
  ::google::protobuf::uint32 clr_orange_;
  ::google::protobuf::uint32 clr_yellow_;
  ::google::protobuf::uint32 clr_green_;
  ::google::protobuf::uint32 clr_blue_;
  ::google::protobuf::uint32 clr_cyan_;
  ::google::protobuf::uint32 clr_purple_;
  ::google::protobuf::uint32 clr_black_;
  ::google::protobuf::uint32 clr_white_;
  ::google::protobuf::uint32 clr_sepia_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Rect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.Rect) */ {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect& from);

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rect(Rect&& from) noexcept
    : Rect() {
    *this = ::std::move(from);
  }

  inline Rect& operator=(Rect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rect& default_instance();

  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Rect* other);
  friend void swap(Rect& a, Rect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rect* New() const PROTOBUF_FINAL { return New(NULL); }

  Rect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Rect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::uint32 x() const;
  void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::uint32 y() const;
  void set_y(::google::protobuf::uint32 value);

  // required uint32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.Rect)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RectArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.RectArray) */ {
 public:
  RectArray();
  virtual ~RectArray();

  RectArray(const RectArray& from);

  inline RectArray& operator=(const RectArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RectArray(RectArray&& from) noexcept
    : RectArray() {
    *this = ::std::move(from);
  }

  inline RectArray& operator=(RectArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RectArray& default_instance();

  static inline const RectArray* internal_default_instance() {
    return reinterpret_cast<const RectArray*>(
               &_RectArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RectArray* other);
  friend void swap(RectArray& a, RectArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RectArray* New() const PROTOBUF_FINAL { return New(NULL); }

  RectArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RectArray& from);
  void MergeFrom(const RectArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RectArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.parsing.img.Rect rect = 1;
  int rect_size() const;
  void clear_rect();
  static const int kRectFieldNumber = 1;
  const ::ru::mail::go::webbase::parsing::img::Rect& rect(int index) const;
  ::ru::mail::go::webbase::parsing::img::Rect* mutable_rect(int index);
  ::ru::mail::go::webbase::parsing::img::Rect* add_rect();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Rect >*
      mutable_rect();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Rect >&
      rect() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.RectArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Rect > rect_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CvFeatures : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.CvFeatures) */ {
 public:
  CvFeatures();
  virtual ~CvFeatures();

  CvFeatures(const CvFeatures& from);

  inline CvFeatures& operator=(const CvFeatures& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CvFeatures(CvFeatures&& from) noexcept
    : CvFeatures() {
    *this = ::std::move(from);
  }

  inline CvFeatures& operator=(CvFeatures&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CvFeatures& default_instance();

  static inline const CvFeatures* internal_default_instance() {
    return reinterpret_cast<const CvFeatures*>(
               &_CvFeatures_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CvFeatures* other);
  friend void swap(CvFeatures& a, CvFeatures& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CvFeatures* New() const PROTOBUF_FINAL { return New(NULL); }

  CvFeatures* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CvFeatures& from);
  void MergeFrom(const CvFeatures& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CvFeatures* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ru.mail.go.webbase.parsing.img.RectArray faces = 1;
  bool has_faces() const;
  void clear_faces();
  static const int kFacesFieldNumber = 1;
  const ::ru::mail::go::webbase::parsing::img::RectArray& faces() const;
  ::ru::mail::go::webbase::parsing::img::RectArray* mutable_faces();
  ::ru::mail::go::webbase::parsing::img::RectArray* release_faces();
  void set_allocated_faces(::ru::mail::go::webbase::parsing::img::RectArray* faces);

  // optional .ru.mail.go.webbase.parsing.img.RectArray textboxes = 4;
  bool has_textboxes() const;
  void clear_textboxes();
  static const int kTextboxesFieldNumber = 4;
  const ::ru::mail::go::webbase::parsing::img::RectArray& textboxes() const;
  ::ru::mail::go::webbase::parsing::img::RectArray* mutable_textboxes();
  ::ru::mail::go::webbase::parsing::img::RectArray* release_textboxes();
  void set_allocated_textboxes(::ru::mail::go::webbase::parsing::img::RectArray* textboxes);

  // optional double quality = 2;
  bool has_quality() const;
  void clear_quality();
  static const int kQualityFieldNumber = 2;
  double quality() const;
  void set_quality(double value);

  // optional double entropy = 3;
  bool has_entropy() const;
  void clear_entropy();
  static const int kEntropyFieldNumber = 3;
  double entropy() const;
  void set_entropy(double value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.CvFeatures)
 private:
  void set_has_faces();
  void clear_has_faces();
  void set_has_quality();
  void clear_has_quality();
  void set_has_entropy();
  void clear_has_entropy();
  void set_has_textboxes();
  void clear_has_textboxes();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ru::mail::go::webbase::parsing::img::RectArray* faces_;
  ::ru::mail::go::webbase::parsing::img::RectArray* textboxes_;
  double quality_;
  double entropy_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Thumb : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.Thumb) */ {
 public:
  Thumb();
  virtual ~Thumb();

  Thumb(const Thumb& from);

  inline Thumb& operator=(const Thumb& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Thumb(Thumb&& from) noexcept
    : Thumb() {
    *this = ::std::move(from);
  }

  inline Thumb& operator=(Thumb&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Thumb& default_instance();

  static inline const Thumb* internal_default_instance() {
    return reinterpret_cast<const Thumb*>(
               &_Thumb_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Thumb* other);
  friend void swap(Thumb& a, Thumb& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Thumb* New() const PROTOBUF_FINAL { return New(NULL); }

  Thumb* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Thumb& from);
  void MergeFrom(const Thumb& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Thumb* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes pic = 1;
  bool has_pic() const;
  void clear_pic();
  static const int kPicFieldNumber = 1;
  const ::std::string& pic() const;
  void set_pic(const ::std::string& value);
  #if LANG_CXX11
  void set_pic(::std::string&& value);
  #endif
  void set_pic(const char* value);
  void set_pic(const void* value, size_t size);
  ::std::string* mutable_pic();
  ::std::string* release_pic();
  void set_allocated_pic(::std::string* pic);

  // optional string url = 6;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 6;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional .ru.mail.go.webbase.parsing.img.CvFeatures features = 7;
  bool has_features() const;
  void clear_features();
  static const int kFeaturesFieldNumber = 7;
  const ::ru::mail::go::webbase::parsing::img::CvFeatures& features() const;
  ::ru::mail::go::webbase::parsing::img::CvFeatures* mutable_features();
  ::ru::mail::go::webbase::parsing::img::CvFeatures* release_features();
  void set_allocated_features(::ru::mail::go::webbase::parsing::img::CvFeatures* features);

  // required uint32 width = 2;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required .ru.mail.go.webbase.parsing.img.ImageFormat format = 4;
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 4;
  ::ru::mail::go::webbase::parsing::img::ImageFormat format() const;
  void set_format(::ru::mail::go::webbase::parsing::img::ImageFormat value);

  // optional bool animated = 8;
  bool has_animated() const;
  void clear_animated();
  static const int kAnimatedFieldNumber = 8;
  bool animated() const;
  void set_animated(bool value);

  // optional uint32 originalWidth = 9;
  bool has_originalwidth() const;
  void clear_originalwidth();
  static const int kOriginalWidthFieldNumber = 9;
  ::google::protobuf::uint32 originalwidth() const;
  void set_originalwidth(::google::protobuf::uint32 value);

  // optional uint32 originalHeight = 10;
  bool has_originalheight() const;
  void clear_originalheight();
  static const int kOriginalHeightFieldNumber = 10;
  ::google::protobuf::uint32 originalheight() const;
  void set_originalheight(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.Thumb)
 private:
  void set_has_pic();
  void clear_has_pic();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_format();
  void clear_has_format();
  void set_has_url();
  void clear_has_url();
  void set_has_features();
  void clear_has_features();
  void set_has_animated();
  void clear_has_animated();
  void set_has_originalwidth();
  void clear_has_originalwidth();
  void set_has_originalheight();
  void clear_has_originalheight();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pic_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::ru::mail::go::webbase::parsing::img::CvFeatures* features_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  int format_;
  bool animated_;
  ::google::protobuf::uint32 originalwidth_;
  ::google::protobuf::uint32 originalheight_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThumbWithQueries : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.ThumbWithQueries) */ {
 public:
  ThumbWithQueries();
  virtual ~ThumbWithQueries();

  ThumbWithQueries(const ThumbWithQueries& from);

  inline ThumbWithQueries& operator=(const ThumbWithQueries& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThumbWithQueries(ThumbWithQueries&& from) noexcept
    : ThumbWithQueries() {
    *this = ::std::move(from);
  }

  inline ThumbWithQueries& operator=(ThumbWithQueries&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThumbWithQueries& default_instance();

  static inline const ThumbWithQueries* internal_default_instance() {
    return reinterpret_cast<const ThumbWithQueries*>(
               &_ThumbWithQueries_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ThumbWithQueries* other);
  friend void swap(ThumbWithQueries& a, ThumbWithQueries& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThumbWithQueries* New() const PROTOBUF_FINAL { return New(NULL); }

  ThumbWithQueries* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ThumbWithQueries& from);
  void MergeFrom(const ThumbWithQueries& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ThumbWithQueries* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string queries = 2;
  int queries_size() const;
  void clear_queries();
  static const int kQueriesFieldNumber = 2;
  const ::std::string& queries(int index) const;
  ::std::string* mutable_queries(int index);
  void set_queries(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_queries(int index, ::std::string&& value);
  #endif
  void set_queries(int index, const char* value);
  void set_queries(int index, const char* value, size_t size);
  ::std::string* add_queries();
  void add_queries(const ::std::string& value);
  #if LANG_CXX11
  void add_queries(::std::string&& value);
  #endif
  void add_queries(const char* value);
  void add_queries(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& queries() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_queries();

  // optional .ru.mail.go.webbase.parsing.img.Thumb thumb = 1;
  bool has_thumb() const;
  void clear_thumb();
  static const int kThumbFieldNumber = 1;
  const ::ru::mail::go::webbase::parsing::img::Thumb& thumb() const;
  ::ru::mail::go::webbase::parsing::img::Thumb* mutable_thumb();
  ::ru::mail::go::webbase::parsing::img::Thumb* release_thumb();
  void set_allocated_thumb(::ru::mail::go::webbase::parsing::img::Thumb* thumb);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.ThumbWithQueries)
 private:
  void set_has_thumb();
  void clear_has_thumb();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> queries_;
  ::ru::mail::go::webbase::parsing::img::Thumb* thumb_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VideoClip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.VideoClip) */ {
 public:
  VideoClip();
  virtual ~VideoClip();

  VideoClip(const VideoClip& from);

  inline VideoClip& operator=(const VideoClip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VideoClip(VideoClip&& from) noexcept
    : VideoClip() {
    *this = ::std::move(from);
  }

  inline VideoClip& operator=(VideoClip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoClip& default_instance();

  static inline const VideoClip* internal_default_instance() {
    return reinterpret_cast<const VideoClip*>(
               &_VideoClip_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(VideoClip* other);
  friend void swap(VideoClip& a, VideoClip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VideoClip* New() const PROTOBUF_FINAL { return New(NULL); }

  VideoClip* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VideoClip& from);
  void MergeFrom(const VideoClip& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VideoClip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VideoClip_VideoCodec VideoCodec;
  static const VideoCodec VE_H264 =
    VideoClip_VideoCodec_VE_H264;
  static const VideoCodec VE_UNKNOWN =
    VideoClip_VideoCodec_VE_UNKNOWN;
  static inline bool VideoCodec_IsValid(int value) {
    return VideoClip_VideoCodec_IsValid(value);
  }
  static const VideoCodec VideoCodec_MIN =
    VideoClip_VideoCodec_VideoCodec_MIN;
  static const VideoCodec VideoCodec_MAX =
    VideoClip_VideoCodec_VideoCodec_MAX;
  static const int VideoCodec_ARRAYSIZE =
    VideoClip_VideoCodec_VideoCodec_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VideoCodec_descriptor() {
    return VideoClip_VideoCodec_descriptor();
  }
  static inline const ::std::string& VideoCodec_Name(VideoCodec value) {
    return VideoClip_VideoCodec_Name(value);
  }
  static inline bool VideoCodec_Parse(const ::std::string& name,
      VideoCodec* value) {
    return VideoClip_VideoCodec_Parse(name, value);
  }

  typedef VideoClip_VideoContainer VideoContainer;
  static const VideoContainer VC_MP4 =
    VideoClip_VideoContainer_VC_MP4;
  static const VideoContainer VC_UNKNOWN =
    VideoClip_VideoContainer_VC_UNKNOWN;
  static inline bool VideoContainer_IsValid(int value) {
    return VideoClip_VideoContainer_IsValid(value);
  }
  static const VideoContainer VideoContainer_MIN =
    VideoClip_VideoContainer_VideoContainer_MIN;
  static const VideoContainer VideoContainer_MAX =
    VideoClip_VideoContainer_VideoContainer_MAX;
  static const int VideoContainer_ARRAYSIZE =
    VideoClip_VideoContainer_VideoContainer_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VideoContainer_descriptor() {
    return VideoClip_VideoContainer_descriptor();
  }
  static inline const ::std::string& VideoContainer_Name(VideoContainer value) {
    return VideoClip_VideoContainer_Name(value);
  }
  static inline bool VideoContainer_Parse(const ::std::string& name,
      VideoContainer* value) {
    return VideoClip_VideoContainer_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes clip = 1;
  bool has_clip() const;
  void clear_clip();
  static const int kClipFieldNumber = 1;
  const ::std::string& clip() const;
  void set_clip(const ::std::string& value);
  #if LANG_CXX11
  void set_clip(::std::string&& value);
  #endif
  void set_clip(const char* value);
  void set_clip(const void* value, size_t size);
  ::std::string* mutable_clip();
  ::std::string* release_clip();
  void set_allocated_clip(::std::string* clip);

  // optional string url = 7;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 7;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required uint32 width = 2;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required uint32 length = 4;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 4;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // required .ru.mail.go.webbase.parsing.img.VideoClip.VideoCodec codec = 5;
  bool has_codec() const;
  void clear_codec();
  static const int kCodecFieldNumber = 5;
  ::ru::mail::go::webbase::parsing::img::VideoClip_VideoCodec codec() const;
  void set_codec(::ru::mail::go::webbase::parsing::img::VideoClip_VideoCodec value);

  // required .ru.mail.go.webbase.parsing.img.VideoClip.VideoContainer container = 6;
  bool has_container() const;
  void clear_container();
  static const int kContainerFieldNumber = 6;
  ::ru::mail::go::webbase::parsing::img::VideoClip_VideoContainer container() const;
  void set_container(::ru::mail::go::webbase::parsing::img::VideoClip_VideoContainer value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.VideoClip)
 private:
  void set_has_clip();
  void clear_has_clip();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_length();
  void clear_has_length();
  void set_has_codec();
  void clear_has_codec();
  void set_has_container();
  void clear_has_container();
  void set_has_url();
  void clear_has_url();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr clip_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 length_;
  int codec_;
  int container_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClusterSeed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.ClusterSeed) */ {
 public:
  ClusterSeed();
  virtual ~ClusterSeed();

  ClusterSeed(const ClusterSeed& from);

  inline ClusterSeed& operator=(const ClusterSeed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClusterSeed(ClusterSeed&& from) noexcept
    : ClusterSeed() {
    *this = ::std::move(from);
  }

  inline ClusterSeed& operator=(ClusterSeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterSeed& default_instance();

  static inline const ClusterSeed* internal_default_instance() {
    return reinterpret_cast<const ClusterSeed*>(
               &_ClusterSeed_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ClusterSeed* other);
  friend void swap(ClusterSeed& a, ClusterSeed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClusterSeed* New() const PROTOBUF_FINAL { return New(NULL); }

  ClusterSeed* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClusterSeed& from);
  void MergeFrom(const ClusterSeed& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClusterSeed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 hash = 1;
  int hash_size() const;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  ::google::protobuf::uint64 hash(int index) const;
  void set_hash(int index, ::google::protobuf::uint64 value);
  void add_hash(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      hash() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_hash();

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.ClusterSeed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > hash_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Cluster : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.Cluster) */ {
 public:
  Cluster();
  virtual ~Cluster();

  Cluster(const Cluster& from);

  inline Cluster& operator=(const Cluster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Cluster(Cluster&& from) noexcept
    : Cluster() {
    *this = ::std::move(from);
  }

  inline Cluster& operator=(Cluster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cluster& default_instance();

  static inline const Cluster* internal_default_instance() {
    return reinterpret_cast<const Cluster*>(
               &_Cluster_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Cluster* other);
  friend void swap(Cluster& a, Cluster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Cluster* New() const PROTOBUF_FINAL { return New(NULL); }

  Cluster* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Cluster& from);
  void MergeFrom(const Cluster& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Cluster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 hash = 2;
  int hash_size() const;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  ::google::protobuf::uint64 hash(int index) const;
  void set_hash(int index, ::google::protobuf::uint64 value);
  void add_hash(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      hash() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_hash();

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.Cluster)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > hash_;
  ::google::protobuf::uint64 id_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HashId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.HashId) */ {
 public:
  HashId();
  virtual ~HashId();

  HashId(const HashId& from);

  inline HashId& operator=(const HashId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HashId(HashId&& from) noexcept
    : HashId() {
    *this = ::std::move(from);
  }

  inline HashId& operator=(HashId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashId& default_instance();

  static inline const HashId* internal_default_instance() {
    return reinterpret_cast<const HashId*>(
               &_HashId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(HashId* other);
  friend void swap(HashId& a, HashId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HashId* New() const PROTOBUF_FINAL { return New(NULL); }

  HashId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HashId& from);
  void MergeFrom(const HashId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HashId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 hash = 1;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  ::google::protobuf::uint64 hash() const;
  void set_hash(::google::protobuf::uint64 value);

  // required uint64 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.HashId)
 private:
  void set_has_hash();
  void clear_has_hash();
  void set_has_id();
  void clear_has_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 hash_;
  ::google::protobuf::uint64 id_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IdOrRow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.IdOrRow) */ {
 public:
  IdOrRow();
  virtual ~IdOrRow();

  IdOrRow(const IdOrRow& from);

  inline IdOrRow& operator=(const IdOrRow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IdOrRow(IdOrRow&& from) noexcept
    : IdOrRow() {
    *this = ::std::move(from);
  }

  inline IdOrRow& operator=(IdOrRow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IdOrRow& default_instance();

  static inline const IdOrRow* internal_default_instance() {
    return reinterpret_cast<const IdOrRow*>(
               &_IdOrRow_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(IdOrRow* other);
  friend void swap(IdOrRow& a, IdOrRow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IdOrRow* New() const PROTOBUF_FINAL { return New(NULL); }

  IdOrRow* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IdOrRow& from);
  void MergeFrom(const IdOrRow& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IdOrRow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes row = 2;
  bool has_row() const;
  void clear_row();
  static const int kRowFieldNumber = 2;
  const ::std::string& row() const;
  void set_row(const ::std::string& value);
  #if LANG_CXX11
  void set_row(::std::string&& value);
  #endif
  void set_row(const char* value);
  void set_row(const void* value, size_t size);
  ::std::string* mutable_row();
  ::std::string* release_row();
  void set_allocated_row(::std::string* row);

  // optional uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.IdOrRow)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_row();
  void clear_has_row();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr row_;
  ::google::protobuf::uint64 id_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RowCluster : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.RowCluster) */ {
 public:
  RowCluster();
  virtual ~RowCluster();

  RowCluster(const RowCluster& from);

  inline RowCluster& operator=(const RowCluster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RowCluster(RowCluster&& from) noexcept
    : RowCluster() {
    *this = ::std::move(from);
  }

  inline RowCluster& operator=(RowCluster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RowCluster& default_instance();

  static inline const RowCluster* internal_default_instance() {
    return reinterpret_cast<const RowCluster*>(
               &_RowCluster_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(RowCluster* other);
  friend void swap(RowCluster& a, RowCluster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RowCluster* New() const PROTOBUF_FINAL { return New(NULL); }

  RowCluster* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RowCluster& from);
  void MergeFrom(const RowCluster& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RowCluster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes row = 2;
  int row_size() const;
  void clear_row();
  static const int kRowFieldNumber = 2;
  const ::std::string& row(int index) const;
  ::std::string* mutable_row(int index);
  void set_row(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_row(int index, ::std::string&& value);
  #endif
  void set_row(int index, const char* value);
  void set_row(int index, const void* value, size_t size);
  ::std::string* add_row();
  void add_row(const ::std::string& value);
  #if LANG_CXX11
  void add_row(::std::string&& value);
  #endif
  void add_row(const char* value);
  void add_row(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& row() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_row();

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.RowCluster)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> row_;
  ::google::protobuf::uint64 id_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Duplicate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.Duplicate) */ {
 public:
  Duplicate();
  virtual ~Duplicate();

  Duplicate(const Duplicate& from);

  inline Duplicate& operator=(const Duplicate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Duplicate(Duplicate&& from) noexcept
    : Duplicate() {
    *this = ::std::move(from);
  }

  inline Duplicate& operator=(Duplicate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Duplicate& default_instance();

  static inline const Duplicate* internal_default_instance() {
    return reinterpret_cast<const Duplicate*>(
               &_Duplicate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Duplicate* other);
  friend void swap(Duplicate& a, Duplicate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Duplicate* New() const PROTOBUF_FINAL { return New(NULL); }

  Duplicate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Duplicate& from);
  void MergeFrom(const Duplicate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Duplicate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string row = 2;
  bool has_row() const;
  void clear_row();
  static const int kRowFieldNumber = 2;
  const ::std::string& row() const;
  void set_row(const ::std::string& value);
  #if LANG_CXX11
  void set_row(::std::string&& value);
  #endif
  void set_row(const char* value);
  void set_row(const char* value, size_t size);
  ::std::string* mutable_row();
  ::std::string* release_row();
  void set_allocated_row(::std::string* row);

  // required .ru.mail.go.webbase.parsing.img.Thumb thumb = 3;
  bool has_thumb() const;
  void clear_thumb();
  static const int kThumbFieldNumber = 3;
  const ::ru::mail::go::webbase::parsing::img::Thumb& thumb() const;
  ::ru::mail::go::webbase::parsing::img::Thumb* mutable_thumb();
  ::ru::mail::go::webbase::parsing::img::Thumb* release_thumb();
  void set_allocated_thumb(::ru::mail::go::webbase::parsing::img::Thumb* thumb);

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.Duplicate)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_row();
  void clear_has_row();
  void set_has_thumb();
  void clear_has_thumb();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr row_;
  ::ru::mail::go::webbase::parsing::img::Thumb* thumb_;
  ::google::protobuf::uint64 id_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SerpSimilar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.parsing.img.SerpSimilar) */ {
 public:
  SerpSimilar();
  virtual ~SerpSimilar();

  SerpSimilar(const SerpSimilar& from);

  inline SerpSimilar& operator=(const SerpSimilar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SerpSimilar(SerpSimilar&& from) noexcept
    : SerpSimilar() {
    *this = ::std::move(from);
  }

  inline SerpSimilar& operator=(SerpSimilar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SerpSimilar& default_instance();

  static inline const SerpSimilar* internal_default_instance() {
    return reinterpret_cast<const SerpSimilar*>(
               &_SerpSimilar_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(SerpSimilar* other);
  friend void swap(SerpSimilar& a, SerpSimilar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SerpSimilar* New() const PROTOBUF_FINAL { return New(NULL); }

  SerpSimilar* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SerpSimilar& from);
  void MergeFrom(const SerpSimilar& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SerpSimilar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.parsing.img.Thumb serp = 2;
  int serp_size() const;
  void clear_serp();
  static const int kSerpFieldNumber = 2;
  const ::ru::mail::go::webbase::parsing::img::Thumb& serp(int index) const;
  ::ru::mail::go::webbase::parsing::img::Thumb* mutable_serp(int index);
  ::ru::mail::go::webbase::parsing::img::Thumb* add_serp();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >*
      mutable_serp();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >&
      serp() const;

  // required .ru.mail.go.webbase.parsing.img.Thumb query = 1;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 1;
  const ::ru::mail::go::webbase::parsing::img::Thumb& query() const;
  ::ru::mail::go::webbase::parsing::img::Thumb* mutable_query();
  ::ru::mail::go::webbase::parsing::img::Thumb* release_query();
  void set_allocated_query(::ru::mail::go::webbase::parsing::img::Thumb* query);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.parsing.img.SerpSimilar)
 private:
  void set_has_query();
  void clear_has_query();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb > serp_;
  ::ru::mail::go::webbase::parsing::img::Thumb* query_;
  friend struct protobuf_image_5fdefs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Exif

// optional double longitude = 1;
inline bool Exif::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exif::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exif::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exif::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double Exif::longitude() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Exif.longitude)
  return longitude_;
}
inline void Exif::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Exif.longitude)
}

// optional double lattitude = 2;
inline bool Exif::has_lattitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Exif::set_has_lattitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Exif::clear_has_lattitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Exif::clear_lattitude() {
  lattitude_ = 0;
  clear_has_lattitude();
}
inline double Exif::lattitude() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Exif.lattitude)
  return lattitude_;
}
inline void Exif::set_lattitude(double value) {
  set_has_lattitude();
  lattitude_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Exif.lattitude)
}

// optional uint64 timestamp = 3;
inline bool Exif::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Exif::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Exif::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Exif::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Exif::timestamp() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Exif.timestamp)
  return timestamp_;
}
inline void Exif::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Exif.timestamp)
}

// -------------------------------------------------------------------

// Colors

// optional uint32 CLR_MULTI = 1 [default = 1];
inline bool Colors::has_clr_multi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Colors::set_has_clr_multi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Colors::clear_has_clr_multi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Colors::clear_clr_multi() {
  clr_multi_ = 1u;
  clear_has_clr_multi();
}
inline ::google::protobuf::uint32 Colors::clr_multi() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_MULTI)
  return clr_multi_;
}
inline void Colors::set_clr_multi(::google::protobuf::uint32 value) {
  set_has_clr_multi();
  clr_multi_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_MULTI)
}

// optional uint32 CLR_BW = 2 [default = 2];
inline bool Colors::has_clr_bw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Colors::set_has_clr_bw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Colors::clear_has_clr_bw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Colors::clear_clr_bw() {
  clr_bw_ = 2u;
  clear_has_clr_bw();
}
inline ::google::protobuf::uint32 Colors::clr_bw() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_BW)
  return clr_bw_;
}
inline void Colors::set_clr_bw(::google::protobuf::uint32 value) {
  set_has_clr_bw();
  clr_bw_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_BW)
}

// optional uint32 CLR_RED = 3 [default = 4];
inline bool Colors::has_clr_red() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Colors::set_has_clr_red() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Colors::clear_has_clr_red() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Colors::clear_clr_red() {
  clr_red_ = 4u;
  clear_has_clr_red();
}
inline ::google::protobuf::uint32 Colors::clr_red() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_RED)
  return clr_red_;
}
inline void Colors::set_clr_red(::google::protobuf::uint32 value) {
  set_has_clr_red();
  clr_red_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_RED)
}

// optional uint32 CLR_ORANGE = 4 [default = 8];
inline bool Colors::has_clr_orange() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Colors::set_has_clr_orange() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Colors::clear_has_clr_orange() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Colors::clear_clr_orange() {
  clr_orange_ = 8u;
  clear_has_clr_orange();
}
inline ::google::protobuf::uint32 Colors::clr_orange() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_ORANGE)
  return clr_orange_;
}
inline void Colors::set_clr_orange(::google::protobuf::uint32 value) {
  set_has_clr_orange();
  clr_orange_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_ORANGE)
}

// optional uint32 CLR_YELLOW = 5 [default = 16];
inline bool Colors::has_clr_yellow() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Colors::set_has_clr_yellow() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Colors::clear_has_clr_yellow() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Colors::clear_clr_yellow() {
  clr_yellow_ = 16u;
  clear_has_clr_yellow();
}
inline ::google::protobuf::uint32 Colors::clr_yellow() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_YELLOW)
  return clr_yellow_;
}
inline void Colors::set_clr_yellow(::google::protobuf::uint32 value) {
  set_has_clr_yellow();
  clr_yellow_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_YELLOW)
}

// optional uint32 CLR_GREEN = 6 [default = 32];
inline bool Colors::has_clr_green() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Colors::set_has_clr_green() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Colors::clear_has_clr_green() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Colors::clear_clr_green() {
  clr_green_ = 32u;
  clear_has_clr_green();
}
inline ::google::protobuf::uint32 Colors::clr_green() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_GREEN)
  return clr_green_;
}
inline void Colors::set_clr_green(::google::protobuf::uint32 value) {
  set_has_clr_green();
  clr_green_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_GREEN)
}

// optional uint32 CLR_BLUE = 7 [default = 64];
inline bool Colors::has_clr_blue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Colors::set_has_clr_blue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Colors::clear_has_clr_blue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Colors::clear_clr_blue() {
  clr_blue_ = 64u;
  clear_has_clr_blue();
}
inline ::google::protobuf::uint32 Colors::clr_blue() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_BLUE)
  return clr_blue_;
}
inline void Colors::set_clr_blue(::google::protobuf::uint32 value) {
  set_has_clr_blue();
  clr_blue_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_BLUE)
}

// optional uint32 CLR_CYAN = 8 [default = 128];
inline bool Colors::has_clr_cyan() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Colors::set_has_clr_cyan() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Colors::clear_has_clr_cyan() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Colors::clear_clr_cyan() {
  clr_cyan_ = 128u;
  clear_has_clr_cyan();
}
inline ::google::protobuf::uint32 Colors::clr_cyan() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_CYAN)
  return clr_cyan_;
}
inline void Colors::set_clr_cyan(::google::protobuf::uint32 value) {
  set_has_clr_cyan();
  clr_cyan_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_CYAN)
}

// optional uint32 CLR_PURPLE = 9 [default = 256];
inline bool Colors::has_clr_purple() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Colors::set_has_clr_purple() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Colors::clear_has_clr_purple() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Colors::clear_clr_purple() {
  clr_purple_ = 256u;
  clear_has_clr_purple();
}
inline ::google::protobuf::uint32 Colors::clr_purple() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_PURPLE)
  return clr_purple_;
}
inline void Colors::set_clr_purple(::google::protobuf::uint32 value) {
  set_has_clr_purple();
  clr_purple_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_PURPLE)
}

// optional uint32 CLR_BLACK = 10 [default = 512];
inline bool Colors::has_clr_black() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Colors::set_has_clr_black() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Colors::clear_has_clr_black() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Colors::clear_clr_black() {
  clr_black_ = 512u;
  clear_has_clr_black();
}
inline ::google::protobuf::uint32 Colors::clr_black() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_BLACK)
  return clr_black_;
}
inline void Colors::set_clr_black(::google::protobuf::uint32 value) {
  set_has_clr_black();
  clr_black_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_BLACK)
}

// optional uint32 CLR_WHITE = 11 [default = 1024];
inline bool Colors::has_clr_white() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Colors::set_has_clr_white() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Colors::clear_has_clr_white() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Colors::clear_clr_white() {
  clr_white_ = 1024u;
  clear_has_clr_white();
}
inline ::google::protobuf::uint32 Colors::clr_white() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_WHITE)
  return clr_white_;
}
inline void Colors::set_clr_white(::google::protobuf::uint32 value) {
  set_has_clr_white();
  clr_white_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_WHITE)
}

// optional uint32 CLR_SEPIA = 12 [default = 2048];
inline bool Colors::has_clr_sepia() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Colors::set_has_clr_sepia() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Colors::clear_has_clr_sepia() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Colors::clear_clr_sepia() {
  clr_sepia_ = 2048u;
  clear_has_clr_sepia();
}
inline ::google::protobuf::uint32 Colors::clr_sepia() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Colors.CLR_SEPIA)
  return clr_sepia_;
}
inline void Colors::set_clr_sepia(::google::protobuf::uint32 value) {
  set_has_clr_sepia();
  clr_sepia_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Colors.CLR_SEPIA)
}

// -------------------------------------------------------------------

// Rect

// required uint32 x = 1;
inline bool Rect::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rect::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rect::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 Rect::x() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Rect.x)
  return x_;
}
inline void Rect::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Rect.x)
}

// required uint32 y = 2;
inline bool Rect::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rect::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rect::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 Rect::y() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Rect.y)
  return y_;
}
inline void Rect::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Rect.y)
}

// required uint32 width = 3;
inline bool Rect::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rect::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rect::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rect::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Rect::width() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Rect.width)
  return width_;
}
inline void Rect::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Rect.width)
}

// required uint32 height = 4;
inline bool Rect::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rect::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rect::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Rect::height() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Rect.height)
  return height_;
}
inline void Rect::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Rect.height)
}

// -------------------------------------------------------------------

// RectArray

// repeated .ru.mail.go.webbase.parsing.img.Rect rect = 1;
inline int RectArray::rect_size() const {
  return rect_.size();
}
inline void RectArray::clear_rect() {
  rect_.Clear();
}
inline const ::ru::mail::go::webbase::parsing::img::Rect& RectArray::rect(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.RectArray.rect)
  return rect_.Get(index);
}
inline ::ru::mail::go::webbase::parsing::img::Rect* RectArray::mutable_rect(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.RectArray.rect)
  return rect_.Mutable(index);
}
inline ::ru::mail::go::webbase::parsing::img::Rect* RectArray::add_rect() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.parsing.img.RectArray.rect)
  return rect_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Rect >*
RectArray::mutable_rect() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.parsing.img.RectArray.rect)
  return &rect_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Rect >&
RectArray::rect() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.parsing.img.RectArray.rect)
  return rect_;
}

// -------------------------------------------------------------------

// CvFeatures

// optional .ru.mail.go.webbase.parsing.img.RectArray faces = 1;
inline bool CvFeatures::has_faces() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CvFeatures::set_has_faces() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CvFeatures::clear_has_faces() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CvFeatures::clear_faces() {
  if (faces_ != NULL) faces_->::ru::mail::go::webbase::parsing::img::RectArray::Clear();
  clear_has_faces();
}
inline const ::ru::mail::go::webbase::parsing::img::RectArray& CvFeatures::faces() const {
  const ::ru::mail::go::webbase::parsing::img::RectArray* p = faces_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.CvFeatures.faces)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::RectArray*>(
      &::ru::mail::go::webbase::parsing::img::_RectArray_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::RectArray* CvFeatures::mutable_faces() {
  set_has_faces();
  if (faces_ == NULL) {
    faces_ = new ::ru::mail::go::webbase::parsing::img::RectArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.CvFeatures.faces)
  return faces_;
}
inline ::ru::mail::go::webbase::parsing::img::RectArray* CvFeatures::release_faces() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.CvFeatures.faces)
  clear_has_faces();
  ::ru::mail::go::webbase::parsing::img::RectArray* temp = faces_;
  faces_ = NULL;
  return temp;
}
inline void CvFeatures::set_allocated_faces(::ru::mail::go::webbase::parsing::img::RectArray* faces) {
  delete faces_;
  faces_ = faces;
  if (faces) {
    set_has_faces();
  } else {
    clear_has_faces();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.CvFeatures.faces)
}

// optional double quality = 2;
inline bool CvFeatures::has_quality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CvFeatures::set_has_quality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CvFeatures::clear_has_quality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CvFeatures::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline double CvFeatures::quality() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.CvFeatures.quality)
  return quality_;
}
inline void CvFeatures::set_quality(double value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.CvFeatures.quality)
}

// optional double entropy = 3;
inline bool CvFeatures::has_entropy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CvFeatures::set_has_entropy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CvFeatures::clear_has_entropy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CvFeatures::clear_entropy() {
  entropy_ = 0;
  clear_has_entropy();
}
inline double CvFeatures::entropy() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.CvFeatures.entropy)
  return entropy_;
}
inline void CvFeatures::set_entropy(double value) {
  set_has_entropy();
  entropy_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.CvFeatures.entropy)
}

// optional .ru.mail.go.webbase.parsing.img.RectArray textboxes = 4;
inline bool CvFeatures::has_textboxes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CvFeatures::set_has_textboxes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CvFeatures::clear_has_textboxes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CvFeatures::clear_textboxes() {
  if (textboxes_ != NULL) textboxes_->::ru::mail::go::webbase::parsing::img::RectArray::Clear();
  clear_has_textboxes();
}
inline const ::ru::mail::go::webbase::parsing::img::RectArray& CvFeatures::textboxes() const {
  const ::ru::mail::go::webbase::parsing::img::RectArray* p = textboxes_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.CvFeatures.textboxes)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::RectArray*>(
      &::ru::mail::go::webbase::parsing::img::_RectArray_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::RectArray* CvFeatures::mutable_textboxes() {
  set_has_textboxes();
  if (textboxes_ == NULL) {
    textboxes_ = new ::ru::mail::go::webbase::parsing::img::RectArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.CvFeatures.textboxes)
  return textboxes_;
}
inline ::ru::mail::go::webbase::parsing::img::RectArray* CvFeatures::release_textboxes() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.CvFeatures.textboxes)
  clear_has_textboxes();
  ::ru::mail::go::webbase::parsing::img::RectArray* temp = textboxes_;
  textboxes_ = NULL;
  return temp;
}
inline void CvFeatures::set_allocated_textboxes(::ru::mail::go::webbase::parsing::img::RectArray* textboxes) {
  delete textboxes_;
  textboxes_ = textboxes;
  if (textboxes) {
    set_has_textboxes();
  } else {
    clear_has_textboxes();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.CvFeatures.textboxes)
}

// -------------------------------------------------------------------

// Thumb

// required bytes pic = 1;
inline bool Thumb::has_pic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Thumb::set_has_pic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Thumb::clear_has_pic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Thumb::clear_pic() {
  pic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pic();
}
inline const ::std::string& Thumb::pic() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Thumb.pic)
  return pic_.GetNoArena();
}
inline void Thumb::set_pic(const ::std::string& value) {
  set_has_pic();
  pic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Thumb.pic)
}
#if LANG_CXX11
inline void Thumb::set_pic(::std::string&& value) {
  set_has_pic();
  pic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.parsing.img.Thumb.pic)
}
#endif
inline void Thumb::set_pic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pic();
  pic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.parsing.img.Thumb.pic)
}
inline void Thumb::set_pic(const void* value, size_t size) {
  set_has_pic();
  pic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.parsing.img.Thumb.pic)
}
inline ::std::string* Thumb::mutable_pic() {
  set_has_pic();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.Thumb.pic)
  return pic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Thumb::release_pic() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.Thumb.pic)
  clear_has_pic();
  return pic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Thumb::set_allocated_pic(::std::string* pic) {
  if (pic != NULL) {
    set_has_pic();
  } else {
    clear_has_pic();
  }
  pic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pic);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.Thumb.pic)
}

// required uint32 width = 2;
inline bool Thumb::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Thumb::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Thumb::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Thumb::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Thumb::width() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Thumb.width)
  return width_;
}
inline void Thumb::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Thumb.width)
}

// required uint32 height = 3;
inline bool Thumb::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Thumb::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Thumb::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Thumb::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Thumb::height() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Thumb.height)
  return height_;
}
inline void Thumb::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Thumb.height)
}

// required .ru.mail.go.webbase.parsing.img.ImageFormat format = 4;
inline bool Thumb::has_format() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Thumb::set_has_format() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Thumb::clear_has_format() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Thumb::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::ru::mail::go::webbase::parsing::img::ImageFormat Thumb::format() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Thumb.format)
  return static_cast< ::ru::mail::go::webbase::parsing::img::ImageFormat >(format_);
}
inline void Thumb::set_format(::ru::mail::go::webbase::parsing::img::ImageFormat value) {
  assert(::ru::mail::go::webbase::parsing::img::ImageFormat_IsValid(value));
  set_has_format();
  format_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Thumb.format)
}

// optional string url = 6;
inline bool Thumb::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Thumb::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Thumb::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Thumb::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& Thumb::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Thumb.url)
  return url_.GetNoArena();
}
inline void Thumb::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Thumb.url)
}
#if LANG_CXX11
inline void Thumb::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.parsing.img.Thumb.url)
}
#endif
inline void Thumb::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.parsing.img.Thumb.url)
}
inline void Thumb::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.parsing.img.Thumb.url)
}
inline ::std::string* Thumb::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.Thumb.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Thumb::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.Thumb.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Thumb::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.Thumb.url)
}

// optional .ru.mail.go.webbase.parsing.img.CvFeatures features = 7;
inline bool Thumb::has_features() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Thumb::set_has_features() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Thumb::clear_has_features() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Thumb::clear_features() {
  if (features_ != NULL) features_->::ru::mail::go::webbase::parsing::img::CvFeatures::Clear();
  clear_has_features();
}
inline const ::ru::mail::go::webbase::parsing::img::CvFeatures& Thumb::features() const {
  const ::ru::mail::go::webbase::parsing::img::CvFeatures* p = features_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Thumb.features)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::CvFeatures*>(
      &::ru::mail::go::webbase::parsing::img::_CvFeatures_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::CvFeatures* Thumb::mutable_features() {
  set_has_features();
  if (features_ == NULL) {
    features_ = new ::ru::mail::go::webbase::parsing::img::CvFeatures;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.Thumb.features)
  return features_;
}
inline ::ru::mail::go::webbase::parsing::img::CvFeatures* Thumb::release_features() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.Thumb.features)
  clear_has_features();
  ::ru::mail::go::webbase::parsing::img::CvFeatures* temp = features_;
  features_ = NULL;
  return temp;
}
inline void Thumb::set_allocated_features(::ru::mail::go::webbase::parsing::img::CvFeatures* features) {
  delete features_;
  features_ = features;
  if (features) {
    set_has_features();
  } else {
    clear_has_features();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.Thumb.features)
}

// optional bool animated = 8;
inline bool Thumb::has_animated() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Thumb::set_has_animated() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Thumb::clear_has_animated() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Thumb::clear_animated() {
  animated_ = false;
  clear_has_animated();
}
inline bool Thumb::animated() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Thumb.animated)
  return animated_;
}
inline void Thumb::set_animated(bool value) {
  set_has_animated();
  animated_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Thumb.animated)
}

// optional uint32 originalWidth = 9;
inline bool Thumb::has_originalwidth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Thumb::set_has_originalwidth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Thumb::clear_has_originalwidth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Thumb::clear_originalwidth() {
  originalwidth_ = 0u;
  clear_has_originalwidth();
}
inline ::google::protobuf::uint32 Thumb::originalwidth() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Thumb.originalWidth)
  return originalwidth_;
}
inline void Thumb::set_originalwidth(::google::protobuf::uint32 value) {
  set_has_originalwidth();
  originalwidth_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Thumb.originalWidth)
}

// optional uint32 originalHeight = 10;
inline bool Thumb::has_originalheight() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Thumb::set_has_originalheight() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Thumb::clear_has_originalheight() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Thumb::clear_originalheight() {
  originalheight_ = 0u;
  clear_has_originalheight();
}
inline ::google::protobuf::uint32 Thumb::originalheight() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Thumb.originalHeight)
  return originalheight_;
}
inline void Thumb::set_originalheight(::google::protobuf::uint32 value) {
  set_has_originalheight();
  originalheight_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Thumb.originalHeight)
}

// -------------------------------------------------------------------

// ThumbWithQueries

// optional .ru.mail.go.webbase.parsing.img.Thumb thumb = 1;
inline bool ThumbWithQueries::has_thumb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThumbWithQueries::set_has_thumb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThumbWithQueries::clear_has_thumb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThumbWithQueries::clear_thumb() {
  if (thumb_ != NULL) thumb_->::ru::mail::go::webbase::parsing::img::Thumb::Clear();
  clear_has_thumb();
}
inline const ::ru::mail::go::webbase::parsing::img::Thumb& ThumbWithQueries::thumb() const {
  const ::ru::mail::go::webbase::parsing::img::Thumb* p = thumb_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.ThumbWithQueries.thumb)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::Thumb*>(
      &::ru::mail::go::webbase::parsing::img::_Thumb_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ThumbWithQueries::mutable_thumb() {
  set_has_thumb();
  if (thumb_ == NULL) {
    thumb_ = new ::ru::mail::go::webbase::parsing::img::Thumb;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.ThumbWithQueries.thumb)
  return thumb_;
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ThumbWithQueries::release_thumb() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.ThumbWithQueries.thumb)
  clear_has_thumb();
  ::ru::mail::go::webbase::parsing::img::Thumb* temp = thumb_;
  thumb_ = NULL;
  return temp;
}
inline void ThumbWithQueries::set_allocated_thumb(::ru::mail::go::webbase::parsing::img::Thumb* thumb) {
  delete thumb_;
  thumb_ = thumb;
  if (thumb) {
    set_has_thumb();
  } else {
    clear_has_thumb();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.ThumbWithQueries.thumb)
}

// repeated string queries = 2;
inline int ThumbWithQueries::queries_size() const {
  return queries_.size();
}
inline void ThumbWithQueries::clear_queries() {
  queries_.Clear();
}
inline const ::std::string& ThumbWithQueries::queries(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
  return queries_.Get(index);
}
inline ::std::string* ThumbWithQueries::mutable_queries(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
  return queries_.Mutable(index);
}
inline void ThumbWithQueries::set_queries(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
  queries_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ThumbWithQueries::set_queries(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
  queries_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ThumbWithQueries::set_queries(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  queries_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
}
inline void ThumbWithQueries::set_queries(int index, const char* value, size_t size) {
  queries_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
}
inline ::std::string* ThumbWithQueries::add_queries() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
  return queries_.Add();
}
inline void ThumbWithQueries::add_queries(const ::std::string& value) {
  queries_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
}
#if LANG_CXX11
inline void ThumbWithQueries::add_queries(::std::string&& value) {
  queries_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
}
#endif
inline void ThumbWithQueries::add_queries(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  queries_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
}
inline void ThumbWithQueries::add_queries(const char* value, size_t size) {
  queries_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ThumbWithQueries::queries() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
  return queries_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ThumbWithQueries::mutable_queries() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.parsing.img.ThumbWithQueries.queries)
  return &queries_;
}

// -------------------------------------------------------------------

// VideoClip

// required bytes clip = 1;
inline bool VideoClip::has_clip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoClip::set_has_clip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoClip::clear_has_clip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoClip::clear_clip() {
  clip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clip();
}
inline const ::std::string& VideoClip::clip() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.VideoClip.clip)
  return clip_.GetNoArena();
}
inline void VideoClip::set_clip(const ::std::string& value) {
  set_has_clip();
  clip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.VideoClip.clip)
}
#if LANG_CXX11
inline void VideoClip::set_clip(::std::string&& value) {
  set_has_clip();
  clip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.parsing.img.VideoClip.clip)
}
#endif
inline void VideoClip::set_clip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clip();
  clip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.parsing.img.VideoClip.clip)
}
inline void VideoClip::set_clip(const void* value, size_t size) {
  set_has_clip();
  clip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.parsing.img.VideoClip.clip)
}
inline ::std::string* VideoClip::mutable_clip() {
  set_has_clip();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.VideoClip.clip)
  return clip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoClip::release_clip() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.VideoClip.clip)
  clear_has_clip();
  return clip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoClip::set_allocated_clip(::std::string* clip) {
  if (clip != NULL) {
    set_has_clip();
  } else {
    clear_has_clip();
  }
  clip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clip);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.VideoClip.clip)
}

// required uint32 width = 2;
inline bool VideoClip::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoClip::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoClip::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoClip::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 VideoClip::width() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.VideoClip.width)
  return width_;
}
inline void VideoClip::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.VideoClip.width)
}

// required uint32 height = 3;
inline bool VideoClip::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VideoClip::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VideoClip::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VideoClip::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 VideoClip::height() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.VideoClip.height)
  return height_;
}
inline void VideoClip::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.VideoClip.height)
}

// required uint32 length = 4;
inline bool VideoClip::has_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VideoClip::set_has_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VideoClip::clear_has_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VideoClip::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 VideoClip::length() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.VideoClip.length)
  return length_;
}
inline void VideoClip::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.VideoClip.length)
}

// required .ru.mail.go.webbase.parsing.img.VideoClip.VideoCodec codec = 5;
inline bool VideoClip::has_codec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VideoClip::set_has_codec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VideoClip::clear_has_codec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VideoClip::clear_codec() {
  codec_ = 0;
  clear_has_codec();
}
inline ::ru::mail::go::webbase::parsing::img::VideoClip_VideoCodec VideoClip::codec() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.VideoClip.codec)
  return static_cast< ::ru::mail::go::webbase::parsing::img::VideoClip_VideoCodec >(codec_);
}
inline void VideoClip::set_codec(::ru::mail::go::webbase::parsing::img::VideoClip_VideoCodec value) {
  assert(::ru::mail::go::webbase::parsing::img::VideoClip_VideoCodec_IsValid(value));
  set_has_codec();
  codec_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.VideoClip.codec)
}

// required .ru.mail.go.webbase.parsing.img.VideoClip.VideoContainer container = 6;
inline bool VideoClip::has_container() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VideoClip::set_has_container() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VideoClip::clear_has_container() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VideoClip::clear_container() {
  container_ = 0;
  clear_has_container();
}
inline ::ru::mail::go::webbase::parsing::img::VideoClip_VideoContainer VideoClip::container() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.VideoClip.container)
  return static_cast< ::ru::mail::go::webbase::parsing::img::VideoClip_VideoContainer >(container_);
}
inline void VideoClip::set_container(::ru::mail::go::webbase::parsing::img::VideoClip_VideoContainer value) {
  assert(::ru::mail::go::webbase::parsing::img::VideoClip_VideoContainer_IsValid(value));
  set_has_container();
  container_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.VideoClip.container)
}

// optional string url = 7;
inline bool VideoClip::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoClip::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoClip::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoClip::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& VideoClip::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.VideoClip.url)
  return url_.GetNoArena();
}
inline void VideoClip::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.VideoClip.url)
}
#if LANG_CXX11
inline void VideoClip::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.parsing.img.VideoClip.url)
}
#endif
inline void VideoClip::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.parsing.img.VideoClip.url)
}
inline void VideoClip::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.parsing.img.VideoClip.url)
}
inline ::std::string* VideoClip::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.VideoClip.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoClip::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.VideoClip.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoClip::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.VideoClip.url)
}

// -------------------------------------------------------------------

// ClusterSeed

// repeated uint64 hash = 1;
inline int ClusterSeed::hash_size() const {
  return hash_.size();
}
inline void ClusterSeed::clear_hash() {
  hash_.Clear();
}
inline ::google::protobuf::uint64 ClusterSeed::hash(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.ClusterSeed.hash)
  return hash_.Get(index);
}
inline void ClusterSeed::set_hash(int index, ::google::protobuf::uint64 value) {
  hash_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.ClusterSeed.hash)
}
inline void ClusterSeed::add_hash(::google::protobuf::uint64 value) {
  hash_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.parsing.img.ClusterSeed.hash)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ClusterSeed::hash() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.parsing.img.ClusterSeed.hash)
  return hash_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ClusterSeed::mutable_hash() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.parsing.img.ClusterSeed.hash)
  return &hash_;
}

// -------------------------------------------------------------------

// Cluster

// required uint64 id = 1;
inline bool Cluster::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cluster::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cluster::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cluster::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Cluster::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Cluster.id)
  return id_;
}
inline void Cluster::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Cluster.id)
}

// repeated uint64 hash = 2;
inline int Cluster::hash_size() const {
  return hash_.size();
}
inline void Cluster::clear_hash() {
  hash_.Clear();
}
inline ::google::protobuf::uint64 Cluster::hash(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Cluster.hash)
  return hash_.Get(index);
}
inline void Cluster::set_hash(int index, ::google::protobuf::uint64 value) {
  hash_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Cluster.hash)
}
inline void Cluster::add_hash(::google::protobuf::uint64 value) {
  hash_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.parsing.img.Cluster.hash)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Cluster::hash() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.parsing.img.Cluster.hash)
  return hash_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Cluster::mutable_hash() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.parsing.img.Cluster.hash)
  return &hash_;
}

// -------------------------------------------------------------------

// HashId

// required uint64 hash = 1;
inline bool HashId::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HashId::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HashId::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HashId::clear_hash() {
  hash_ = GOOGLE_ULONGLONG(0);
  clear_has_hash();
}
inline ::google::protobuf::uint64 HashId::hash() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.HashId.hash)
  return hash_;
}
inline void HashId::set_hash(::google::protobuf::uint64 value) {
  set_has_hash();
  hash_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.HashId.hash)
}

// required uint64 id = 2;
inline bool HashId::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HashId::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HashId::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HashId::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 HashId::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.HashId.id)
  return id_;
}
inline void HashId::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.HashId.id)
}

// -------------------------------------------------------------------

// IdOrRow

// optional uint64 id = 1;
inline bool IdOrRow::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IdOrRow::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IdOrRow::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IdOrRow::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 IdOrRow::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.IdOrRow.id)
  return id_;
}
inline void IdOrRow::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.IdOrRow.id)
}

// optional bytes row = 2;
inline bool IdOrRow::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IdOrRow::set_has_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IdOrRow::clear_has_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IdOrRow::clear_row() {
  row_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_row();
}
inline const ::std::string& IdOrRow::row() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.IdOrRow.row)
  return row_.GetNoArena();
}
inline void IdOrRow::set_row(const ::std::string& value) {
  set_has_row();
  row_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.IdOrRow.row)
}
#if LANG_CXX11
inline void IdOrRow::set_row(::std::string&& value) {
  set_has_row();
  row_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.parsing.img.IdOrRow.row)
}
#endif
inline void IdOrRow::set_row(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_row();
  row_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.parsing.img.IdOrRow.row)
}
inline void IdOrRow::set_row(const void* value, size_t size) {
  set_has_row();
  row_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.parsing.img.IdOrRow.row)
}
inline ::std::string* IdOrRow::mutable_row() {
  set_has_row();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.IdOrRow.row)
  return row_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdOrRow::release_row() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.IdOrRow.row)
  clear_has_row();
  return row_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdOrRow::set_allocated_row(::std::string* row) {
  if (row != NULL) {
    set_has_row();
  } else {
    clear_has_row();
  }
  row_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), row);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.IdOrRow.row)
}

// -------------------------------------------------------------------

// RowCluster

// required uint64 id = 1;
inline bool RowCluster::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RowCluster::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RowCluster::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RowCluster::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 RowCluster::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.RowCluster.id)
  return id_;
}
inline void RowCluster::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.RowCluster.id)
}

// repeated bytes row = 2;
inline int RowCluster::row_size() const {
  return row_.size();
}
inline void RowCluster::clear_row() {
  row_.Clear();
}
inline const ::std::string& RowCluster::row(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.RowCluster.row)
  return row_.Get(index);
}
inline ::std::string* RowCluster::mutable_row(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.RowCluster.row)
  return row_.Mutable(index);
}
inline void RowCluster::set_row(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.RowCluster.row)
  row_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RowCluster::set_row(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.RowCluster.row)
  row_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RowCluster::set_row(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  row_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.parsing.img.RowCluster.row)
}
inline void RowCluster::set_row(int index, const void* value, size_t size) {
  row_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.parsing.img.RowCluster.row)
}
inline ::std::string* RowCluster::add_row() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.parsing.img.RowCluster.row)
  return row_.Add();
}
inline void RowCluster::add_row(const ::std::string& value) {
  row_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.parsing.img.RowCluster.row)
}
#if LANG_CXX11
inline void RowCluster::add_row(::std::string&& value) {
  row_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.parsing.img.RowCluster.row)
}
#endif
inline void RowCluster::add_row(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  row_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.parsing.img.RowCluster.row)
}
inline void RowCluster::add_row(const void* value, size_t size) {
  row_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.parsing.img.RowCluster.row)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RowCluster::row() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.parsing.img.RowCluster.row)
  return row_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RowCluster::mutable_row() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.parsing.img.RowCluster.row)
  return &row_;
}

// -------------------------------------------------------------------

// Duplicate

// required uint64 id = 1;
inline bool Duplicate::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Duplicate::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Duplicate::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Duplicate::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Duplicate::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Duplicate.id)
  return id_;
}
inline void Duplicate::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Duplicate.id)
}

// required string row = 2;
inline bool Duplicate::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Duplicate::set_has_row() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Duplicate::clear_has_row() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Duplicate::clear_row() {
  row_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_row();
}
inline const ::std::string& Duplicate::row() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Duplicate.row)
  return row_.GetNoArena();
}
inline void Duplicate::set_row(const ::std::string& value) {
  set_has_row();
  row_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.parsing.img.Duplicate.row)
}
#if LANG_CXX11
inline void Duplicate::set_row(::std::string&& value) {
  set_has_row();
  row_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.parsing.img.Duplicate.row)
}
#endif
inline void Duplicate::set_row(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_row();
  row_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.parsing.img.Duplicate.row)
}
inline void Duplicate::set_row(const char* value, size_t size) {
  set_has_row();
  row_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.parsing.img.Duplicate.row)
}
inline ::std::string* Duplicate::mutable_row() {
  set_has_row();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.Duplicate.row)
  return row_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Duplicate::release_row() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.Duplicate.row)
  clear_has_row();
  return row_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Duplicate::set_allocated_row(::std::string* row) {
  if (row != NULL) {
    set_has_row();
  } else {
    clear_has_row();
  }
  row_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), row);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.Duplicate.row)
}

// required .ru.mail.go.webbase.parsing.img.Thumb thumb = 3;
inline bool Duplicate::has_thumb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Duplicate::set_has_thumb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Duplicate::clear_has_thumb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Duplicate::clear_thumb() {
  if (thumb_ != NULL) thumb_->::ru::mail::go::webbase::parsing::img::Thumb::Clear();
  clear_has_thumb();
}
inline const ::ru::mail::go::webbase::parsing::img::Thumb& Duplicate::thumb() const {
  const ::ru::mail::go::webbase::parsing::img::Thumb* p = thumb_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.Duplicate.thumb)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::Thumb*>(
      &::ru::mail::go::webbase::parsing::img::_Thumb_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* Duplicate::mutable_thumb() {
  set_has_thumb();
  if (thumb_ == NULL) {
    thumb_ = new ::ru::mail::go::webbase::parsing::img::Thumb;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.Duplicate.thumb)
  return thumb_;
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* Duplicate::release_thumb() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.Duplicate.thumb)
  clear_has_thumb();
  ::ru::mail::go::webbase::parsing::img::Thumb* temp = thumb_;
  thumb_ = NULL;
  return temp;
}
inline void Duplicate::set_allocated_thumb(::ru::mail::go::webbase::parsing::img::Thumb* thumb) {
  delete thumb_;
  thumb_ = thumb;
  if (thumb) {
    set_has_thumb();
  } else {
    clear_has_thumb();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.Duplicate.thumb)
}

// -------------------------------------------------------------------

// SerpSimilar

// required .ru.mail.go.webbase.parsing.img.Thumb query = 1;
inline bool SerpSimilar::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SerpSimilar::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SerpSimilar::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SerpSimilar::clear_query() {
  if (query_ != NULL) query_->::ru::mail::go::webbase::parsing::img::Thumb::Clear();
  clear_has_query();
}
inline const ::ru::mail::go::webbase::parsing::img::Thumb& SerpSimilar::query() const {
  const ::ru::mail::go::webbase::parsing::img::Thumb* p = query_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.SerpSimilar.query)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::Thumb*>(
      &::ru::mail::go::webbase::parsing::img::_Thumb_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* SerpSimilar::mutable_query() {
  set_has_query();
  if (query_ == NULL) {
    query_ = new ::ru::mail::go::webbase::parsing::img::Thumb;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.SerpSimilar.query)
  return query_;
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* SerpSimilar::release_query() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.parsing.img.SerpSimilar.query)
  clear_has_query();
  ::ru::mail::go::webbase::parsing::img::Thumb* temp = query_;
  query_ = NULL;
  return temp;
}
inline void SerpSimilar::set_allocated_query(::ru::mail::go::webbase::parsing::img::Thumb* query) {
  delete query_;
  query_ = query;
  if (query) {
    set_has_query();
  } else {
    clear_has_query();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.parsing.img.SerpSimilar.query)
}

// repeated .ru.mail.go.webbase.parsing.img.Thumb serp = 2;
inline int SerpSimilar::serp_size() const {
  return serp_.size();
}
inline void SerpSimilar::clear_serp() {
  serp_.Clear();
}
inline const ::ru::mail::go::webbase::parsing::img::Thumb& SerpSimilar::serp(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.parsing.img.SerpSimilar.serp)
  return serp_.Get(index);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* SerpSimilar::mutable_serp(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.parsing.img.SerpSimilar.serp)
  return serp_.Mutable(index);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* SerpSimilar::add_serp() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.parsing.img.SerpSimilar.serp)
  return serp_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >*
SerpSimilar::mutable_serp() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.parsing.img.SerpSimilar.serp)
  return &serp_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >&
SerpSimilar::serp() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.parsing.img.SerpSimilar.serp)
  return serp_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace img
}  // namespace parsing
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::webbase::parsing::img::VideoClip_VideoCodec> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::parsing::img::VideoClip_VideoCodec>() {
  return ::ru::mail::go::webbase::parsing::img::VideoClip_VideoCodec_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::parsing::img::VideoClip_VideoContainer> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::parsing::img::VideoClip_VideoContainer>() {
  return ::ru::mail::go::webbase::parsing::img::VideoClip_VideoContainer_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::parsing::img::ImageFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::parsing::img::ImageFormat>() {
  return ::ru::mail::go::webbase::parsing::img::ImageFormat_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::parsing::img::ImageClass> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::parsing::img::ImageClass>() {
  return ::ru::mail::go::webbase::parsing::img::ImageClass_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::parsing::img::Interpolation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::parsing::img::Interpolation>() {
  return ::ru::mail::go::webbase::parsing::img::Interpolation_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::parsing::img::BorderType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::parsing::img::BorderType>() {
  return ::ru::mail::go::webbase::parsing::img::BorderType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_image_5fdefs_2eproto__INCLUDED
