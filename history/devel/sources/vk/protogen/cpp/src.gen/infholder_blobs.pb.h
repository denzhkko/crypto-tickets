// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: infholder_blobs.proto

#ifndef PROTOBUF_infholder_5fblobs_2eproto__INCLUDED
#define PROTOBUF_infholder_5fblobs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sekitei.pb.h"
#include "doc_parser.pb.h"
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {
class CleanDoc;
class CleanDocDefaultTypeInternal;
extern CleanDocDefaultTypeInternal _CleanDoc_default_instance_;
class NavigLink;
class NavigLinkDefaultTypeInternal;
extern NavigLinkDefaultTypeInternal _NavigLink_default_instance_;
class TransferDoc;
class TransferDocDefaultTypeInternal;
extern TransferDocDefaultTypeInternal _TransferDoc_default_instance_;
class infholderBlob;
class infholderBlobDefaultTypeInternal;
extern infholderBlobDefaultTypeInternal _infholderBlob_default_instance_;
}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {

namespace protobuf_infholder_5fblobs_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_infholder_5fblobs_2eproto

enum TransferDoc_transferType {
  TransferDoc_transferType_host = 1,
  TransferDoc_transferType_page = 2
};
bool TransferDoc_transferType_IsValid(int value);
const TransferDoc_transferType TransferDoc_transferType_transferType_MIN = TransferDoc_transferType_host;
const TransferDoc_transferType TransferDoc_transferType_transferType_MAX = TransferDoc_transferType_page;
const int TransferDoc_transferType_transferType_ARRAYSIZE = TransferDoc_transferType_transferType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransferDoc_transferType_descriptor();
inline const ::std::string& TransferDoc_transferType_Name(TransferDoc_transferType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransferDoc_transferType_descriptor(), value);
}
inline bool TransferDoc_transferType_Parse(
    const ::std::string& name, TransferDoc_transferType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransferDoc_transferType>(
    TransferDoc_transferType_descriptor(), name, value);
}
enum infholderBlob_InfholderState {
  infholderBlob_InfholderState_ok = 1,
  infholderBlob_InfholderState_cut_all = 2,
  infholderBlob_InfholderState_error = 3
};
bool infholderBlob_InfholderState_IsValid(int value);
const infholderBlob_InfholderState infholderBlob_InfholderState_InfholderState_MIN = infholderBlob_InfholderState_ok;
const infholderBlob_InfholderState infholderBlob_InfholderState_InfholderState_MAX = infholderBlob_InfholderState_error;
const int infholderBlob_InfholderState_InfholderState_ARRAYSIZE = infholderBlob_InfholderState_InfholderState_MAX + 1;

const ::google::protobuf::EnumDescriptor* infholderBlob_InfholderState_descriptor();
inline const ::std::string& infholderBlob_InfholderState_Name(infholderBlob_InfholderState value) {
  return ::google::protobuf::internal::NameOfEnum(
    infholderBlob_InfholderState_descriptor(), value);
}
inline bool infholderBlob_InfholderState_Parse(
    const ::std::string& name, infholderBlob_InfholderState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<infholderBlob_InfholderState>(
    infholderBlob_InfholderState_descriptor(), name, value);
}
// ===================================================================

class TransferDoc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.TransferDoc) */ {
 public:
  TransferDoc();
  virtual ~TransferDoc();

  TransferDoc(const TransferDoc& from);

  inline TransferDoc& operator=(const TransferDoc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferDoc(TransferDoc&& from) noexcept
    : TransferDoc() {
    *this = ::std::move(from);
  }

  inline TransferDoc& operator=(TransferDoc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferDoc& default_instance();

  static inline const TransferDoc* internal_default_instance() {
    return reinterpret_cast<const TransferDoc*>(
               &_TransferDoc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TransferDoc* other);
  friend void swap(TransferDoc& a, TransferDoc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferDoc* New() const PROTOBUF_FINAL { return New(NULL); }

  TransferDoc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransferDoc& from);
  void MergeFrom(const TransferDoc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransferDoc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TransferDoc_transferType transferType;
  static const transferType host =
    TransferDoc_transferType_host;
  static const transferType page =
    TransferDoc_transferType_page;
  static inline bool transferType_IsValid(int value) {
    return TransferDoc_transferType_IsValid(value);
  }
  static const transferType transferType_MIN =
    TransferDoc_transferType_transferType_MIN;
  static const transferType transferType_MAX =
    TransferDoc_transferType_transferType_MAX;
  static const int transferType_ARRAYSIZE =
    TransferDoc_transferType_transferType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  transferType_descriptor() {
    return TransferDoc_transferType_descriptor();
  }
  static inline const ::std::string& transferType_Name(transferType value) {
    return TransferDoc_transferType_Name(value);
  }
  static inline bool transferType_Parse(const ::std::string& name,
      transferType* value) {
    return TransferDoc_transferType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string base = 3;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 3;
  const ::std::string& base() const;
  void set_base(const ::std::string& value);
  #if LANG_CXX11
  void set_base(::std::string&& value);
  #endif
  void set_base(const char* value);
  void set_base(const char* value, size_t size);
  ::std::string* mutable_base();
  ::std::string* release_base();
  void set_allocated_base(::std::string* base);

  // optional .ru.mail.go.webbase.blobs.OriginalDoc sdd = 2;
  bool has_sdd() const;
  void clear_sdd();
  static const int kSddFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::OriginalDoc& sdd() const;
  ::ru::mail::go::webbase::blobs::OriginalDoc* mutable_sdd();
  ::ru::mail::go::webbase::blobs::OriginalDoc* release_sdd();
  void set_allocated_sdd(::ru::mail::go::webbase::blobs::OriginalDoc* sdd);

  // optional .ru.mail.go.webbase.sekitei.Sekitei_m sm = 4;
  bool has_sm() const;
  void clear_sm();
  static const int kSmFieldNumber = 4;
  const ::ru::mail::go::webbase::sekitei::Sekitei_m& sm() const;
  ::ru::mail::go::webbase::sekitei::Sekitei_m* mutable_sm();
  ::ru::mail::go::webbase::sekitei::Sekitei_m* release_sm();
  void set_allocated_sm(::ru::mail::go::webbase::sekitei::Sekitei_m* sm);

  // required .ru.mail.go.webbase.blobs.TransferDoc.transferType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::TransferDoc_transferType type() const;
  void set_type(::ru::mail::go::webbase::blobs::TransferDoc_transferType value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.TransferDoc)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_sdd();
  void clear_has_sdd();
  void set_has_base();
  void clear_has_base();
  void set_has_sm();
  void clear_has_sm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr base_;
  ::ru::mail::go::webbase::blobs::OriginalDoc* sdd_;
  ::ru::mail::go::webbase::sekitei::Sekitei_m* sm_;
  int type_;
  friend struct protobuf_infholder_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NavigLink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.NavigLink) */ {
 public:
  NavigLink();
  virtual ~NavigLink();

  NavigLink(const NavigLink& from);

  inline NavigLink& operator=(const NavigLink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NavigLink(NavigLink&& from) noexcept
    : NavigLink() {
    *this = ::std::move(from);
  }

  inline NavigLink& operator=(NavigLink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavigLink& default_instance();

  static inline const NavigLink* internal_default_instance() {
    return reinterpret_cast<const NavigLink*>(
               &_NavigLink_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(NavigLink* other);
  friend void swap(NavigLink& a, NavigLink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NavigLink* New() const PROTOBUF_FINAL { return New(NULL); }

  NavigLink* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NavigLink& from);
  void MergeFrom(const NavigLink& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NavigLink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.NavigLink)
 private:
  void set_has_url();
  void clear_has_url();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  friend struct protobuf_infholder_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CleanDoc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.CleanDoc) */ {
 public:
  CleanDoc();
  virtual ~CleanDoc();

  CleanDoc(const CleanDoc& from);

  inline CleanDoc& operator=(const CleanDoc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CleanDoc(CleanDoc&& from) noexcept
    : CleanDoc() {
    *this = ::std::move(from);
  }

  inline CleanDoc& operator=(CleanDoc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CleanDoc& default_instance();

  static inline const CleanDoc* internal_default_instance() {
    return reinterpret_cast<const CleanDoc*>(
               &_CleanDoc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(CleanDoc* other);
  friend void swap(CleanDoc& a, CleanDoc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CleanDoc* New() const PROTOBUF_FINAL { return New(NULL); }

  CleanDoc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CleanDoc& from);
  void MergeFrom(const CleanDoc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CleanDoc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.NavigLink navig_urls = 4;
  int navig_urls_size() const;
  void clear_navig_urls();
  static const int kNavigUrlsFieldNumber = 4;
  const ::ru::mail::go::webbase::blobs::NavigLink& navig_urls(int index) const;
  ::ru::mail::go::webbase::blobs::NavigLink* mutable_navig_urls(int index);
  ::ru::mail::go::webbase::blobs::NavigLink* add_navig_urls();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::NavigLink >*
      mutable_navig_urls();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::NavigLink >&
      navig_urls() const;

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional .ru.mail.go.webbase.blobs.RegionBlob data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::RegionBlob& data() const;
  ::ru::mail::go::webbase::blobs::RegionBlob* mutable_data();
  ::ru::mail::go::webbase::blobs::RegionBlob* release_data();
  void set_allocated_data(::ru::mail::go::webbase::blobs::RegionBlob* data);

  // optional .ru.mail.go.webbase.blobs.RegionBlob clean_data = 3;
  bool has_clean_data() const;
  void clear_clean_data();
  static const int kCleanDataFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::RegionBlob& clean_data() const;
  ::ru::mail::go::webbase::blobs::RegionBlob* mutable_clean_data();
  ::ru::mail::go::webbase::blobs::RegionBlob* release_clean_data();
  void set_allocated_clean_data(::ru::mail::go::webbase::blobs::RegionBlob* clean_data);

  // optional int32 num = 5;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 5;
  ::google::protobuf::int32 num() const;
  void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.CleanDoc)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_data();
  void clear_has_data();
  void set_has_clean_data();
  void clear_has_clean_data();
  void set_has_num();
  void clear_has_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::NavigLink > navig_urls_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::ru::mail::go::webbase::blobs::RegionBlob* data_;
  ::ru::mail::go::webbase::blobs::RegionBlob* clean_data_;
  ::google::protobuf::int32 num_;
  friend struct protobuf_infholder_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class infholderBlob : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.infholderBlob) */ {
 public:
  infholderBlob();
  virtual ~infholderBlob();

  infholderBlob(const infholderBlob& from);

  inline infholderBlob& operator=(const infholderBlob& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  infholderBlob(infholderBlob&& from) noexcept
    : infholderBlob() {
    *this = ::std::move(from);
  }

  inline infholderBlob& operator=(infholderBlob&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const infholderBlob& default_instance();

  static inline const infholderBlob* internal_default_instance() {
    return reinterpret_cast<const infholderBlob*>(
               &_infholderBlob_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(infholderBlob* other);
  friend void swap(infholderBlob& a, infholderBlob& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline infholderBlob* New() const PROTOBUF_FINAL { return New(NULL); }

  infholderBlob* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const infholderBlob& from);
  void MergeFrom(const infholderBlob& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(infholderBlob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef infholderBlob_InfholderState InfholderState;
  static const InfholderState ok =
    infholderBlob_InfholderState_ok;
  static const InfholderState cut_all =
    infholderBlob_InfholderState_cut_all;
  static const InfholderState error =
    infholderBlob_InfholderState_error;
  static inline bool InfholderState_IsValid(int value) {
    return infholderBlob_InfholderState_IsValid(value);
  }
  static const InfholderState InfholderState_MIN =
    infholderBlob_InfholderState_InfholderState_MIN;
  static const InfholderState InfholderState_MAX =
    infholderBlob_InfholderState_InfholderState_MAX;
  static const int InfholderState_ARRAYSIZE =
    infholderBlob_InfholderState_InfholderState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  InfholderState_descriptor() {
    return infholderBlob_InfholderState_descriptor();
  }
  static inline const ::std::string& InfholderState_Name(InfholderState value) {
    return infholderBlob_InfholderState_Name(value);
  }
  static inline bool InfholderState_Parse(const ::std::string& name,
      InfholderState* value) {
    return infholderBlob_InfholderState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.CleanDoc docs = 1;
  int docs_size() const;
  void clear_docs();
  static const int kDocsFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::CleanDoc& docs(int index) const;
  ::ru::mail::go::webbase::blobs::CleanDoc* mutable_docs(int index);
  ::ru::mail::go::webbase::blobs::CleanDoc* add_docs();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::CleanDoc >*
      mutable_docs();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::CleanDoc >&
      docs() const;

  // repeated .ru.mail.go.webbase.blobs.ProfileInfo profiles = 3;
  int profiles_size() const;
  void clear_profiles();
  static const int kProfilesFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::ProfileInfo& profiles(int index) const;
  ::ru::mail::go::webbase::blobs::ProfileInfo* mutable_profiles(int index);
  ::ru::mail::go::webbase::blobs::ProfileInfo* add_profiles();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ProfileInfo >*
      mutable_profiles();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ProfileInfo >&
      profiles() const;

  // optional .ru.mail.go.webbase.blobs.infholderBlob.InfholderState state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::ru::mail::go::webbase::blobs::infholderBlob_InfholderState state() const;
  void set_state(::ru::mail::go::webbase::blobs::infholderBlob_InfholderState value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.infholderBlob)
 private:
  void set_has_state();
  void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::CleanDoc > docs_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ProfileInfo > profiles_;
  int state_;
  friend struct protobuf_infholder_5fblobs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TransferDoc

// required .ru.mail.go.webbase.blobs.TransferDoc.transferType type = 1;
inline bool TransferDoc::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransferDoc::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransferDoc::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransferDoc::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ru::mail::go::webbase::blobs::TransferDoc_transferType TransferDoc::type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TransferDoc.type)
  return static_cast< ::ru::mail::go::webbase::blobs::TransferDoc_transferType >(type_);
}
inline void TransferDoc::set_type(::ru::mail::go::webbase::blobs::TransferDoc_transferType value) {
  assert(::ru::mail::go::webbase::blobs::TransferDoc_transferType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TransferDoc.type)
}

// optional .ru.mail.go.webbase.blobs.OriginalDoc sdd = 2;
inline bool TransferDoc::has_sdd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransferDoc::set_has_sdd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransferDoc::clear_has_sdd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransferDoc::clear_sdd() {
  if (sdd_ != NULL) sdd_->::ru::mail::go::webbase::blobs::OriginalDoc::Clear();
  clear_has_sdd();
}
inline const ::ru::mail::go::webbase::blobs::OriginalDoc& TransferDoc::sdd() const {
  const ::ru::mail::go::webbase::blobs::OriginalDoc* p = sdd_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TransferDoc.sdd)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::OriginalDoc*>(
      &::ru::mail::go::webbase::blobs::_OriginalDoc_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::OriginalDoc* TransferDoc::mutable_sdd() {
  set_has_sdd();
  if (sdd_ == NULL) {
    sdd_ = new ::ru::mail::go::webbase::blobs::OriginalDoc;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TransferDoc.sdd)
  return sdd_;
}
inline ::ru::mail::go::webbase::blobs::OriginalDoc* TransferDoc::release_sdd() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TransferDoc.sdd)
  clear_has_sdd();
  ::ru::mail::go::webbase::blobs::OriginalDoc* temp = sdd_;
  sdd_ = NULL;
  return temp;
}
inline void TransferDoc::set_allocated_sdd(::ru::mail::go::webbase::blobs::OriginalDoc* sdd) {
  delete sdd_;
  sdd_ = sdd;
  if (sdd) {
    set_has_sdd();
  } else {
    clear_has_sdd();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TransferDoc.sdd)
}

// optional string base = 3;
inline bool TransferDoc::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransferDoc::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransferDoc::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransferDoc::clear_base() {
  base_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_base();
}
inline const ::std::string& TransferDoc::base() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TransferDoc.base)
  return base_.GetNoArena();
}
inline void TransferDoc::set_base(const ::std::string& value) {
  set_has_base();
  base_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TransferDoc.base)
}
#if LANG_CXX11
inline void TransferDoc::set_base(::std::string&& value) {
  set_has_base();
  base_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TransferDoc.base)
}
#endif
inline void TransferDoc::set_base(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_base();
  base_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TransferDoc.base)
}
inline void TransferDoc::set_base(const char* value, size_t size) {
  set_has_base();
  base_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TransferDoc.base)
}
inline ::std::string* TransferDoc::mutable_base() {
  set_has_base();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TransferDoc.base)
  return base_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferDoc::release_base() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TransferDoc.base)
  clear_has_base();
  return base_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferDoc::set_allocated_base(::std::string* base) {
  if (base != NULL) {
    set_has_base();
  } else {
    clear_has_base();
  }
  base_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), base);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TransferDoc.base)
}

// optional .ru.mail.go.webbase.sekitei.Sekitei_m sm = 4;
inline bool TransferDoc::has_sm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransferDoc::set_has_sm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransferDoc::clear_has_sm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransferDoc::clear_sm() {
  if (sm_ != NULL) sm_->::ru::mail::go::webbase::sekitei::Sekitei_m::Clear();
  clear_has_sm();
}
inline const ::ru::mail::go::webbase::sekitei::Sekitei_m& TransferDoc::sm() const {
  const ::ru::mail::go::webbase::sekitei::Sekitei_m* p = sm_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TransferDoc.sm)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::sekitei::Sekitei_m*>(
      &::ru::mail::go::webbase::sekitei::_Sekitei_m_default_instance_);
}
inline ::ru::mail::go::webbase::sekitei::Sekitei_m* TransferDoc::mutable_sm() {
  set_has_sm();
  if (sm_ == NULL) {
    sm_ = new ::ru::mail::go::webbase::sekitei::Sekitei_m;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TransferDoc.sm)
  return sm_;
}
inline ::ru::mail::go::webbase::sekitei::Sekitei_m* TransferDoc::release_sm() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TransferDoc.sm)
  clear_has_sm();
  ::ru::mail::go::webbase::sekitei::Sekitei_m* temp = sm_;
  sm_ = NULL;
  return temp;
}
inline void TransferDoc::set_allocated_sm(::ru::mail::go::webbase::sekitei::Sekitei_m* sm) {
  delete sm_;
  sm_ = sm;
  if (sm) {
    set_has_sm();
  } else {
    clear_has_sm();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TransferDoc.sm)
}

// -------------------------------------------------------------------

// NavigLink

// required string url = 1;
inline bool NavigLink::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NavigLink::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NavigLink::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NavigLink::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& NavigLink::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.NavigLink.url)
  return url_.GetNoArena();
}
inline void NavigLink::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.NavigLink.url)
}
#if LANG_CXX11
inline void NavigLink::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.NavigLink.url)
}
#endif
inline void NavigLink::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.NavigLink.url)
}
inline void NavigLink::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.NavigLink.url)
}
inline ::std::string* NavigLink::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.NavigLink.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NavigLink::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.NavigLink.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NavigLink::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.NavigLink.url)
}

// -------------------------------------------------------------------

// CleanDoc

// required string url = 1;
inline bool CleanDoc::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CleanDoc::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CleanDoc::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CleanDoc::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& CleanDoc::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CleanDoc.url)
  return url_.GetNoArena();
}
inline void CleanDoc::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CleanDoc.url)
}
#if LANG_CXX11
inline void CleanDoc::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.CleanDoc.url)
}
#endif
inline void CleanDoc::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.CleanDoc.url)
}
inline void CleanDoc::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.CleanDoc.url)
}
inline ::std::string* CleanDoc::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CleanDoc.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CleanDoc::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CleanDoc.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CleanDoc::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CleanDoc.url)
}

// optional .ru.mail.go.webbase.blobs.RegionBlob data = 2;
inline bool CleanDoc::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CleanDoc::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CleanDoc::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CleanDoc::clear_data() {
  if (data_ != NULL) data_->::ru::mail::go::webbase::blobs::RegionBlob::Clear();
  clear_has_data();
}
inline const ::ru::mail::go::webbase::blobs::RegionBlob& CleanDoc::data() const {
  const ::ru::mail::go::webbase::blobs::RegionBlob* p = data_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CleanDoc.data)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::RegionBlob*>(
      &::ru::mail::go::webbase::blobs::_RegionBlob_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::RegionBlob* CleanDoc::mutable_data() {
  set_has_data();
  if (data_ == NULL) {
    data_ = new ::ru::mail::go::webbase::blobs::RegionBlob;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CleanDoc.data)
  return data_;
}
inline ::ru::mail::go::webbase::blobs::RegionBlob* CleanDoc::release_data() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CleanDoc.data)
  clear_has_data();
  ::ru::mail::go::webbase::blobs::RegionBlob* temp = data_;
  data_ = NULL;
  return temp;
}
inline void CleanDoc::set_allocated_data(::ru::mail::go::webbase::blobs::RegionBlob* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CleanDoc.data)
}

// optional .ru.mail.go.webbase.blobs.RegionBlob clean_data = 3;
inline bool CleanDoc::has_clean_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CleanDoc::set_has_clean_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CleanDoc::clear_has_clean_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CleanDoc::clear_clean_data() {
  if (clean_data_ != NULL) clean_data_->::ru::mail::go::webbase::blobs::RegionBlob::Clear();
  clear_has_clean_data();
}
inline const ::ru::mail::go::webbase::blobs::RegionBlob& CleanDoc::clean_data() const {
  const ::ru::mail::go::webbase::blobs::RegionBlob* p = clean_data_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CleanDoc.clean_data)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::RegionBlob*>(
      &::ru::mail::go::webbase::blobs::_RegionBlob_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::RegionBlob* CleanDoc::mutable_clean_data() {
  set_has_clean_data();
  if (clean_data_ == NULL) {
    clean_data_ = new ::ru::mail::go::webbase::blobs::RegionBlob;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CleanDoc.clean_data)
  return clean_data_;
}
inline ::ru::mail::go::webbase::blobs::RegionBlob* CleanDoc::release_clean_data() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CleanDoc.clean_data)
  clear_has_clean_data();
  ::ru::mail::go::webbase::blobs::RegionBlob* temp = clean_data_;
  clean_data_ = NULL;
  return temp;
}
inline void CleanDoc::set_allocated_clean_data(::ru::mail::go::webbase::blobs::RegionBlob* clean_data) {
  delete clean_data_;
  clean_data_ = clean_data;
  if (clean_data) {
    set_has_clean_data();
  } else {
    clear_has_clean_data();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CleanDoc.clean_data)
}

// repeated .ru.mail.go.webbase.blobs.NavigLink navig_urls = 4;
inline int CleanDoc::navig_urls_size() const {
  return navig_urls_.size();
}
inline void CleanDoc::clear_navig_urls() {
  navig_urls_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::NavigLink& CleanDoc::navig_urls(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CleanDoc.navig_urls)
  return navig_urls_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::NavigLink* CleanDoc::mutable_navig_urls(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CleanDoc.navig_urls)
  return navig_urls_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::NavigLink* CleanDoc::add_navig_urls() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.CleanDoc.navig_urls)
  return navig_urls_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::NavigLink >*
CleanDoc::mutable_navig_urls() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.CleanDoc.navig_urls)
  return &navig_urls_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::NavigLink >&
CleanDoc::navig_urls() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.CleanDoc.navig_urls)
  return navig_urls_;
}

// optional int32 num = 5;
inline bool CleanDoc::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CleanDoc::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CleanDoc::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CleanDoc::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 CleanDoc::num() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CleanDoc.num)
  return num_;
}
inline void CleanDoc::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CleanDoc.num)
}

// -------------------------------------------------------------------

// infholderBlob

// repeated .ru.mail.go.webbase.blobs.CleanDoc docs = 1;
inline int infholderBlob::docs_size() const {
  return docs_.size();
}
inline void infholderBlob::clear_docs() {
  docs_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::CleanDoc& infholderBlob::docs(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.infholderBlob.docs)
  return docs_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::CleanDoc* infholderBlob::mutable_docs(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.infholderBlob.docs)
  return docs_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::CleanDoc* infholderBlob::add_docs() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.infholderBlob.docs)
  return docs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::CleanDoc >*
infholderBlob::mutable_docs() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.infholderBlob.docs)
  return &docs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::CleanDoc >&
infholderBlob::docs() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.infholderBlob.docs)
  return docs_;
}

// optional .ru.mail.go.webbase.blobs.infholderBlob.InfholderState state = 2;
inline bool infholderBlob::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void infholderBlob::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void infholderBlob::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void infholderBlob::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::ru::mail::go::webbase::blobs::infholderBlob_InfholderState infholderBlob::state() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.infholderBlob.state)
  return static_cast< ::ru::mail::go::webbase::blobs::infholderBlob_InfholderState >(state_);
}
inline void infholderBlob::set_state(::ru::mail::go::webbase::blobs::infholderBlob_InfholderState value) {
  assert(::ru::mail::go::webbase::blobs::infholderBlob_InfholderState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.infholderBlob.state)
}

// repeated .ru.mail.go.webbase.blobs.ProfileInfo profiles = 3;
inline int infholderBlob::profiles_size() const {
  return profiles_.size();
}
inline void infholderBlob::clear_profiles() {
  profiles_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::ProfileInfo& infholderBlob::profiles(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.infholderBlob.profiles)
  return profiles_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::ProfileInfo* infholderBlob::mutable_profiles(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.infholderBlob.profiles)
  return profiles_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::ProfileInfo* infholderBlob::add_profiles() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.infholderBlob.profiles)
  return profiles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ProfileInfo >*
infholderBlob::mutable_profiles() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.infholderBlob.profiles)
  return &profiles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ProfileInfo >&
infholderBlob::profiles() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.infholderBlob.profiles)
  return profiles_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::TransferDoc_transferType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::TransferDoc_transferType>() {
  return ::ru::mail::go::webbase::blobs::TransferDoc_transferType_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::infholderBlob_InfholderState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::infholderBlob_InfholderState>() {
  return ::ru::mail::go::webbase::blobs::infholderBlob_InfholderState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_infholder_5fblobs_2eproto__INCLUDED
