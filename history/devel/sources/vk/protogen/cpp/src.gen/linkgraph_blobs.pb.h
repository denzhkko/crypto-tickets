// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: linkgraph_blobs.proto

#ifndef PROTOBUF_linkgraph_5fblobs_2eproto__INCLUDED
#define PROTOBUF_linkgraph_5fblobs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "parsed_blobs.pb.h"
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace linkgraph {
class RedirectorMessage;
class RedirectorMessageDefaultTypeInternal;
extern RedirectorMessageDefaultTypeInternal _RedirectorMessage_default_instance_;
class RedirectorMessage_ExtraText;
class RedirectorMessage_ExtraTextDefaultTypeInternal;
extern RedirectorMessage_ExtraTextDefaultTypeInternal _RedirectorMessage_ExtraText_default_instance_;
class RedirectorMessage_Link;
class RedirectorMessage_LinkDefaultTypeInternal;
extern RedirectorMessage_LinkDefaultTypeInternal _RedirectorMessage_Link_default_instance_;
class RedirectorMessage_Redirect;
class RedirectorMessage_RedirectDefaultTypeInternal;
extern RedirectorMessage_RedirectDefaultTypeInternal _RedirectorMessage_Redirect_default_instance_;
}  // namespace linkgraph
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace linkgraph {

namespace protobuf_linkgraph_5fblobs_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_linkgraph_5fblobs_2eproto

// ===================================================================

class RedirectorMessage_Redirect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect) */ {
 public:
  RedirectorMessage_Redirect();
  virtual ~RedirectorMessage_Redirect();

  RedirectorMessage_Redirect(const RedirectorMessage_Redirect& from);

  inline RedirectorMessage_Redirect& operator=(const RedirectorMessage_Redirect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RedirectorMessage_Redirect(RedirectorMessage_Redirect&& from) noexcept
    : RedirectorMessage_Redirect() {
    *this = ::std::move(from);
  }

  inline RedirectorMessage_Redirect& operator=(RedirectorMessage_Redirect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedirectorMessage_Redirect& default_instance();

  static inline const RedirectorMessage_Redirect* internal_default_instance() {
    return reinterpret_cast<const RedirectorMessage_Redirect*>(
               &_RedirectorMessage_Redirect_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RedirectorMessage_Redirect* other);
  friend void swap(RedirectorMessage_Redirect& a, RedirectorMessage_Redirect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RedirectorMessage_Redirect* New() const PROTOBUF_FINAL { return New(NULL); }

  RedirectorMessage_Redirect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RedirectorMessage_Redirect& from);
  void MergeFrom(const RedirectorMessage_Redirect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RedirectorMessage_Redirect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string to = 1;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 1;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect)
 private:
  void set_has_to();
  void clear_has_to();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  friend struct protobuf_linkgraph_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RedirectorMessage_Link : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link) */ {
 public:
  RedirectorMessage_Link();
  virtual ~RedirectorMessage_Link();

  RedirectorMessage_Link(const RedirectorMessage_Link& from);

  inline RedirectorMessage_Link& operator=(const RedirectorMessage_Link& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RedirectorMessage_Link(RedirectorMessage_Link&& from) noexcept
    : RedirectorMessage_Link() {
    *this = ::std::move(from);
  }

  inline RedirectorMessage_Link& operator=(RedirectorMessage_Link&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedirectorMessage_Link& default_instance();

  static inline const RedirectorMessage_Link* internal_default_instance() {
    return reinterpret_cast<const RedirectorMessage_Link*>(
               &_RedirectorMessage_Link_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RedirectorMessage_Link* other);
  friend void swap(RedirectorMessage_Link& a, RedirectorMessage_Link& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RedirectorMessage_Link* New() const PROTOBUF_FINAL { return New(NULL); }

  RedirectorMessage_Link* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RedirectorMessage_Link& from);
  void MergeFrom(const RedirectorMessage_Link& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RedirectorMessage_Link* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string from = 1;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 1;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // required string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link)
 private:
  void set_has_from();
  void clear_has_from();
  void set_has_text();
  void clear_has_text();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  friend struct protobuf_linkgraph_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RedirectorMessage_ExtraText : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText) */ {
 public:
  RedirectorMessage_ExtraText();
  virtual ~RedirectorMessage_ExtraText();

  RedirectorMessage_ExtraText(const RedirectorMessage_ExtraText& from);

  inline RedirectorMessage_ExtraText& operator=(const RedirectorMessage_ExtraText& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RedirectorMessage_ExtraText(RedirectorMessage_ExtraText&& from) noexcept
    : RedirectorMessage_ExtraText() {
    *this = ::std::move(from);
  }

  inline RedirectorMessage_ExtraText& operator=(RedirectorMessage_ExtraText&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedirectorMessage_ExtraText& default_instance();

  static inline const RedirectorMessage_ExtraText* internal_default_instance() {
    return reinterpret_cast<const RedirectorMessage_ExtraText*>(
               &_RedirectorMessage_ExtraText_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RedirectorMessage_ExtraText* other);
  friend void swap(RedirectorMessage_ExtraText& a, RedirectorMessage_ExtraText& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RedirectorMessage_ExtraText* New() const PROTOBUF_FINAL { return New(NULL); }

  RedirectorMessage_ExtraText* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RedirectorMessage_ExtraText& from);
  void MergeFrom(const RedirectorMessage_ExtraText& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RedirectorMessage_ExtraText* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ru.mail.go.webbase.blobs.ExtraTextArray extratextArray = 2;
  bool has_extratextarray() const;
  void clear_extratextarray();
  static const int kExtratextArrayFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::ExtraTextArray& extratextarray() const;
  ::ru::mail::go::webbase::blobs::ExtraTextArray* mutable_extratextarray();
  ::ru::mail::go::webbase::blobs::ExtraTextArray* release_extratextarray();
  void set_allocated_extratextarray(::ru::mail::go::webbase::blobs::ExtraTextArray* extratextarray);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_extratextarray();
  void clear_has_extratextarray();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ru::mail::go::webbase::blobs::ExtraTextArray* extratextarray_;
  friend struct protobuf_linkgraph_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RedirectorMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.linkgraph.RedirectorMessage) */ {
 public:
  RedirectorMessage();
  virtual ~RedirectorMessage();

  RedirectorMessage(const RedirectorMessage& from);

  inline RedirectorMessage& operator=(const RedirectorMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RedirectorMessage(RedirectorMessage&& from) noexcept
    : RedirectorMessage() {
    *this = ::std::move(from);
  }

  inline RedirectorMessage& operator=(RedirectorMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedirectorMessage& default_instance();

  static inline const RedirectorMessage* internal_default_instance() {
    return reinterpret_cast<const RedirectorMessage*>(
               &_RedirectorMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RedirectorMessage* other);
  friend void swap(RedirectorMessage& a, RedirectorMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RedirectorMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  RedirectorMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RedirectorMessage& from);
  void MergeFrom(const RedirectorMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RedirectorMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RedirectorMessage_Redirect Redirect;
  typedef RedirectorMessage_Link Link;
  typedef RedirectorMessage_ExtraText ExtraText;

  // accessors -------------------------------------------------------

  // optional .ru.mail.go.webbase.linkgraph.RedirectorMessage.Link link = 1;
  bool has_link() const;
  void clear_link();
  static const int kLinkFieldNumber = 1;
  const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link& link() const;
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link* mutable_link();
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link* release_link();
  void set_allocated_link(::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link* link);

  // optional .ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect redirect = 2;
  bool has_redirect() const;
  void clear_redirect();
  static const int kRedirectFieldNumber = 2;
  const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect& redirect() const;
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect* mutable_redirect();
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect* release_redirect();
  void set_allocated_redirect(::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect* redirect);

  // optional .ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText etext = 3;
  bool has_etext() const;
  void clear_etext();
  static const int kEtextFieldNumber = 3;
  const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText& etext() const;
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText* mutable_etext();
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText* release_etext();
  void set_allocated_etext(::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText* etext);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.linkgraph.RedirectorMessage)
 private:
  void set_has_link();
  void clear_has_link();
  void set_has_redirect();
  void clear_has_redirect();
  void set_has_etext();
  void clear_has_etext();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link* link_;
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect* redirect_;
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText* etext_;
  friend struct protobuf_linkgraph_5fblobs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RedirectorMessage_Redirect

// required string to = 1;
inline bool RedirectorMessage_Redirect::has_to() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedirectorMessage_Redirect::set_has_to() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedirectorMessage_Redirect::clear_has_to() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedirectorMessage_Redirect::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to();
}
inline const ::std::string& RedirectorMessage_Redirect::to() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect.to)
  return to_.GetNoArena();
}
inline void RedirectorMessage_Redirect::set_to(const ::std::string& value) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect.to)
}
#if LANG_CXX11
inline void RedirectorMessage_Redirect::set_to(::std::string&& value) {
  set_has_to();
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect.to)
}
#endif
inline void RedirectorMessage_Redirect::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect.to)
}
inline void RedirectorMessage_Redirect::set_to(const char* value, size_t size) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect.to)
}
inline ::std::string* RedirectorMessage_Redirect::mutable_to() {
  set_has_to();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedirectorMessage_Redirect::release_to() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect.to)
  clear_has_to();
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedirectorMessage_Redirect::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    set_has_to();
  } else {
    clear_has_to();
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect.to)
}

// -------------------------------------------------------------------

// RedirectorMessage_Link

// required string from = 1;
inline bool RedirectorMessage_Link::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedirectorMessage_Link::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedirectorMessage_Link::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedirectorMessage_Link::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from();
}
inline const ::std::string& RedirectorMessage_Link::from() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.from)
  return from_.GetNoArena();
}
inline void RedirectorMessage_Link::set_from(const ::std::string& value) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.from)
}
#if LANG_CXX11
inline void RedirectorMessage_Link::set_from(::std::string&& value) {
  set_has_from();
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.from)
}
#endif
inline void RedirectorMessage_Link::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.from)
}
inline void RedirectorMessage_Link::set_from(const char* value, size_t size) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.from)
}
inline ::std::string* RedirectorMessage_Link::mutable_from() {
  set_has_from();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedirectorMessage_Link::release_from() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.from)
  clear_has_from();
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedirectorMessage_Link::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    set_has_from();
  } else {
    clear_has_from();
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.from)
}

// required string text = 2;
inline bool RedirectorMessage_Link::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedirectorMessage_Link::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedirectorMessage_Link::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedirectorMessage_Link::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& RedirectorMessage_Link::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.text)
  return text_.GetNoArena();
}
inline void RedirectorMessage_Link::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.text)
}
#if LANG_CXX11
inline void RedirectorMessage_Link::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.text)
}
#endif
inline void RedirectorMessage_Link::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.text)
}
inline void RedirectorMessage_Link::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.text)
}
inline ::std::string* RedirectorMessage_Link::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedirectorMessage_Link::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedirectorMessage_Link::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.linkgraph.RedirectorMessage.Link.text)
}

// -------------------------------------------------------------------

// RedirectorMessage_ExtraText

// required string id = 1;
inline bool RedirectorMessage_ExtraText::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedirectorMessage_ExtraText::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedirectorMessage_ExtraText::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedirectorMessage_ExtraText::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& RedirectorMessage_ExtraText::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.id)
  return id_.GetNoArena();
}
inline void RedirectorMessage_ExtraText::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.id)
}
#if LANG_CXX11
inline void RedirectorMessage_ExtraText::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.id)
}
#endif
inline void RedirectorMessage_ExtraText::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.id)
}
inline void RedirectorMessage_ExtraText::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.id)
}
inline ::std::string* RedirectorMessage_ExtraText::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedirectorMessage_ExtraText::release_id() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedirectorMessage_ExtraText::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.id)
}

// required .ru.mail.go.webbase.blobs.ExtraTextArray extratextArray = 2;
inline bool RedirectorMessage_ExtraText::has_extratextarray() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedirectorMessage_ExtraText::set_has_extratextarray() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedirectorMessage_ExtraText::clear_has_extratextarray() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedirectorMessage_ExtraText::clear_extratextarray() {
  if (extratextarray_ != NULL) extratextarray_->::ru::mail::go::webbase::blobs::ExtraTextArray::Clear();
  clear_has_extratextarray();
}
inline const ::ru::mail::go::webbase::blobs::ExtraTextArray& RedirectorMessage_ExtraText::extratextarray() const {
  const ::ru::mail::go::webbase::blobs::ExtraTextArray* p = extratextarray_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.extratextArray)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ExtraTextArray*>(
      &::ru::mail::go::webbase::blobs::_ExtraTextArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ExtraTextArray* RedirectorMessage_ExtraText::mutable_extratextarray() {
  set_has_extratextarray();
  if (extratextarray_ == NULL) {
    extratextarray_ = new ::ru::mail::go::webbase::blobs::ExtraTextArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.extratextArray)
  return extratextarray_;
}
inline ::ru::mail::go::webbase::blobs::ExtraTextArray* RedirectorMessage_ExtraText::release_extratextarray() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.extratextArray)
  clear_has_extratextarray();
  ::ru::mail::go::webbase::blobs::ExtraTextArray* temp = extratextarray_;
  extratextarray_ = NULL;
  return temp;
}
inline void RedirectorMessage_ExtraText::set_allocated_extratextarray(::ru::mail::go::webbase::blobs::ExtraTextArray* extratextarray) {
  delete extratextarray_;
  extratextarray_ = extratextarray;
  if (extratextarray) {
    set_has_extratextarray();
  } else {
    clear_has_extratextarray();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText.extratextArray)
}

// -------------------------------------------------------------------

// RedirectorMessage

// optional .ru.mail.go.webbase.linkgraph.RedirectorMessage.Link link = 1;
inline bool RedirectorMessage::has_link() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedirectorMessage::set_has_link() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedirectorMessage::clear_has_link() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedirectorMessage::clear_link() {
  if (link_ != NULL) link_->::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link::Clear();
  clear_has_link();
}
inline const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link& RedirectorMessage::link() const {
  const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link* p = link_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.linkgraph.RedirectorMessage.link)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link*>(
      &::ru::mail::go::webbase::linkgraph::_RedirectorMessage_Link_default_instance_);
}
inline ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link* RedirectorMessage::mutable_link() {
  set_has_link();
  if (link_ == NULL) {
    link_ = new ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.linkgraph.RedirectorMessage.link)
  return link_;
}
inline ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link* RedirectorMessage::release_link() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.linkgraph.RedirectorMessage.link)
  clear_has_link();
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link* temp = link_;
  link_ = NULL;
  return temp;
}
inline void RedirectorMessage::set_allocated_link(::ru::mail::go::webbase::linkgraph::RedirectorMessage_Link* link) {
  delete link_;
  link_ = link;
  if (link) {
    set_has_link();
  } else {
    clear_has_link();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.linkgraph.RedirectorMessage.link)
}

// optional .ru.mail.go.webbase.linkgraph.RedirectorMessage.Redirect redirect = 2;
inline bool RedirectorMessage::has_redirect() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedirectorMessage::set_has_redirect() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedirectorMessage::clear_has_redirect() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedirectorMessage::clear_redirect() {
  if (redirect_ != NULL) redirect_->::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect::Clear();
  clear_has_redirect();
}
inline const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect& RedirectorMessage::redirect() const {
  const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect* p = redirect_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.linkgraph.RedirectorMessage.redirect)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect*>(
      &::ru::mail::go::webbase::linkgraph::_RedirectorMessage_Redirect_default_instance_);
}
inline ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect* RedirectorMessage::mutable_redirect() {
  set_has_redirect();
  if (redirect_ == NULL) {
    redirect_ = new ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.linkgraph.RedirectorMessage.redirect)
  return redirect_;
}
inline ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect* RedirectorMessage::release_redirect() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.linkgraph.RedirectorMessage.redirect)
  clear_has_redirect();
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect* temp = redirect_;
  redirect_ = NULL;
  return temp;
}
inline void RedirectorMessage::set_allocated_redirect(::ru::mail::go::webbase::linkgraph::RedirectorMessage_Redirect* redirect) {
  delete redirect_;
  redirect_ = redirect;
  if (redirect) {
    set_has_redirect();
  } else {
    clear_has_redirect();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.linkgraph.RedirectorMessage.redirect)
}

// optional .ru.mail.go.webbase.linkgraph.RedirectorMessage.ExtraText etext = 3;
inline bool RedirectorMessage::has_etext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedirectorMessage::set_has_etext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedirectorMessage::clear_has_etext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedirectorMessage::clear_etext() {
  if (etext_ != NULL) etext_->::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText::Clear();
  clear_has_etext();
}
inline const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText& RedirectorMessage::etext() const {
  const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText* p = etext_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.linkgraph.RedirectorMessage.etext)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText*>(
      &::ru::mail::go::webbase::linkgraph::_RedirectorMessage_ExtraText_default_instance_);
}
inline ::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText* RedirectorMessage::mutable_etext() {
  set_has_etext();
  if (etext_ == NULL) {
    etext_ = new ::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.linkgraph.RedirectorMessage.etext)
  return etext_;
}
inline ::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText* RedirectorMessage::release_etext() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.linkgraph.RedirectorMessage.etext)
  clear_has_etext();
  ::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText* temp = etext_;
  etext_ = NULL;
  return temp;
}
inline void RedirectorMessage::set_allocated_etext(::ru::mail::go::webbase::linkgraph::RedirectorMessage_ExtraText* etext) {
  delete etext_;
  etext_ = etext;
  if (etext) {
    set_has_etext();
  } else {
    clear_has_etext();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.linkgraph.RedirectorMessage.etext)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace linkgraph
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_linkgraph_5fblobs_2eproto__INCLUDED
