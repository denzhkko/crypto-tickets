// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: log_parser.proto

#ifndef PROTOBUF_log_5fparser_2eproto__INCLUDED
#define PROTOBUF_log_5fparser_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "urllog_record.pb.h"
#include "sputnik_logs.pb.h"
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace clickrank {
class RecordWrapper;
class RecordWrapperDefaultTypeInternal;
extern RecordWrapperDefaultTypeInternal _RecordWrapper_default_instance_;
class Session;
class SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
}  // namespace clickrank
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace clickrank {

namespace protobuf_log_5fparser_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_log_5fparser_2eproto

enum RecordType {
  URL = 1,
  BARTERTOWN = 2,
  ACCESS = 3,
  SERP = 4,
  EXPERIMENTD = 5
};
bool RecordType_IsValid(int value);
const RecordType RecordType_MIN = URL;
const RecordType RecordType_MAX = EXPERIMENTD;
const int RecordType_ARRAYSIZE = RecordType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecordType_descriptor();
inline const ::std::string& RecordType_Name(RecordType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecordType_descriptor(), value);
}
inline bool RecordType_Parse(
    const ::std::string& name, RecordType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecordType>(
    RecordType_descriptor(), name, value);
}
// ===================================================================

class RecordWrapper : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.clickrank.RecordWrapper) */ {
 public:
  RecordWrapper();
  virtual ~RecordWrapper();

  RecordWrapper(const RecordWrapper& from);

  inline RecordWrapper& operator=(const RecordWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecordWrapper(RecordWrapper&& from) noexcept
    : RecordWrapper() {
    *this = ::std::move(from);
  }

  inline RecordWrapper& operator=(RecordWrapper&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordWrapper& default_instance();

  static inline const RecordWrapper* internal_default_instance() {
    return reinterpret_cast<const RecordWrapper*>(
               &_RecordWrapper_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RecordWrapper* other);
  friend void swap(RecordWrapper& a, RecordWrapper& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecordWrapper* New() const PROTOBUF_FINAL { return New(NULL); }

  RecordWrapper* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RecordWrapper& from);
  void MergeFrom(const RecordWrapper& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RecordWrapper* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ru.mail.go.webbase.ranking.UrlLogRecord url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::ru::mail::go::webbase::ranking::UrlLogRecord& url() const;
  ::ru::mail::go::webbase::ranking::UrlLogRecord* mutable_url();
  ::ru::mail::go::webbase::ranking::UrlLogRecord* release_url();
  void set_allocated_url(::ru::mail::go::webbase::ranking::UrlLogRecord* url);

  // optional .ru.mail.go.webbase.ranking.BartertownLogRecord bartertown = 3;
  bool has_bartertown() const;
  void clear_bartertown();
  static const int kBartertownFieldNumber = 3;
  const ::ru::mail::go::webbase::ranking::BartertownLogRecord& bartertown() const;
  ::ru::mail::go::webbase::ranking::BartertownLogRecord* mutable_bartertown();
  ::ru::mail::go::webbase::ranking::BartertownLogRecord* release_bartertown();
  void set_allocated_bartertown(::ru::mail::go::webbase::ranking::BartertownLogRecord* bartertown);

  // optional .ru.mail.go.webbase.ranking.AccessLogRecord access = 4;
  bool has_access() const;
  void clear_access();
  static const int kAccessFieldNumber = 4;
  const ::ru::mail::go::webbase::ranking::AccessLogRecord& access() const;
  ::ru::mail::go::webbase::ranking::AccessLogRecord* mutable_access();
  ::ru::mail::go::webbase::ranking::AccessLogRecord* release_access();
  void set_allocated_access(::ru::mail::go::webbase::ranking::AccessLogRecord* access);

  // optional .ru.mail.go.webbase.ranking.SerpLogRecord serp = 5;
  bool has_serp() const;
  void clear_serp();
  static const int kSerpFieldNumber = 5;
  const ::ru::mail::go::webbase::ranking::SerpLogRecord& serp() const;
  ::ru::mail::go::webbase::ranking::SerpLogRecord* mutable_serp();
  ::ru::mail::go::webbase::ranking::SerpLogRecord* release_serp();
  void set_allocated_serp(::ru::mail::go::webbase::ranking::SerpLogRecord* serp);

  // optional .ru.mail.go.webbase.ranking.SerpLogRecord experimentd = 6;
  bool has_experimentd() const;
  void clear_experimentd();
  static const int kExperimentdFieldNumber = 6;
  const ::ru::mail::go::webbase::ranking::SerpLogRecord& experimentd() const;
  ::ru::mail::go::webbase::ranking::SerpLogRecord* mutable_experimentd();
  ::ru::mail::go::webbase::ranking::SerpLogRecord* release_experimentd();
  void set_allocated_experimentd(::ru::mail::go::webbase::ranking::SerpLogRecord* experimentd);

  // required .ru.mail.go.webbase.clickrank.RecordType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ru::mail::go::webbase::clickrank::RecordType type() const;
  void set_type(::ru::mail::go::webbase::clickrank::RecordType value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.clickrank.RecordWrapper)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_url();
  void clear_has_url();
  void set_has_bartertown();
  void clear_has_bartertown();
  void set_has_access();
  void clear_has_access();
  void set_has_serp();
  void clear_has_serp();
  void set_has_experimentd();
  void clear_has_experimentd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ru::mail::go::webbase::ranking::UrlLogRecord* url_;
  ::ru::mail::go::webbase::ranking::BartertownLogRecord* bartertown_;
  ::ru::mail::go::webbase::ranking::AccessLogRecord* access_;
  ::ru::mail::go::webbase::ranking::SerpLogRecord* serp_;
  ::ru::mail::go::webbase::ranking::SerpLogRecord* experimentd_;
  int type_;
  friend struct protobuf_log_5fparser_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Session : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.clickrank.Session) */ {
 public:
  Session();
  virtual ~Session();

  Session(const Session& from);

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Session(Session&& from) noexcept
    : Session() {
    *this = ::std::move(from);
  }

  inline Session& operator=(Session&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Session& default_instance();

  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
               &_Session_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Session* other);
  friend void swap(Session& a, Session& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Session* New() const PROTOBUF_FINAL { return New(NULL); }

  Session* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Session& from);
  void MergeFrom(const Session& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Session* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string url = 1;
  int url_size() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url(int index) const;
  ::std::string* mutable_url(int index);
  void set_url(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_url(int index, ::std::string&& value);
  #endif
  void set_url(int index, const char* value);
  void set_url(int index, const char* value, size_t size);
  ::std::string* add_url();
  void add_url(const ::std::string& value);
  #if LANG_CXX11
  void add_url(::std::string&& value);
  #endif
  void add_url(const char* value);
  void add_url(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& url() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_url();

  // repeated int32 click = 2;
  int click_size() const;
  void clear_click();
  static const int kClickFieldNumber = 2;
  ::google::protobuf::int32 click(int index) const;
  void set_click(int index, ::google::protobuf::int32 value);
  void add_click(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      click() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_click();

  // repeated string quick_links = 4;
  int quick_links_size() const;
  void clear_quick_links();
  static const int kQuickLinksFieldNumber = 4;
  const ::std::string& quick_links(int index) const;
  ::std::string* mutable_quick_links(int index);
  void set_quick_links(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_quick_links(int index, ::std::string&& value);
  #endif
  void set_quick_links(int index, const char* value);
  void set_quick_links(int index, const char* value, size_t size);
  ::std::string* add_quick_links();
  void add_quick_links(const ::std::string& value);
  #if LANG_CXX11
  void add_quick_links(::std::string&& value);
  #endif
  void add_quick_links(const char* value);
  void add_quick_links(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& quick_links() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_quick_links();

  // repeated uint64 click_time = 6;
  int click_time_size() const;
  void clear_click_time();
  static const int kClickTimeFieldNumber = 6;
  ::google::protobuf::uint64 click_time(int index) const;
  void set_click_time(int index, ::google::protobuf::uint64 value);
  void add_click_time(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      click_time() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_click_time();

  // repeated .ru.mail.go.webbase.SputnikRanker.Redirect redirect = 10;
  int redirect_size() const;
  void clear_redirect();
  static const int kRedirectFieldNumber = 10;
  const ::ru::mail::go::webbase::SputnikRanker::Redirect& redirect(int index) const;
  ::ru::mail::go::webbase::SputnikRanker::Redirect* mutable_redirect(int index);
  ::ru::mail::go::webbase::SputnikRanker::Redirect* add_redirect();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::SputnikRanker::Redirect >*
      mutable_redirect();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::SputnikRanker::Redirect >&
      redirect() const;

  // repeated int32 aux_click = 13;
  int aux_click_size() const;
  void clear_aux_click();
  static const int kAuxClickFieldNumber = 13;
  ::google::protobuf::int32 aux_click(int index) const;
  void set_aux_click(int index, ::google::protobuf::int32 value);
  void add_aux_click(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      aux_click() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_aux_click();

  // repeated uint64 aux_click_time = 14;
  int aux_click_time_size() const;
  void clear_aux_click_time();
  static const int kAuxClickTimeFieldNumber = 14;
  ::google::protobuf::uint64 aux_click_time(int index) const;
  void set_aux_click_time(int index, ::google::protobuf::uint64 value);
  void add_aux_click_time(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      aux_click_time() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_aux_click_time();

  // optional string userId = 3;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 3;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // optional string geoSpecific = 7;
  bool has_geospecific() const;
  void clear_geospecific();
  static const int kGeoSpecificFieldNumber = 7;
  const ::std::string& geospecific() const;
  void set_geospecific(const ::std::string& value);
  #if LANG_CXX11
  void set_geospecific(::std::string&& value);
  #endif
  void set_geospecific(const char* value);
  void set_geospecific(const char* value, size_t size);
  ::std::string* mutable_geospecific();
  ::std::string* release_geospecific();
  void set_allocated_geospecific(::std::string* geospecific);

  // optional string serp = 11;
  bool has_serp() const;
  void clear_serp();
  static const int kSerpFieldNumber = 11;
  const ::std::string& serp() const;
  void set_serp(const ::std::string& value);
  #if LANG_CXX11
  void set_serp(::std::string&& value);
  #endif
  void set_serp(const char* value);
  void set_serp(const char* value, size_t size);
  ::std::string* mutable_serp();
  ::std::string* release_serp();
  void set_allocated_serp(::std::string* serp);

  // optional .ru.mail.go.webbase.ranking.ParamList sessionInfo = 9;
  bool has_sessioninfo() const;
  void clear_sessioninfo();
  static const int kSessionInfoFieldNumber = 9;
  const ::ru::mail::go::webbase::ranking::ParamList& sessioninfo() const;
  ::ru::mail::go::webbase::ranking::ParamList* mutable_sessioninfo();
  ::ru::mail::go::webbase::ranking::ParamList* release_sessioninfo();
  void set_allocated_sessioninfo(::ru::mail::go::webbase::ranking::ParamList* sessioninfo);

  // optional .ru.mail.go.webbase.ranking.ParamList dbType = 12;
  bool has_dbtype() const;
  void clear_dbtype();
  static const int kDbTypeFieldNumber = 12;
  const ::ru::mail::go::webbase::ranking::ParamList& dbtype() const;
  ::ru::mail::go::webbase::ranking::ParamList* mutable_dbtype();
  ::ru::mail::go::webbase::ranking::ParamList* release_dbtype();
  void set_allocated_dbtype(::ru::mail::go::webbase::ranking::ParamList* dbtype);

  // optional uint64 timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional bool persional = 8;
  bool has_persional() const;
  void clear_persional();
  static const int kPersionalFieldNumber = 8;
  bool persional() const;
  void set_persional(bool value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.clickrank.Session)
 private:
  void set_has_userid();
  void clear_has_userid();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_sessioninfo();
  void clear_has_sessioninfo();
  void set_has_geospecific();
  void clear_has_geospecific();
  void set_has_persional();
  void clear_has_persional();
  void set_has_serp();
  void clear_has_serp();
  void set_has_dbtype();
  void clear_has_dbtype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> url_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > click_;
  ::google::protobuf::RepeatedPtrField< ::std::string> quick_links_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > click_time_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::SputnikRanker::Redirect > redirect_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > aux_click_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > aux_click_time_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::internal::ArenaStringPtr geospecific_;
  ::google::protobuf::internal::ArenaStringPtr serp_;
  ::ru::mail::go::webbase::ranking::ParamList* sessioninfo_;
  ::ru::mail::go::webbase::ranking::ParamList* dbtype_;
  ::google::protobuf::uint64 timestamp_;
  bool persional_;
  friend struct protobuf_log_5fparser_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RecordWrapper

// required .ru.mail.go.webbase.clickrank.RecordType type = 1;
inline bool RecordWrapper::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecordWrapper::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RecordWrapper::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RecordWrapper::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ru::mail::go::webbase::clickrank::RecordType RecordWrapper::type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.RecordWrapper.type)
  return static_cast< ::ru::mail::go::webbase::clickrank::RecordType >(type_);
}
inline void RecordWrapper::set_type(::ru::mail::go::webbase::clickrank::RecordType value) {
  assert(::ru::mail::go::webbase::clickrank::RecordType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.RecordWrapper.type)
}

// optional .ru.mail.go.webbase.ranking.UrlLogRecord url = 2;
inline bool RecordWrapper::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordWrapper::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordWrapper::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordWrapper::clear_url() {
  if (url_ != NULL) url_->::ru::mail::go::webbase::ranking::UrlLogRecord::Clear();
  clear_has_url();
}
inline const ::ru::mail::go::webbase::ranking::UrlLogRecord& RecordWrapper::url() const {
  const ::ru::mail::go::webbase::ranking::UrlLogRecord* p = url_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.RecordWrapper.url)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::ranking::UrlLogRecord*>(
      &::ru::mail::go::webbase::ranking::_UrlLogRecord_default_instance_);
}
inline ::ru::mail::go::webbase::ranking::UrlLogRecord* RecordWrapper::mutable_url() {
  set_has_url();
  if (url_ == NULL) {
    url_ = new ::ru::mail::go::webbase::ranking::UrlLogRecord;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.RecordWrapper.url)
  return url_;
}
inline ::ru::mail::go::webbase::ranking::UrlLogRecord* RecordWrapper::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.clickrank.RecordWrapper.url)
  clear_has_url();
  ::ru::mail::go::webbase::ranking::UrlLogRecord* temp = url_;
  url_ = NULL;
  return temp;
}
inline void RecordWrapper::set_allocated_url(::ru::mail::go::webbase::ranking::UrlLogRecord* url) {
  delete url_;
  url_ = url;
  if (url) {
    set_has_url();
  } else {
    clear_has_url();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.clickrank.RecordWrapper.url)
}

// optional .ru.mail.go.webbase.ranking.BartertownLogRecord bartertown = 3;
inline bool RecordWrapper::has_bartertown() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordWrapper::set_has_bartertown() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecordWrapper::clear_has_bartertown() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecordWrapper::clear_bartertown() {
  if (bartertown_ != NULL) bartertown_->::ru::mail::go::webbase::ranking::BartertownLogRecord::Clear();
  clear_has_bartertown();
}
inline const ::ru::mail::go::webbase::ranking::BartertownLogRecord& RecordWrapper::bartertown() const {
  const ::ru::mail::go::webbase::ranking::BartertownLogRecord* p = bartertown_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.RecordWrapper.bartertown)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::ranking::BartertownLogRecord*>(
      &::ru::mail::go::webbase::ranking::_BartertownLogRecord_default_instance_);
}
inline ::ru::mail::go::webbase::ranking::BartertownLogRecord* RecordWrapper::mutable_bartertown() {
  set_has_bartertown();
  if (bartertown_ == NULL) {
    bartertown_ = new ::ru::mail::go::webbase::ranking::BartertownLogRecord;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.RecordWrapper.bartertown)
  return bartertown_;
}
inline ::ru::mail::go::webbase::ranking::BartertownLogRecord* RecordWrapper::release_bartertown() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.clickrank.RecordWrapper.bartertown)
  clear_has_bartertown();
  ::ru::mail::go::webbase::ranking::BartertownLogRecord* temp = bartertown_;
  bartertown_ = NULL;
  return temp;
}
inline void RecordWrapper::set_allocated_bartertown(::ru::mail::go::webbase::ranking::BartertownLogRecord* bartertown) {
  delete bartertown_;
  bartertown_ = bartertown;
  if (bartertown) {
    set_has_bartertown();
  } else {
    clear_has_bartertown();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.clickrank.RecordWrapper.bartertown)
}

// optional .ru.mail.go.webbase.ranking.AccessLogRecord access = 4;
inline bool RecordWrapper::has_access() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordWrapper::set_has_access() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecordWrapper::clear_has_access() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecordWrapper::clear_access() {
  if (access_ != NULL) access_->::ru::mail::go::webbase::ranking::AccessLogRecord::Clear();
  clear_has_access();
}
inline const ::ru::mail::go::webbase::ranking::AccessLogRecord& RecordWrapper::access() const {
  const ::ru::mail::go::webbase::ranking::AccessLogRecord* p = access_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.RecordWrapper.access)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::ranking::AccessLogRecord*>(
      &::ru::mail::go::webbase::ranking::_AccessLogRecord_default_instance_);
}
inline ::ru::mail::go::webbase::ranking::AccessLogRecord* RecordWrapper::mutable_access() {
  set_has_access();
  if (access_ == NULL) {
    access_ = new ::ru::mail::go::webbase::ranking::AccessLogRecord;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.RecordWrapper.access)
  return access_;
}
inline ::ru::mail::go::webbase::ranking::AccessLogRecord* RecordWrapper::release_access() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.clickrank.RecordWrapper.access)
  clear_has_access();
  ::ru::mail::go::webbase::ranking::AccessLogRecord* temp = access_;
  access_ = NULL;
  return temp;
}
inline void RecordWrapper::set_allocated_access(::ru::mail::go::webbase::ranking::AccessLogRecord* access) {
  delete access_;
  access_ = access;
  if (access) {
    set_has_access();
  } else {
    clear_has_access();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.clickrank.RecordWrapper.access)
}

// optional .ru.mail.go.webbase.ranking.SerpLogRecord serp = 5;
inline bool RecordWrapper::has_serp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecordWrapper::set_has_serp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecordWrapper::clear_has_serp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecordWrapper::clear_serp() {
  if (serp_ != NULL) serp_->::ru::mail::go::webbase::ranking::SerpLogRecord::Clear();
  clear_has_serp();
}
inline const ::ru::mail::go::webbase::ranking::SerpLogRecord& RecordWrapper::serp() const {
  const ::ru::mail::go::webbase::ranking::SerpLogRecord* p = serp_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.RecordWrapper.serp)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::ranking::SerpLogRecord*>(
      &::ru::mail::go::webbase::ranking::_SerpLogRecord_default_instance_);
}
inline ::ru::mail::go::webbase::ranking::SerpLogRecord* RecordWrapper::mutable_serp() {
  set_has_serp();
  if (serp_ == NULL) {
    serp_ = new ::ru::mail::go::webbase::ranking::SerpLogRecord;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.RecordWrapper.serp)
  return serp_;
}
inline ::ru::mail::go::webbase::ranking::SerpLogRecord* RecordWrapper::release_serp() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.clickrank.RecordWrapper.serp)
  clear_has_serp();
  ::ru::mail::go::webbase::ranking::SerpLogRecord* temp = serp_;
  serp_ = NULL;
  return temp;
}
inline void RecordWrapper::set_allocated_serp(::ru::mail::go::webbase::ranking::SerpLogRecord* serp) {
  delete serp_;
  serp_ = serp;
  if (serp) {
    set_has_serp();
  } else {
    clear_has_serp();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.clickrank.RecordWrapper.serp)
}

// optional .ru.mail.go.webbase.ranking.SerpLogRecord experimentd = 6;
inline bool RecordWrapper::has_experimentd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecordWrapper::set_has_experimentd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecordWrapper::clear_has_experimentd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecordWrapper::clear_experimentd() {
  if (experimentd_ != NULL) experimentd_->::ru::mail::go::webbase::ranking::SerpLogRecord::Clear();
  clear_has_experimentd();
}
inline const ::ru::mail::go::webbase::ranking::SerpLogRecord& RecordWrapper::experimentd() const {
  const ::ru::mail::go::webbase::ranking::SerpLogRecord* p = experimentd_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.RecordWrapper.experimentd)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::ranking::SerpLogRecord*>(
      &::ru::mail::go::webbase::ranking::_SerpLogRecord_default_instance_);
}
inline ::ru::mail::go::webbase::ranking::SerpLogRecord* RecordWrapper::mutable_experimentd() {
  set_has_experimentd();
  if (experimentd_ == NULL) {
    experimentd_ = new ::ru::mail::go::webbase::ranking::SerpLogRecord;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.RecordWrapper.experimentd)
  return experimentd_;
}
inline ::ru::mail::go::webbase::ranking::SerpLogRecord* RecordWrapper::release_experimentd() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.clickrank.RecordWrapper.experimentd)
  clear_has_experimentd();
  ::ru::mail::go::webbase::ranking::SerpLogRecord* temp = experimentd_;
  experimentd_ = NULL;
  return temp;
}
inline void RecordWrapper::set_allocated_experimentd(::ru::mail::go::webbase::ranking::SerpLogRecord* experimentd) {
  delete experimentd_;
  experimentd_ = experimentd;
  if (experimentd) {
    set_has_experimentd();
  } else {
    clear_has_experimentd();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.clickrank.RecordWrapper.experimentd)
}

// -------------------------------------------------------------------

// Session

// repeated string url = 1;
inline int Session::url_size() const {
  return url_.size();
}
inline void Session::clear_url() {
  url_.Clear();
}
inline const ::std::string& Session::url(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.url)
  return url_.Get(index);
}
inline ::std::string* Session::mutable_url(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.Session.url)
  return url_.Mutable(index);
}
inline void Session::set_url(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.url)
  url_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Session::set_url(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.url)
  url_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Session::set_url(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  url_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.clickrank.Session.url)
}
inline void Session::set_url(int index, const char* value, size_t size) {
  url_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.clickrank.Session.url)
}
inline ::std::string* Session::add_url() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.clickrank.Session.url)
  return url_.Add();
}
inline void Session::add_url(const ::std::string& value) {
  url_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.clickrank.Session.url)
}
#if LANG_CXX11
inline void Session::add_url(::std::string&& value) {
  url_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.clickrank.Session.url)
}
#endif
inline void Session::add_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  url_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.clickrank.Session.url)
}
inline void Session::add_url(const char* value, size_t size) {
  url_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.clickrank.Session.url)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Session::url() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.clickrank.Session.url)
  return url_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Session::mutable_url() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.clickrank.Session.url)
  return &url_;
}

// repeated int32 click = 2;
inline int Session::click_size() const {
  return click_.size();
}
inline void Session::clear_click() {
  click_.Clear();
}
inline ::google::protobuf::int32 Session::click(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.click)
  return click_.Get(index);
}
inline void Session::set_click(int index, ::google::protobuf::int32 value) {
  click_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.click)
}
inline void Session::add_click(::google::protobuf::int32 value) {
  click_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.clickrank.Session.click)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Session::click() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.clickrank.Session.click)
  return click_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Session::mutable_click() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.clickrank.Session.click)
  return &click_;
}

// optional string userId = 3;
inline bool Session::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Session::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Session::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Session::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_userid();
}
inline const ::std::string& Session::userid() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.userId)
  return userid_.GetNoArena();
}
inline void Session::set_userid(const ::std::string& value) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.userId)
}
#if LANG_CXX11
inline void Session::set_userid(::std::string&& value) {
  set_has_userid();
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.clickrank.Session.userId)
}
#endif
inline void Session::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.clickrank.Session.userId)
}
inline void Session::set_userid(const char* value, size_t size) {
  set_has_userid();
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.clickrank.Session.userId)
}
inline ::std::string* Session::mutable_userid() {
  set_has_userid();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.Session.userId)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_userid() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.clickrank.Session.userId)
  clear_has_userid();
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    set_has_userid();
  } else {
    clear_has_userid();
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.clickrank.Session.userId)
}

// repeated string quick_links = 4;
inline int Session::quick_links_size() const {
  return quick_links_.size();
}
inline void Session::clear_quick_links() {
  quick_links_.Clear();
}
inline const ::std::string& Session::quick_links(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.quick_links)
  return quick_links_.Get(index);
}
inline ::std::string* Session::mutable_quick_links(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.Session.quick_links)
  return quick_links_.Mutable(index);
}
inline void Session::set_quick_links(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.quick_links)
  quick_links_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Session::set_quick_links(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.quick_links)
  quick_links_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Session::set_quick_links(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  quick_links_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.clickrank.Session.quick_links)
}
inline void Session::set_quick_links(int index, const char* value, size_t size) {
  quick_links_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.clickrank.Session.quick_links)
}
inline ::std::string* Session::add_quick_links() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.clickrank.Session.quick_links)
  return quick_links_.Add();
}
inline void Session::add_quick_links(const ::std::string& value) {
  quick_links_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.clickrank.Session.quick_links)
}
#if LANG_CXX11
inline void Session::add_quick_links(::std::string&& value) {
  quick_links_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.clickrank.Session.quick_links)
}
#endif
inline void Session::add_quick_links(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  quick_links_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.clickrank.Session.quick_links)
}
inline void Session::add_quick_links(const char* value, size_t size) {
  quick_links_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.clickrank.Session.quick_links)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Session::quick_links() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.clickrank.Session.quick_links)
  return quick_links_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Session::mutable_quick_links() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.clickrank.Session.quick_links)
  return &quick_links_;
}

// optional uint64 timestamp = 5;
inline bool Session::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Session::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Session::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Session::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Session::timestamp() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.timestamp)
  return timestamp_;
}
inline void Session::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.timestamp)
}

// repeated uint64 click_time = 6;
inline int Session::click_time_size() const {
  return click_time_.size();
}
inline void Session::clear_click_time() {
  click_time_.Clear();
}
inline ::google::protobuf::uint64 Session::click_time(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.click_time)
  return click_time_.Get(index);
}
inline void Session::set_click_time(int index, ::google::protobuf::uint64 value) {
  click_time_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.click_time)
}
inline void Session::add_click_time(::google::protobuf::uint64 value) {
  click_time_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.clickrank.Session.click_time)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Session::click_time() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.clickrank.Session.click_time)
  return click_time_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Session::mutable_click_time() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.clickrank.Session.click_time)
  return &click_time_;
}

// optional .ru.mail.go.webbase.ranking.ParamList sessionInfo = 9;
inline bool Session::has_sessioninfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Session::set_has_sessioninfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Session::clear_has_sessioninfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Session::clear_sessioninfo() {
  if (sessioninfo_ != NULL) sessioninfo_->::ru::mail::go::webbase::ranking::ParamList::Clear();
  clear_has_sessioninfo();
}
inline const ::ru::mail::go::webbase::ranking::ParamList& Session::sessioninfo() const {
  const ::ru::mail::go::webbase::ranking::ParamList* p = sessioninfo_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.sessionInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::ranking::ParamList*>(
      &::ru::mail::go::webbase::ranking::_ParamList_default_instance_);
}
inline ::ru::mail::go::webbase::ranking::ParamList* Session::mutable_sessioninfo() {
  set_has_sessioninfo();
  if (sessioninfo_ == NULL) {
    sessioninfo_ = new ::ru::mail::go::webbase::ranking::ParamList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.Session.sessionInfo)
  return sessioninfo_;
}
inline ::ru::mail::go::webbase::ranking::ParamList* Session::release_sessioninfo() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.clickrank.Session.sessionInfo)
  clear_has_sessioninfo();
  ::ru::mail::go::webbase::ranking::ParamList* temp = sessioninfo_;
  sessioninfo_ = NULL;
  return temp;
}
inline void Session::set_allocated_sessioninfo(::ru::mail::go::webbase::ranking::ParamList* sessioninfo) {
  delete sessioninfo_;
  sessioninfo_ = sessioninfo;
  if (sessioninfo) {
    set_has_sessioninfo();
  } else {
    clear_has_sessioninfo();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.clickrank.Session.sessionInfo)
}

// optional string geoSpecific = 7;
inline bool Session::has_geospecific() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Session::set_has_geospecific() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Session::clear_has_geospecific() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Session::clear_geospecific() {
  geospecific_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_geospecific();
}
inline const ::std::string& Session::geospecific() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.geoSpecific)
  return geospecific_.GetNoArena();
}
inline void Session::set_geospecific(const ::std::string& value) {
  set_has_geospecific();
  geospecific_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.geoSpecific)
}
#if LANG_CXX11
inline void Session::set_geospecific(::std::string&& value) {
  set_has_geospecific();
  geospecific_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.clickrank.Session.geoSpecific)
}
#endif
inline void Session::set_geospecific(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_geospecific();
  geospecific_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.clickrank.Session.geoSpecific)
}
inline void Session::set_geospecific(const char* value, size_t size) {
  set_has_geospecific();
  geospecific_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.clickrank.Session.geoSpecific)
}
inline ::std::string* Session::mutable_geospecific() {
  set_has_geospecific();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.Session.geoSpecific)
  return geospecific_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_geospecific() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.clickrank.Session.geoSpecific)
  clear_has_geospecific();
  return geospecific_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_geospecific(::std::string* geospecific) {
  if (geospecific != NULL) {
    set_has_geospecific();
  } else {
    clear_has_geospecific();
  }
  geospecific_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), geospecific);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.clickrank.Session.geoSpecific)
}

// optional bool persional = 8;
inline bool Session::has_persional() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Session::set_has_persional() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Session::clear_has_persional() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Session::clear_persional() {
  persional_ = false;
  clear_has_persional();
}
inline bool Session::persional() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.persional)
  return persional_;
}
inline void Session::set_persional(bool value) {
  set_has_persional();
  persional_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.persional)
}

// repeated .ru.mail.go.webbase.SputnikRanker.Redirect redirect = 10;
inline int Session::redirect_size() const {
  return redirect_.size();
}
inline void Session::clear_redirect() {
  redirect_.Clear();
}
inline const ::ru::mail::go::webbase::SputnikRanker::Redirect& Session::redirect(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.redirect)
  return redirect_.Get(index);
}
inline ::ru::mail::go::webbase::SputnikRanker::Redirect* Session::mutable_redirect(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.Session.redirect)
  return redirect_.Mutable(index);
}
inline ::ru::mail::go::webbase::SputnikRanker::Redirect* Session::add_redirect() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.clickrank.Session.redirect)
  return redirect_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::SputnikRanker::Redirect >*
Session::mutable_redirect() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.clickrank.Session.redirect)
  return &redirect_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::SputnikRanker::Redirect >&
Session::redirect() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.clickrank.Session.redirect)
  return redirect_;
}

// optional string serp = 11;
inline bool Session::has_serp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Session::set_has_serp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Session::clear_has_serp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Session::clear_serp() {
  serp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serp();
}
inline const ::std::string& Session::serp() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.serp)
  return serp_.GetNoArena();
}
inline void Session::set_serp(const ::std::string& value) {
  set_has_serp();
  serp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.serp)
}
#if LANG_CXX11
inline void Session::set_serp(::std::string&& value) {
  set_has_serp();
  serp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.clickrank.Session.serp)
}
#endif
inline void Session::set_serp(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serp();
  serp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.clickrank.Session.serp)
}
inline void Session::set_serp(const char* value, size_t size) {
  set_has_serp();
  serp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.clickrank.Session.serp)
}
inline ::std::string* Session::mutable_serp() {
  set_has_serp();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.Session.serp)
  return serp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_serp() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.clickrank.Session.serp)
  clear_has_serp();
  return serp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_serp(::std::string* serp) {
  if (serp != NULL) {
    set_has_serp();
  } else {
    clear_has_serp();
  }
  serp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serp);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.clickrank.Session.serp)
}

// optional .ru.mail.go.webbase.ranking.ParamList dbType = 12;
inline bool Session::has_dbtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Session::set_has_dbtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Session::clear_has_dbtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Session::clear_dbtype() {
  if (dbtype_ != NULL) dbtype_->::ru::mail::go::webbase::ranking::ParamList::Clear();
  clear_has_dbtype();
}
inline const ::ru::mail::go::webbase::ranking::ParamList& Session::dbtype() const {
  const ::ru::mail::go::webbase::ranking::ParamList* p = dbtype_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.dbType)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::ranking::ParamList*>(
      &::ru::mail::go::webbase::ranking::_ParamList_default_instance_);
}
inline ::ru::mail::go::webbase::ranking::ParamList* Session::mutable_dbtype() {
  set_has_dbtype();
  if (dbtype_ == NULL) {
    dbtype_ = new ::ru::mail::go::webbase::ranking::ParamList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.clickrank.Session.dbType)
  return dbtype_;
}
inline ::ru::mail::go::webbase::ranking::ParamList* Session::release_dbtype() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.clickrank.Session.dbType)
  clear_has_dbtype();
  ::ru::mail::go::webbase::ranking::ParamList* temp = dbtype_;
  dbtype_ = NULL;
  return temp;
}
inline void Session::set_allocated_dbtype(::ru::mail::go::webbase::ranking::ParamList* dbtype) {
  delete dbtype_;
  dbtype_ = dbtype;
  if (dbtype) {
    set_has_dbtype();
  } else {
    clear_has_dbtype();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.clickrank.Session.dbType)
}

// repeated int32 aux_click = 13;
inline int Session::aux_click_size() const {
  return aux_click_.size();
}
inline void Session::clear_aux_click() {
  aux_click_.Clear();
}
inline ::google::protobuf::int32 Session::aux_click(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.aux_click)
  return aux_click_.Get(index);
}
inline void Session::set_aux_click(int index, ::google::protobuf::int32 value) {
  aux_click_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.aux_click)
}
inline void Session::add_aux_click(::google::protobuf::int32 value) {
  aux_click_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.clickrank.Session.aux_click)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Session::aux_click() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.clickrank.Session.aux_click)
  return aux_click_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Session::mutable_aux_click() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.clickrank.Session.aux_click)
  return &aux_click_;
}

// repeated uint64 aux_click_time = 14;
inline int Session::aux_click_time_size() const {
  return aux_click_time_.size();
}
inline void Session::clear_aux_click_time() {
  aux_click_time_.Clear();
}
inline ::google::protobuf::uint64 Session::aux_click_time(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.clickrank.Session.aux_click_time)
  return aux_click_time_.Get(index);
}
inline void Session::set_aux_click_time(int index, ::google::protobuf::uint64 value) {
  aux_click_time_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.clickrank.Session.aux_click_time)
}
inline void Session::add_aux_click_time(::google::protobuf::uint64 value) {
  aux_click_time_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.clickrank.Session.aux_click_time)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Session::aux_click_time() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.clickrank.Session.aux_click_time)
  return aux_click_time_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Session::mutable_aux_click_time() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.clickrank.Session.aux_click_time)
  return &aux_click_time_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace clickrank
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::webbase::clickrank::RecordType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::clickrank::RecordType>() {
  return ::ru::mail::go::webbase::clickrank::RecordType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_log_5fparser_2eproto__INCLUDED
