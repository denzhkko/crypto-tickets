// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: otvet.proto

#ifndef PROTOBUF_otvet_2eproto__INCLUDED
#define PROTOBUF_otvet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace otvet {
class Answer;
class AnswerDefaultTypeInternal;
extern AnswerDefaultTypeInternal _Answer_default_instance_;
class Category;
class CategoryDefaultTypeInternal;
extern CategoryDefaultTypeInternal _Category_default_instance_;
class Delete;
class DeleteDefaultTypeInternal;
extern DeleteDefaultTypeInternal _Delete_default_instance_;
class Meta;
class MetaDefaultTypeInternal;
extern MetaDefaultTypeInternal _Meta_default_instance_;
class Person;
class PersonDefaultTypeInternal;
extern PersonDefaultTypeInternal _Person_default_instance_;
class Question;
class QuestionDefaultTypeInternal;
extern QuestionDefaultTypeInternal _Question_default_instance_;
}  // namespace otvet
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace otvet {

namespace protobuf_otvet_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_otvet_2eproto

enum Meta_Type {
  Meta_Type_QUESTION = 1,
  Meta_Type_DELETE = 2
};
bool Meta_Type_IsValid(int value);
const Meta_Type Meta_Type_Type_MIN = Meta_Type_QUESTION;
const Meta_Type Meta_Type_Type_MAX = Meta_Type_DELETE;
const int Meta_Type_Type_ARRAYSIZE = Meta_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Meta_Type_descriptor();
inline const ::std::string& Meta_Type_Name(Meta_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Meta_Type_descriptor(), value);
}
inline bool Meta_Type_Parse(
    const ::std::string& name, Meta_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Meta_Type>(
    Meta_Type_descriptor(), name, value);
}
enum Question_Type {
  Question_Type_QUESTION = 1,
  Question_Type_POLL = 2
};
bool Question_Type_IsValid(int value);
const Question_Type Question_Type_Type_MIN = Question_Type_QUESTION;
const Question_Type Question_Type_Type_MAX = Question_Type_POLL;
const int Question_Type_Type_ARRAYSIZE = Question_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Question_Type_descriptor();
inline const ::std::string& Question_Type_Name(Question_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Question_Type_descriptor(), value);
}
inline bool Question_Type_Parse(
    const ::std::string& name, Question_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Question_Type>(
    Question_Type_descriptor(), name, value);
}
enum Question_State {
  Question_State_OPEN = 1,
  Question_State_VOTING = 2,
  Question_State_RESOLVED = 3
};
bool Question_State_IsValid(int value);
const Question_State Question_State_State_MIN = Question_State_OPEN;
const Question_State Question_State_State_MAX = Question_State_RESOLVED;
const int Question_State_State_ARRAYSIZE = Question_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* Question_State_descriptor();
inline const ::std::string& Question_State_Name(Question_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    Question_State_descriptor(), value);
}
inline bool Question_State_Parse(
    const ::std::string& name, Question_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Question_State>(
    Question_State_descriptor(), name, value);
}
// ===================================================================

class Meta : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.otvet.Meta) */ {
 public:
  Meta();
  virtual ~Meta();

  Meta(const Meta& from);

  inline Meta& operator=(const Meta& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Meta(Meta&& from) noexcept
    : Meta() {
    *this = ::std::move(from);
  }

  inline Meta& operator=(Meta&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Meta& default_instance();

  static inline const Meta* internal_default_instance() {
    return reinterpret_cast<const Meta*>(
               &_Meta_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Meta* other);
  friend void swap(Meta& a, Meta& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Meta* New() const PROTOBUF_FINAL { return New(NULL); }

  Meta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Meta& from);
  void MergeFrom(const Meta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Meta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Meta_Type Type;
  static const Type QUESTION =
    Meta_Type_QUESTION;
  static const Type DELETE =
    Meta_Type_DELETE;
  static inline bool Type_IsValid(int value) {
    return Meta_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Meta_Type_Type_MIN;
  static const Type Type_MAX =
    Meta_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Meta_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Meta_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Meta_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Meta_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // required uint32 version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // required .ru.mail.go.webbase.otvet.Meta.Type type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::ru::mail::go::webbase::otvet::Meta_Type type() const;
  void set_type(::ru::mail::go::webbase::otvet::Meta_Type value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.otvet.Meta)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_version();
  void clear_has_version();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 version_;
  int type_;
  friend struct protobuf_otvet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Delete : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.otvet.Delete) */ {
 public:
  Delete();
  virtual ~Delete();

  Delete(const Delete& from);

  inline Delete& operator=(const Delete& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Delete(Delete&& from) noexcept
    : Delete() {
    *this = ::std::move(from);
  }

  inline Delete& operator=(Delete&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Delete& default_instance();

  static inline const Delete* internal_default_instance() {
    return reinterpret_cast<const Delete*>(
               &_Delete_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Delete* other);
  friend void swap(Delete& a, Delete& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Delete* New() const PROTOBUF_FINAL { return New(NULL); }

  Delete* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Delete& from);
  void MergeFrom(const Delete& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Delete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.otvet.Delete)
 private:
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  friend struct protobuf_otvet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Person : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.otvet.Person) */ {
 public:
  Person();
  virtual ~Person();

  Person(const Person& from);

  inline Person& operator=(const Person& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Person(Person&& from) noexcept
    : Person() {
    *this = ::std::move(from);
  }

  inline Person& operator=(Person&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Person& default_instance();

  static inline const Person* internal_default_instance() {
    return reinterpret_cast<const Person*>(
               &_Person_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Person* other);
  friend void swap(Person& a, Person& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Person* New() const PROTOBUF_FINAL { return New(NULL); }

  Person* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Person& from);
  void MergeFrom(const Person& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Person* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nickname = 1;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  #if LANG_CXX11
  void set_nickname(::std::string&& value);
  #endif
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // required string email = 2;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 2;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // optional string filin = 3;
  bool has_filin() const;
  void clear_filin();
  static const int kFilinFieldNumber = 3;
  const ::std::string& filin() const;
  void set_filin(const ::std::string& value);
  #if LANG_CXX11
  void set_filin(::std::string&& value);
  #endif
  void set_filin(const char* value);
  void set_filin(const char* value, size_t size);
  ::std::string* mutable_filin();
  ::std::string* release_filin();
  void set_allocated_filin(::std::string* filin);

  // required uint64 id = 4;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 4;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.otvet.Person)
 private:
  void set_has_nickname();
  void clear_has_nickname();
  void set_has_email();
  void clear_has_email();
  void set_has_filin();
  void clear_has_filin();
  void set_has_id();
  void clear_has_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr filin_;
  ::google::protobuf::uint64 id_;
  friend struct protobuf_otvet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Category : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.otvet.Category) */ {
 public:
  Category();
  virtual ~Category();

  Category(const Category& from);

  inline Category& operator=(const Category& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Category(Category&& from) noexcept
    : Category() {
    *this = ::std::move(from);
  }

  inline Category& operator=(Category&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Category& default_instance();

  static inline const Category* internal_default_instance() {
    return reinterpret_cast<const Category*>(
               &_Category_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Category* other);
  friend void swap(Category& a, Category& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Category* New() const PROTOBUF_FINAL { return New(NULL); }

  Category* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Category& from);
  void MergeFrom(const Category& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Category* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint64 id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.otvet.Category)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_name();
  void clear_has_name();
  void set_has_id();
  void clear_has_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 id_;
  friend struct protobuf_otvet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Answer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.otvet.Answer) */ {
 public:
  Answer();
  virtual ~Answer();

  Answer(const Answer& from);

  inline Answer& operator=(const Answer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Answer(Answer&& from) noexcept
    : Answer() {
    *this = ::std::move(from);
  }

  inline Answer& operator=(Answer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Answer& default_instance();

  static inline const Answer* internal_default_instance() {
    return reinterpret_cast<const Answer*>(
               &_Answer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Answer* other);
  friend void swap(Answer& a, Answer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Answer* New() const PROTOBUF_FINAL { return New(NULL); }

  Answer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Answer& from);
  void MergeFrom(const Answer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Answer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string date = 2;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 2;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // required string text = 4;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 4;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional string source = 5;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 5;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // required .ru.mail.go.webbase.otvet.Person author = 1;
  bool has_author() const;
  void clear_author();
  static const int kAuthorFieldNumber = 1;
  const ::ru::mail::go::webbase::otvet::Person& author() const;
  ::ru::mail::go::webbase::otvet::Person* mutable_author();
  ::ru::mail::go::webbase::otvet::Person* release_author();
  void set_allocated_author(::ru::mail::go::webbase::otvet::Person* author);

  // required bool best = 3;
  bool has_best() const;
  void clear_best();
  static const int kBestFieldNumber = 3;
  bool best() const;
  void set_best(bool value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.otvet.Answer)
 private:
  void set_has_author();
  void clear_has_author();
  void set_has_date();
  void clear_has_date();
  void set_has_best();
  void clear_has_best();
  void set_has_text();
  void clear_has_text();
  void set_has_source();
  void clear_has_source();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::ru::mail::go::webbase::otvet::Person* author_;
  bool best_;
  friend struct protobuf_otvet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Question : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.otvet.Question) */ {
 public:
  Question();
  virtual ~Question();

  Question(const Question& from);

  inline Question& operator=(const Question& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Question(Question&& from) noexcept
    : Question() {
    *this = ::std::move(from);
  }

  inline Question& operator=(Question&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Question& default_instance();

  static inline const Question* internal_default_instance() {
    return reinterpret_cast<const Question*>(
               &_Question_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Question* other);
  friend void swap(Question& a, Question& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Question* New() const PROTOBUF_FINAL { return New(NULL); }

  Question* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Question& from);
  void MergeFrom(const Question& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Question* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Question_Type Type;
  static const Type QUESTION =
    Question_Type_QUESTION;
  static const Type POLL =
    Question_Type_POLL;
  static inline bool Type_IsValid(int value) {
    return Question_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Question_Type_Type_MIN;
  static const Type Type_MAX =
    Question_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Question_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Question_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Question_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Question_Type_Parse(name, value);
  }

  typedef Question_State State;
  static const State OPEN =
    Question_State_OPEN;
  static const State VOTING =
    Question_State_VOTING;
  static const State RESOLVED =
    Question_State_RESOLVED;
  static inline bool State_IsValid(int value) {
    return Question_State_IsValid(value);
  }
  static const State State_MIN =
    Question_State_State_MIN;
  static const State State_MAX =
    Question_State_State_MAX;
  static const int State_ARRAYSIZE =
    Question_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return Question_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return Question_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return Question_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.otvet.Answer answers = 11;
  int answers_size() const;
  void clear_answers();
  static const int kAnswersFieldNumber = 11;
  const ::ru::mail::go::webbase::otvet::Answer& answers(int index) const;
  ::ru::mail::go::webbase::otvet::Answer* mutable_answers(int index);
  ::ru::mail::go::webbase::otvet::Answer* add_answers();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::otvet::Answer >*
      mutable_answers();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::otvet::Answer >&
      answers() const;

  // required string date = 2;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 2;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // required string url = 3;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 3;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required string text = 6;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 6;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // required string comment = 7;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 7;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // required .ru.mail.go.webbase.otvet.Person author = 8;
  bool has_author() const;
  void clear_author();
  static const int kAuthorFieldNumber = 8;
  const ::ru::mail::go::webbase::otvet::Person& author() const;
  ::ru::mail::go::webbase::otvet::Person* mutable_author();
  ::ru::mail::go::webbase::otvet::Person* release_author();
  void set_allocated_author(::ru::mail::go::webbase::otvet::Person* author);

  // optional .ru.mail.go.webbase.otvet.Category category = 9;
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 9;
  const ::ru::mail::go::webbase::otvet::Category& category() const;
  ::ru::mail::go::webbase::otvet::Category* mutable_category();
  ::ru::mail::go::webbase::otvet::Category* release_category();
  void set_allocated_category(::ru::mail::go::webbase::otvet::Category* category);

  // required .ru.mail.go.webbase.otvet.Category subcategory = 10;
  bool has_subcategory() const;
  void clear_subcategory();
  static const int kSubcategoryFieldNumber = 10;
  const ::ru::mail::go::webbase::otvet::Category& subcategory() const;
  ::ru::mail::go::webbase::otvet::Category* mutable_subcategory();
  ::ru::mail::go::webbase::otvet::Category* release_subcategory();
  void set_allocated_subcategory(::ru::mail::go::webbase::otvet::Category* subcategory);

  // required uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // required .ru.mail.go.webbase.otvet.Question.State state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::ru::mail::go::webbase::otvet::Question_State state() const;
  void set_state(::ru::mail::go::webbase::otvet::Question_State value);

  // required .ru.mail.go.webbase.otvet.Question.Type type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::ru::mail::go::webbase::otvet::Question_Type type() const;
  void set_type(::ru::mail::go::webbase::otvet::Question_Type value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.otvet.Question)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_date();
  void clear_has_date();
  void set_has_url();
  void clear_has_url();
  void set_has_state();
  void clear_has_state();
  void set_has_type();
  void clear_has_type();
  void set_has_text();
  void clear_has_text();
  void set_has_comment();
  void clear_has_comment();
  void set_has_author();
  void clear_has_author();
  void set_has_category();
  void clear_has_category();
  void set_has_subcategory();
  void clear_has_subcategory();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::otvet::Answer > answers_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::ru::mail::go::webbase::otvet::Person* author_;
  ::ru::mail::go::webbase::otvet::Category* category_;
  ::ru::mail::go::webbase::otvet::Category* subcategory_;
  ::google::protobuf::uint64 id_;
  int state_;
  int type_;
  friend struct protobuf_otvet_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Meta

// required uint64 timestamp = 1;
inline bool Meta::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Meta::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Meta::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Meta::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Meta::timestamp() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Meta.timestamp)
  return timestamp_;
}
inline void Meta::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Meta.timestamp)
}

// required uint32 version = 2;
inline bool Meta::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Meta::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Meta::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Meta::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Meta::version() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Meta.version)
  return version_;
}
inline void Meta::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Meta.version)
}

// required .ru.mail.go.webbase.otvet.Meta.Type type = 3;
inline bool Meta::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Meta::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Meta::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Meta::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ru::mail::go::webbase::otvet::Meta_Type Meta::type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Meta.type)
  return static_cast< ::ru::mail::go::webbase::otvet::Meta_Type >(type_);
}
inline void Meta::set_type(::ru::mail::go::webbase::otvet::Meta_Type value) {
  assert(::ru::mail::go::webbase::otvet::Meta_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Meta.type)
}

// -------------------------------------------------------------------

// Delete

// required uint64 id = 1;
inline bool Delete::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Delete::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Delete::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Delete::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Delete::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Delete.id)
  return id_;
}
inline void Delete::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Delete.id)
}

// -------------------------------------------------------------------

// Person

// required string nickname = 1;
inline bool Person::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Person::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Person::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Person::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nickname();
}
inline const ::std::string& Person::nickname() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Person.nickname)
  return nickname_.GetNoArena();
}
inline void Person::set_nickname(const ::std::string& value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Person.nickname)
}
#if LANG_CXX11
inline void Person::set_nickname(::std::string&& value) {
  set_has_nickname();
  nickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Person.nickname)
}
#endif
inline void Person::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Person.nickname)
}
inline void Person::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Person.nickname)
}
inline ::std::string* Person::mutable_nickname() {
  set_has_nickname();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Person.nickname)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Person::release_nickname() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Person.nickname)
  clear_has_nickname();
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Person::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Person.nickname)
}

// required string email = 2;
inline bool Person::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Person::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Person::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Person::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_email();
}
inline const ::std::string& Person::email() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Person.email)
  return email_.GetNoArena();
}
inline void Person::set_email(const ::std::string& value) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Person.email)
}
#if LANG_CXX11
inline void Person::set_email(::std::string&& value) {
  set_has_email();
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Person.email)
}
#endif
inline void Person::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Person.email)
}
inline void Person::set_email(const char* value, size_t size) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Person.email)
}
inline ::std::string* Person::mutable_email() {
  set_has_email();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Person.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Person::release_email() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Person.email)
  clear_has_email();
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Person::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    set_has_email();
  } else {
    clear_has_email();
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Person.email)
}

// optional string filin = 3;
inline bool Person::has_filin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Person::set_has_filin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Person::clear_has_filin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Person::clear_filin() {
  filin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filin();
}
inline const ::std::string& Person::filin() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Person.filin)
  return filin_.GetNoArena();
}
inline void Person::set_filin(const ::std::string& value) {
  set_has_filin();
  filin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Person.filin)
}
#if LANG_CXX11
inline void Person::set_filin(::std::string&& value) {
  set_has_filin();
  filin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Person.filin)
}
#endif
inline void Person::set_filin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_filin();
  filin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Person.filin)
}
inline void Person::set_filin(const char* value, size_t size) {
  set_has_filin();
  filin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Person.filin)
}
inline ::std::string* Person::mutable_filin() {
  set_has_filin();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Person.filin)
  return filin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Person::release_filin() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Person.filin)
  clear_has_filin();
  return filin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Person::set_allocated_filin(::std::string* filin) {
  if (filin != NULL) {
    set_has_filin();
  } else {
    clear_has_filin();
  }
  filin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filin);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Person.filin)
}

// required uint64 id = 4;
inline bool Person::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Person::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Person::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Person::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Person::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Person.id)
  return id_;
}
inline void Person::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Person.id)
}

// -------------------------------------------------------------------

// Category

// required string url = 1;
inline bool Category::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Category::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Category::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Category::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& Category::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Category.url)
  return url_.GetNoArena();
}
inline void Category::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Category.url)
}
#if LANG_CXX11
inline void Category::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Category.url)
}
#endif
inline void Category::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Category.url)
}
inline void Category::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Category.url)
}
inline ::std::string* Category::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Category.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Category::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Category.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Category::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Category.url)
}

// required string name = 2;
inline bool Category::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Category::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Category::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Category::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Category::name() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Category.name)
  return name_.GetNoArena();
}
inline void Category::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Category.name)
}
#if LANG_CXX11
inline void Category::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Category.name)
}
#endif
inline void Category::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Category.name)
}
inline void Category::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Category.name)
}
inline ::std::string* Category::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Category.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Category::release_name() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Category.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Category::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Category.name)
}

// required uint64 id = 3;
inline bool Category::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Category::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Category::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Category::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Category::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Category.id)
  return id_;
}
inline void Category::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Category.id)
}

// -------------------------------------------------------------------

// Answer

// required .ru.mail.go.webbase.otvet.Person author = 1;
inline bool Answer::has_author() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Answer::set_has_author() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Answer::clear_has_author() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Answer::clear_author() {
  if (author_ != NULL) author_->::ru::mail::go::webbase::otvet::Person::Clear();
  clear_has_author();
}
inline const ::ru::mail::go::webbase::otvet::Person& Answer::author() const {
  const ::ru::mail::go::webbase::otvet::Person* p = author_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Answer.author)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::otvet::Person*>(
      &::ru::mail::go::webbase::otvet::_Person_default_instance_);
}
inline ::ru::mail::go::webbase::otvet::Person* Answer::mutable_author() {
  set_has_author();
  if (author_ == NULL) {
    author_ = new ::ru::mail::go::webbase::otvet::Person;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Answer.author)
  return author_;
}
inline ::ru::mail::go::webbase::otvet::Person* Answer::release_author() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Answer.author)
  clear_has_author();
  ::ru::mail::go::webbase::otvet::Person* temp = author_;
  author_ = NULL;
  return temp;
}
inline void Answer::set_allocated_author(::ru::mail::go::webbase::otvet::Person* author) {
  delete author_;
  author_ = author;
  if (author) {
    set_has_author();
  } else {
    clear_has_author();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Answer.author)
}

// required string date = 2;
inline bool Answer::has_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Answer::set_has_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Answer::clear_has_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Answer::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date();
}
inline const ::std::string& Answer::date() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Answer.date)
  return date_.GetNoArena();
}
inline void Answer::set_date(const ::std::string& value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Answer.date)
}
#if LANG_CXX11
inline void Answer::set_date(::std::string&& value) {
  set_has_date();
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Answer.date)
}
#endif
inline void Answer::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Answer.date)
}
inline void Answer::set_date(const char* value, size_t size) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Answer.date)
}
inline ::std::string* Answer::mutable_date() {
  set_has_date();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Answer.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Answer::release_date() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Answer.date)
  clear_has_date();
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Answer::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    set_has_date();
  } else {
    clear_has_date();
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Answer.date)
}

// required bool best = 3;
inline bool Answer::has_best() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Answer::set_has_best() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Answer::clear_has_best() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Answer::clear_best() {
  best_ = false;
  clear_has_best();
}
inline bool Answer::best() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Answer.best)
  return best_;
}
inline void Answer::set_best(bool value) {
  set_has_best();
  best_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Answer.best)
}

// required string text = 4;
inline bool Answer::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Answer::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Answer::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Answer::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Answer::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Answer.text)
  return text_.GetNoArena();
}
inline void Answer::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Answer.text)
}
#if LANG_CXX11
inline void Answer::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Answer.text)
}
#endif
inline void Answer::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Answer.text)
}
inline void Answer::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Answer.text)
}
inline ::std::string* Answer::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Answer.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Answer::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Answer.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Answer::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Answer.text)
}

// optional string source = 5;
inline bool Answer::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Answer::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Answer::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Answer::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source();
}
inline const ::std::string& Answer::source() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Answer.source)
  return source_.GetNoArena();
}
inline void Answer::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Answer.source)
}
#if LANG_CXX11
inline void Answer::set_source(::std::string&& value) {
  set_has_source();
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Answer.source)
}
#endif
inline void Answer::set_source(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Answer.source)
}
inline void Answer::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Answer.source)
}
inline ::std::string* Answer::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Answer.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Answer::release_source() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Answer.source)
  clear_has_source();
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Answer::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Answer.source)
}

// -------------------------------------------------------------------

// Question

// required uint64 id = 1;
inline bool Question::has_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Question::set_has_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Question::clear_has_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Question::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Question::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Question.id)
  return id_;
}
inline void Question::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Question.id)
}

// required string date = 2;
inline bool Question::has_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Question::set_has_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Question::clear_has_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Question::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date();
}
inline const ::std::string& Question::date() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Question.date)
  return date_.GetNoArena();
}
inline void Question::set_date(const ::std::string& value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Question.date)
}
#if LANG_CXX11
inline void Question::set_date(::std::string&& value) {
  set_has_date();
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Question.date)
}
#endif
inline void Question::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Question.date)
}
inline void Question::set_date(const char* value, size_t size) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Question.date)
}
inline ::std::string* Question::mutable_date() {
  set_has_date();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Question.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Question::release_date() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Question.date)
  clear_has_date();
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Question::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    set_has_date();
  } else {
    clear_has_date();
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Question.date)
}

// required string url = 3;
inline bool Question::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Question::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Question::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Question::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& Question::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Question.url)
  return url_.GetNoArena();
}
inline void Question::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Question.url)
}
#if LANG_CXX11
inline void Question::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Question.url)
}
#endif
inline void Question::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Question.url)
}
inline void Question::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Question.url)
}
inline ::std::string* Question::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Question.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Question::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Question.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Question::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Question.url)
}

// required .ru.mail.go.webbase.otvet.Question.State state = 4;
inline bool Question::has_state() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Question::set_has_state() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Question::clear_has_state() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Question::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::ru::mail::go::webbase::otvet::Question_State Question::state() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Question.state)
  return static_cast< ::ru::mail::go::webbase::otvet::Question_State >(state_);
}
inline void Question::set_state(::ru::mail::go::webbase::otvet::Question_State value) {
  assert(::ru::mail::go::webbase::otvet::Question_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Question.state)
}

// required .ru.mail.go.webbase.otvet.Question.Type type = 5;
inline bool Question::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Question::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Question::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Question::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::ru::mail::go::webbase::otvet::Question_Type Question::type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Question.type)
  return static_cast< ::ru::mail::go::webbase::otvet::Question_Type >(type_);
}
inline void Question::set_type(::ru::mail::go::webbase::otvet::Question_Type value) {
  assert(::ru::mail::go::webbase::otvet::Question_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Question.type)
}

// required string text = 6;
inline bool Question::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Question::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Question::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Question::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Question::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Question.text)
  return text_.GetNoArena();
}
inline void Question::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Question.text)
}
#if LANG_CXX11
inline void Question::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Question.text)
}
#endif
inline void Question::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Question.text)
}
inline void Question::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Question.text)
}
inline ::std::string* Question::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Question.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Question::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Question.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Question::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Question.text)
}

// required string comment = 7;
inline bool Question::has_comment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Question::set_has_comment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Question::clear_has_comment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Question::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comment();
}
inline const ::std::string& Question::comment() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Question.comment)
  return comment_.GetNoArena();
}
inline void Question::set_comment(const ::std::string& value) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.otvet.Question.comment)
}
#if LANG_CXX11
inline void Question::set_comment(::std::string&& value) {
  set_has_comment();
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.otvet.Question.comment)
}
#endif
inline void Question::set_comment(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.otvet.Question.comment)
}
inline void Question::set_comment(const char* value, size_t size) {
  set_has_comment();
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.otvet.Question.comment)
}
inline ::std::string* Question::mutable_comment() {
  set_has_comment();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Question.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Question::release_comment() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Question.comment)
  clear_has_comment();
  return comment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Question::set_allocated_comment(::std::string* comment) {
  if (comment != NULL) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Question.comment)
}

// required .ru.mail.go.webbase.otvet.Person author = 8;
inline bool Question::has_author() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Question::set_has_author() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Question::clear_has_author() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Question::clear_author() {
  if (author_ != NULL) author_->::ru::mail::go::webbase::otvet::Person::Clear();
  clear_has_author();
}
inline const ::ru::mail::go::webbase::otvet::Person& Question::author() const {
  const ::ru::mail::go::webbase::otvet::Person* p = author_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Question.author)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::otvet::Person*>(
      &::ru::mail::go::webbase::otvet::_Person_default_instance_);
}
inline ::ru::mail::go::webbase::otvet::Person* Question::mutable_author() {
  set_has_author();
  if (author_ == NULL) {
    author_ = new ::ru::mail::go::webbase::otvet::Person;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Question.author)
  return author_;
}
inline ::ru::mail::go::webbase::otvet::Person* Question::release_author() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Question.author)
  clear_has_author();
  ::ru::mail::go::webbase::otvet::Person* temp = author_;
  author_ = NULL;
  return temp;
}
inline void Question::set_allocated_author(::ru::mail::go::webbase::otvet::Person* author) {
  delete author_;
  author_ = author;
  if (author) {
    set_has_author();
  } else {
    clear_has_author();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Question.author)
}

// optional .ru.mail.go.webbase.otvet.Category category = 9;
inline bool Question::has_category() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Question::set_has_category() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Question::clear_has_category() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Question::clear_category() {
  if (category_ != NULL) category_->::ru::mail::go::webbase::otvet::Category::Clear();
  clear_has_category();
}
inline const ::ru::mail::go::webbase::otvet::Category& Question::category() const {
  const ::ru::mail::go::webbase::otvet::Category* p = category_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Question.category)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::otvet::Category*>(
      &::ru::mail::go::webbase::otvet::_Category_default_instance_);
}
inline ::ru::mail::go::webbase::otvet::Category* Question::mutable_category() {
  set_has_category();
  if (category_ == NULL) {
    category_ = new ::ru::mail::go::webbase::otvet::Category;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Question.category)
  return category_;
}
inline ::ru::mail::go::webbase::otvet::Category* Question::release_category() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Question.category)
  clear_has_category();
  ::ru::mail::go::webbase::otvet::Category* temp = category_;
  category_ = NULL;
  return temp;
}
inline void Question::set_allocated_category(::ru::mail::go::webbase::otvet::Category* category) {
  delete category_;
  category_ = category;
  if (category) {
    set_has_category();
  } else {
    clear_has_category();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Question.category)
}

// required .ru.mail.go.webbase.otvet.Category subcategory = 10;
inline bool Question::has_subcategory() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Question::set_has_subcategory() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Question::clear_has_subcategory() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Question::clear_subcategory() {
  if (subcategory_ != NULL) subcategory_->::ru::mail::go::webbase::otvet::Category::Clear();
  clear_has_subcategory();
}
inline const ::ru::mail::go::webbase::otvet::Category& Question::subcategory() const {
  const ::ru::mail::go::webbase::otvet::Category* p = subcategory_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Question.subcategory)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::otvet::Category*>(
      &::ru::mail::go::webbase::otvet::_Category_default_instance_);
}
inline ::ru::mail::go::webbase::otvet::Category* Question::mutable_subcategory() {
  set_has_subcategory();
  if (subcategory_ == NULL) {
    subcategory_ = new ::ru::mail::go::webbase::otvet::Category;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Question.subcategory)
  return subcategory_;
}
inline ::ru::mail::go::webbase::otvet::Category* Question::release_subcategory() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.otvet.Question.subcategory)
  clear_has_subcategory();
  ::ru::mail::go::webbase::otvet::Category* temp = subcategory_;
  subcategory_ = NULL;
  return temp;
}
inline void Question::set_allocated_subcategory(::ru::mail::go::webbase::otvet::Category* subcategory) {
  delete subcategory_;
  subcategory_ = subcategory;
  if (subcategory) {
    set_has_subcategory();
  } else {
    clear_has_subcategory();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.otvet.Question.subcategory)
}

// repeated .ru.mail.go.webbase.otvet.Answer answers = 11;
inline int Question::answers_size() const {
  return answers_.size();
}
inline void Question::clear_answers() {
  answers_.Clear();
}
inline const ::ru::mail::go::webbase::otvet::Answer& Question::answers(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.otvet.Question.answers)
  return answers_.Get(index);
}
inline ::ru::mail::go::webbase::otvet::Answer* Question::mutable_answers(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.otvet.Question.answers)
  return answers_.Mutable(index);
}
inline ::ru::mail::go::webbase::otvet::Answer* Question::add_answers() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.otvet.Question.answers)
  return answers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::otvet::Answer >*
Question::mutable_answers() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.otvet.Question.answers)
  return &answers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::otvet::Answer >&
Question::answers() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.otvet.Question.answers)
  return answers_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace otvet
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::webbase::otvet::Meta_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::otvet::Meta_Type>() {
  return ::ru::mail::go::webbase::otvet::Meta_Type_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::otvet::Question_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::otvet::Question_Type>() {
  return ::ru::mail::go::webbase::otvet::Question_Type_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::otvet::Question_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::otvet::Question_State>() {
  return ::ru::mail::go::webbase::otvet::Question_State_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_otvet_2eproto__INCLUDED
