// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: query_history.proto

#ifndef PROTOBUF_query_5fhistory_2eproto__INCLUDED
#define PROTOBUF_query_5fhistory_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace gogo {
namespace qhist {
class InfocardFactInfo;
class InfocardFactInfoDefaultTypeInternal;
extern InfocardFactInfoDefaultTypeInternal _InfocardFactInfo_default_instance_;
class InfocardInfo;
class InfocardInfoDefaultTypeInternal;
extern InfocardInfoDefaultTypeInternal _InfocardInfo_default_instance_;
class MixinInfo;
class MixinInfoDefaultTypeInternal;
extern MixinInfoDefaultTypeInternal _MixinInfo_default_instance_;
class MixinsData;
class MixinsDataDefaultTypeInternal;
extern MixinsDataDefaultTypeInternal _MixinsData_default_instance_;
class QueryClassifiersData;
class QueryClassifiersDataDefaultTypeInternal;
extern QueryClassifiersDataDefaultTypeInternal _QueryClassifiersData_default_instance_;
class QueryObjectInfo;
class QueryObjectInfoDefaultTypeInternal;
extern QueryObjectInfoDefaultTypeInternal _QueryObjectInfo_default_instance_;
class SunriseData;
class SunriseDataDefaultTypeInternal;
extern SunriseDataDefaultTypeInternal _SunriseData_default_instance_;
class TimeData;
class TimeDataDefaultTypeInternal;
extern TimeDataDefaultTypeInternal _TimeData_default_instance_;
class UserHistory;
class UserHistoryDefaultTypeInternal;
extern UserHistoryDefaultTypeInternal _UserHistory_default_instance_;
class UserHistoryQuery;
class UserHistoryQueryDefaultTypeInternal;
extern UserHistoryQueryDefaultTypeInternal _UserHistoryQuery_default_instance_;
class WeatherData;
class WeatherDataDefaultTypeInternal;
extern WeatherDataDefaultTypeInternal _WeatherData_default_instance_;
}  // namespace qhist
}  // namespace gogo

namespace gogo {
namespace qhist {

namespace protobuf_query_5fhistory_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_query_5fhistory_2eproto

enum MixinInfo_SerpSide {
  MixinInfo_SerpSide_LEFT = 1,
  MixinInfo_SerpSide_RIGHT = 2
};
bool MixinInfo_SerpSide_IsValid(int value);
const MixinInfo_SerpSide MixinInfo_SerpSide_SerpSide_MIN = MixinInfo_SerpSide_LEFT;
const MixinInfo_SerpSide MixinInfo_SerpSide_SerpSide_MAX = MixinInfo_SerpSide_RIGHT;
const int MixinInfo_SerpSide_SerpSide_ARRAYSIZE = MixinInfo_SerpSide_SerpSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* MixinInfo_SerpSide_descriptor();
inline const ::std::string& MixinInfo_SerpSide_Name(MixinInfo_SerpSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    MixinInfo_SerpSide_descriptor(), value);
}
inline bool MixinInfo_SerpSide_Parse(
    const ::std::string& name, MixinInfo_SerpSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MixinInfo_SerpSide>(
    MixinInfo_SerpSide_descriptor(), name, value);
}
enum SunriseData_SunriseType {
  SunriseData_SunriseType_SUNRISE = 1,
  SunriseData_SunriseType_SUNSET = 2,
  SunriseData_SunriseType_DAY_LENGTH = 3,
  SunriseData_SunriseType_NIGHT_LENGTH = 4
};
bool SunriseData_SunriseType_IsValid(int value);
const SunriseData_SunriseType SunriseData_SunriseType_SunriseType_MIN = SunriseData_SunriseType_SUNRISE;
const SunriseData_SunriseType SunriseData_SunriseType_SunriseType_MAX = SunriseData_SunriseType_NIGHT_LENGTH;
const int SunriseData_SunriseType_SunriseType_ARRAYSIZE = SunriseData_SunriseType_SunriseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SunriseData_SunriseType_descriptor();
inline const ::std::string& SunriseData_SunriseType_Name(SunriseData_SunriseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SunriseData_SunriseType_descriptor(), value);
}
inline bool SunriseData_SunriseType_Parse(
    const ::std::string& name, SunriseData_SunriseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SunriseData_SunriseType>(
    SunriseData_SunriseType_descriptor(), name, value);
}
// ===================================================================

class QueryClassifiersData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.qhist.QueryClassifiersData) */ {
 public:
  QueryClassifiersData();
  virtual ~QueryClassifiersData();

  QueryClassifiersData(const QueryClassifiersData& from);

  inline QueryClassifiersData& operator=(const QueryClassifiersData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryClassifiersData(QueryClassifiersData&& from) noexcept
    : QueryClassifiersData() {
    *this = ::std::move(from);
  }

  inline QueryClassifiersData& operator=(QueryClassifiersData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryClassifiersData& default_instance();

  static inline const QueryClassifiersData* internal_default_instance() {
    return reinterpret_cast<const QueryClassifiersData*>(
               &_QueryClassifiersData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(QueryClassifiersData* other);
  friend void swap(QueryClassifiersData& a, QueryClassifiersData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryClassifiersData* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryClassifiersData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryClassifiersData& from);
  void MergeFrom(const QueryClassifiersData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryClassifiersData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float infocard_prob = 1;
  bool has_infocard_prob() const;
  void clear_infocard_prob();
  static const int kInfocardProbFieldNumber = 1;
  float infocard_prob() const;
  void set_infocard_prob(float value);

  // optional float health_prob = 2;
  bool has_health_prob() const;
  void clear_health_prob();
  static const int kHealthProbFieldNumber = 2;
  float health_prob() const;
  void set_health_prob(float value);

  // optional float torg_prob = 3;
  bool has_torg_prob() const;
  void clear_torg_prob();
  static const int kTorgProbFieldNumber = 3;
  float torg_prob() const;
  void set_torg_prob(float value);

  // optional float film_prob = 4;
  bool has_film_prob() const;
  void clear_film_prob();
  static const int kFilmProbFieldNumber = 4;
  float film_prob() const;
  void set_film_prob(float value);

  // optional float porn_doc_prob = 6;
  bool has_porn_doc_prob() const;
  void clear_porn_doc_prob();
  static const int kPornDocProbFieldNumber = 6;
  float porn_doc_prob() const;
  void set_porn_doc_prob(float value);

  // optional float recipe_doc_prob = 7;
  bool has_recipe_doc_prob() const;
  void clear_recipe_doc_prob();
  static const int kRecipeDocProbFieldNumber = 7;
  float recipe_doc_prob() const;
  void set_recipe_doc_prob(float value);

  // optional float music_doc_prob = 8;
  bool has_music_doc_prob() const;
  void clear_music_doc_prob();
  static const int kMusicDocProbFieldNumber = 8;
  float music_doc_prob() const;
  void set_music_doc_prob(float value);

  // @@protoc_insertion_point(class_scope:gogo.qhist.QueryClassifiersData)
 private:
  void set_has_infocard_prob();
  void clear_has_infocard_prob();
  void set_has_health_prob();
  void clear_has_health_prob();
  void set_has_torg_prob();
  void clear_has_torg_prob();
  void set_has_film_prob();
  void clear_has_film_prob();
  void set_has_porn_doc_prob();
  void clear_has_porn_doc_prob();
  void set_has_recipe_doc_prob();
  void clear_has_recipe_doc_prob();
  void set_has_music_doc_prob();
  void clear_has_music_doc_prob();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float infocard_prob_;
  float health_prob_;
  float torg_prob_;
  float film_prob_;
  float porn_doc_prob_;
  float recipe_doc_prob_;
  float music_doc_prob_;
  friend struct protobuf_query_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MixinInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.qhist.MixinInfo) */ {
 public:
  MixinInfo();
  virtual ~MixinInfo();

  MixinInfo(const MixinInfo& from);

  inline MixinInfo& operator=(const MixinInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MixinInfo(MixinInfo&& from) noexcept
    : MixinInfo() {
    *this = ::std::move(from);
  }

  inline MixinInfo& operator=(MixinInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MixinInfo& default_instance();

  static inline const MixinInfo* internal_default_instance() {
    return reinterpret_cast<const MixinInfo*>(
               &_MixinInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(MixinInfo* other);
  friend void swap(MixinInfo& a, MixinInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MixinInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MixinInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MixinInfo& from);
  void MergeFrom(const MixinInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MixinInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MixinInfo_SerpSide SerpSide;
  static const SerpSide LEFT =
    MixinInfo_SerpSide_LEFT;
  static const SerpSide RIGHT =
    MixinInfo_SerpSide_RIGHT;
  static inline bool SerpSide_IsValid(int value) {
    return MixinInfo_SerpSide_IsValid(value);
  }
  static const SerpSide SerpSide_MIN =
    MixinInfo_SerpSide_SerpSide_MIN;
  static const SerpSide SerpSide_MAX =
    MixinInfo_SerpSide_SerpSide_MAX;
  static const int SerpSide_ARRAYSIZE =
    MixinInfo_SerpSide_SerpSide_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SerpSide_descriptor() {
    return MixinInfo_SerpSide_descriptor();
  }
  static inline const ::std::string& SerpSide_Name(SerpSide value) {
    return MixinInfo_SerpSide_Name(value);
  }
  static inline bool SerpSide_Parse(const ::std::string& name,
      SerpSide* value) {
    return MixinInfo_SerpSide_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // optional .gogo.qhist.MixinInfo.SerpSide side = 2;
  bool has_side() const;
  void clear_side();
  static const int kSideFieldNumber = 2;
  ::gogo::qhist::MixinInfo_SerpSide side() const;
  void set_side(::gogo::qhist::MixinInfo_SerpSide value);

  // @@protoc_insertion_point(class_scope:gogo.qhist.MixinInfo)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_side();
  void clear_has_side();
  void set_has_position();
  void clear_has_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 position_;
  int side_;
  friend struct protobuf_query_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InfocardFactInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.qhist.InfocardFactInfo) */ {
 public:
  InfocardFactInfo();
  virtual ~InfocardFactInfo();

  InfocardFactInfo(const InfocardFactInfo& from);

  inline InfocardFactInfo& operator=(const InfocardFactInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InfocardFactInfo(InfocardFactInfo&& from) noexcept
    : InfocardFactInfo() {
    *this = ::std::move(from);
  }

  inline InfocardFactInfo& operator=(InfocardFactInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfocardFactInfo& default_instance();

  static inline const InfocardFactInfo* internal_default_instance() {
    return reinterpret_cast<const InfocardFactInfo*>(
               &_InfocardFactInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(InfocardFactInfo* other);
  friend void swap(InfocardFactInfo& a, InfocardFactInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InfocardFactInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  InfocardFactInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InfocardFactInfo& from);
  void MergeFrom(const InfocardFactInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InfocardFactInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:gogo.qhist.InfocardFactInfo)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct protobuf_query_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InfocardInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.qhist.InfocardInfo) */ {
 public:
  InfocardInfo();
  virtual ~InfocardInfo();

  InfocardInfo(const InfocardInfo& from);

  inline InfocardInfo& operator=(const InfocardInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InfocardInfo(InfocardInfo&& from) noexcept
    : InfocardInfo() {
    *this = ::std::move(from);
  }

  inline InfocardInfo& operator=(InfocardInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InfocardInfo& default_instance();

  static inline const InfocardInfo* internal_default_instance() {
    return reinterpret_cast<const InfocardInfo*>(
               &_InfocardInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(InfocardInfo* other);
  friend void swap(InfocardInfo& a, InfocardInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InfocardInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  InfocardInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InfocardInfo& from);
  void MergeFrom(const InfocardInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InfocardInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .gogo.qhist.InfocardFactInfo fact = 3;
  bool has_fact() const;
  void clear_fact();
  static const int kFactFieldNumber = 3;
  const ::gogo::qhist::InfocardFactInfo& fact() const;
  ::gogo::qhist::InfocardFactInfo* mutable_fact();
  ::gogo::qhist::InfocardFactInfo* release_fact();
  void set_allocated_fact(::gogo::qhist::InfocardFactInfo* fact);

  // optional uint64 object = 1;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 1;
  ::google::protobuf::uint64 object() const;
  void set_object(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:gogo.qhist.InfocardInfo)
 private:
  void set_has_object();
  void clear_has_object();
  void set_has_fact();
  void clear_has_fact();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::gogo::qhist::InfocardFactInfo* fact_;
  ::google::protobuf::uint64 object_;
  friend struct protobuf_query_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryObjectInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.qhist.QueryObjectInfo) */ {
 public:
  QueryObjectInfo();
  virtual ~QueryObjectInfo();

  QueryObjectInfo(const QueryObjectInfo& from);

  inline QueryObjectInfo& operator=(const QueryObjectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryObjectInfo(QueryObjectInfo&& from) noexcept
    : QueryObjectInfo() {
    *this = ::std::move(from);
  }

  inline QueryObjectInfo& operator=(QueryObjectInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryObjectInfo& default_instance();

  static inline const QueryObjectInfo* internal_default_instance() {
    return reinterpret_cast<const QueryObjectInfo*>(
               &_QueryObjectInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(QueryObjectInfo* other);
  friend void swap(QueryObjectInfo& a, QueryObjectInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryObjectInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryObjectInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryObjectInfo& from);
  void MergeFrom(const QueryObjectInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryObjectInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:gogo.qhist.QueryObjectInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  friend struct protobuf_query_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MixinsData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.qhist.MixinsData) */ {
 public:
  MixinsData();
  virtual ~MixinsData();

  MixinsData(const MixinsData& from);

  inline MixinsData& operator=(const MixinsData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MixinsData(MixinsData&& from) noexcept
    : MixinsData() {
    *this = ::std::move(from);
  }

  inline MixinsData& operator=(MixinsData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MixinsData& default_instance();

  static inline const MixinsData* internal_default_instance() {
    return reinterpret_cast<const MixinsData*>(
               &_MixinsData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(MixinsData* other);
  friend void swap(MixinsData& a, MixinsData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MixinsData* New() const PROTOBUF_FINAL { return New(NULL); }

  MixinsData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MixinsData& from);
  void MergeFrom(const MixinsData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MixinsData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .gogo.qhist.WeatherData weather_data = 1;
  bool has_weather_data() const;
  void clear_weather_data();
  static const int kWeatherDataFieldNumber = 1;
  const ::gogo::qhist::WeatherData& weather_data() const;
  ::gogo::qhist::WeatherData* mutable_weather_data();
  ::gogo::qhist::WeatherData* release_weather_data();
  void set_allocated_weather_data(::gogo::qhist::WeatherData* weather_data);

  // optional .gogo.qhist.TimeData time_data = 2;
  bool has_time_data() const;
  void clear_time_data();
  static const int kTimeDataFieldNumber = 2;
  const ::gogo::qhist::TimeData& time_data() const;
  ::gogo::qhist::TimeData* mutable_time_data();
  ::gogo::qhist::TimeData* release_time_data();
  void set_allocated_time_data(::gogo::qhist::TimeData* time_data);

  // optional .gogo.qhist.SunriseData sunrise_data = 3;
  bool has_sunrise_data() const;
  void clear_sunrise_data();
  static const int kSunriseDataFieldNumber = 3;
  const ::gogo::qhist::SunriseData& sunrise_data() const;
  ::gogo::qhist::SunriseData* mutable_sunrise_data();
  ::gogo::qhist::SunriseData* release_sunrise_data();
  void set_allocated_sunrise_data(::gogo::qhist::SunriseData* sunrise_data);

  // @@protoc_insertion_point(class_scope:gogo.qhist.MixinsData)
 private:
  void set_has_weather_data();
  void clear_has_weather_data();
  void set_has_time_data();
  void clear_has_time_data();
  void set_has_sunrise_data();
  void clear_has_sunrise_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::gogo::qhist::WeatherData* weather_data_;
  ::gogo::qhist::TimeData* time_data_;
  ::gogo::qhist::SunriseData* sunrise_data_;
  friend struct protobuf_query_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WeatherData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.qhist.WeatherData) */ {
 public:
  WeatherData();
  virtual ~WeatherData();

  WeatherData(const WeatherData& from);

  inline WeatherData& operator=(const WeatherData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WeatherData(WeatherData&& from) noexcept
    : WeatherData() {
    *this = ::std::move(from);
  }

  inline WeatherData& operator=(WeatherData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeatherData& default_instance();

  static inline const WeatherData* internal_default_instance() {
    return reinterpret_cast<const WeatherData*>(
               &_WeatherData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(WeatherData* other);
  friend void swap(WeatherData& a, WeatherData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WeatherData* New() const PROTOBUF_FINAL { return New(NULL); }

  WeatherData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WeatherData& from);
  void MergeFrom(const WeatherData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WeatherData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string date = 3;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 3;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // optional uint64 city = 1;
  bool has_city() const;
  void clear_city();
  static const int kCityFieldNumber = 1;
  ::google::protobuf::uint64 city() const;
  void set_city(::google::protobuf::uint64 value);

  // optional int32 day = 2;
  bool has_day() const;
  void clear_day();
  static const int kDayFieldNumber = 2;
  ::google::protobuf::int32 day() const;
  void set_day(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gogo.qhist.WeatherData)
 private:
  void set_has_city();
  void clear_has_city();
  void set_has_day();
  void clear_has_day();
  void set_has_date();
  void clear_has_date();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::uint64 city_;
  ::google::protobuf::int32 day_;
  friend struct protobuf_query_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TimeData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.qhist.TimeData) */ {
 public:
  TimeData();
  virtual ~TimeData();

  TimeData(const TimeData& from);

  inline TimeData& operator=(const TimeData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimeData(TimeData&& from) noexcept
    : TimeData() {
    *this = ::std::move(from);
  }

  inline TimeData& operator=(TimeData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeData& default_instance();

  static inline const TimeData* internal_default_instance() {
    return reinterpret_cast<const TimeData*>(
               &_TimeData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TimeData* other);
  friend void swap(TimeData& a, TimeData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimeData* New() const PROTOBUF_FINAL { return New(NULL); }

  TimeData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TimeData& from);
  void MergeFrom(const TimeData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TimeData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 city = 1;
  bool has_city() const;
  void clear_city();
  static const int kCityFieldNumber = 1;
  ::google::protobuf::uint64 city() const;
  void set_city(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:gogo.qhist.TimeData)
 private:
  void set_has_city();
  void clear_has_city();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 city_;
  friend struct protobuf_query_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SunriseData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.qhist.SunriseData) */ {
 public:
  SunriseData();
  virtual ~SunriseData();

  SunriseData(const SunriseData& from);

  inline SunriseData& operator=(const SunriseData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SunriseData(SunriseData&& from) noexcept
    : SunriseData() {
    *this = ::std::move(from);
  }

  inline SunriseData& operator=(SunriseData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SunriseData& default_instance();

  static inline const SunriseData* internal_default_instance() {
    return reinterpret_cast<const SunriseData*>(
               &_SunriseData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SunriseData* other);
  friend void swap(SunriseData& a, SunriseData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SunriseData* New() const PROTOBUF_FINAL { return New(NULL); }

  SunriseData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SunriseData& from);
  void MergeFrom(const SunriseData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SunriseData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SunriseData_SunriseType SunriseType;
  static const SunriseType SUNRISE =
    SunriseData_SunriseType_SUNRISE;
  static const SunriseType SUNSET =
    SunriseData_SunriseType_SUNSET;
  static const SunriseType DAY_LENGTH =
    SunriseData_SunriseType_DAY_LENGTH;
  static const SunriseType NIGHT_LENGTH =
    SunriseData_SunriseType_NIGHT_LENGTH;
  static inline bool SunriseType_IsValid(int value) {
    return SunriseData_SunriseType_IsValid(value);
  }
  static const SunriseType SunriseType_MIN =
    SunriseData_SunriseType_SunriseType_MIN;
  static const SunriseType SunriseType_MAX =
    SunriseData_SunriseType_SunriseType_MAX;
  static const int SunriseType_ARRAYSIZE =
    SunriseData_SunriseType_SunriseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SunriseType_descriptor() {
    return SunriseData_SunriseType_descriptor();
  }
  static inline const ::std::string& SunriseType_Name(SunriseType value) {
    return SunriseData_SunriseType_Name(value);
  }
  static inline bool SunriseType_Parse(const ::std::string& name,
      SunriseType* value) {
    return SunriseData_SunriseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string date = 4;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 4;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // optional uint64 city = 2;
  bool has_city() const;
  void clear_city();
  static const int kCityFieldNumber = 2;
  ::google::protobuf::uint64 city() const;
  void set_city(::google::protobuf::uint64 value);

  // optional int32 day = 3;
  bool has_day() const;
  void clear_day();
  static const int kDayFieldNumber = 3;
  ::google::protobuf::int32 day() const;
  void set_day(::google::protobuf::int32 value);

  // optional .gogo.qhist.SunriseData.SunriseType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::gogo::qhist::SunriseData_SunriseType type() const;
  void set_type(::gogo::qhist::SunriseData_SunriseType value);

  // @@protoc_insertion_point(class_scope:gogo.qhist.SunriseData)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_city();
  void clear_has_city();
  void set_has_day();
  void clear_has_day();
  void set_has_date();
  void clear_has_date();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::uint64 city_;
  ::google::protobuf::int32 day_;
  int type_;
  friend struct protobuf_query_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHistoryQuery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.qhist.UserHistoryQuery) */ {
 public:
  UserHistoryQuery();
  virtual ~UserHistoryQuery();

  UserHistoryQuery(const UserHistoryQuery& from);

  inline UserHistoryQuery& operator=(const UserHistoryQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHistoryQuery(UserHistoryQuery&& from) noexcept
    : UserHistoryQuery() {
    *this = ::std::move(from);
  }

  inline UserHistoryQuery& operator=(UserHistoryQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHistoryQuery& default_instance();

  static inline const UserHistoryQuery* internal_default_instance() {
    return reinterpret_cast<const UserHistoryQuery*>(
               &_UserHistoryQuery_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(UserHistoryQuery* other);
  friend void swap(UserHistoryQuery& a, UserHistoryQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHistoryQuery* New() const PROTOBUF_FINAL { return New(NULL); }

  UserHistoryQuery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserHistoryQuery& from);
  void MergeFrom(const UserHistoryQuery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserHistoryQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gogo.qhist.MixinInfo mixins = 5;
  int mixins_size() const;
  void clear_mixins();
  static const int kMixinsFieldNumber = 5;
  const ::gogo::qhist::MixinInfo& mixins(int index) const;
  ::gogo::qhist::MixinInfo* mutable_mixins(int index);
  ::gogo::qhist::MixinInfo* add_mixins();
  ::google::protobuf::RepeatedPtrField< ::gogo::qhist::MixinInfo >*
      mutable_mixins();
  const ::google::protobuf::RepeatedPtrField< ::gogo::qhist::MixinInfo >&
      mixins() const;

  // repeated .gogo.qhist.InfocardInfo infocards = 6;
  int infocards_size() const;
  void clear_infocards();
  static const int kInfocardsFieldNumber = 6;
  const ::gogo::qhist::InfocardInfo& infocards(int index) const;
  ::gogo::qhist::InfocardInfo* mutable_infocards(int index);
  ::gogo::qhist::InfocardInfo* add_infocards();
  ::google::protobuf::RepeatedPtrField< ::gogo::qhist::InfocardInfo >*
      mutable_infocards();
  const ::google::protobuf::RepeatedPtrField< ::gogo::qhist::InfocardInfo >&
      infocards() const;

  // repeated .gogo.qhist.QueryObjectInfo query_objects = 7;
  int query_objects_size() const;
  void clear_query_objects();
  static const int kQueryObjectsFieldNumber = 7;
  const ::gogo::qhist::QueryObjectInfo& query_objects(int index) const;
  ::gogo::qhist::QueryObjectInfo* mutable_query_objects(int index);
  ::gogo::qhist::QueryObjectInfo* add_query_objects();
  ::google::protobuf::RepeatedPtrField< ::gogo::qhist::QueryObjectInfo >*
      mutable_query_objects();
  const ::google::protobuf::RepeatedPtrField< ::gogo::qhist::QueryObjectInfo >&
      query_objects() const;

  // optional string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional string bin_name = 3;
  bool has_bin_name() const;
  void clear_bin_name();
  static const int kBinNameFieldNumber = 3;
  const ::std::string& bin_name() const;
  void set_bin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_bin_name(::std::string&& value);
  #endif
  void set_bin_name(const char* value);
  void set_bin_name(const char* value, size_t size);
  ::std::string* mutable_bin_name();
  ::std::string* release_bin_name();
  void set_allocated_bin_name(::std::string* bin_name);

  // optional .gogo.qhist.QueryClassifiersData classifiers = 4;
  bool has_classifiers() const;
  void clear_classifiers();
  static const int kClassifiersFieldNumber = 4;
  const ::gogo::qhist::QueryClassifiersData& classifiers() const;
  ::gogo::qhist::QueryClassifiersData* mutable_classifiers();
  ::gogo::qhist::QueryClassifiersData* release_classifiers();
  void set_allocated_classifiers(::gogo::qhist::QueryClassifiersData* classifiers);

  // optional .gogo.qhist.MixinsData mixins_data = 8;
  bool has_mixins_data() const;
  void clear_mixins_data();
  static const int kMixinsDataFieldNumber = 8;
  const ::gogo::qhist::MixinsData& mixins_data() const;
  ::gogo::qhist::MixinsData* mutable_mixins_data();
  ::gogo::qhist::MixinsData* release_mixins_data();
  void set_allocated_mixins_data(::gogo::qhist::MixinsData* mixins_data);

  // optional uint64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:gogo.qhist.UserHistoryQuery)
 private:
  void set_has_text();
  void clear_has_text();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_bin_name();
  void clear_has_bin_name();
  void set_has_classifiers();
  void clear_has_classifiers();
  void set_has_mixins_data();
  void clear_has_mixins_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::gogo::qhist::MixinInfo > mixins_;
  ::google::protobuf::RepeatedPtrField< ::gogo::qhist::InfocardInfo > infocards_;
  ::google::protobuf::RepeatedPtrField< ::gogo::qhist::QueryObjectInfo > query_objects_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr bin_name_;
  ::gogo::qhist::QueryClassifiersData* classifiers_;
  ::gogo::qhist::MixinsData* mixins_data_;
  ::google::protobuf::uint64 timestamp_;
  friend struct protobuf_query_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserHistory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.qhist.UserHistory) */ {
 public:
  UserHistory();
  virtual ~UserHistory();

  UserHistory(const UserHistory& from);

  inline UserHistory& operator=(const UserHistory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserHistory(UserHistory&& from) noexcept
    : UserHistory() {
    *this = ::std::move(from);
  }

  inline UserHistory& operator=(UserHistory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHistory& default_instance();

  static inline const UserHistory* internal_default_instance() {
    return reinterpret_cast<const UserHistory*>(
               &_UserHistory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(UserHistory* other);
  friend void swap(UserHistory& a, UserHistory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserHistory* New() const PROTOBUF_FINAL { return New(NULL); }

  UserHistory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserHistory& from);
  void MergeFrom(const UserHistory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserHistory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gogo.qhist.UserHistoryQuery queries = 1;
  int queries_size() const;
  void clear_queries();
  static const int kQueriesFieldNumber = 1;
  const ::gogo::qhist::UserHistoryQuery& queries(int index) const;
  ::gogo::qhist::UserHistoryQuery* mutable_queries(int index);
  ::gogo::qhist::UserHistoryQuery* add_queries();
  ::google::protobuf::RepeatedPtrField< ::gogo::qhist::UserHistoryQuery >*
      mutable_queries();
  const ::google::protobuf::RepeatedPtrField< ::gogo::qhist::UserHistoryQuery >&
      queries() const;

  // optional string error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // optional uint32 enabled = 3;
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 3;
  ::google::protobuf::uint32 enabled() const;
  void set_enabled(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:gogo.qhist.UserHistory)
 private:
  void set_has_error();
  void clear_has_error();
  void set_has_enabled();
  void clear_has_enabled();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::gogo::qhist::UserHistoryQuery > queries_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::uint32 enabled_;
  friend struct protobuf_query_5fhistory_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// QueryClassifiersData

// optional float infocard_prob = 1;
inline bool QueryClassifiersData::has_infocard_prob() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryClassifiersData::set_has_infocard_prob() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryClassifiersData::clear_has_infocard_prob() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryClassifiersData::clear_infocard_prob() {
  infocard_prob_ = 0;
  clear_has_infocard_prob();
}
inline float QueryClassifiersData::infocard_prob() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.QueryClassifiersData.infocard_prob)
  return infocard_prob_;
}
inline void QueryClassifiersData::set_infocard_prob(float value) {
  set_has_infocard_prob();
  infocard_prob_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.QueryClassifiersData.infocard_prob)
}

// optional float health_prob = 2;
inline bool QueryClassifiersData::has_health_prob() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryClassifiersData::set_has_health_prob() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryClassifiersData::clear_has_health_prob() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryClassifiersData::clear_health_prob() {
  health_prob_ = 0;
  clear_has_health_prob();
}
inline float QueryClassifiersData::health_prob() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.QueryClassifiersData.health_prob)
  return health_prob_;
}
inline void QueryClassifiersData::set_health_prob(float value) {
  set_has_health_prob();
  health_prob_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.QueryClassifiersData.health_prob)
}

// optional float torg_prob = 3;
inline bool QueryClassifiersData::has_torg_prob() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryClassifiersData::set_has_torg_prob() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryClassifiersData::clear_has_torg_prob() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryClassifiersData::clear_torg_prob() {
  torg_prob_ = 0;
  clear_has_torg_prob();
}
inline float QueryClassifiersData::torg_prob() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.QueryClassifiersData.torg_prob)
  return torg_prob_;
}
inline void QueryClassifiersData::set_torg_prob(float value) {
  set_has_torg_prob();
  torg_prob_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.QueryClassifiersData.torg_prob)
}

// optional float film_prob = 4;
inline bool QueryClassifiersData::has_film_prob() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryClassifiersData::set_has_film_prob() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryClassifiersData::clear_has_film_prob() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryClassifiersData::clear_film_prob() {
  film_prob_ = 0;
  clear_has_film_prob();
}
inline float QueryClassifiersData::film_prob() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.QueryClassifiersData.film_prob)
  return film_prob_;
}
inline void QueryClassifiersData::set_film_prob(float value) {
  set_has_film_prob();
  film_prob_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.QueryClassifiersData.film_prob)
}

// optional float porn_doc_prob = 6;
inline bool QueryClassifiersData::has_porn_doc_prob() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QueryClassifiersData::set_has_porn_doc_prob() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QueryClassifiersData::clear_has_porn_doc_prob() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QueryClassifiersData::clear_porn_doc_prob() {
  porn_doc_prob_ = 0;
  clear_has_porn_doc_prob();
}
inline float QueryClassifiersData::porn_doc_prob() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.QueryClassifiersData.porn_doc_prob)
  return porn_doc_prob_;
}
inline void QueryClassifiersData::set_porn_doc_prob(float value) {
  set_has_porn_doc_prob();
  porn_doc_prob_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.QueryClassifiersData.porn_doc_prob)
}

// optional float recipe_doc_prob = 7;
inline bool QueryClassifiersData::has_recipe_doc_prob() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QueryClassifiersData::set_has_recipe_doc_prob() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QueryClassifiersData::clear_has_recipe_doc_prob() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QueryClassifiersData::clear_recipe_doc_prob() {
  recipe_doc_prob_ = 0;
  clear_has_recipe_doc_prob();
}
inline float QueryClassifiersData::recipe_doc_prob() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.QueryClassifiersData.recipe_doc_prob)
  return recipe_doc_prob_;
}
inline void QueryClassifiersData::set_recipe_doc_prob(float value) {
  set_has_recipe_doc_prob();
  recipe_doc_prob_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.QueryClassifiersData.recipe_doc_prob)
}

// optional float music_doc_prob = 8;
inline bool QueryClassifiersData::has_music_doc_prob() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void QueryClassifiersData::set_has_music_doc_prob() {
  _has_bits_[0] |= 0x00000040u;
}
inline void QueryClassifiersData::clear_has_music_doc_prob() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void QueryClassifiersData::clear_music_doc_prob() {
  music_doc_prob_ = 0;
  clear_has_music_doc_prob();
}
inline float QueryClassifiersData::music_doc_prob() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.QueryClassifiersData.music_doc_prob)
  return music_doc_prob_;
}
inline void QueryClassifiersData::set_music_doc_prob(float value) {
  set_has_music_doc_prob();
  music_doc_prob_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.QueryClassifiersData.music_doc_prob)
}

// -------------------------------------------------------------------

// MixinInfo

// optional string name = 1;
inline bool MixinInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MixinInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MixinInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MixinInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MixinInfo::name() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.MixinInfo.name)
  return name_.GetNoArena();
}
inline void MixinInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.qhist.MixinInfo.name)
}
#if LANG_CXX11
inline void MixinInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.qhist.MixinInfo.name)
}
#endif
inline void MixinInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.qhist.MixinInfo.name)
}
inline void MixinInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.qhist.MixinInfo.name)
}
inline ::std::string* MixinInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:gogo.qhist.MixinInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MixinInfo::release_name() {
  // @@protoc_insertion_point(field_release:gogo.qhist.MixinInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MixinInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.MixinInfo.name)
}

// optional .gogo.qhist.MixinInfo.SerpSide side = 2;
inline bool MixinInfo::has_side() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MixinInfo::set_has_side() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MixinInfo::clear_has_side() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MixinInfo::clear_side() {
  side_ = 1;
  clear_has_side();
}
inline ::gogo::qhist::MixinInfo_SerpSide MixinInfo::side() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.MixinInfo.side)
  return static_cast< ::gogo::qhist::MixinInfo_SerpSide >(side_);
}
inline void MixinInfo::set_side(::gogo::qhist::MixinInfo_SerpSide value) {
  assert(::gogo::qhist::MixinInfo_SerpSide_IsValid(value));
  set_has_side();
  side_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.MixinInfo.side)
}

// optional uint32 position = 3;
inline bool MixinInfo::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MixinInfo::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MixinInfo::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MixinInfo::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 MixinInfo::position() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.MixinInfo.position)
  return position_;
}
inline void MixinInfo::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.MixinInfo.position)
}

// -------------------------------------------------------------------

// InfocardFactInfo

// optional string name = 1;
inline bool InfocardFactInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfocardFactInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfocardFactInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfocardFactInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& InfocardFactInfo::name() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.InfocardFactInfo.name)
  return name_.GetNoArena();
}
inline void InfocardFactInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.qhist.InfocardFactInfo.name)
}
#if LANG_CXX11
inline void InfocardFactInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.qhist.InfocardFactInfo.name)
}
#endif
inline void InfocardFactInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.qhist.InfocardFactInfo.name)
}
inline void InfocardFactInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.qhist.InfocardFactInfo.name)
}
inline ::std::string* InfocardFactInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:gogo.qhist.InfocardFactInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InfocardFactInfo::release_name() {
  // @@protoc_insertion_point(field_release:gogo.qhist.InfocardFactInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InfocardFactInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.InfocardFactInfo.name)
}

// -------------------------------------------------------------------

// InfocardInfo

// optional uint64 object = 1;
inline bool InfocardInfo::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InfocardInfo::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InfocardInfo::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InfocardInfo::clear_object() {
  object_ = GOOGLE_ULONGLONG(0);
  clear_has_object();
}
inline ::google::protobuf::uint64 InfocardInfo::object() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.InfocardInfo.object)
  return object_;
}
inline void InfocardInfo::set_object(::google::protobuf::uint64 value) {
  set_has_object();
  object_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.InfocardInfo.object)
}

// optional .gogo.qhist.InfocardFactInfo fact = 3;
inline bool InfocardInfo::has_fact() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InfocardInfo::set_has_fact() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InfocardInfo::clear_has_fact() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InfocardInfo::clear_fact() {
  if (fact_ != NULL) fact_->::gogo::qhist::InfocardFactInfo::Clear();
  clear_has_fact();
}
inline const ::gogo::qhist::InfocardFactInfo& InfocardInfo::fact() const {
  const ::gogo::qhist::InfocardFactInfo* p = fact_;
  // @@protoc_insertion_point(field_get:gogo.qhist.InfocardInfo.fact)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::qhist::InfocardFactInfo*>(
      &::gogo::qhist::_InfocardFactInfo_default_instance_);
}
inline ::gogo::qhist::InfocardFactInfo* InfocardInfo::mutable_fact() {
  set_has_fact();
  if (fact_ == NULL) {
    fact_ = new ::gogo::qhist::InfocardFactInfo;
  }
  // @@protoc_insertion_point(field_mutable:gogo.qhist.InfocardInfo.fact)
  return fact_;
}
inline ::gogo::qhist::InfocardFactInfo* InfocardInfo::release_fact() {
  // @@protoc_insertion_point(field_release:gogo.qhist.InfocardInfo.fact)
  clear_has_fact();
  ::gogo::qhist::InfocardFactInfo* temp = fact_;
  fact_ = NULL;
  return temp;
}
inline void InfocardInfo::set_allocated_fact(::gogo::qhist::InfocardFactInfo* fact) {
  delete fact_;
  fact_ = fact;
  if (fact) {
    set_has_fact();
  } else {
    clear_has_fact();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.InfocardInfo.fact)
}

// -------------------------------------------------------------------

// QueryObjectInfo

// optional string type = 1;
inline bool QueryObjectInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryObjectInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryObjectInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryObjectInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& QueryObjectInfo::type() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.QueryObjectInfo.type)
  return type_.GetNoArena();
}
inline void QueryObjectInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.qhist.QueryObjectInfo.type)
}
#if LANG_CXX11
inline void QueryObjectInfo::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.qhist.QueryObjectInfo.type)
}
#endif
inline void QueryObjectInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.qhist.QueryObjectInfo.type)
}
inline void QueryObjectInfo::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.qhist.QueryObjectInfo.type)
}
inline ::std::string* QueryObjectInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:gogo.qhist.QueryObjectInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryObjectInfo::release_type() {
  // @@protoc_insertion_point(field_release:gogo.qhist.QueryObjectInfo.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryObjectInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.QueryObjectInfo.type)
}

// optional string text = 2;
inline bool QueryObjectInfo::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryObjectInfo::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryObjectInfo::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryObjectInfo::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& QueryObjectInfo::text() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.QueryObjectInfo.text)
  return text_.GetNoArena();
}
inline void QueryObjectInfo::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.qhist.QueryObjectInfo.text)
}
#if LANG_CXX11
inline void QueryObjectInfo::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.qhist.QueryObjectInfo.text)
}
#endif
inline void QueryObjectInfo::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.qhist.QueryObjectInfo.text)
}
inline void QueryObjectInfo::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.qhist.QueryObjectInfo.text)
}
inline ::std::string* QueryObjectInfo::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:gogo.qhist.QueryObjectInfo.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryObjectInfo::release_text() {
  // @@protoc_insertion_point(field_release:gogo.qhist.QueryObjectInfo.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryObjectInfo::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.QueryObjectInfo.text)
}

// -------------------------------------------------------------------

// MixinsData

// optional .gogo.qhist.WeatherData weather_data = 1;
inline bool MixinsData::has_weather_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MixinsData::set_has_weather_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MixinsData::clear_has_weather_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MixinsData::clear_weather_data() {
  if (weather_data_ != NULL) weather_data_->::gogo::qhist::WeatherData::Clear();
  clear_has_weather_data();
}
inline const ::gogo::qhist::WeatherData& MixinsData::weather_data() const {
  const ::gogo::qhist::WeatherData* p = weather_data_;
  // @@protoc_insertion_point(field_get:gogo.qhist.MixinsData.weather_data)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::qhist::WeatherData*>(
      &::gogo::qhist::_WeatherData_default_instance_);
}
inline ::gogo::qhist::WeatherData* MixinsData::mutable_weather_data() {
  set_has_weather_data();
  if (weather_data_ == NULL) {
    weather_data_ = new ::gogo::qhist::WeatherData;
  }
  // @@protoc_insertion_point(field_mutable:gogo.qhist.MixinsData.weather_data)
  return weather_data_;
}
inline ::gogo::qhist::WeatherData* MixinsData::release_weather_data() {
  // @@protoc_insertion_point(field_release:gogo.qhist.MixinsData.weather_data)
  clear_has_weather_data();
  ::gogo::qhist::WeatherData* temp = weather_data_;
  weather_data_ = NULL;
  return temp;
}
inline void MixinsData::set_allocated_weather_data(::gogo::qhist::WeatherData* weather_data) {
  delete weather_data_;
  weather_data_ = weather_data;
  if (weather_data) {
    set_has_weather_data();
  } else {
    clear_has_weather_data();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.MixinsData.weather_data)
}

// optional .gogo.qhist.TimeData time_data = 2;
inline bool MixinsData::has_time_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MixinsData::set_has_time_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MixinsData::clear_has_time_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MixinsData::clear_time_data() {
  if (time_data_ != NULL) time_data_->::gogo::qhist::TimeData::Clear();
  clear_has_time_data();
}
inline const ::gogo::qhist::TimeData& MixinsData::time_data() const {
  const ::gogo::qhist::TimeData* p = time_data_;
  // @@protoc_insertion_point(field_get:gogo.qhist.MixinsData.time_data)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::qhist::TimeData*>(
      &::gogo::qhist::_TimeData_default_instance_);
}
inline ::gogo::qhist::TimeData* MixinsData::mutable_time_data() {
  set_has_time_data();
  if (time_data_ == NULL) {
    time_data_ = new ::gogo::qhist::TimeData;
  }
  // @@protoc_insertion_point(field_mutable:gogo.qhist.MixinsData.time_data)
  return time_data_;
}
inline ::gogo::qhist::TimeData* MixinsData::release_time_data() {
  // @@protoc_insertion_point(field_release:gogo.qhist.MixinsData.time_data)
  clear_has_time_data();
  ::gogo::qhist::TimeData* temp = time_data_;
  time_data_ = NULL;
  return temp;
}
inline void MixinsData::set_allocated_time_data(::gogo::qhist::TimeData* time_data) {
  delete time_data_;
  time_data_ = time_data;
  if (time_data) {
    set_has_time_data();
  } else {
    clear_has_time_data();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.MixinsData.time_data)
}

// optional .gogo.qhist.SunriseData sunrise_data = 3;
inline bool MixinsData::has_sunrise_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MixinsData::set_has_sunrise_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MixinsData::clear_has_sunrise_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MixinsData::clear_sunrise_data() {
  if (sunrise_data_ != NULL) sunrise_data_->::gogo::qhist::SunriseData::Clear();
  clear_has_sunrise_data();
}
inline const ::gogo::qhist::SunriseData& MixinsData::sunrise_data() const {
  const ::gogo::qhist::SunriseData* p = sunrise_data_;
  // @@protoc_insertion_point(field_get:gogo.qhist.MixinsData.sunrise_data)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::qhist::SunriseData*>(
      &::gogo::qhist::_SunriseData_default_instance_);
}
inline ::gogo::qhist::SunriseData* MixinsData::mutable_sunrise_data() {
  set_has_sunrise_data();
  if (sunrise_data_ == NULL) {
    sunrise_data_ = new ::gogo::qhist::SunriseData;
  }
  // @@protoc_insertion_point(field_mutable:gogo.qhist.MixinsData.sunrise_data)
  return sunrise_data_;
}
inline ::gogo::qhist::SunriseData* MixinsData::release_sunrise_data() {
  // @@protoc_insertion_point(field_release:gogo.qhist.MixinsData.sunrise_data)
  clear_has_sunrise_data();
  ::gogo::qhist::SunriseData* temp = sunrise_data_;
  sunrise_data_ = NULL;
  return temp;
}
inline void MixinsData::set_allocated_sunrise_data(::gogo::qhist::SunriseData* sunrise_data) {
  delete sunrise_data_;
  sunrise_data_ = sunrise_data;
  if (sunrise_data) {
    set_has_sunrise_data();
  } else {
    clear_has_sunrise_data();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.MixinsData.sunrise_data)
}

// -------------------------------------------------------------------

// WeatherData

// optional uint64 city = 1;
inline bool WeatherData::has_city() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeatherData::set_has_city() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeatherData::clear_has_city() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeatherData::clear_city() {
  city_ = GOOGLE_ULONGLONG(0);
  clear_has_city();
}
inline ::google::protobuf::uint64 WeatherData::city() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.WeatherData.city)
  return city_;
}
inline void WeatherData::set_city(::google::protobuf::uint64 value) {
  set_has_city();
  city_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.WeatherData.city)
}

// optional int32 day = 2;
inline bool WeatherData::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeatherData::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeatherData::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeatherData::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 WeatherData::day() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.WeatherData.day)
  return day_;
}
inline void WeatherData::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.WeatherData.day)
}

// optional string date = 3;
inline bool WeatherData::has_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeatherData::set_has_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeatherData::clear_has_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeatherData::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date();
}
inline const ::std::string& WeatherData::date() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.WeatherData.date)
  return date_.GetNoArena();
}
inline void WeatherData::set_date(const ::std::string& value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.qhist.WeatherData.date)
}
#if LANG_CXX11
inline void WeatherData::set_date(::std::string&& value) {
  set_has_date();
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.qhist.WeatherData.date)
}
#endif
inline void WeatherData::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.qhist.WeatherData.date)
}
inline void WeatherData::set_date(const char* value, size_t size) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.qhist.WeatherData.date)
}
inline ::std::string* WeatherData::mutable_date() {
  set_has_date();
  // @@protoc_insertion_point(field_mutable:gogo.qhist.WeatherData.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WeatherData::release_date() {
  // @@protoc_insertion_point(field_release:gogo.qhist.WeatherData.date)
  clear_has_date();
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WeatherData::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    set_has_date();
  } else {
    clear_has_date();
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.WeatherData.date)
}

// -------------------------------------------------------------------

// TimeData

// optional uint64 city = 1;
inline bool TimeData::has_city() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeData::set_has_city() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeData::clear_has_city() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeData::clear_city() {
  city_ = GOOGLE_ULONGLONG(0);
  clear_has_city();
}
inline ::google::protobuf::uint64 TimeData::city() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.TimeData.city)
  return city_;
}
inline void TimeData::set_city(::google::protobuf::uint64 value) {
  set_has_city();
  city_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.TimeData.city)
}

// -------------------------------------------------------------------

// SunriseData

// optional .gogo.qhist.SunriseData.SunriseType type = 1;
inline bool SunriseData::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SunriseData::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SunriseData::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SunriseData::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::gogo::qhist::SunriseData_SunriseType SunriseData::type() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.SunriseData.type)
  return static_cast< ::gogo::qhist::SunriseData_SunriseType >(type_);
}
inline void SunriseData::set_type(::gogo::qhist::SunriseData_SunriseType value) {
  assert(::gogo::qhist::SunriseData_SunriseType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.SunriseData.type)
}

// optional uint64 city = 2;
inline bool SunriseData::has_city() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SunriseData::set_has_city() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SunriseData::clear_has_city() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SunriseData::clear_city() {
  city_ = GOOGLE_ULONGLONG(0);
  clear_has_city();
}
inline ::google::protobuf::uint64 SunriseData::city() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.SunriseData.city)
  return city_;
}
inline void SunriseData::set_city(::google::protobuf::uint64 value) {
  set_has_city();
  city_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.SunriseData.city)
}

// optional int32 day = 3;
inline bool SunriseData::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SunriseData::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SunriseData::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SunriseData::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 SunriseData::day() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.SunriseData.day)
  return day_;
}
inline void SunriseData::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.SunriseData.day)
}

// optional string date = 4;
inline bool SunriseData::has_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SunriseData::set_has_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SunriseData::clear_has_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SunriseData::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date();
}
inline const ::std::string& SunriseData::date() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.SunriseData.date)
  return date_.GetNoArena();
}
inline void SunriseData::set_date(const ::std::string& value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.qhist.SunriseData.date)
}
#if LANG_CXX11
inline void SunriseData::set_date(::std::string&& value) {
  set_has_date();
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.qhist.SunriseData.date)
}
#endif
inline void SunriseData::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.qhist.SunriseData.date)
}
inline void SunriseData::set_date(const char* value, size_t size) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.qhist.SunriseData.date)
}
inline ::std::string* SunriseData::mutable_date() {
  set_has_date();
  // @@protoc_insertion_point(field_mutable:gogo.qhist.SunriseData.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SunriseData::release_date() {
  // @@protoc_insertion_point(field_release:gogo.qhist.SunriseData.date)
  clear_has_date();
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SunriseData::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    set_has_date();
  } else {
    clear_has_date();
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.SunriseData.date)
}

// -------------------------------------------------------------------

// UserHistoryQuery

// optional string text = 1;
inline bool UserHistoryQuery::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHistoryQuery::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHistoryQuery::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHistoryQuery::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& UserHistoryQuery::text() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.UserHistoryQuery.text)
  return text_.GetNoArena();
}
inline void UserHistoryQuery::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.qhist.UserHistoryQuery.text)
}
#if LANG_CXX11
inline void UserHistoryQuery::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.qhist.UserHistoryQuery.text)
}
#endif
inline void UserHistoryQuery::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.qhist.UserHistoryQuery.text)
}
inline void UserHistoryQuery::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.qhist.UserHistoryQuery.text)
}
inline ::std::string* UserHistoryQuery::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:gogo.qhist.UserHistoryQuery.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserHistoryQuery::release_text() {
  // @@protoc_insertion_point(field_release:gogo.qhist.UserHistoryQuery.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserHistoryQuery::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.UserHistoryQuery.text)
}

// optional uint64 timestamp = 2;
inline bool UserHistoryQuery::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserHistoryQuery::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserHistoryQuery::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserHistoryQuery::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 UserHistoryQuery::timestamp() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.UserHistoryQuery.timestamp)
  return timestamp_;
}
inline void UserHistoryQuery::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.UserHistoryQuery.timestamp)
}

// optional string bin_name = 3;
inline bool UserHistoryQuery::has_bin_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHistoryQuery::set_has_bin_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHistoryQuery::clear_has_bin_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHistoryQuery::clear_bin_name() {
  bin_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bin_name();
}
inline const ::std::string& UserHistoryQuery::bin_name() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.UserHistoryQuery.bin_name)
  return bin_name_.GetNoArena();
}
inline void UserHistoryQuery::set_bin_name(const ::std::string& value) {
  set_has_bin_name();
  bin_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.qhist.UserHistoryQuery.bin_name)
}
#if LANG_CXX11
inline void UserHistoryQuery::set_bin_name(::std::string&& value) {
  set_has_bin_name();
  bin_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.qhist.UserHistoryQuery.bin_name)
}
#endif
inline void UserHistoryQuery::set_bin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bin_name();
  bin_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.qhist.UserHistoryQuery.bin_name)
}
inline void UserHistoryQuery::set_bin_name(const char* value, size_t size) {
  set_has_bin_name();
  bin_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.qhist.UserHistoryQuery.bin_name)
}
inline ::std::string* UserHistoryQuery::mutable_bin_name() {
  set_has_bin_name();
  // @@protoc_insertion_point(field_mutable:gogo.qhist.UserHistoryQuery.bin_name)
  return bin_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserHistoryQuery::release_bin_name() {
  // @@protoc_insertion_point(field_release:gogo.qhist.UserHistoryQuery.bin_name)
  clear_has_bin_name();
  return bin_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserHistoryQuery::set_allocated_bin_name(::std::string* bin_name) {
  if (bin_name != NULL) {
    set_has_bin_name();
  } else {
    clear_has_bin_name();
  }
  bin_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bin_name);
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.UserHistoryQuery.bin_name)
}

// optional .gogo.qhist.QueryClassifiersData classifiers = 4;
inline bool UserHistoryQuery::has_classifiers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserHistoryQuery::set_has_classifiers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserHistoryQuery::clear_has_classifiers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserHistoryQuery::clear_classifiers() {
  if (classifiers_ != NULL) classifiers_->::gogo::qhist::QueryClassifiersData::Clear();
  clear_has_classifiers();
}
inline const ::gogo::qhist::QueryClassifiersData& UserHistoryQuery::classifiers() const {
  const ::gogo::qhist::QueryClassifiersData* p = classifiers_;
  // @@protoc_insertion_point(field_get:gogo.qhist.UserHistoryQuery.classifiers)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::qhist::QueryClassifiersData*>(
      &::gogo::qhist::_QueryClassifiersData_default_instance_);
}
inline ::gogo::qhist::QueryClassifiersData* UserHistoryQuery::mutable_classifiers() {
  set_has_classifiers();
  if (classifiers_ == NULL) {
    classifiers_ = new ::gogo::qhist::QueryClassifiersData;
  }
  // @@protoc_insertion_point(field_mutable:gogo.qhist.UserHistoryQuery.classifiers)
  return classifiers_;
}
inline ::gogo::qhist::QueryClassifiersData* UserHistoryQuery::release_classifiers() {
  // @@protoc_insertion_point(field_release:gogo.qhist.UserHistoryQuery.classifiers)
  clear_has_classifiers();
  ::gogo::qhist::QueryClassifiersData* temp = classifiers_;
  classifiers_ = NULL;
  return temp;
}
inline void UserHistoryQuery::set_allocated_classifiers(::gogo::qhist::QueryClassifiersData* classifiers) {
  delete classifiers_;
  classifiers_ = classifiers;
  if (classifiers) {
    set_has_classifiers();
  } else {
    clear_has_classifiers();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.UserHistoryQuery.classifiers)
}

// repeated .gogo.qhist.MixinInfo mixins = 5;
inline int UserHistoryQuery::mixins_size() const {
  return mixins_.size();
}
inline void UserHistoryQuery::clear_mixins() {
  mixins_.Clear();
}
inline const ::gogo::qhist::MixinInfo& UserHistoryQuery::mixins(int index) const {
  // @@protoc_insertion_point(field_get:gogo.qhist.UserHistoryQuery.mixins)
  return mixins_.Get(index);
}
inline ::gogo::qhist::MixinInfo* UserHistoryQuery::mutable_mixins(int index) {
  // @@protoc_insertion_point(field_mutable:gogo.qhist.UserHistoryQuery.mixins)
  return mixins_.Mutable(index);
}
inline ::gogo::qhist::MixinInfo* UserHistoryQuery::add_mixins() {
  // @@protoc_insertion_point(field_add:gogo.qhist.UserHistoryQuery.mixins)
  return mixins_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gogo::qhist::MixinInfo >*
UserHistoryQuery::mutable_mixins() {
  // @@protoc_insertion_point(field_mutable_list:gogo.qhist.UserHistoryQuery.mixins)
  return &mixins_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gogo::qhist::MixinInfo >&
UserHistoryQuery::mixins() const {
  // @@protoc_insertion_point(field_list:gogo.qhist.UserHistoryQuery.mixins)
  return mixins_;
}

// repeated .gogo.qhist.InfocardInfo infocards = 6;
inline int UserHistoryQuery::infocards_size() const {
  return infocards_.size();
}
inline void UserHistoryQuery::clear_infocards() {
  infocards_.Clear();
}
inline const ::gogo::qhist::InfocardInfo& UserHistoryQuery::infocards(int index) const {
  // @@protoc_insertion_point(field_get:gogo.qhist.UserHistoryQuery.infocards)
  return infocards_.Get(index);
}
inline ::gogo::qhist::InfocardInfo* UserHistoryQuery::mutable_infocards(int index) {
  // @@protoc_insertion_point(field_mutable:gogo.qhist.UserHistoryQuery.infocards)
  return infocards_.Mutable(index);
}
inline ::gogo::qhist::InfocardInfo* UserHistoryQuery::add_infocards() {
  // @@protoc_insertion_point(field_add:gogo.qhist.UserHistoryQuery.infocards)
  return infocards_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gogo::qhist::InfocardInfo >*
UserHistoryQuery::mutable_infocards() {
  // @@protoc_insertion_point(field_mutable_list:gogo.qhist.UserHistoryQuery.infocards)
  return &infocards_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gogo::qhist::InfocardInfo >&
UserHistoryQuery::infocards() const {
  // @@protoc_insertion_point(field_list:gogo.qhist.UserHistoryQuery.infocards)
  return infocards_;
}

// repeated .gogo.qhist.QueryObjectInfo query_objects = 7;
inline int UserHistoryQuery::query_objects_size() const {
  return query_objects_.size();
}
inline void UserHistoryQuery::clear_query_objects() {
  query_objects_.Clear();
}
inline const ::gogo::qhist::QueryObjectInfo& UserHistoryQuery::query_objects(int index) const {
  // @@protoc_insertion_point(field_get:gogo.qhist.UserHistoryQuery.query_objects)
  return query_objects_.Get(index);
}
inline ::gogo::qhist::QueryObjectInfo* UserHistoryQuery::mutable_query_objects(int index) {
  // @@protoc_insertion_point(field_mutable:gogo.qhist.UserHistoryQuery.query_objects)
  return query_objects_.Mutable(index);
}
inline ::gogo::qhist::QueryObjectInfo* UserHistoryQuery::add_query_objects() {
  // @@protoc_insertion_point(field_add:gogo.qhist.UserHistoryQuery.query_objects)
  return query_objects_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gogo::qhist::QueryObjectInfo >*
UserHistoryQuery::mutable_query_objects() {
  // @@protoc_insertion_point(field_mutable_list:gogo.qhist.UserHistoryQuery.query_objects)
  return &query_objects_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gogo::qhist::QueryObjectInfo >&
UserHistoryQuery::query_objects() const {
  // @@protoc_insertion_point(field_list:gogo.qhist.UserHistoryQuery.query_objects)
  return query_objects_;
}

// optional .gogo.qhist.MixinsData mixins_data = 8;
inline bool UserHistoryQuery::has_mixins_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserHistoryQuery::set_has_mixins_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserHistoryQuery::clear_has_mixins_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserHistoryQuery::clear_mixins_data() {
  if (mixins_data_ != NULL) mixins_data_->::gogo::qhist::MixinsData::Clear();
  clear_has_mixins_data();
}
inline const ::gogo::qhist::MixinsData& UserHistoryQuery::mixins_data() const {
  const ::gogo::qhist::MixinsData* p = mixins_data_;
  // @@protoc_insertion_point(field_get:gogo.qhist.UserHistoryQuery.mixins_data)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::qhist::MixinsData*>(
      &::gogo::qhist::_MixinsData_default_instance_);
}
inline ::gogo::qhist::MixinsData* UserHistoryQuery::mutable_mixins_data() {
  set_has_mixins_data();
  if (mixins_data_ == NULL) {
    mixins_data_ = new ::gogo::qhist::MixinsData;
  }
  // @@protoc_insertion_point(field_mutable:gogo.qhist.UserHistoryQuery.mixins_data)
  return mixins_data_;
}
inline ::gogo::qhist::MixinsData* UserHistoryQuery::release_mixins_data() {
  // @@protoc_insertion_point(field_release:gogo.qhist.UserHistoryQuery.mixins_data)
  clear_has_mixins_data();
  ::gogo::qhist::MixinsData* temp = mixins_data_;
  mixins_data_ = NULL;
  return temp;
}
inline void UserHistoryQuery::set_allocated_mixins_data(::gogo::qhist::MixinsData* mixins_data) {
  delete mixins_data_;
  mixins_data_ = mixins_data;
  if (mixins_data) {
    set_has_mixins_data();
  } else {
    clear_has_mixins_data();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.UserHistoryQuery.mixins_data)
}

// -------------------------------------------------------------------

// UserHistory

// repeated .gogo.qhist.UserHistoryQuery queries = 1;
inline int UserHistory::queries_size() const {
  return queries_.size();
}
inline void UserHistory::clear_queries() {
  queries_.Clear();
}
inline const ::gogo::qhist::UserHistoryQuery& UserHistory::queries(int index) const {
  // @@protoc_insertion_point(field_get:gogo.qhist.UserHistory.queries)
  return queries_.Get(index);
}
inline ::gogo::qhist::UserHistoryQuery* UserHistory::mutable_queries(int index) {
  // @@protoc_insertion_point(field_mutable:gogo.qhist.UserHistory.queries)
  return queries_.Mutable(index);
}
inline ::gogo::qhist::UserHistoryQuery* UserHistory::add_queries() {
  // @@protoc_insertion_point(field_add:gogo.qhist.UserHistory.queries)
  return queries_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gogo::qhist::UserHistoryQuery >*
UserHistory::mutable_queries() {
  // @@protoc_insertion_point(field_mutable_list:gogo.qhist.UserHistory.queries)
  return &queries_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gogo::qhist::UserHistoryQuery >&
UserHistory::queries() const {
  // @@protoc_insertion_point(field_list:gogo.qhist.UserHistory.queries)
  return queries_;
}

// optional string error = 2;
inline bool UserHistory::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHistory::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHistory::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHistory::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& UserHistory::error() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.UserHistory.error)
  return error_.GetNoArena();
}
inline void UserHistory::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.qhist.UserHistory.error)
}
#if LANG_CXX11
inline void UserHistory::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.qhist.UserHistory.error)
}
#endif
inline void UserHistory::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.qhist.UserHistory.error)
}
inline void UserHistory::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.qhist.UserHistory.error)
}
inline ::std::string* UserHistory::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:gogo.qhist.UserHistory.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserHistory::release_error() {
  // @@protoc_insertion_point(field_release:gogo.qhist.UserHistory.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserHistory::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:gogo.qhist.UserHistory.error)
}

// optional uint32 enabled = 3;
inline bool UserHistory::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHistory::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHistory::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHistory::clear_enabled() {
  enabled_ = 0u;
  clear_has_enabled();
}
inline ::google::protobuf::uint32 UserHistory::enabled() const {
  // @@protoc_insertion_point(field_get:gogo.qhist.UserHistory.enabled)
  return enabled_;
}
inline void UserHistory::set_enabled(::google::protobuf::uint32 value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:gogo.qhist.UserHistory.enabled)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace qhist
}  // namespace gogo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::gogo::qhist::MixinInfo_SerpSide> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gogo::qhist::MixinInfo_SerpSide>() {
  return ::gogo::qhist::MixinInfo_SerpSide_descriptor();
}
template <> struct is_proto_enum< ::gogo::qhist::SunriseData_SunriseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gogo::qhist::SunriseData_SunriseType>() {
  return ::gogo::qhist::SunriseData_SunriseType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_query_5fhistory_2eproto__INCLUDED
