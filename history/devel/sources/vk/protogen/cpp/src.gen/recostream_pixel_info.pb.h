// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: recostream_pixel_info.proto

#ifndef PROTOBUF_recostream_5fpixel_5finfo_2eproto__INCLUDED
#define PROTOBUF_recostream_5fpixel_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "cosmo_result.pb.h"
#include "uuid.pb.h"
// @@protoc_insertion_point(includes)
namespace recostream {
namespace pb {
class DocumentMetaInfo;
class DocumentMetaInfoDefaultTypeInternal;
extern DocumentMetaInfoDefaultTypeInternal _DocumentMetaInfo_default_instance_;
class PromoInfo;
class PromoInfoDefaultTypeInternal;
extern PromoInfoDefaultTypeInternal _PromoInfo_default_instance_;
class ProviderMetaInfo;
class ProviderMetaInfoDefaultTypeInternal;
extern ProviderMetaInfoDefaultTypeInternal _ProviderMetaInfo_default_instance_;
class ProviderOriginInfo;
class ProviderOriginInfoDefaultTypeInternal;
extern ProviderOriginInfoDefaultTypeInternal _ProviderOriginInfo_default_instance_;
class ResultInfo;
class ResultInfoDefaultTypeInternal;
extern ResultInfoDefaultTypeInternal _ResultInfo_default_instance_;
class ResultMetaInfo;
class ResultMetaInfoDefaultTypeInternal;
extern ResultMetaInfoDefaultTypeInternal _ResultMetaInfo_default_instance_;
class UserInfo;
class UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
}  // namespace pb
}  // namespace recostream

namespace recostream {
namespace pb {

namespace protobuf_recostream_5fpixel_5finfo_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_recostream_5fpixel_5finfo_2eproto

// ===================================================================

class ResultInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.ResultInfo) */ {
 public:
  ResultInfo();
  virtual ~ResultInfo();

  ResultInfo(const ResultInfo& from);

  inline ResultInfo& operator=(const ResultInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResultInfo(ResultInfo&& from) noexcept
    : ResultInfo() {
    *this = ::std::move(from);
  }

  inline ResultInfo& operator=(ResultInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultInfo& default_instance();

  static inline const ResultInfo* internal_default_instance() {
    return reinterpret_cast<const ResultInfo*>(
               &_ResultInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ResultInfo* other);
  friend void swap(ResultInfo& a, ResultInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResultInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ResultInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResultInfo& from);
  void MergeFrom(const ResultInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResultInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string block_label = 2;
  bool has_block_label() const;
  void clear_block_label();
  static const int kBlockLabelFieldNumber = 2;
  const ::std::string& block_label() const;
  void set_block_label(const ::std::string& value);
  #if LANG_CXX11
  void set_block_label(::std::string&& value);
  #endif
  void set_block_label(const char* value);
  void set_block_label(const char* value, size_t size);
  ::std::string* mutable_block_label();
  ::std::string* release_block_label();
  void set_allocated_block_label(::std::string* block_label);

  // optional string distribution_channel_id = 12;
  bool has_distribution_channel_id() const;
  void clear_distribution_channel_id();
  static const int kDistributionChannelIdFieldNumber = 12;
  const ::std::string& distribution_channel_id() const;
  void set_distribution_channel_id(const ::std::string& value);
  #if LANG_CXX11
  void set_distribution_channel_id(::std::string&& value);
  #endif
  void set_distribution_channel_id(const char* value);
  void set_distribution_channel_id(const char* value, size_t size);
  ::std::string* mutable_distribution_channel_id();
  ::std::string* release_distribution_channel_id();
  void set_allocated_distribution_channel_id(::std::string* distribution_channel_id);

  // optional int32 position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // optional bool is_internal_url = 3;
  bool has_is_internal_url() const;
  void clear_is_internal_url();
  static const int kIsInternalUrlFieldNumber = 3;
  bool is_internal_url() const;
  void set_is_internal_url(bool value);

  // optional bool is_fulltext = 4;
  bool has_is_fulltext() const;
  void clear_is_fulltext();
  static const int kIsFulltextFieldNumber = 4;
  bool is_fulltext() const;
  void set_is_fulltext(bool value);

  // optional bool has_pictures = 5;
  bool has_has_pictures() const;
  void clear_has_pictures();
  static const int kHasPicturesFieldNumber = 5;
  bool has_pictures() const;
  void set_has_pictures(bool value);

  // optional bool is_commercial_fulltext = 6;
  bool has_is_commercial_fulltext() const;
  void clear_is_commercial_fulltext();
  static const int kIsCommercialFulltextFieldNumber = 6;
  bool is_commercial_fulltext() const;
  void set_is_commercial_fulltext(bool value);

  // optional int32 block_position = 7;
  bool has_block_position() const;
  void clear_block_position();
  static const int kBlockPositionFieldNumber = 7;
  ::google::protobuf::int32 block_position() const;
  void set_block_position(::google::protobuf::int32 value);

  // optional bool from_scrollable = 8;
  bool has_from_scrollable() const;
  void clear_from_scrollable();
  static const int kFromScrollableFieldNumber = 8;
  bool from_scrollable() const;
  void set_from_scrollable(bool value);

  // optional bool filler = 9;
  bool has_filler() const;
  void clear_filler();
  static const int kFillerFieldNumber = 9;
  bool filler() const;
  void set_filler(bool value);

  // optional bool is_video = 11;
  bool has_is_video() const;
  void clear_is_video();
  static const int kIsVideoFieldNumber = 11;
  bool is_video() const;
  void set_is_video(bool value);

  // optional int64 advert_sitename = 10;
  bool has_advert_sitename() const;
  void clear_advert_sitename();
  static const int kAdvertSitenameFieldNumber = 10;
  ::google::protobuf::int64 advert_sitename() const;
  void set_advert_sitename(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.ResultInfo)
 private:
  void set_has_position();
  void clear_has_position();
  void set_has_block_label();
  void clear_has_block_label();
  void set_has_is_internal_url();
  void clear_has_is_internal_url();
  void set_has_is_fulltext();
  void clear_has_is_fulltext();
  void set_has_has_pictures();
  void clear_has_has_pictures();
  void set_has_is_commercial_fulltext();
  void clear_has_is_commercial_fulltext();
  void set_has_block_position();
  void clear_has_block_position();
  void set_has_from_scrollable();
  void clear_has_from_scrollable();
  void set_has_filler();
  void clear_has_filler();
  void set_has_advert_sitename();
  void clear_has_advert_sitename();
  void set_has_is_video();
  void clear_has_is_video();
  void set_has_distribution_channel_id();
  void clear_has_distribution_channel_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr block_label_;
  ::google::protobuf::internal::ArenaStringPtr distribution_channel_id_;
  ::google::protobuf::int32 position_;
  bool is_internal_url_;
  bool is_fulltext_;
  bool has_pictures_;
  bool is_commercial_fulltext_;
  ::google::protobuf::int32 block_position_;
  bool from_scrollable_;
  bool filler_;
  bool is_video_;
  ::google::protobuf::int64 advert_sitename_;
  friend struct protobuf_recostream_5fpixel_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PromoInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.PromoInfo) */ {
 public:
  PromoInfo();
  virtual ~PromoInfo();

  PromoInfo(const PromoInfo& from);

  inline PromoInfo& operator=(const PromoInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PromoInfo(PromoInfo&& from) noexcept
    : PromoInfo() {
    *this = ::std::move(from);
  }

  inline PromoInfo& operator=(PromoInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PromoInfo& default_instance();

  static inline const PromoInfo* internal_default_instance() {
    return reinterpret_cast<const PromoInfo*>(
               &_PromoInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(PromoInfo* other);
  friend void swap(PromoInfo& a, PromoInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PromoInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PromoInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PromoInfo& from);
  void MergeFrom(const PromoInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PromoInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 active_campaigns = 1;
  int active_campaigns_size() const;
  void clear_active_campaigns();
  static const int kActiveCampaignsFieldNumber = 1;
  ::google::protobuf::int32 active_campaigns(int index) const;
  void set_active_campaigns(int index, ::google::protobuf::int32 value);
  void add_active_campaigns(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      active_campaigns() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_active_campaigns();

  // @@protoc_insertion_point(class_scope:recostream.pb.PromoInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > active_campaigns_;
  friend struct protobuf_recostream_5fpixel_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.UserInfo) */ {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(UserInfo* other);
  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  UserInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string geo = 4;
  bool has_geo() const;
  void clear_geo();
  static const int kGeoFieldNumber = 4;
  const ::std::string& geo() const;
  void set_geo(const ::std::string& value);
  #if LANG_CXX11
  void set_geo(::std::string&& value);
  #endif
  void set_geo(const char* value);
  void set_geo(const char* value, size_t size);
  ::std::string* mutable_geo();
  ::std::string* release_geo();
  void set_allocated_geo(::std::string* geo);

  // optional string idfa = 9;
  bool has_idfa() const;
  void clear_idfa();
  static const int kIdfaFieldNumber = 9;
  const ::std::string& idfa() const;
  void set_idfa(const ::std::string& value);
  #if LANG_CXX11
  void set_idfa(::std::string&& value);
  #endif
  void set_idfa(const char* value);
  void set_idfa(const char* value, size_t size);
  ::std::string* mutable_idfa();
  ::std::string* release_idfa();
  void set_allocated_idfa(::std::string* idfa);

  // optional string gaid = 10;
  bool has_gaid() const;
  void clear_gaid();
  static const int kGaidFieldNumber = 10;
  const ::std::string& gaid() const;
  void set_gaid(const ::std::string& value);
  #if LANG_CXX11
  void set_gaid(::std::string&& value);
  #endif
  void set_gaid(const char* value);
  void set_gaid(const char* value, size_t size);
  ::std::string* mutable_gaid();
  ::std::string* release_gaid();
  void set_allocated_gaid(::std::string* gaid);

  // optional .utils.pb.UUID compact_idfa = 11;
  bool has_compact_idfa() const;
  void clear_compact_idfa();
  static const int kCompactIdfaFieldNumber = 11;
  const ::utils::pb::UUID& compact_idfa() const;
  ::utils::pb::UUID* mutable_compact_idfa();
  ::utils::pb::UUID* release_compact_idfa();
  void set_allocated_compact_idfa(::utils::pb::UUID* compact_idfa);

  // optional .utils.pb.UUID compact_gaid = 12;
  bool has_compact_gaid() const;
  void clear_compact_gaid();
  static const int kCompactGaidFieldNumber = 12;
  const ::utils::pb::UUID& compact_gaid() const;
  ::utils::pb::UUID* mutable_compact_gaid();
  ::utils::pb::UUID* release_compact_gaid();
  void set_allocated_compact_gaid(::utils::pb::UUID* compact_gaid);

  // optional int64 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int64 user_id() const;
  void set_user_id(::google::protobuf::int64 value);

  // optional int64 vid = 2;
  bool has_vid() const;
  void clear_vid();
  static const int kVidFieldNumber = 2;
  ::google::protobuf::int64 vid() const;
  void set_vid(::google::protobuf::int64 value);

  // optional int64 hash_email = 3;
  bool has_hash_email() const;
  void clear_hash_email();
  static const int kHashEmailFieldNumber = 3;
  ::google::protobuf::int64 hash_email() const;
  void set_hash_email(::google::protobuf::int64 value);

  // optional uint32 age = 5;
  bool has_age() const;
  void clear_age();
  static const int kAgeFieldNumber = 5;
  ::google::protobuf::uint32 age() const;
  void set_age(::google::protobuf::uint32 value);

  // optional bool sex = 6;
  bool has_sex() const;
  void clear_sex();
  static const int kSexFieldNumber = 6;
  bool sex() const;
  void set_sex(bool value);

  // optional int64 hash_device_id = 7;
  bool has_hash_device_id() const;
  void clear_hash_device_id();
  static const int kHashDeviceIdFieldNumber = 7;
  ::google::protobuf::int64 hash_device_id() const;
  void set_hash_device_id(::google::protobuf::int64 value);

  // optional int64 hash_advertising_id = 8;
  bool has_hash_advertising_id() const;
  void clear_hash_advertising_id();
  static const int kHashAdvertisingIdFieldNumber = 8;
  ::google::protobuf::int64 hash_advertising_id() const;
  void set_hash_advertising_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.UserInfo)
 private:
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_vid();
  void clear_has_vid();
  void set_has_hash_email();
  void clear_has_hash_email();
  void set_has_geo();
  void clear_has_geo();
  void set_has_age();
  void clear_has_age();
  void set_has_sex();
  void clear_has_sex();
  void set_has_hash_device_id();
  void clear_has_hash_device_id();
  void set_has_hash_advertising_id();
  void clear_has_hash_advertising_id();
  void set_has_idfa();
  void clear_has_idfa();
  void set_has_gaid();
  void clear_has_gaid();
  void set_has_compact_idfa();
  void clear_has_compact_idfa();
  void set_has_compact_gaid();
  void clear_has_compact_gaid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr geo_;
  ::google::protobuf::internal::ArenaStringPtr idfa_;
  ::google::protobuf::internal::ArenaStringPtr gaid_;
  ::utils::pb::UUID* compact_idfa_;
  ::utils::pb::UUID* compact_gaid_;
  ::google::protobuf::int64 user_id_;
  ::google::protobuf::int64 vid_;
  ::google::protobuf::int64 hash_email_;
  ::google::protobuf::uint32 age_;
  bool sex_;
  ::google::protobuf::int64 hash_device_id_;
  ::google::protobuf::int64 hash_advertising_id_;
  friend struct protobuf_recostream_5fpixel_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DocumentMetaInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.DocumentMetaInfo) */ {
 public:
  DocumentMetaInfo();
  virtual ~DocumentMetaInfo();

  DocumentMetaInfo(const DocumentMetaInfo& from);

  inline DocumentMetaInfo& operator=(const DocumentMetaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DocumentMetaInfo(DocumentMetaInfo&& from) noexcept
    : DocumentMetaInfo() {
    *this = ::std::move(from);
  }

  inline DocumentMetaInfo& operator=(DocumentMetaInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DocumentMetaInfo& default_instance();

  static inline const DocumentMetaInfo* internal_default_instance() {
    return reinterpret_cast<const DocumentMetaInfo*>(
               &_DocumentMetaInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(DocumentMetaInfo* other);
  friend void swap(DocumentMetaInfo& a, DocumentMetaInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DocumentMetaInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DocumentMetaInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DocumentMetaInfo& from);
  void MergeFrom(const DocumentMetaInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DocumentMetaInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string from_label = 6;
  bool has_from_label() const;
  void clear_from_label();
  static const int kFromLabelFieldNumber = 6;
  const ::std::string& from_label() const;
  void set_from_label(const ::std::string& value);
  #if LANG_CXX11
  void set_from_label(::std::string&& value);
  #endif
  void set_from_label(const char* value);
  void set_from_label(const char* value, size_t size);
  ::std::string* mutable_from_label();
  ::std::string* release_from_label();
  void set_allocated_from_label(::std::string* from_label);

  // optional string url = 9;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 9;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional .cosmo.pb.Metrics metrics = 1;
  bool has_metrics() const;
  void clear_metrics();
  static const int kMetricsFieldNumber = 1;
  const ::cosmo::pb::Metrics& metrics() const;
  ::cosmo::pb::Metrics* mutable_metrics();
  ::cosmo::pb::Metrics* release_metrics();
  void set_allocated_metrics(::cosmo::pb::Metrics* metrics);

  // optional .cosmo.pb.DocumentInfo document_info = 2;
  bool has_document_info() const;
  void clear_document_info();
  static const int kDocumentInfoFieldNumber = 2;
  const ::cosmo::pb::DocumentInfo& document_info() const;
  ::cosmo::pb::DocumentInfo* mutable_document_info();
  ::cosmo::pb::DocumentInfo* release_document_info();
  void set_allocated_document_info(::cosmo::pb::DocumentInfo* document_info);

  // optional .cosmo.pb.InterleavingInfo interleaving_info = 3;
  bool has_interleaving_info() const;
  void clear_interleaving_info();
  static const int kInterleavingInfoFieldNumber = 3;
  const ::cosmo::pb::InterleavingInfo& interleaving_info() const;
  ::cosmo::pb::InterleavingInfo* mutable_interleaving_info();
  ::cosmo::pb::InterleavingInfo* release_interleaving_info();
  void set_allocated_interleaving_info(::cosmo::pb::InterleavingInfo* interleaving_info);

  // optional .cosmo.pb.MixerInfo mixer_info = 4;
  bool has_mixer_info() const;
  void clear_mixer_info();
  static const int kMixerInfoFieldNumber = 4;
  const ::cosmo::pb::MixerInfo& mixer_info() const;
  ::cosmo::pb::MixerInfo* mutable_mixer_info();
  ::cosmo::pb::MixerInfo* release_mixer_info();
  void set_allocated_mixer_info(::cosmo::pb::MixerInfo* mixer_info);

  // optional .recostream.pb.ResultInfo result_info = 5;
  bool has_result_info() const;
  void clear_result_info();
  static const int kResultInfoFieldNumber = 5;
  const ::recostream::pb::ResultInfo& result_info() const;
  ::recostream::pb::ResultInfo* mutable_result_info();
  ::recostream::pb::ResultInfo* release_result_info();
  void set_allocated_result_info(::recostream::pb::ResultInfo* result_info);

  // optional .recostream.pb.PromoInfo promo_info = 7;
  bool has_promo_info() const;
  void clear_promo_info();
  static const int kPromoInfoFieldNumber = 7;
  const ::recostream::pb::PromoInfo& promo_info() const;
  ::recostream::pb::PromoInfo* mutable_promo_info();
  ::recostream::pb::PromoInfo* release_promo_info();
  void set_allocated_promo_info(::recostream::pb::PromoInfo* promo_info);

  // optional .recostream.pb.UserInfo user_info = 8;
  bool has_user_info() const;
  void clear_user_info();
  static const int kUserInfoFieldNumber = 8;
  const ::recostream::pb::UserInfo& user_info() const;
  ::recostream::pb::UserInfo* mutable_user_info();
  ::recostream::pb::UserInfo* release_user_info();
  void set_allocated_user_info(::recostream::pb::UserInfo* user_info);

  // @@protoc_insertion_point(class_scope:recostream.pb.DocumentMetaInfo)
 private:
  void set_has_metrics();
  void clear_has_metrics();
  void set_has_document_info();
  void clear_has_document_info();
  void set_has_interleaving_info();
  void clear_has_interleaving_info();
  void set_has_mixer_info();
  void clear_has_mixer_info();
  void set_has_result_info();
  void clear_has_result_info();
  void set_has_from_label();
  void clear_has_from_label();
  void set_has_promo_info();
  void clear_has_promo_info();
  void set_has_user_info();
  void clear_has_user_info();
  void set_has_url();
  void clear_has_url();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr from_label_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::cosmo::pb::Metrics* metrics_;
  ::cosmo::pb::DocumentInfo* document_info_;
  ::cosmo::pb::InterleavingInfo* interleaving_info_;
  ::cosmo::pb::MixerInfo* mixer_info_;
  ::recostream::pb::ResultInfo* result_info_;
  ::recostream::pb::PromoInfo* promo_info_;
  ::recostream::pb::UserInfo* user_info_;
  friend struct protobuf_recostream_5fpixel_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProviderOriginInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.ProviderOriginInfo) */ {
 public:
  ProviderOriginInfo();
  virtual ~ProviderOriginInfo();

  ProviderOriginInfo(const ProviderOriginInfo& from);

  inline ProviderOriginInfo& operator=(const ProviderOriginInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProviderOriginInfo(ProviderOriginInfo&& from) noexcept
    : ProviderOriginInfo() {
    *this = ::std::move(from);
  }

  inline ProviderOriginInfo& operator=(ProviderOriginInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProviderOriginInfo& default_instance();

  static inline const ProviderOriginInfo* internal_default_instance() {
    return reinterpret_cast<const ProviderOriginInfo*>(
               &_ProviderOriginInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ProviderOriginInfo* other);
  friend void swap(ProviderOriginInfo& a, ProviderOriginInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProviderOriginInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ProviderOriginInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProviderOriginInfo& from);
  void MergeFrom(const ProviderOriginInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProviderOriginInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:recostream.pb.ProviderOriginInfo)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct protobuf_recostream_5fpixel_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProviderMetaInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.ProviderMetaInfo) */ {
 public:
  ProviderMetaInfo();
  virtual ~ProviderMetaInfo();

  ProviderMetaInfo(const ProviderMetaInfo& from);

  inline ProviderMetaInfo& operator=(const ProviderMetaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProviderMetaInfo(ProviderMetaInfo&& from) noexcept
    : ProviderMetaInfo() {
    *this = ::std::move(from);
  }

  inline ProviderMetaInfo& operator=(ProviderMetaInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProviderMetaInfo& default_instance();

  static inline const ProviderMetaInfo* internal_default_instance() {
    return reinterpret_cast<const ProviderMetaInfo*>(
               &_ProviderMetaInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ProviderMetaInfo* other);
  friend void swap(ProviderMetaInfo& a, ProviderMetaInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProviderMetaInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ProviderMetaInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProviderMetaInfo& from);
  void MergeFrom(const ProviderMetaInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProviderMetaInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .recostream.pb.ProviderOriginInfo origin_info = 1;
  bool has_origin_info() const;
  void clear_origin_info();
  static const int kOriginInfoFieldNumber = 1;
  const ::recostream::pb::ProviderOriginInfo& origin_info() const;
  ::recostream::pb::ProviderOriginInfo* mutable_origin_info();
  ::recostream::pb::ProviderOriginInfo* release_origin_info();
  void set_allocated_origin_info(::recostream::pb::ProviderOriginInfo* origin_info);

  // optional .cosmo.pb.MixerInfo mixer_info = 2;
  bool has_mixer_info() const;
  void clear_mixer_info();
  static const int kMixerInfoFieldNumber = 2;
  const ::cosmo::pb::MixerInfo& mixer_info() const;
  ::cosmo::pb::MixerInfo* mutable_mixer_info();
  ::cosmo::pb::MixerInfo* release_mixer_info();
  void set_allocated_mixer_info(::cosmo::pb::MixerInfo* mixer_info);

  // optional .cosmo.pb.Metrics metrics = 3;
  bool has_metrics() const;
  void clear_metrics();
  static const int kMetricsFieldNumber = 3;
  const ::cosmo::pb::Metrics& metrics() const;
  ::cosmo::pb::Metrics* mutable_metrics();
  ::cosmo::pb::Metrics* release_metrics();
  void set_allocated_metrics(::cosmo::pb::Metrics* metrics);

  // @@protoc_insertion_point(class_scope:recostream.pb.ProviderMetaInfo)
 private:
  void set_has_origin_info();
  void clear_has_origin_info();
  void set_has_mixer_info();
  void clear_has_mixer_info();
  void set_has_metrics();
  void clear_has_metrics();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::recostream::pb::ProviderOriginInfo* origin_info_;
  ::cosmo::pb::MixerInfo* mixer_info_;
  ::cosmo::pb::Metrics* metrics_;
  friend struct protobuf_recostream_5fpixel_5finfo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResultMetaInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.ResultMetaInfo) */ {
 public:
  ResultMetaInfo();
  virtual ~ResultMetaInfo();

  ResultMetaInfo(const ResultMetaInfo& from);

  inline ResultMetaInfo& operator=(const ResultMetaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResultMetaInfo(ResultMetaInfo&& from) noexcept
    : ResultMetaInfo() {
    *this = ::std::move(from);
  }

  inline ResultMetaInfo& operator=(ResultMetaInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultMetaInfo& default_instance();

  static inline const ResultMetaInfo* internal_default_instance() {
    return reinterpret_cast<const ResultMetaInfo*>(
               &_ResultMetaInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ResultMetaInfo* other);
  friend void swap(ResultMetaInfo& a, ResultMetaInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResultMetaInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ResultMetaInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResultMetaInfo& from);
  void MergeFrom(const ResultMetaInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResultMetaInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .recostream.pb.ProviderMetaInfo providers = 1;
  int providers_size() const;
  void clear_providers();
  static const int kProvidersFieldNumber = 1;
  const ::recostream::pb::ProviderMetaInfo& providers(int index) const;
  ::recostream::pb::ProviderMetaInfo* mutable_providers(int index);
  ::recostream::pb::ProviderMetaInfo* add_providers();
  ::google::protobuf::RepeatedPtrField< ::recostream::pb::ProviderMetaInfo >*
      mutable_providers();
  const ::google::protobuf::RepeatedPtrField< ::recostream::pb::ProviderMetaInfo >&
      providers() const;

  // optional string from_label = 2;
  bool has_from_label() const;
  void clear_from_label();
  static const int kFromLabelFieldNumber = 2;
  const ::std::string& from_label() const;
  void set_from_label(const ::std::string& value);
  #if LANG_CXX11
  void set_from_label(::std::string&& value);
  #endif
  void set_from_label(const char* value);
  void set_from_label(const char* value, size_t size);
  ::std::string* mutable_from_label();
  ::std::string* release_from_label();
  void set_allocated_from_label(::std::string* from_label);

  // optional .recostream.pb.UserInfo user_info = 3;
  bool has_user_info() const;
  void clear_user_info();
  static const int kUserInfoFieldNumber = 3;
  const ::recostream::pb::UserInfo& user_info() const;
  ::recostream::pb::UserInfo* mutable_user_info();
  ::recostream::pb::UserInfo* release_user_info();
  void set_allocated_user_info(::recostream::pb::UserInfo* user_info);

  // optional int64 advert_sitename = 4;
  bool has_advert_sitename() const;
  void clear_advert_sitename();
  static const int kAdvertSitenameFieldNumber = 4;
  ::google::protobuf::int64 advert_sitename() const;
  void set_advert_sitename(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.ResultMetaInfo)
 private:
  void set_has_from_label();
  void clear_has_from_label();
  void set_has_user_info();
  void clear_has_user_info();
  void set_has_advert_sitename();
  void clear_has_advert_sitename();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::recostream::pb::ProviderMetaInfo > providers_;
  ::google::protobuf::internal::ArenaStringPtr from_label_;
  ::recostream::pb::UserInfo* user_info_;
  ::google::protobuf::int64 advert_sitename_;
  friend struct protobuf_recostream_5fpixel_5finfo_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ResultInfo

// optional int32 position = 1;
inline bool ResultInfo::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResultInfo::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResultInfo::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResultInfo::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 ResultInfo::position() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.position)
  return position_;
}
inline void ResultInfo::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.position)
}

// optional string block_label = 2;
inline bool ResultInfo::has_block_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultInfo::set_has_block_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultInfo::clear_has_block_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultInfo::clear_block_label() {
  block_label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_block_label();
}
inline const ::std::string& ResultInfo::block_label() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.block_label)
  return block_label_.GetNoArena();
}
inline void ResultInfo::set_block_label(const ::std::string& value) {
  set_has_block_label();
  block_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.block_label)
}
#if LANG_CXX11
inline void ResultInfo::set_block_label(::std::string&& value) {
  set_has_block_label();
  block_label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.ResultInfo.block_label)
}
#endif
inline void ResultInfo::set_block_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_block_label();
  block_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.ResultInfo.block_label)
}
inline void ResultInfo::set_block_label(const char* value, size_t size) {
  set_has_block_label();
  block_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.ResultInfo.block_label)
}
inline ::std::string* ResultInfo::mutable_block_label() {
  set_has_block_label();
  // @@protoc_insertion_point(field_mutable:recostream.pb.ResultInfo.block_label)
  return block_label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultInfo::release_block_label() {
  // @@protoc_insertion_point(field_release:recostream.pb.ResultInfo.block_label)
  clear_has_block_label();
  return block_label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultInfo::set_allocated_block_label(::std::string* block_label) {
  if (block_label != NULL) {
    set_has_block_label();
  } else {
    clear_has_block_label();
  }
  block_label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), block_label);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.ResultInfo.block_label)
}

// optional bool is_internal_url = 3;
inline bool ResultInfo::has_is_internal_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResultInfo::set_has_is_internal_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResultInfo::clear_has_is_internal_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResultInfo::clear_is_internal_url() {
  is_internal_url_ = false;
  clear_has_is_internal_url();
}
inline bool ResultInfo::is_internal_url() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.is_internal_url)
  return is_internal_url_;
}
inline void ResultInfo::set_is_internal_url(bool value) {
  set_has_is_internal_url();
  is_internal_url_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.is_internal_url)
}

// optional bool is_fulltext = 4;
inline bool ResultInfo::has_is_fulltext() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResultInfo::set_has_is_fulltext() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResultInfo::clear_has_is_fulltext() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResultInfo::clear_is_fulltext() {
  is_fulltext_ = false;
  clear_has_is_fulltext();
}
inline bool ResultInfo::is_fulltext() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.is_fulltext)
  return is_fulltext_;
}
inline void ResultInfo::set_is_fulltext(bool value) {
  set_has_is_fulltext();
  is_fulltext_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.is_fulltext)
}

// optional bool has_pictures = 5;
inline bool ResultInfo::has_has_pictures() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResultInfo::set_has_has_pictures() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResultInfo::clear_has_has_pictures() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResultInfo::clear_has_pictures() {
  has_pictures_ = false;
  clear_has_has_pictures();
}
inline bool ResultInfo::has_pictures() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.has_pictures)
  return has_pictures_;
}
inline void ResultInfo::set_has_pictures(bool value) {
  set_has_has_pictures();
  has_pictures_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.has_pictures)
}

// optional bool is_commercial_fulltext = 6;
inline bool ResultInfo::has_is_commercial_fulltext() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResultInfo::set_has_is_commercial_fulltext() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResultInfo::clear_has_is_commercial_fulltext() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResultInfo::clear_is_commercial_fulltext() {
  is_commercial_fulltext_ = false;
  clear_has_is_commercial_fulltext();
}
inline bool ResultInfo::is_commercial_fulltext() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.is_commercial_fulltext)
  return is_commercial_fulltext_;
}
inline void ResultInfo::set_is_commercial_fulltext(bool value) {
  set_has_is_commercial_fulltext();
  is_commercial_fulltext_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.is_commercial_fulltext)
}

// optional int32 block_position = 7;
inline bool ResultInfo::has_block_position() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResultInfo::set_has_block_position() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResultInfo::clear_has_block_position() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResultInfo::clear_block_position() {
  block_position_ = 0;
  clear_has_block_position();
}
inline ::google::protobuf::int32 ResultInfo::block_position() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.block_position)
  return block_position_;
}
inline void ResultInfo::set_block_position(::google::protobuf::int32 value) {
  set_has_block_position();
  block_position_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.block_position)
}

// optional bool from_scrollable = 8;
inline bool ResultInfo::has_from_scrollable() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResultInfo::set_has_from_scrollable() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResultInfo::clear_has_from_scrollable() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResultInfo::clear_from_scrollable() {
  from_scrollable_ = false;
  clear_has_from_scrollable();
}
inline bool ResultInfo::from_scrollable() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.from_scrollable)
  return from_scrollable_;
}
inline void ResultInfo::set_from_scrollable(bool value) {
  set_has_from_scrollable();
  from_scrollable_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.from_scrollable)
}

// optional bool filler = 9;
inline bool ResultInfo::has_filler() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResultInfo::set_has_filler() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResultInfo::clear_has_filler() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResultInfo::clear_filler() {
  filler_ = false;
  clear_has_filler();
}
inline bool ResultInfo::filler() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.filler)
  return filler_;
}
inline void ResultInfo::set_filler(bool value) {
  set_has_filler();
  filler_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.filler)
}

// optional int64 advert_sitename = 10;
inline bool ResultInfo::has_advert_sitename() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResultInfo::set_has_advert_sitename() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResultInfo::clear_has_advert_sitename() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResultInfo::clear_advert_sitename() {
  advert_sitename_ = GOOGLE_LONGLONG(0);
  clear_has_advert_sitename();
}
inline ::google::protobuf::int64 ResultInfo::advert_sitename() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.advert_sitename)
  return advert_sitename_;
}
inline void ResultInfo::set_advert_sitename(::google::protobuf::int64 value) {
  set_has_advert_sitename();
  advert_sitename_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.advert_sitename)
}

// optional bool is_video = 11;
inline bool ResultInfo::has_is_video() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResultInfo::set_has_is_video() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResultInfo::clear_has_is_video() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResultInfo::clear_is_video() {
  is_video_ = false;
  clear_has_is_video();
}
inline bool ResultInfo::is_video() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.is_video)
  return is_video_;
}
inline void ResultInfo::set_is_video(bool value) {
  set_has_is_video();
  is_video_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.is_video)
}

// optional string distribution_channel_id = 12;
inline bool ResultInfo::has_distribution_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResultInfo::set_has_distribution_channel_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResultInfo::clear_has_distribution_channel_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResultInfo::clear_distribution_channel_id() {
  distribution_channel_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_distribution_channel_id();
}
inline const ::std::string& ResultInfo::distribution_channel_id() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultInfo.distribution_channel_id)
  return distribution_channel_id_.GetNoArena();
}
inline void ResultInfo::set_distribution_channel_id(const ::std::string& value) {
  set_has_distribution_channel_id();
  distribution_channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.ResultInfo.distribution_channel_id)
}
#if LANG_CXX11
inline void ResultInfo::set_distribution_channel_id(::std::string&& value) {
  set_has_distribution_channel_id();
  distribution_channel_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.ResultInfo.distribution_channel_id)
}
#endif
inline void ResultInfo::set_distribution_channel_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_distribution_channel_id();
  distribution_channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.ResultInfo.distribution_channel_id)
}
inline void ResultInfo::set_distribution_channel_id(const char* value, size_t size) {
  set_has_distribution_channel_id();
  distribution_channel_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.ResultInfo.distribution_channel_id)
}
inline ::std::string* ResultInfo::mutable_distribution_channel_id() {
  set_has_distribution_channel_id();
  // @@protoc_insertion_point(field_mutable:recostream.pb.ResultInfo.distribution_channel_id)
  return distribution_channel_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultInfo::release_distribution_channel_id() {
  // @@protoc_insertion_point(field_release:recostream.pb.ResultInfo.distribution_channel_id)
  clear_has_distribution_channel_id();
  return distribution_channel_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultInfo::set_allocated_distribution_channel_id(::std::string* distribution_channel_id) {
  if (distribution_channel_id != NULL) {
    set_has_distribution_channel_id();
  } else {
    clear_has_distribution_channel_id();
  }
  distribution_channel_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), distribution_channel_id);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.ResultInfo.distribution_channel_id)
}

// -------------------------------------------------------------------

// PromoInfo

// repeated int32 active_campaigns = 1;
inline int PromoInfo::active_campaigns_size() const {
  return active_campaigns_.size();
}
inline void PromoInfo::clear_active_campaigns() {
  active_campaigns_.Clear();
}
inline ::google::protobuf::int32 PromoInfo::active_campaigns(int index) const {
  // @@protoc_insertion_point(field_get:recostream.pb.PromoInfo.active_campaigns)
  return active_campaigns_.Get(index);
}
inline void PromoInfo::set_active_campaigns(int index, ::google::protobuf::int32 value) {
  active_campaigns_.Set(index, value);
  // @@protoc_insertion_point(field_set:recostream.pb.PromoInfo.active_campaigns)
}
inline void PromoInfo::add_active_campaigns(::google::protobuf::int32 value) {
  active_campaigns_.Add(value);
  // @@protoc_insertion_point(field_add:recostream.pb.PromoInfo.active_campaigns)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PromoInfo::active_campaigns() const {
  // @@protoc_insertion_point(field_list:recostream.pb.PromoInfo.active_campaigns)
  return active_campaigns_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PromoInfo::mutable_active_campaigns() {
  // @@protoc_insertion_point(field_mutable_list:recostream.pb.PromoInfo.active_campaigns)
  return &active_campaigns_;
}

// -------------------------------------------------------------------

// UserInfo

// optional int64 user_id = 1;
inline bool UserInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.user_id)
  return user_id_;
}
inline void UserInfo::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.UserInfo.user_id)
}

// optional int64 vid = 2;
inline bool UserInfo::has_vid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_vid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_vid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_vid() {
  vid_ = GOOGLE_LONGLONG(0);
  clear_has_vid();
}
inline ::google::protobuf::int64 UserInfo::vid() const {
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.vid)
  return vid_;
}
inline void UserInfo::set_vid(::google::protobuf::int64 value) {
  set_has_vid();
  vid_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.UserInfo.vid)
}

// optional int64 hash_email = 3;
inline bool UserInfo::has_hash_email() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_hash_email() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_hash_email() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_hash_email() {
  hash_email_ = GOOGLE_LONGLONG(0);
  clear_has_hash_email();
}
inline ::google::protobuf::int64 UserInfo::hash_email() const {
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.hash_email)
  return hash_email_;
}
inline void UserInfo::set_hash_email(::google::protobuf::int64 value) {
  set_has_hash_email();
  hash_email_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.UserInfo.hash_email)
}

// optional string geo = 4;
inline bool UserInfo::has_geo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_geo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_geo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_geo() {
  geo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_geo();
}
inline const ::std::string& UserInfo::geo() const {
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.geo)
  return geo_.GetNoArena();
}
inline void UserInfo::set_geo(const ::std::string& value) {
  set_has_geo();
  geo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.UserInfo.geo)
}
#if LANG_CXX11
inline void UserInfo::set_geo(::std::string&& value) {
  set_has_geo();
  geo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.UserInfo.geo)
}
#endif
inline void UserInfo::set_geo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_geo();
  geo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.UserInfo.geo)
}
inline void UserInfo::set_geo(const char* value, size_t size) {
  set_has_geo();
  geo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.UserInfo.geo)
}
inline ::std::string* UserInfo::mutable_geo() {
  set_has_geo();
  // @@protoc_insertion_point(field_mutable:recostream.pb.UserInfo.geo)
  return geo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_geo() {
  // @@protoc_insertion_point(field_release:recostream.pb.UserInfo.geo)
  clear_has_geo();
  return geo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_geo(::std::string* geo) {
  if (geo != NULL) {
    set_has_geo();
  } else {
    clear_has_geo();
  }
  geo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), geo);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.UserInfo.geo)
}

// optional uint32 age = 5;
inline bool UserInfo::has_age() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_age() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_age() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_age() {
  age_ = 0u;
  clear_has_age();
}
inline ::google::protobuf::uint32 UserInfo::age() const {
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.age)
  return age_;
}
inline void UserInfo::set_age(::google::protobuf::uint32 value) {
  set_has_age();
  age_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.UserInfo.age)
}

// optional bool sex = 6;
inline bool UserInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_sex() {
  sex_ = false;
  clear_has_sex();
}
inline bool UserInfo::sex() const {
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.sex)
  return sex_;
}
inline void UserInfo::set_sex(bool value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.UserInfo.sex)
}

// optional int64 hash_device_id = 7;
inline bool UserInfo::has_hash_device_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfo::set_has_hash_device_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfo::clear_has_hash_device_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfo::clear_hash_device_id() {
  hash_device_id_ = GOOGLE_LONGLONG(0);
  clear_has_hash_device_id();
}
inline ::google::protobuf::int64 UserInfo::hash_device_id() const {
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.hash_device_id)
  return hash_device_id_;
}
inline void UserInfo::set_hash_device_id(::google::protobuf::int64 value) {
  set_has_hash_device_id();
  hash_device_id_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.UserInfo.hash_device_id)
}

// optional int64 hash_advertising_id = 8;
inline bool UserInfo::has_hash_advertising_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfo::set_has_hash_advertising_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfo::clear_has_hash_advertising_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfo::clear_hash_advertising_id() {
  hash_advertising_id_ = GOOGLE_LONGLONG(0);
  clear_has_hash_advertising_id();
}
inline ::google::protobuf::int64 UserInfo::hash_advertising_id() const {
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.hash_advertising_id)
  return hash_advertising_id_;
}
inline void UserInfo::set_hash_advertising_id(::google::protobuf::int64 value) {
  set_has_hash_advertising_id();
  hash_advertising_id_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.UserInfo.hash_advertising_id)
}

// optional string idfa = 9;
inline bool UserInfo::has_idfa() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_idfa() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_idfa() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_idfa() {
  idfa_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_idfa();
}
inline const ::std::string& UserInfo::idfa() const {
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.idfa)
  return idfa_.GetNoArena();
}
inline void UserInfo::set_idfa(const ::std::string& value) {
  set_has_idfa();
  idfa_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.UserInfo.idfa)
}
#if LANG_CXX11
inline void UserInfo::set_idfa(::std::string&& value) {
  set_has_idfa();
  idfa_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.UserInfo.idfa)
}
#endif
inline void UserInfo::set_idfa(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_idfa();
  idfa_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.UserInfo.idfa)
}
inline void UserInfo::set_idfa(const char* value, size_t size) {
  set_has_idfa();
  idfa_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.UserInfo.idfa)
}
inline ::std::string* UserInfo::mutable_idfa() {
  set_has_idfa();
  // @@protoc_insertion_point(field_mutable:recostream.pb.UserInfo.idfa)
  return idfa_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_idfa() {
  // @@protoc_insertion_point(field_release:recostream.pb.UserInfo.idfa)
  clear_has_idfa();
  return idfa_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_idfa(::std::string* idfa) {
  if (idfa != NULL) {
    set_has_idfa();
  } else {
    clear_has_idfa();
  }
  idfa_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), idfa);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.UserInfo.idfa)
}

// optional string gaid = 10;
inline bool UserInfo::has_gaid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_gaid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_gaid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_gaid() {
  gaid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gaid();
}
inline const ::std::string& UserInfo::gaid() const {
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.gaid)
  return gaid_.GetNoArena();
}
inline void UserInfo::set_gaid(const ::std::string& value) {
  set_has_gaid();
  gaid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.UserInfo.gaid)
}
#if LANG_CXX11
inline void UserInfo::set_gaid(::std::string&& value) {
  set_has_gaid();
  gaid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.UserInfo.gaid)
}
#endif
inline void UserInfo::set_gaid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gaid();
  gaid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.UserInfo.gaid)
}
inline void UserInfo::set_gaid(const char* value, size_t size) {
  set_has_gaid();
  gaid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.UserInfo.gaid)
}
inline ::std::string* UserInfo::mutable_gaid() {
  set_has_gaid();
  // @@protoc_insertion_point(field_mutable:recostream.pb.UserInfo.gaid)
  return gaid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_gaid() {
  // @@protoc_insertion_point(field_release:recostream.pb.UserInfo.gaid)
  clear_has_gaid();
  return gaid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_gaid(::std::string* gaid) {
  if (gaid != NULL) {
    set_has_gaid();
  } else {
    clear_has_gaid();
  }
  gaid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gaid);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.UserInfo.gaid)
}

// optional .utils.pb.UUID compact_idfa = 11;
inline bool UserInfo::has_compact_idfa() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_compact_idfa() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_compact_idfa() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_compact_idfa() {
  if (compact_idfa_ != NULL) compact_idfa_->::utils::pb::UUID::Clear();
  clear_has_compact_idfa();
}
inline const ::utils::pb::UUID& UserInfo::compact_idfa() const {
  const ::utils::pb::UUID* p = compact_idfa_;
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.compact_idfa)
  return p != NULL ? *p : *reinterpret_cast<const ::utils::pb::UUID*>(
      &::utils::pb::_UUID_default_instance_);
}
inline ::utils::pb::UUID* UserInfo::mutable_compact_idfa() {
  set_has_compact_idfa();
  if (compact_idfa_ == NULL) {
    compact_idfa_ = new ::utils::pb::UUID;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.UserInfo.compact_idfa)
  return compact_idfa_;
}
inline ::utils::pb::UUID* UserInfo::release_compact_idfa() {
  // @@protoc_insertion_point(field_release:recostream.pb.UserInfo.compact_idfa)
  clear_has_compact_idfa();
  ::utils::pb::UUID* temp = compact_idfa_;
  compact_idfa_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_compact_idfa(::utils::pb::UUID* compact_idfa) {
  delete compact_idfa_;
  compact_idfa_ = compact_idfa;
  if (compact_idfa) {
    set_has_compact_idfa();
  } else {
    clear_has_compact_idfa();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.UserInfo.compact_idfa)
}

// optional .utils.pb.UUID compact_gaid = 12;
inline bool UserInfo::has_compact_gaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_compact_gaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_compact_gaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_compact_gaid() {
  if (compact_gaid_ != NULL) compact_gaid_->::utils::pb::UUID::Clear();
  clear_has_compact_gaid();
}
inline const ::utils::pb::UUID& UserInfo::compact_gaid() const {
  const ::utils::pb::UUID* p = compact_gaid_;
  // @@protoc_insertion_point(field_get:recostream.pb.UserInfo.compact_gaid)
  return p != NULL ? *p : *reinterpret_cast<const ::utils::pb::UUID*>(
      &::utils::pb::_UUID_default_instance_);
}
inline ::utils::pb::UUID* UserInfo::mutable_compact_gaid() {
  set_has_compact_gaid();
  if (compact_gaid_ == NULL) {
    compact_gaid_ = new ::utils::pb::UUID;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.UserInfo.compact_gaid)
  return compact_gaid_;
}
inline ::utils::pb::UUID* UserInfo::release_compact_gaid() {
  // @@protoc_insertion_point(field_release:recostream.pb.UserInfo.compact_gaid)
  clear_has_compact_gaid();
  ::utils::pb::UUID* temp = compact_gaid_;
  compact_gaid_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_compact_gaid(::utils::pb::UUID* compact_gaid) {
  delete compact_gaid_;
  compact_gaid_ = compact_gaid;
  if (compact_gaid) {
    set_has_compact_gaid();
  } else {
    clear_has_compact_gaid();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.UserInfo.compact_gaid)
}

// -------------------------------------------------------------------

// DocumentMetaInfo

// optional .cosmo.pb.Metrics metrics = 1;
inline bool DocumentMetaInfo::has_metrics() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DocumentMetaInfo::set_has_metrics() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DocumentMetaInfo::clear_has_metrics() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DocumentMetaInfo::clear_metrics() {
  if (metrics_ != NULL) metrics_->::cosmo::pb::Metrics::Clear();
  clear_has_metrics();
}
inline const ::cosmo::pb::Metrics& DocumentMetaInfo::metrics() const {
  const ::cosmo::pb::Metrics* p = metrics_;
  // @@protoc_insertion_point(field_get:recostream.pb.DocumentMetaInfo.metrics)
  return p != NULL ? *p : *reinterpret_cast<const ::cosmo::pb::Metrics*>(
      &::cosmo::pb::_Metrics_default_instance_);
}
inline ::cosmo::pb::Metrics* DocumentMetaInfo::mutable_metrics() {
  set_has_metrics();
  if (metrics_ == NULL) {
    metrics_ = new ::cosmo::pb::Metrics;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.DocumentMetaInfo.metrics)
  return metrics_;
}
inline ::cosmo::pb::Metrics* DocumentMetaInfo::release_metrics() {
  // @@protoc_insertion_point(field_release:recostream.pb.DocumentMetaInfo.metrics)
  clear_has_metrics();
  ::cosmo::pb::Metrics* temp = metrics_;
  metrics_ = NULL;
  return temp;
}
inline void DocumentMetaInfo::set_allocated_metrics(::cosmo::pb::Metrics* metrics) {
  delete metrics_;
  metrics_ = metrics;
  if (metrics) {
    set_has_metrics();
  } else {
    clear_has_metrics();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.DocumentMetaInfo.metrics)
}

// optional .cosmo.pb.DocumentInfo document_info = 2;
inline bool DocumentMetaInfo::has_document_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DocumentMetaInfo::set_has_document_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DocumentMetaInfo::clear_has_document_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DocumentMetaInfo::clear_document_info() {
  if (document_info_ != NULL) document_info_->::cosmo::pb::DocumentInfo::Clear();
  clear_has_document_info();
}
inline const ::cosmo::pb::DocumentInfo& DocumentMetaInfo::document_info() const {
  const ::cosmo::pb::DocumentInfo* p = document_info_;
  // @@protoc_insertion_point(field_get:recostream.pb.DocumentMetaInfo.document_info)
  return p != NULL ? *p : *reinterpret_cast<const ::cosmo::pb::DocumentInfo*>(
      &::cosmo::pb::_DocumentInfo_default_instance_);
}
inline ::cosmo::pb::DocumentInfo* DocumentMetaInfo::mutable_document_info() {
  set_has_document_info();
  if (document_info_ == NULL) {
    document_info_ = new ::cosmo::pb::DocumentInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.DocumentMetaInfo.document_info)
  return document_info_;
}
inline ::cosmo::pb::DocumentInfo* DocumentMetaInfo::release_document_info() {
  // @@protoc_insertion_point(field_release:recostream.pb.DocumentMetaInfo.document_info)
  clear_has_document_info();
  ::cosmo::pb::DocumentInfo* temp = document_info_;
  document_info_ = NULL;
  return temp;
}
inline void DocumentMetaInfo::set_allocated_document_info(::cosmo::pb::DocumentInfo* document_info) {
  delete document_info_;
  document_info_ = document_info;
  if (document_info) {
    set_has_document_info();
  } else {
    clear_has_document_info();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.DocumentMetaInfo.document_info)
}

// optional .cosmo.pb.InterleavingInfo interleaving_info = 3;
inline bool DocumentMetaInfo::has_interleaving_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DocumentMetaInfo::set_has_interleaving_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DocumentMetaInfo::clear_has_interleaving_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DocumentMetaInfo::clear_interleaving_info() {
  if (interleaving_info_ != NULL) interleaving_info_->::cosmo::pb::InterleavingInfo::Clear();
  clear_has_interleaving_info();
}
inline const ::cosmo::pb::InterleavingInfo& DocumentMetaInfo::interleaving_info() const {
  const ::cosmo::pb::InterleavingInfo* p = interleaving_info_;
  // @@protoc_insertion_point(field_get:recostream.pb.DocumentMetaInfo.interleaving_info)
  return p != NULL ? *p : *reinterpret_cast<const ::cosmo::pb::InterleavingInfo*>(
      &::cosmo::pb::_InterleavingInfo_default_instance_);
}
inline ::cosmo::pb::InterleavingInfo* DocumentMetaInfo::mutable_interleaving_info() {
  set_has_interleaving_info();
  if (interleaving_info_ == NULL) {
    interleaving_info_ = new ::cosmo::pb::InterleavingInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.DocumentMetaInfo.interleaving_info)
  return interleaving_info_;
}
inline ::cosmo::pb::InterleavingInfo* DocumentMetaInfo::release_interleaving_info() {
  // @@protoc_insertion_point(field_release:recostream.pb.DocumentMetaInfo.interleaving_info)
  clear_has_interleaving_info();
  ::cosmo::pb::InterleavingInfo* temp = interleaving_info_;
  interleaving_info_ = NULL;
  return temp;
}
inline void DocumentMetaInfo::set_allocated_interleaving_info(::cosmo::pb::InterleavingInfo* interleaving_info) {
  delete interleaving_info_;
  interleaving_info_ = interleaving_info;
  if (interleaving_info) {
    set_has_interleaving_info();
  } else {
    clear_has_interleaving_info();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.DocumentMetaInfo.interleaving_info)
}

// optional .cosmo.pb.MixerInfo mixer_info = 4;
inline bool DocumentMetaInfo::has_mixer_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DocumentMetaInfo::set_has_mixer_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DocumentMetaInfo::clear_has_mixer_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DocumentMetaInfo::clear_mixer_info() {
  if (mixer_info_ != NULL) mixer_info_->::cosmo::pb::MixerInfo::Clear();
  clear_has_mixer_info();
}
inline const ::cosmo::pb::MixerInfo& DocumentMetaInfo::mixer_info() const {
  const ::cosmo::pb::MixerInfo* p = mixer_info_;
  // @@protoc_insertion_point(field_get:recostream.pb.DocumentMetaInfo.mixer_info)
  return p != NULL ? *p : *reinterpret_cast<const ::cosmo::pb::MixerInfo*>(
      &::cosmo::pb::_MixerInfo_default_instance_);
}
inline ::cosmo::pb::MixerInfo* DocumentMetaInfo::mutable_mixer_info() {
  set_has_mixer_info();
  if (mixer_info_ == NULL) {
    mixer_info_ = new ::cosmo::pb::MixerInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.DocumentMetaInfo.mixer_info)
  return mixer_info_;
}
inline ::cosmo::pb::MixerInfo* DocumentMetaInfo::release_mixer_info() {
  // @@protoc_insertion_point(field_release:recostream.pb.DocumentMetaInfo.mixer_info)
  clear_has_mixer_info();
  ::cosmo::pb::MixerInfo* temp = mixer_info_;
  mixer_info_ = NULL;
  return temp;
}
inline void DocumentMetaInfo::set_allocated_mixer_info(::cosmo::pb::MixerInfo* mixer_info) {
  delete mixer_info_;
  mixer_info_ = mixer_info;
  if (mixer_info) {
    set_has_mixer_info();
  } else {
    clear_has_mixer_info();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.DocumentMetaInfo.mixer_info)
}

// optional .recostream.pb.ResultInfo result_info = 5;
inline bool DocumentMetaInfo::has_result_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DocumentMetaInfo::set_has_result_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DocumentMetaInfo::clear_has_result_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DocumentMetaInfo::clear_result_info() {
  if (result_info_ != NULL) result_info_->::recostream::pb::ResultInfo::Clear();
  clear_has_result_info();
}
inline const ::recostream::pb::ResultInfo& DocumentMetaInfo::result_info() const {
  const ::recostream::pb::ResultInfo* p = result_info_;
  // @@protoc_insertion_point(field_get:recostream.pb.DocumentMetaInfo.result_info)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::ResultInfo*>(
      &::recostream::pb::_ResultInfo_default_instance_);
}
inline ::recostream::pb::ResultInfo* DocumentMetaInfo::mutable_result_info() {
  set_has_result_info();
  if (result_info_ == NULL) {
    result_info_ = new ::recostream::pb::ResultInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.DocumentMetaInfo.result_info)
  return result_info_;
}
inline ::recostream::pb::ResultInfo* DocumentMetaInfo::release_result_info() {
  // @@protoc_insertion_point(field_release:recostream.pb.DocumentMetaInfo.result_info)
  clear_has_result_info();
  ::recostream::pb::ResultInfo* temp = result_info_;
  result_info_ = NULL;
  return temp;
}
inline void DocumentMetaInfo::set_allocated_result_info(::recostream::pb::ResultInfo* result_info) {
  delete result_info_;
  result_info_ = result_info;
  if (result_info) {
    set_has_result_info();
  } else {
    clear_has_result_info();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.DocumentMetaInfo.result_info)
}

// optional string from_label = 6;
inline bool DocumentMetaInfo::has_from_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DocumentMetaInfo::set_has_from_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DocumentMetaInfo::clear_has_from_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DocumentMetaInfo::clear_from_label() {
  from_label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from_label();
}
inline const ::std::string& DocumentMetaInfo::from_label() const {
  // @@protoc_insertion_point(field_get:recostream.pb.DocumentMetaInfo.from_label)
  return from_label_.GetNoArena();
}
inline void DocumentMetaInfo::set_from_label(const ::std::string& value) {
  set_has_from_label();
  from_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.DocumentMetaInfo.from_label)
}
#if LANG_CXX11
inline void DocumentMetaInfo::set_from_label(::std::string&& value) {
  set_has_from_label();
  from_label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.DocumentMetaInfo.from_label)
}
#endif
inline void DocumentMetaInfo::set_from_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from_label();
  from_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.DocumentMetaInfo.from_label)
}
inline void DocumentMetaInfo::set_from_label(const char* value, size_t size) {
  set_has_from_label();
  from_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.DocumentMetaInfo.from_label)
}
inline ::std::string* DocumentMetaInfo::mutable_from_label() {
  set_has_from_label();
  // @@protoc_insertion_point(field_mutable:recostream.pb.DocumentMetaInfo.from_label)
  return from_label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DocumentMetaInfo::release_from_label() {
  // @@protoc_insertion_point(field_release:recostream.pb.DocumentMetaInfo.from_label)
  clear_has_from_label();
  return from_label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DocumentMetaInfo::set_allocated_from_label(::std::string* from_label) {
  if (from_label != NULL) {
    set_has_from_label();
  } else {
    clear_has_from_label();
  }
  from_label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_label);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.DocumentMetaInfo.from_label)
}

// optional .recostream.pb.PromoInfo promo_info = 7;
inline bool DocumentMetaInfo::has_promo_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DocumentMetaInfo::set_has_promo_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DocumentMetaInfo::clear_has_promo_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DocumentMetaInfo::clear_promo_info() {
  if (promo_info_ != NULL) promo_info_->::recostream::pb::PromoInfo::Clear();
  clear_has_promo_info();
}
inline const ::recostream::pb::PromoInfo& DocumentMetaInfo::promo_info() const {
  const ::recostream::pb::PromoInfo* p = promo_info_;
  // @@protoc_insertion_point(field_get:recostream.pb.DocumentMetaInfo.promo_info)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::PromoInfo*>(
      &::recostream::pb::_PromoInfo_default_instance_);
}
inline ::recostream::pb::PromoInfo* DocumentMetaInfo::mutable_promo_info() {
  set_has_promo_info();
  if (promo_info_ == NULL) {
    promo_info_ = new ::recostream::pb::PromoInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.DocumentMetaInfo.promo_info)
  return promo_info_;
}
inline ::recostream::pb::PromoInfo* DocumentMetaInfo::release_promo_info() {
  // @@protoc_insertion_point(field_release:recostream.pb.DocumentMetaInfo.promo_info)
  clear_has_promo_info();
  ::recostream::pb::PromoInfo* temp = promo_info_;
  promo_info_ = NULL;
  return temp;
}
inline void DocumentMetaInfo::set_allocated_promo_info(::recostream::pb::PromoInfo* promo_info) {
  delete promo_info_;
  promo_info_ = promo_info;
  if (promo_info) {
    set_has_promo_info();
  } else {
    clear_has_promo_info();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.DocumentMetaInfo.promo_info)
}

// optional .recostream.pb.UserInfo user_info = 8;
inline bool DocumentMetaInfo::has_user_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DocumentMetaInfo::set_has_user_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DocumentMetaInfo::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DocumentMetaInfo::clear_user_info() {
  if (user_info_ != NULL) user_info_->::recostream::pb::UserInfo::Clear();
  clear_has_user_info();
}
inline const ::recostream::pb::UserInfo& DocumentMetaInfo::user_info() const {
  const ::recostream::pb::UserInfo* p = user_info_;
  // @@protoc_insertion_point(field_get:recostream.pb.DocumentMetaInfo.user_info)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::UserInfo*>(
      &::recostream::pb::_UserInfo_default_instance_);
}
inline ::recostream::pb::UserInfo* DocumentMetaInfo::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) {
    user_info_ = new ::recostream::pb::UserInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.DocumentMetaInfo.user_info)
  return user_info_;
}
inline ::recostream::pb::UserInfo* DocumentMetaInfo::release_user_info() {
  // @@protoc_insertion_point(field_release:recostream.pb.DocumentMetaInfo.user_info)
  clear_has_user_info();
  ::recostream::pb::UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void DocumentMetaInfo::set_allocated_user_info(::recostream::pb::UserInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.DocumentMetaInfo.user_info)
}

// optional string url = 9;
inline bool DocumentMetaInfo::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DocumentMetaInfo::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DocumentMetaInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DocumentMetaInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& DocumentMetaInfo::url() const {
  // @@protoc_insertion_point(field_get:recostream.pb.DocumentMetaInfo.url)
  return url_.GetNoArena();
}
inline void DocumentMetaInfo::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.DocumentMetaInfo.url)
}
#if LANG_CXX11
inline void DocumentMetaInfo::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.DocumentMetaInfo.url)
}
#endif
inline void DocumentMetaInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.DocumentMetaInfo.url)
}
inline void DocumentMetaInfo::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.DocumentMetaInfo.url)
}
inline ::std::string* DocumentMetaInfo::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:recostream.pb.DocumentMetaInfo.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DocumentMetaInfo::release_url() {
  // @@protoc_insertion_point(field_release:recostream.pb.DocumentMetaInfo.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DocumentMetaInfo::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.DocumentMetaInfo.url)
}

// -------------------------------------------------------------------

// ProviderOriginInfo

// required string name = 1;
inline bool ProviderOriginInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProviderOriginInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProviderOriginInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProviderOriginInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ProviderOriginInfo::name() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ProviderOriginInfo.name)
  return name_.GetNoArena();
}
inline void ProviderOriginInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.ProviderOriginInfo.name)
}
#if LANG_CXX11
inline void ProviderOriginInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.ProviderOriginInfo.name)
}
#endif
inline void ProviderOriginInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.ProviderOriginInfo.name)
}
inline void ProviderOriginInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.ProviderOriginInfo.name)
}
inline ::std::string* ProviderOriginInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:recostream.pb.ProviderOriginInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProviderOriginInfo::release_name() {
  // @@protoc_insertion_point(field_release:recostream.pb.ProviderOriginInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProviderOriginInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.ProviderOriginInfo.name)
}

// -------------------------------------------------------------------

// ProviderMetaInfo

// optional .recostream.pb.ProviderOriginInfo origin_info = 1;
inline bool ProviderMetaInfo::has_origin_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProviderMetaInfo::set_has_origin_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProviderMetaInfo::clear_has_origin_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProviderMetaInfo::clear_origin_info() {
  if (origin_info_ != NULL) origin_info_->::recostream::pb::ProviderOriginInfo::Clear();
  clear_has_origin_info();
}
inline const ::recostream::pb::ProviderOriginInfo& ProviderMetaInfo::origin_info() const {
  const ::recostream::pb::ProviderOriginInfo* p = origin_info_;
  // @@protoc_insertion_point(field_get:recostream.pb.ProviderMetaInfo.origin_info)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::ProviderOriginInfo*>(
      &::recostream::pb::_ProviderOriginInfo_default_instance_);
}
inline ::recostream::pb::ProviderOriginInfo* ProviderMetaInfo::mutable_origin_info() {
  set_has_origin_info();
  if (origin_info_ == NULL) {
    origin_info_ = new ::recostream::pb::ProviderOriginInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.ProviderMetaInfo.origin_info)
  return origin_info_;
}
inline ::recostream::pb::ProviderOriginInfo* ProviderMetaInfo::release_origin_info() {
  // @@protoc_insertion_point(field_release:recostream.pb.ProviderMetaInfo.origin_info)
  clear_has_origin_info();
  ::recostream::pb::ProviderOriginInfo* temp = origin_info_;
  origin_info_ = NULL;
  return temp;
}
inline void ProviderMetaInfo::set_allocated_origin_info(::recostream::pb::ProviderOriginInfo* origin_info) {
  delete origin_info_;
  origin_info_ = origin_info;
  if (origin_info) {
    set_has_origin_info();
  } else {
    clear_has_origin_info();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.ProviderMetaInfo.origin_info)
}

// optional .cosmo.pb.MixerInfo mixer_info = 2;
inline bool ProviderMetaInfo::has_mixer_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProviderMetaInfo::set_has_mixer_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProviderMetaInfo::clear_has_mixer_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProviderMetaInfo::clear_mixer_info() {
  if (mixer_info_ != NULL) mixer_info_->::cosmo::pb::MixerInfo::Clear();
  clear_has_mixer_info();
}
inline const ::cosmo::pb::MixerInfo& ProviderMetaInfo::mixer_info() const {
  const ::cosmo::pb::MixerInfo* p = mixer_info_;
  // @@protoc_insertion_point(field_get:recostream.pb.ProviderMetaInfo.mixer_info)
  return p != NULL ? *p : *reinterpret_cast<const ::cosmo::pb::MixerInfo*>(
      &::cosmo::pb::_MixerInfo_default_instance_);
}
inline ::cosmo::pb::MixerInfo* ProviderMetaInfo::mutable_mixer_info() {
  set_has_mixer_info();
  if (mixer_info_ == NULL) {
    mixer_info_ = new ::cosmo::pb::MixerInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.ProviderMetaInfo.mixer_info)
  return mixer_info_;
}
inline ::cosmo::pb::MixerInfo* ProviderMetaInfo::release_mixer_info() {
  // @@protoc_insertion_point(field_release:recostream.pb.ProviderMetaInfo.mixer_info)
  clear_has_mixer_info();
  ::cosmo::pb::MixerInfo* temp = mixer_info_;
  mixer_info_ = NULL;
  return temp;
}
inline void ProviderMetaInfo::set_allocated_mixer_info(::cosmo::pb::MixerInfo* mixer_info) {
  delete mixer_info_;
  mixer_info_ = mixer_info;
  if (mixer_info) {
    set_has_mixer_info();
  } else {
    clear_has_mixer_info();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.ProviderMetaInfo.mixer_info)
}

// optional .cosmo.pb.Metrics metrics = 3;
inline bool ProviderMetaInfo::has_metrics() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProviderMetaInfo::set_has_metrics() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProviderMetaInfo::clear_has_metrics() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProviderMetaInfo::clear_metrics() {
  if (metrics_ != NULL) metrics_->::cosmo::pb::Metrics::Clear();
  clear_has_metrics();
}
inline const ::cosmo::pb::Metrics& ProviderMetaInfo::metrics() const {
  const ::cosmo::pb::Metrics* p = metrics_;
  // @@protoc_insertion_point(field_get:recostream.pb.ProviderMetaInfo.metrics)
  return p != NULL ? *p : *reinterpret_cast<const ::cosmo::pb::Metrics*>(
      &::cosmo::pb::_Metrics_default_instance_);
}
inline ::cosmo::pb::Metrics* ProviderMetaInfo::mutable_metrics() {
  set_has_metrics();
  if (metrics_ == NULL) {
    metrics_ = new ::cosmo::pb::Metrics;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.ProviderMetaInfo.metrics)
  return metrics_;
}
inline ::cosmo::pb::Metrics* ProviderMetaInfo::release_metrics() {
  // @@protoc_insertion_point(field_release:recostream.pb.ProviderMetaInfo.metrics)
  clear_has_metrics();
  ::cosmo::pb::Metrics* temp = metrics_;
  metrics_ = NULL;
  return temp;
}
inline void ProviderMetaInfo::set_allocated_metrics(::cosmo::pb::Metrics* metrics) {
  delete metrics_;
  metrics_ = metrics;
  if (metrics) {
    set_has_metrics();
  } else {
    clear_has_metrics();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.ProviderMetaInfo.metrics)
}

// -------------------------------------------------------------------

// ResultMetaInfo

// repeated .recostream.pb.ProviderMetaInfo providers = 1;
inline int ResultMetaInfo::providers_size() const {
  return providers_.size();
}
inline void ResultMetaInfo::clear_providers() {
  providers_.Clear();
}
inline const ::recostream::pb::ProviderMetaInfo& ResultMetaInfo::providers(int index) const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultMetaInfo.providers)
  return providers_.Get(index);
}
inline ::recostream::pb::ProviderMetaInfo* ResultMetaInfo::mutable_providers(int index) {
  // @@protoc_insertion_point(field_mutable:recostream.pb.ResultMetaInfo.providers)
  return providers_.Mutable(index);
}
inline ::recostream::pb::ProviderMetaInfo* ResultMetaInfo::add_providers() {
  // @@protoc_insertion_point(field_add:recostream.pb.ResultMetaInfo.providers)
  return providers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::recostream::pb::ProviderMetaInfo >*
ResultMetaInfo::mutable_providers() {
  // @@protoc_insertion_point(field_mutable_list:recostream.pb.ResultMetaInfo.providers)
  return &providers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::recostream::pb::ProviderMetaInfo >&
ResultMetaInfo::providers() const {
  // @@protoc_insertion_point(field_list:recostream.pb.ResultMetaInfo.providers)
  return providers_;
}

// optional string from_label = 2;
inline bool ResultMetaInfo::has_from_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultMetaInfo::set_has_from_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultMetaInfo::clear_has_from_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultMetaInfo::clear_from_label() {
  from_label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from_label();
}
inline const ::std::string& ResultMetaInfo::from_label() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultMetaInfo.from_label)
  return from_label_.GetNoArena();
}
inline void ResultMetaInfo::set_from_label(const ::std::string& value) {
  set_has_from_label();
  from_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.ResultMetaInfo.from_label)
}
#if LANG_CXX11
inline void ResultMetaInfo::set_from_label(::std::string&& value) {
  set_has_from_label();
  from_label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.ResultMetaInfo.from_label)
}
#endif
inline void ResultMetaInfo::set_from_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from_label();
  from_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.ResultMetaInfo.from_label)
}
inline void ResultMetaInfo::set_from_label(const char* value, size_t size) {
  set_has_from_label();
  from_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.ResultMetaInfo.from_label)
}
inline ::std::string* ResultMetaInfo::mutable_from_label() {
  set_has_from_label();
  // @@protoc_insertion_point(field_mutable:recostream.pb.ResultMetaInfo.from_label)
  return from_label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultMetaInfo::release_from_label() {
  // @@protoc_insertion_point(field_release:recostream.pb.ResultMetaInfo.from_label)
  clear_has_from_label();
  return from_label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultMetaInfo::set_allocated_from_label(::std::string* from_label) {
  if (from_label != NULL) {
    set_has_from_label();
  } else {
    clear_has_from_label();
  }
  from_label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_label);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.ResultMetaInfo.from_label)
}

// optional .recostream.pb.UserInfo user_info = 3;
inline bool ResultMetaInfo::has_user_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResultMetaInfo::set_has_user_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResultMetaInfo::clear_has_user_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResultMetaInfo::clear_user_info() {
  if (user_info_ != NULL) user_info_->::recostream::pb::UserInfo::Clear();
  clear_has_user_info();
}
inline const ::recostream::pb::UserInfo& ResultMetaInfo::user_info() const {
  const ::recostream::pb::UserInfo* p = user_info_;
  // @@protoc_insertion_point(field_get:recostream.pb.ResultMetaInfo.user_info)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::UserInfo*>(
      &::recostream::pb::_UserInfo_default_instance_);
}
inline ::recostream::pb::UserInfo* ResultMetaInfo::mutable_user_info() {
  set_has_user_info();
  if (user_info_ == NULL) {
    user_info_ = new ::recostream::pb::UserInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.ResultMetaInfo.user_info)
  return user_info_;
}
inline ::recostream::pb::UserInfo* ResultMetaInfo::release_user_info() {
  // @@protoc_insertion_point(field_release:recostream.pb.ResultMetaInfo.user_info)
  clear_has_user_info();
  ::recostream::pb::UserInfo* temp = user_info_;
  user_info_ = NULL;
  return temp;
}
inline void ResultMetaInfo::set_allocated_user_info(::recostream::pb::UserInfo* user_info) {
  delete user_info_;
  user_info_ = user_info;
  if (user_info) {
    set_has_user_info();
  } else {
    clear_has_user_info();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.ResultMetaInfo.user_info)
}

// optional int64 advert_sitename = 4;
inline bool ResultMetaInfo::has_advert_sitename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResultMetaInfo::set_has_advert_sitename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResultMetaInfo::clear_has_advert_sitename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResultMetaInfo::clear_advert_sitename() {
  advert_sitename_ = GOOGLE_LONGLONG(0);
  clear_has_advert_sitename();
}
inline ::google::protobuf::int64 ResultMetaInfo::advert_sitename() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultMetaInfo.advert_sitename)
  return advert_sitename_;
}
inline void ResultMetaInfo::set_advert_sitename(::google::protobuf::int64 value) {
  set_has_advert_sitename();
  advert_sitename_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultMetaInfo.advert_sitename)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace pb
}  // namespace recostream

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_recostream_5fpixel_5finfo_2eproto__INCLUDED
