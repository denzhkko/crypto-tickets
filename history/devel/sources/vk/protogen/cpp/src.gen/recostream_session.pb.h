// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: recostream_session.proto

#ifndef PROTOBUF_recostream_5fsession_2eproto__INCLUDED
#define PROTOBUF_recostream_5fsession_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace recostream {
namespace pb {
class CosmoSources;
class CosmoSourcesDefaultTypeInternal;
extern CosmoSourcesDefaultTypeInternal _CosmoSources_default_instance_;
class CosmoSources_StatesEntry;
class CosmoSources_StatesEntryDefaultTypeInternal;
extern CosmoSources_StatesEntryDefaultTypeInternal _CosmoSources_StatesEntry_default_instance_;
class CosmoState;
class CosmoStateDefaultTypeInternal;
extern CosmoStateDefaultTypeInternal _CosmoState_default_instance_;
class CosmoState_CacheCursor;
class CosmoState_CacheCursorDefaultTypeInternal;
extern CosmoState_CacheCursorDefaultTypeInternal _CosmoState_CacheCursor_default_instance_;
class CosmoState_ExperimentInfo;
class CosmoState_ExperimentInfoDefaultTypeInternal;
extern CosmoState_ExperimentInfoDefaultTypeInternal _CosmoState_ExperimentInfo_default_instance_;
class CosmoState_Stats;
class CosmoState_StatsDefaultTypeInternal;
extern CosmoState_StatsDefaultTypeInternal _CosmoState_Stats_default_instance_;
class LoginState;
class LoginStateDefaultTypeInternal;
extern LoginStateDefaultTypeInternal _LoginState_default_instance_;
class PPNState;
class PPNStateDefaultTypeInternal;
extern PPNStateDefaultTypeInternal _PPNState_default_instance_;
class ProfileSettingField;
class ProfileSettingFieldDefaultTypeInternal;
extern ProfileSettingFieldDefaultTypeInternal _ProfileSettingField_default_instance_;
class ProfileSettings;
class ProfileSettingsDefaultTypeInternal;
extern ProfileSettingsDefaultTypeInternal _ProfileSettings_default_instance_;
class RecoSessionState;
class RecoSessionStateDefaultTypeInternal;
extern RecoSessionStateDefaultTypeInternal _RecoSessionState_default_instance_;
class ResultsPageState;
class ResultsPageStateDefaultTypeInternal;
extern ResultsPageStateDefaultTypeInternal _ResultsPageState_default_instance_;
class ResultsPageState_BlockState;
class ResultsPageState_BlockStateDefaultTypeInternal;
extern ResultsPageState_BlockStateDefaultTypeInternal _ResultsPageState_BlockState_default_instance_;
class SubscriptionState;
class SubscriptionStateDefaultTypeInternal;
extern SubscriptionStateDefaultTypeInternal _SubscriptionState_default_instance_;
class SubscriptionState_SubscriptionInfo;
class SubscriptionState_SubscriptionInfoDefaultTypeInternal;
extern SubscriptionState_SubscriptionInfoDefaultTypeInternal _SubscriptionState_SubscriptionInfo_default_instance_;
class TargetSources;
class TargetSourcesDefaultTypeInternal;
extern TargetSourcesDefaultTypeInternal _TargetSources_default_instance_;
class TargetSources_StatesEntry;
class TargetSources_StatesEntryDefaultTypeInternal;
extern TargetSources_StatesEntryDefaultTypeInternal _TargetSources_StatesEntry_default_instance_;
class TargetState;
class TargetStateDefaultTypeInternal;
extern TargetStateDefaultTypeInternal _TargetState_default_instance_;
}  // namespace pb
}  // namespace recostream

namespace recostream {
namespace pb {

namespace protobuf_recostream_5fsession_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_recostream_5fsession_2eproto

// ===================================================================

class LoginState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.LoginState) */ {
 public:
  LoginState();
  virtual ~LoginState();

  LoginState(const LoginState& from);

  inline LoginState& operator=(const LoginState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginState(LoginState&& from) noexcept
    : LoginState() {
    *this = ::std::move(from);
  }

  inline LoginState& operator=(LoginState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginState& default_instance();

  static inline const LoginState* internal_default_instance() {
    return reinterpret_cast<const LoginState*>(
               &_LoginState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LoginState* other);
  friend void swap(LoginState& a, LoginState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginState* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginState& from);
  void MergeFrom(const LoginState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string many_vids = 8;
  int many_vids_size() const;
  void clear_many_vids();
  static const int kManyVidsFieldNumber = 8;
  const ::std::string& many_vids(int index) const;
  ::std::string* mutable_many_vids(int index);
  void set_many_vids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_many_vids(int index, ::std::string&& value);
  #endif
  void set_many_vids(int index, const char* value);
  void set_many_vids(int index, const char* value, size_t size);
  ::std::string* add_many_vids();
  void add_many_vids(const ::std::string& value);
  #if LANG_CXX11
  void add_many_vids(::std::string&& value);
  #endif
  void add_many_vids(const char* value);
  void add_many_vids(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& many_vids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_many_vids();

  // repeated string many_emails = 9;
  int many_emails_size() const;
  void clear_many_emails();
  static const int kManyEmailsFieldNumber = 9;
  const ::std::string& many_emails(int index) const;
  ::std::string* mutable_many_emails(int index);
  void set_many_emails(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_many_emails(int index, ::std::string&& value);
  #endif
  void set_many_emails(int index, const char* value);
  void set_many_emails(int index, const char* value, size_t size);
  ::std::string* add_many_emails();
  void add_many_emails(const ::std::string& value);
  #if LANG_CXX11
  void add_many_emails(::std::string&& value);
  #endif
  void add_many_emails(const char* value);
  void add_many_emails(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& many_emails() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_many_emails();

  // optional string from_label = 5;
  bool has_from_label() const;
  void clear_from_label();
  static const int kFromLabelFieldNumber = 5;
  const ::std::string& from_label() const;
  void set_from_label(const ::std::string& value);
  #if LANG_CXX11
  void set_from_label(::std::string&& value);
  #endif
  void set_from_label(const char* value);
  void set_from_label(const char* value, size_t size);
  ::std::string* mutable_from_label();
  ::std::string* release_from_label();
  void set_allocated_from_label(::std::string* from_label);

  // optional string category_ids = 7;
  bool has_category_ids() const;
  void clear_category_ids();
  static const int kCategoryIdsFieldNumber = 7;
  const ::std::string& category_ids() const;
  void set_category_ids(const ::std::string& value);
  #if LANG_CXX11
  void set_category_ids(::std::string&& value);
  #endif
  void set_category_ids(const char* value);
  void set_category_ids(const char* value, size_t size);
  ::std::string* mutable_category_ids();
  ::std::string* release_category_ids();
  void set_allocated_category_ids(::std::string* category_ids);

  // optional string vk_id = 10;
  bool has_vk_id() const;
  void clear_vk_id();
  static const int kVkIdFieldNumber = 10;
  const ::std::string& vk_id() const;
  void set_vk_id(const ::std::string& value);
  #if LANG_CXX11
  void set_vk_id(::std::string&& value);
  #endif
  void set_vk_id(const char* value);
  void set_vk_id(const char* value, size_t size);
  ::std::string* mutable_vk_id();
  ::std::string* release_vk_id();
  void set_allocated_vk_id(::std::string* vk_id);

  // optional string ok_id = 11;
  bool has_ok_id() const;
  void clear_ok_id();
  static const int kOkIdFieldNumber = 11;
  const ::std::string& ok_id() const;
  void set_ok_id(const ::std::string& value);
  #if LANG_CXX11
  void set_ok_id(::std::string&& value);
  #endif
  void set_ok_id(const char* value);
  void set_ok_id(const char* value, size_t size);
  ::std::string* mutable_ok_id();
  ::std::string* release_ok_id();
  void set_allocated_ok_id(::std::string* ok_id);

  // optional string idfa = 12;
  bool has_idfa() const;
  void clear_idfa();
  static const int kIdfaFieldNumber = 12;
  const ::std::string& idfa() const;
  void set_idfa(const ::std::string& value);
  #if LANG_CXX11
  void set_idfa(::std::string&& value);
  #endif
  void set_idfa(const char* value);
  void set_idfa(const char* value, size_t size);
  ::std::string* mutable_idfa();
  ::std::string* release_idfa();
  void set_allocated_idfa(::std::string* idfa);

  // optional string gaid = 13;
  bool has_gaid() const;
  void clear_gaid();
  static const int kGaidFieldNumber = 13;
  const ::std::string& gaid() const;
  void set_gaid(const ::std::string& value);
  #if LANG_CXX11
  void set_gaid(::std::string&& value);
  #endif
  void set_gaid(const char* value);
  void set_gaid(const char* value, size_t size);
  ::std::string* mutable_gaid();
  ::std::string* release_gaid();
  void set_allocated_gaid(::std::string* gaid);

  // required int64 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::int64 user_id() const;
  void set_user_id(::google::protobuf::int64 value);

  // optional uint64 vid = 2;
  bool has_vid() const;
  void clear_vid();
  static const int kVidFieldNumber = 2;
  ::google::protobuf::uint64 vid() const;
  void set_vid(::google::protobuf::uint64 value);

  // optional int32 split = 3;
  bool has_split() const;
  void clear_split();
  static const int kSplitFieldNumber = 3;
  ::google::protobuf::int32 split() const;
  void set_split(::google::protobuf::int32 value);

  // optional bool is_anonymous = 4;
  bool has_is_anonymous() const;
  void clear_is_anonymous();
  static const int kIsAnonymousFieldNumber = 4;
  bool is_anonymous() const;
  void set_is_anonymous(bool value);

  // optional int64 advert_sitename = 6;
  bool has_advert_sitename() const;
  void clear_advert_sitename();
  static const int kAdvertSitenameFieldNumber = 6;
  ::google::protobuf::int64 advert_sitename() const;
  void set_advert_sitename(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.LoginState)
 private:
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_vid();
  void clear_has_vid();
  void set_has_split();
  void clear_has_split();
  void set_has_is_anonymous();
  void clear_has_is_anonymous();
  void set_has_from_label();
  void clear_has_from_label();
  void set_has_advert_sitename();
  void clear_has_advert_sitename();
  void set_has_category_ids();
  void clear_has_category_ids();
  void set_has_vk_id();
  void clear_has_vk_id();
  void set_has_ok_id();
  void clear_has_ok_id();
  void set_has_idfa();
  void clear_has_idfa();
  void set_has_gaid();
  void clear_has_gaid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> many_vids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> many_emails_;
  ::google::protobuf::internal::ArenaStringPtr from_label_;
  ::google::protobuf::internal::ArenaStringPtr category_ids_;
  ::google::protobuf::internal::ArenaStringPtr vk_id_;
  ::google::protobuf::internal::ArenaStringPtr ok_id_;
  ::google::protobuf::internal::ArenaStringPtr idfa_;
  ::google::protobuf::internal::ArenaStringPtr gaid_;
  ::google::protobuf::int64 user_id_;
  ::google::protobuf::uint64 vid_;
  ::google::protobuf::int32 split_;
  bool is_anonymous_;
  ::google::protobuf::int64 advert_sitename_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CosmoState_CacheCursor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.CosmoState.CacheCursor) */ {
 public:
  CosmoState_CacheCursor();
  virtual ~CosmoState_CacheCursor();

  CosmoState_CacheCursor(const CosmoState_CacheCursor& from);

  inline CosmoState_CacheCursor& operator=(const CosmoState_CacheCursor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CosmoState_CacheCursor(CosmoState_CacheCursor&& from) noexcept
    : CosmoState_CacheCursor() {
    *this = ::std::move(from);
  }

  inline CosmoState_CacheCursor& operator=(CosmoState_CacheCursor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CosmoState_CacheCursor& default_instance();

  static inline const CosmoState_CacheCursor* internal_default_instance() {
    return reinterpret_cast<const CosmoState_CacheCursor*>(
               &_CosmoState_CacheCursor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(CosmoState_CacheCursor* other);
  friend void swap(CosmoState_CacheCursor& a, CosmoState_CacheCursor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CosmoState_CacheCursor* New() const PROTOBUF_FINAL { return New(NULL); }

  CosmoState_CacheCursor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CosmoState_CacheCursor& from);
  void MergeFrom(const CosmoState_CacheCursor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CosmoState_CacheCursor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string record_id = 1;
  bool has_record_id() const;
  void clear_record_id();
  static const int kRecordIdFieldNumber = 1;
  const ::std::string& record_id() const;
  void set_record_id(const ::std::string& value);
  #if LANG_CXX11
  void set_record_id(::std::string&& value);
  #endif
  void set_record_id(const char* value);
  void set_record_id(const char* value, size_t size);
  ::std::string* mutable_record_id();
  ::std::string* release_record_id();
  void set_allocated_record_id(::std::string* record_id);

  // required int32 pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  ::google::protobuf::int32 pos() const;
  void set_pos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.CosmoState.CacheCursor)
 private:
  void set_has_record_id();
  void clear_has_record_id();
  void set_has_pos();
  void clear_has_pos();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr record_id_;
  ::google::protobuf::int32 pos_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CosmoState_Stats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.CosmoState.Stats) */ {
 public:
  CosmoState_Stats();
  virtual ~CosmoState_Stats();

  CosmoState_Stats(const CosmoState_Stats& from);

  inline CosmoState_Stats& operator=(const CosmoState_Stats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CosmoState_Stats(CosmoState_Stats&& from) noexcept
    : CosmoState_Stats() {
    *this = ::std::move(from);
  }

  inline CosmoState_Stats& operator=(CosmoState_Stats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CosmoState_Stats& default_instance();

  static inline const CosmoState_Stats* internal_default_instance() {
    return reinterpret_cast<const CosmoState_Stats*>(
               &_CosmoState_Stats_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(CosmoState_Stats* other);
  friend void swap(CosmoState_Stats& a, CosmoState_Stats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CosmoState_Stats* New() const PROTOBUF_FINAL { return New(NULL); }

  CosmoState_Stats* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CosmoState_Stats& from);
  void MergeFrom(const CosmoState_Stats& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CosmoState_Stats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 skipped = 1;
  bool has_skipped() const;
  void clear_skipped();
  static const int kSkippedFieldNumber = 1;
  ::google::protobuf::int32 skipped() const;
  void set_skipped(::google::protobuf::int32 value);

  // optional int32 bahroma_missed = 2;
  bool has_bahroma_missed() const;
  void clear_bahroma_missed();
  static const int kBahromaMissedFieldNumber = 2;
  ::google::protobuf::int32 bahroma_missed() const;
  void set_bahroma_missed(::google::protobuf::int32 value);

  // optional int32 banned = 3;
  bool has_banned() const;
  void clear_banned();
  static const int kBannedFieldNumber = 3;
  ::google::protobuf::int32 banned() const;
  void set_banned(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.CosmoState.Stats)
 private:
  void set_has_skipped();
  void clear_has_skipped();
  void set_has_bahroma_missed();
  void clear_has_bahroma_missed();
  void set_has_banned();
  void clear_has_banned();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 skipped_;
  ::google::protobuf::int32 bahroma_missed_;
  ::google::protobuf::int32 banned_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CosmoState_ExperimentInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.CosmoState.ExperimentInfo) */ {
 public:
  CosmoState_ExperimentInfo();
  virtual ~CosmoState_ExperimentInfo();

  CosmoState_ExperimentInfo(const CosmoState_ExperimentInfo& from);

  inline CosmoState_ExperimentInfo& operator=(const CosmoState_ExperimentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CosmoState_ExperimentInfo(CosmoState_ExperimentInfo&& from) noexcept
    : CosmoState_ExperimentInfo() {
    *this = ::std::move(from);
  }

  inline CosmoState_ExperimentInfo& operator=(CosmoState_ExperimentInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CosmoState_ExperimentInfo& default_instance();

  static inline const CosmoState_ExperimentInfo* internal_default_instance() {
    return reinterpret_cast<const CosmoState_ExperimentInfo*>(
               &_CosmoState_ExperimentInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CosmoState_ExperimentInfo* other);
  friend void swap(CosmoState_ExperimentInfo& a, CosmoState_ExperimentInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CosmoState_ExperimentInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  CosmoState_ExperimentInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CosmoState_ExperimentInfo& from);
  void MergeFrom(const CosmoState_ExperimentInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CosmoState_ExperimentInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 experiment_id = 1;
  bool has_experiment_id() const;
  void clear_experiment_id();
  static const int kExperimentIdFieldNumber = 1;
  ::google::protobuf::uint32 experiment_id() const;
  void set_experiment_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.CosmoState.ExperimentInfo)
 private:
  void set_has_experiment_id();
  void clear_has_experiment_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 experiment_id_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CosmoState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.CosmoState) */ {
 public:
  CosmoState();
  virtual ~CosmoState();

  CosmoState(const CosmoState& from);

  inline CosmoState& operator=(const CosmoState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CosmoState(CosmoState&& from) noexcept
    : CosmoState() {
    *this = ::std::move(from);
  }

  inline CosmoState& operator=(CosmoState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CosmoState& default_instance();

  static inline const CosmoState* internal_default_instance() {
    return reinterpret_cast<const CosmoState*>(
               &_CosmoState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(CosmoState* other);
  friend void swap(CosmoState& a, CosmoState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CosmoState* New() const PROTOBUF_FINAL { return New(NULL); }

  CosmoState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CosmoState& from);
  void MergeFrom(const CosmoState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CosmoState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CosmoState_CacheCursor CacheCursor;
  typedef CosmoState_Stats Stats;
  typedef CosmoState_ExperimentInfo ExperimentInfo;

  // accessors -------------------------------------------------------

  // optional .recostream.pb.CosmoState.CacheCursor cache_cursor = 1;
  bool has_cache_cursor() const;
  void clear_cache_cursor();
  static const int kCacheCursorFieldNumber = 1;
  const ::recostream::pb::CosmoState_CacheCursor& cache_cursor() const;
  ::recostream::pb::CosmoState_CacheCursor* mutable_cache_cursor();
  ::recostream::pb::CosmoState_CacheCursor* release_cache_cursor();
  void set_allocated_cache_cursor(::recostream::pb::CosmoState_CacheCursor* cache_cursor);

  // optional .recostream.pb.CosmoState.Stats stats = 2;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 2;
  const ::recostream::pb::CosmoState_Stats& stats() const;
  ::recostream::pb::CosmoState_Stats* mutable_stats();
  ::recostream::pb::CosmoState_Stats* release_stats();
  void set_allocated_stats(::recostream::pb::CosmoState_Stats* stats);

  // optional .recostream.pb.CosmoState.ExperimentInfo experiment_info = 3;
  bool has_experiment_info() const;
  void clear_experiment_info();
  static const int kExperimentInfoFieldNumber = 3;
  const ::recostream::pb::CosmoState_ExperimentInfo& experiment_info() const;
  ::recostream::pb::CosmoState_ExperimentInfo* mutable_experiment_info();
  ::recostream::pb::CosmoState_ExperimentInfo* release_experiment_info();
  void set_allocated_experiment_info(::recostream::pb::CosmoState_ExperimentInfo* experiment_info);

  // @@protoc_insertion_point(class_scope:recostream.pb.CosmoState)
 private:
  void set_has_cache_cursor();
  void clear_has_cache_cursor();
  void set_has_stats();
  void clear_has_stats();
  void set_has_experiment_info();
  void clear_has_experiment_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::recostream::pb::CosmoState_CacheCursor* cache_cursor_;
  ::recostream::pb::CosmoState_Stats* stats_;
  ::recostream::pb::CosmoState_ExperimentInfo* experiment_info_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class CosmoSources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.CosmoSources) */ {
 public:
  CosmoSources();
  virtual ~CosmoSources();

  CosmoSources(const CosmoSources& from);

  inline CosmoSources& operator=(const CosmoSources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CosmoSources(CosmoSources&& from) noexcept
    : CosmoSources() {
    *this = ::std::move(from);
  }

  inline CosmoSources& operator=(CosmoSources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CosmoSources& default_instance();

  static inline const CosmoSources* internal_default_instance() {
    return reinterpret_cast<const CosmoSources*>(
               &_CosmoSources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(CosmoSources* other);
  friend void swap(CosmoSources& a, CosmoSources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CosmoSources* New() const PROTOBUF_FINAL { return New(NULL); }

  CosmoSources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CosmoSources& from);
  void MergeFrom(const CosmoSources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CosmoSources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .recostream.pb.CosmoState> states = 1;
  int states_size() const;
  void clear_states();
  static const int kStatesFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::recostream::pb::CosmoState >&
      states() const;
  ::google::protobuf::Map< ::std::string, ::recostream::pb::CosmoState >*
      mutable_states();

  // @@protoc_insertion_point(class_scope:recostream.pb.CosmoSources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  public:
  class CosmoSources_StatesEntry : public ::google::protobuf::internal::MapEntry<CosmoSources_StatesEntry, 
      ::std::string, ::recostream::pb::CosmoState,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<CosmoSources_StatesEntry, 
      ::std::string, ::recostream::pb::CosmoState,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > SuperType;
    CosmoSources_StatesEntry();
    CosmoSources_StatesEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const CosmoSources_StatesEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_CosmoSources_StatesEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      CosmoSources_StatesEntry,
      ::std::string, ::recostream::pb::CosmoState,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > states_;
  private:
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TargetState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.TargetState) */ {
 public:
  TargetState();
  virtual ~TargetState();

  TargetState(const TargetState& from);

  inline TargetState& operator=(const TargetState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TargetState(TargetState&& from) noexcept
    : TargetState() {
    *this = ::std::move(from);
  }

  inline TargetState& operator=(TargetState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetState& default_instance();

  static inline const TargetState* internal_default_instance() {
    return reinterpret_cast<const TargetState*>(
               &_TargetState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TargetState* other);
  friend void swap(TargetState& a, TargetState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TargetState* New() const PROTOBUF_FINAL { return New(NULL); }

  TargetState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TargetState& from);
  void MergeFrom(const TargetState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TargetState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 last_banners = 1;
  int last_banners_size() const;
  void clear_last_banners();
  static const int kLastBannersFieldNumber = 1;
  ::google::protobuf::int32 last_banners(int index) const;
  void set_last_banners(int index, ::google::protobuf::int32 value);
  void add_last_banners(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      last_banners() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_last_banners();

  // @@protoc_insertion_point(class_scope:recostream.pb.TargetState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > last_banners_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------


// -------------------------------------------------------------------

class TargetSources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.TargetSources) */ {
 public:
  TargetSources();
  virtual ~TargetSources();

  TargetSources(const TargetSources& from);

  inline TargetSources& operator=(const TargetSources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TargetSources(TargetSources&& from) noexcept
    : TargetSources() {
    *this = ::std::move(from);
  }

  inline TargetSources& operator=(TargetSources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetSources& default_instance();

  static inline const TargetSources* internal_default_instance() {
    return reinterpret_cast<const TargetSources*>(
               &_TargetSources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(TargetSources* other);
  friend void swap(TargetSources& a, TargetSources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TargetSources* New() const PROTOBUF_FINAL { return New(NULL); }

  TargetSources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TargetSources& from);
  void MergeFrom(const TargetSources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TargetSources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .recostream.pb.TargetState> states = 1;
  int states_size() const;
  void clear_states();
  static const int kStatesFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::recostream::pb::TargetState >&
      states() const;
  ::google::protobuf::Map< ::std::string, ::recostream::pb::TargetState >*
      mutable_states();

  // @@protoc_insertion_point(class_scope:recostream.pb.TargetSources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  public:
  class TargetSources_StatesEntry : public ::google::protobuf::internal::MapEntry<TargetSources_StatesEntry, 
      ::std::string, ::recostream::pb::TargetState,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<TargetSources_StatesEntry, 
      ::std::string, ::recostream::pb::TargetState,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > SuperType;
    TargetSources_StatesEntry();
    TargetSources_StatesEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const TargetSources_StatesEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_TargetSources_StatesEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      TargetSources_StatesEntry,
      ::std::string, ::recostream::pb::TargetState,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > states_;
  private:
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResultsPageState_BlockState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.ResultsPageState.BlockState) */ {
 public:
  ResultsPageState_BlockState();
  virtual ~ResultsPageState_BlockState();

  ResultsPageState_BlockState(const ResultsPageState_BlockState& from);

  inline ResultsPageState_BlockState& operator=(const ResultsPageState_BlockState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResultsPageState_BlockState(ResultsPageState_BlockState&& from) noexcept
    : ResultsPageState_BlockState() {
    *this = ::std::move(from);
  }

  inline ResultsPageState_BlockState& operator=(ResultsPageState_BlockState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultsPageState_BlockState& default_instance();

  static inline const ResultsPageState_BlockState* internal_default_instance() {
    return reinterpret_cast<const ResultsPageState_BlockState*>(
               &_ResultsPageState_BlockState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ResultsPageState_BlockState* other);
  friend void swap(ResultsPageState_BlockState& a, ResultsPageState_BlockState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResultsPageState_BlockState* New() const PROTOBUF_FINAL { return New(NULL); }

  ResultsPageState_BlockState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResultsPageState_BlockState& from);
  void MergeFrom(const ResultsPageState_BlockState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResultsPageState_BlockState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 used_positions = 2;
  bool has_used_positions() const;
  void clear_used_positions();
  static const int kUsedPositionsFieldNumber = 2;
  ::google::protobuf::int32 used_positions() const;
  void set_used_positions(::google::protobuf::int32 value);

  // optional int32 block_layout_position = 3;
  bool has_block_layout_position() const;
  void clear_block_layout_position();
  static const int kBlockLayoutPositionFieldNumber = 3;
  ::google::protobuf::int32 block_layout_position() const;
  void set_block_layout_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.ResultsPageState.BlockState)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_used_positions();
  void clear_has_used_positions();
  void set_has_block_layout_position();
  void clear_has_block_layout_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 used_positions_;
  ::google::protobuf::int32 block_layout_position_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResultsPageState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.ResultsPageState) */ {
 public:
  ResultsPageState();
  virtual ~ResultsPageState();

  ResultsPageState(const ResultsPageState& from);

  inline ResultsPageState& operator=(const ResultsPageState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResultsPageState(ResultsPageState&& from) noexcept
    : ResultsPageState() {
    *this = ::std::move(from);
  }

  inline ResultsPageState& operator=(ResultsPageState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultsPageState& default_instance();

  static inline const ResultsPageState* internal_default_instance() {
    return reinterpret_cast<const ResultsPageState*>(
               &_ResultsPageState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ResultsPageState* other);
  friend void swap(ResultsPageState& a, ResultsPageState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResultsPageState* New() const PROTOBUF_FINAL { return New(NULL); }

  ResultsPageState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResultsPageState& from);
  void MergeFrom(const ResultsPageState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResultsPageState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ResultsPageState_BlockState BlockState;

  // accessors -------------------------------------------------------

  // repeated .recostream.pb.ResultsPageState.BlockState blocks = 3;
  int blocks_size() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 3;
  const ::recostream::pb::ResultsPageState_BlockState& blocks(int index) const;
  ::recostream::pb::ResultsPageState_BlockState* mutable_blocks(int index);
  ::recostream::pb::ResultsPageState_BlockState* add_blocks();
  ::google::protobuf::RepeatedPtrField< ::recostream::pb::ResultsPageState_BlockState >*
      mutable_blocks();
  const ::google::protobuf::RepeatedPtrField< ::recostream::pb::ResultsPageState_BlockState >&
      blocks() const;

  // repeated string terminated_providers = 5;
  int terminated_providers_size() const;
  void clear_terminated_providers();
  static const int kTerminatedProvidersFieldNumber = 5;
  const ::std::string& terminated_providers(int index) const;
  ::std::string* mutable_terminated_providers(int index);
  void set_terminated_providers(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_terminated_providers(int index, ::std::string&& value);
  #endif
  void set_terminated_providers(int index, const char* value);
  void set_terminated_providers(int index, const char* value, size_t size);
  ::std::string* add_terminated_providers();
  void add_terminated_providers(const ::std::string& value);
  #if LANG_CXX11
  void add_terminated_providers(::std::string&& value);
  #endif
  void add_terminated_providers(const char* value);
  void add_terminated_providers(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& terminated_providers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_terminated_providers();

  // repeated uint32 lenta = 6;
  int lenta_size() const;
  void clear_lenta();
  static const int kLentaFieldNumber = 6;
  ::google::protobuf::uint32 lenta(int index) const;
  void set_lenta(int index, ::google::protobuf::uint32 value);
  void add_lenta(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      lenta() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_lenta();

  // repeated int64 document_hashes = 7;
  int document_hashes_size() const;
  void clear_document_hashes();
  static const int kDocumentHashesFieldNumber = 7;
  ::google::protobuf::int64 document_hashes(int index) const;
  void set_document_hashes(int index, ::google::protobuf::int64 value);
  void add_document_hashes(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      document_hashes() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_document_hashes();

  // optional int32 layout_position = 1;
  bool has_layout_position() const;
  void clear_layout_position();
  static const int kLayoutPositionFieldNumber = 1;
  ::google::protobuf::int32 layout_position() const;
  void set_layout_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.ResultsPageState)
 private:
  void set_has_layout_position();
  void clear_has_layout_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::recostream::pb::ResultsPageState_BlockState > blocks_;
  ::google::protobuf::RepeatedPtrField< ::std::string> terminated_providers_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > lenta_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > document_hashes_;
  ::google::protobuf::int32 layout_position_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PPNState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.PPNState) */ {
 public:
  PPNState();
  virtual ~PPNState();

  PPNState(const PPNState& from);

  inline PPNState& operator=(const PPNState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PPNState(PPNState&& from) noexcept
    : PPNState() {
    *this = ::std::move(from);
  }

  inline PPNState& operator=(PPNState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PPNState& default_instance();

  static inline const PPNState* internal_default_instance() {
    return reinterpret_cast<const PPNState*>(
               &_PPNState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(PPNState* other);
  friend void swap(PPNState& a, PPNState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PPNState* New() const PROTOBUF_FINAL { return New(NULL); }

  PPNState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PPNState& from);
  void MergeFrom(const PPNState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PPNState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string results_hash = 1;
  bool has_results_hash() const;
  void clear_results_hash();
  static const int kResultsHashFieldNumber = 1;
  const ::std::string& results_hash() const;
  void set_results_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_results_hash(::std::string&& value);
  #endif
  void set_results_hash(const char* value);
  void set_results_hash(const char* value, size_t size);
  ::std::string* mutable_results_hash();
  ::std::string* release_results_hash();
  void set_allocated_results_hash(::std::string* results_hash);

  // optional int64 creation_ts = 3 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_creation_ts() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_creation_ts();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kCreationTsFieldNumber = 3;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int64 creation_ts() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_creation_ts(::google::protobuf::int64 value);

  // optional int32 position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.PPNState)
 private:
  void set_has_results_hash();
  void clear_has_results_hash();
  void set_has_position();
  void clear_has_position();
  void set_has_creation_ts();
  void clear_has_creation_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr results_hash_;
  ::google::protobuf::int64 creation_ts_;
  ::google::protobuf::int32 position_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubscriptionState_SubscriptionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.SubscriptionState.SubscriptionInfo) */ {
 public:
  SubscriptionState_SubscriptionInfo();
  virtual ~SubscriptionState_SubscriptionInfo();

  SubscriptionState_SubscriptionInfo(const SubscriptionState_SubscriptionInfo& from);

  inline SubscriptionState_SubscriptionInfo& operator=(const SubscriptionState_SubscriptionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubscriptionState_SubscriptionInfo(SubscriptionState_SubscriptionInfo&& from) noexcept
    : SubscriptionState_SubscriptionInfo() {
    *this = ::std::move(from);
  }

  inline SubscriptionState_SubscriptionInfo& operator=(SubscriptionState_SubscriptionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscriptionState_SubscriptionInfo& default_instance();

  static inline const SubscriptionState_SubscriptionInfo* internal_default_instance() {
    return reinterpret_cast<const SubscriptionState_SubscriptionInfo*>(
               &_SubscriptionState_SubscriptionInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(SubscriptionState_SubscriptionInfo* other);
  friend void swap(SubscriptionState_SubscriptionInfo& a, SubscriptionState_SubscriptionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscriptionState_SubscriptionInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SubscriptionState_SubscriptionInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubscriptionState_SubscriptionInfo& from);
  void MergeFrom(const SubscriptionState_SubscriptionInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubscriptionState_SubscriptionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 last_ts = 2;
  bool has_last_ts() const;
  void clear_last_ts();
  static const int kLastTsFieldNumber = 2;
  ::google::protobuf::int64 last_ts() const;
  void set_last_ts(::google::protobuf::int64 value);

  // required uint32 cnt = 1;
  bool has_cnt() const;
  void clear_cnt();
  static const int kCntFieldNumber = 1;
  ::google::protobuf::uint32 cnt() const;
  void set_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.SubscriptionState.SubscriptionInfo)
 private:
  void set_has_cnt();
  void clear_has_cnt();
  void set_has_last_ts();
  void clear_has_last_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 last_ts_;
  ::google::protobuf::uint32 cnt_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubscriptionState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.SubscriptionState) */ {
 public:
  SubscriptionState();
  virtual ~SubscriptionState();

  SubscriptionState(const SubscriptionState& from);

  inline SubscriptionState& operator=(const SubscriptionState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubscriptionState(SubscriptionState&& from) noexcept
    : SubscriptionState() {
    *this = ::std::move(from);
  }

  inline SubscriptionState& operator=(SubscriptionState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscriptionState& default_instance();

  static inline const SubscriptionState* internal_default_instance() {
    return reinterpret_cast<const SubscriptionState*>(
               &_SubscriptionState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(SubscriptionState* other);
  friend void swap(SubscriptionState& a, SubscriptionState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscriptionState* New() const PROTOBUF_FINAL { return New(NULL); }

  SubscriptionState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SubscriptionState& from);
  void MergeFrom(const SubscriptionState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SubscriptionState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SubscriptionState_SubscriptionInfo SubscriptionInfo;

  // accessors -------------------------------------------------------

  // repeated int64 user_source_subscriptions = 5;
  int user_source_subscriptions_size() const;
  void clear_user_source_subscriptions();
  static const int kUserSourceSubscriptionsFieldNumber = 5;
  ::google::protobuf::int64 user_source_subscriptions(int index) const;
  void set_user_source_subscriptions(int index, ::google::protobuf::int64 value);
  void add_user_source_subscriptions(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      user_source_subscriptions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_user_source_subscriptions();

  // optional string block_name = 1;
  bool has_block_name() const;
  void clear_block_name();
  static const int kBlockNameFieldNumber = 1;
  const ::std::string& block_name() const;
  void set_block_name(const ::std::string& value);
  #if LANG_CXX11
  void set_block_name(::std::string&& value);
  #endif
  void set_block_name(const char* value);
  void set_block_name(const char* value, size_t size);
  ::std::string* mutable_block_name();
  ::std::string* release_block_name();
  void set_allocated_block_name(::std::string* block_name);

  // optional .recostream.pb.SubscriptionState.SubscriptionInfo category_subscription = 6;
  bool has_category_subscription() const;
  void clear_category_subscription();
  static const int kCategorySubscriptionFieldNumber = 6;
  const ::recostream::pb::SubscriptionState_SubscriptionInfo& category_subscription() const;
  ::recostream::pb::SubscriptionState_SubscriptionInfo* mutable_category_subscription();
  ::recostream::pb::SubscriptionState_SubscriptionInfo* release_category_subscription();
  void set_allocated_category_subscription(::recostream::pb::SubscriptionState_SubscriptionInfo* category_subscription);

  // optional .recostream.pb.SubscriptionState.SubscriptionInfo cold_sources_subscription = 7;
  bool has_cold_sources_subscription() const;
  void clear_cold_sources_subscription();
  static const int kColdSourcesSubscriptionFieldNumber = 7;
  const ::recostream::pb::SubscriptionState_SubscriptionInfo& cold_sources_subscription() const;
  ::recostream::pb::SubscriptionState_SubscriptionInfo* mutable_cold_sources_subscription();
  ::recostream::pb::SubscriptionState_SubscriptionInfo* release_cold_sources_subscription();
  void set_allocated_cold_sources_subscription(::recostream::pb::SubscriptionState_SubscriptionInfo* cold_sources_subscription);

  // optional bool show_category_subscription = 3;
  bool has_show_category_subscription() const;
  void clear_show_category_subscription();
  static const int kShowCategorySubscriptionFieldNumber = 3;
  bool show_category_subscription() const;
  void set_show_category_subscription(bool value);

  // optional bool show_cold_sources_subscription = 4;
  bool has_show_cold_sources_subscription() const;
  void clear_show_cold_sources_subscription();
  static const int kShowColdSourcesSubscriptionFieldNumber = 4;
  bool show_cold_sources_subscription() const;
  void set_show_cold_sources_subscription(bool value);

  // @@protoc_insertion_point(class_scope:recostream.pb.SubscriptionState)
 private:
  void set_has_block_name();
  void clear_has_block_name();
  void set_has_show_category_subscription();
  void clear_has_show_category_subscription();
  void set_has_show_cold_sources_subscription();
  void clear_has_show_cold_sources_subscription();
  void set_has_category_subscription();
  void clear_has_category_subscription();
  void set_has_cold_sources_subscription();
  void clear_has_cold_sources_subscription();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > user_source_subscriptions_;
  ::google::protobuf::internal::ArenaStringPtr block_name_;
  ::recostream::pb::SubscriptionState_SubscriptionInfo* category_subscription_;
  ::recostream::pb::SubscriptionState_SubscriptionInfo* cold_sources_subscription_;
  bool show_category_subscription_;
  bool show_cold_sources_subscription_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RecoSessionState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.RecoSessionState) */ {
 public:
  RecoSessionState();
  virtual ~RecoSessionState();

  RecoSessionState(const RecoSessionState& from);

  inline RecoSessionState& operator=(const RecoSessionState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RecoSessionState(RecoSessionState&& from) noexcept
    : RecoSessionState() {
    *this = ::std::move(from);
  }

  inline RecoSessionState& operator=(RecoSessionState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecoSessionState& default_instance();

  static inline const RecoSessionState* internal_default_instance() {
    return reinterpret_cast<const RecoSessionState*>(
               &_RecoSessionState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(RecoSessionState* other);
  friend void swap(RecoSessionState& a, RecoSessionState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RecoSessionState* New() const PROTOBUF_FINAL { return New(NULL); }

  RecoSessionState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RecoSessionState& from);
  void MergeFrom(const RecoSessionState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RecoSessionState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .recostream.pb.LoginState login_state = 1;
  bool has_login_state() const;
  void clear_login_state();
  static const int kLoginStateFieldNumber = 1;
  const ::recostream::pb::LoginState& login_state() const;
  ::recostream::pb::LoginState* mutable_login_state();
  ::recostream::pb::LoginState* release_login_state();
  void set_allocated_login_state(::recostream::pb::LoginState* login_state);

  // optional .recostream.pb.ResultsPageState results_page_state = 3;
  bool has_results_page_state() const;
  void clear_results_page_state();
  static const int kResultsPageStateFieldNumber = 3;
  const ::recostream::pb::ResultsPageState& results_page_state() const;
  ::recostream::pb::ResultsPageState* mutable_results_page_state();
  ::recostream::pb::ResultsPageState* release_results_page_state();
  void set_allocated_results_page_state(::recostream::pb::ResultsPageState* results_page_state);

  // optional .recostream.pb.CosmoSources cosmo_sources = 4;
  bool has_cosmo_sources() const;
  void clear_cosmo_sources();
  static const int kCosmoSourcesFieldNumber = 4;
  const ::recostream::pb::CosmoSources& cosmo_sources() const;
  ::recostream::pb::CosmoSources* mutable_cosmo_sources();
  ::recostream::pb::CosmoSources* release_cosmo_sources();
  void set_allocated_cosmo_sources(::recostream::pb::CosmoSources* cosmo_sources);

  // optional .recostream.pb.PPNState ppn_state = 5;
  bool has_ppn_state() const;
  void clear_ppn_state();
  static const int kPpnStateFieldNumber = 5;
  const ::recostream::pb::PPNState& ppn_state() const;
  ::recostream::pb::PPNState* mutable_ppn_state();
  ::recostream::pb::PPNState* release_ppn_state();
  void set_allocated_ppn_state(::recostream::pb::PPNState* ppn_state);

  // optional .recostream.pb.TargetSources target_sources = 6;
  bool has_target_sources() const;
  void clear_target_sources();
  static const int kTargetSourcesFieldNumber = 6;
  const ::recostream::pb::TargetSources& target_sources() const;
  ::recostream::pb::TargetSources* mutable_target_sources();
  ::recostream::pb::TargetSources* release_target_sources();
  void set_allocated_target_sources(::recostream::pb::TargetSources* target_sources);

  // optional .recostream.pb.SubscriptionState subscription_state = 7;
  bool has_subscription_state() const;
  void clear_subscription_state();
  static const int kSubscriptionStateFieldNumber = 7;
  const ::recostream::pb::SubscriptionState& subscription_state() const;
  ::recostream::pb::SubscriptionState* mutable_subscription_state();
  ::recostream::pb::SubscriptionState* release_subscription_state();
  void set_allocated_subscription_state(::recostream::pb::SubscriptionState* subscription_state);

  // optional bool cold_lenta = 8;
  bool has_cold_lenta() const;
  void clear_cold_lenta();
  static const int kColdLentaFieldNumber = 8;
  bool cold_lenta() const;
  void set_cold_lenta(bool value);

  // optional int64 creation_ts = 100;
  bool has_creation_ts() const;
  void clear_creation_ts();
  static const int kCreationTsFieldNumber = 100;
  ::google::protobuf::int64 creation_ts() const;
  void set_creation_ts(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:recostream.pb.RecoSessionState)
 private:
  void set_has_login_state();
  void clear_has_login_state();
  void set_has_results_page_state();
  void clear_has_results_page_state();
  void set_has_cosmo_sources();
  void clear_has_cosmo_sources();
  void set_has_ppn_state();
  void clear_has_ppn_state();
  void set_has_target_sources();
  void clear_has_target_sources();
  void set_has_subscription_state();
  void clear_has_subscription_state();
  void set_has_cold_lenta();
  void clear_has_cold_lenta();
  void set_has_creation_ts();
  void clear_has_creation_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::recostream::pb::LoginState* login_state_;
  ::recostream::pb::ResultsPageState* results_page_state_;
  ::recostream::pb::CosmoSources* cosmo_sources_;
  ::recostream::pb::PPNState* ppn_state_;
  ::recostream::pb::TargetSources* target_sources_;
  ::recostream::pb::SubscriptionState* subscription_state_;
  bool cold_lenta_;
  ::google::protobuf::int64 creation_ts_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProfileSettingField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.ProfileSettingField) */ {
 public:
  ProfileSettingField();
  virtual ~ProfileSettingField();

  ProfileSettingField(const ProfileSettingField& from);

  inline ProfileSettingField& operator=(const ProfileSettingField& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProfileSettingField(ProfileSettingField&& from) noexcept
    : ProfileSettingField() {
    *this = ::std::move(from);
  }

  inline ProfileSettingField& operator=(ProfileSettingField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProfileSettingField& default_instance();

  static inline const ProfileSettingField* internal_default_instance() {
    return reinterpret_cast<const ProfileSettingField*>(
               &_ProfileSettingField_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(ProfileSettingField* other);
  friend void swap(ProfileSettingField& a, ProfileSettingField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProfileSettingField* New() const PROTOBUF_FINAL { return New(NULL); }

  ProfileSettingField* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProfileSettingField& from);
  void MergeFrom(const ProfileSettingField& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProfileSettingField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:recostream.pb.ProfileSettingField)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProfileSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:recostream.pb.ProfileSettings) */ {
 public:
  ProfileSettings();
  virtual ~ProfileSettings();

  ProfileSettings(const ProfileSettings& from);

  inline ProfileSettings& operator=(const ProfileSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProfileSettings(ProfileSettings&& from) noexcept
    : ProfileSettings() {
    *this = ::std::move(from);
  }

  inline ProfileSettings& operator=(ProfileSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProfileSettings& default_instance();

  static inline const ProfileSettings* internal_default_instance() {
    return reinterpret_cast<const ProfileSettings*>(
               &_ProfileSettings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(ProfileSettings* other);
  friend void swap(ProfileSettings& a, ProfileSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProfileSettings* New() const PROTOBUF_FINAL { return New(NULL); }

  ProfileSettings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProfileSettings& from);
  void MergeFrom(const ProfileSettings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProfileSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .recostream.pb.ProfileSettingField settings = 1;
  int settings_size() const;
  void clear_settings();
  static const int kSettingsFieldNumber = 1;
  const ::recostream::pb::ProfileSettingField& settings(int index) const;
  ::recostream::pb::ProfileSettingField* mutable_settings(int index);
  ::recostream::pb::ProfileSettingField* add_settings();
  ::google::protobuf::RepeatedPtrField< ::recostream::pb::ProfileSettingField >*
      mutable_settings();
  const ::google::protobuf::RepeatedPtrField< ::recostream::pb::ProfileSettingField >&
      settings() const;

  // @@protoc_insertion_point(class_scope:recostream.pb.ProfileSettings)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::recostream::pb::ProfileSettingField > settings_;
  friend struct protobuf_recostream_5fsession_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginState

// required int64 user_id = 1;
inline bool LoginState::has_user_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginState::set_has_user_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginState::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginState::clear_user_id() {
  user_id_ = GOOGLE_LONGLONG(0);
  clear_has_user_id();
}
inline ::google::protobuf::int64 LoginState::user_id() const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.user_id)
  return user_id_;
}
inline void LoginState::set_user_id(::google::protobuf::int64 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.user_id)
}

// optional uint64 vid = 2;
inline bool LoginState::has_vid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginState::set_has_vid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginState::clear_has_vid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginState::clear_vid() {
  vid_ = GOOGLE_ULONGLONG(0);
  clear_has_vid();
}
inline ::google::protobuf::uint64 LoginState::vid() const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.vid)
  return vid_;
}
inline void LoginState::set_vid(::google::protobuf::uint64 value) {
  set_has_vid();
  vid_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.vid)
}

// optional int32 split = 3;
inline bool LoginState::has_split() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginState::set_has_split() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginState::clear_has_split() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginState::clear_split() {
  split_ = 0;
  clear_has_split();
}
inline ::google::protobuf::int32 LoginState::split() const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.split)
  return split_;
}
inline void LoginState::set_split(::google::protobuf::int32 value) {
  set_has_split();
  split_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.split)
}

// optional bool is_anonymous = 4;
inline bool LoginState::has_is_anonymous() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginState::set_has_is_anonymous() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginState::clear_has_is_anonymous() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginState::clear_is_anonymous() {
  is_anonymous_ = false;
  clear_has_is_anonymous();
}
inline bool LoginState::is_anonymous() const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.is_anonymous)
  return is_anonymous_;
}
inline void LoginState::set_is_anonymous(bool value) {
  set_has_is_anonymous();
  is_anonymous_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.is_anonymous)
}

// optional string from_label = 5;
inline bool LoginState::has_from_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginState::set_has_from_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginState::clear_has_from_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginState::clear_from_label() {
  from_label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from_label();
}
inline const ::std::string& LoginState::from_label() const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.from_label)
  return from_label_.GetNoArena();
}
inline void LoginState::set_from_label(const ::std::string& value) {
  set_has_from_label();
  from_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.from_label)
}
#if LANG_CXX11
inline void LoginState::set_from_label(::std::string&& value) {
  set_has_from_label();
  from_label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.LoginState.from_label)
}
#endif
inline void LoginState::set_from_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from_label();
  from_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.LoginState.from_label)
}
inline void LoginState::set_from_label(const char* value, size_t size) {
  set_has_from_label();
  from_label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.LoginState.from_label)
}
inline ::std::string* LoginState::mutable_from_label() {
  set_has_from_label();
  // @@protoc_insertion_point(field_mutable:recostream.pb.LoginState.from_label)
  return from_label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginState::release_from_label() {
  // @@protoc_insertion_point(field_release:recostream.pb.LoginState.from_label)
  clear_has_from_label();
  return from_label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginState::set_allocated_from_label(::std::string* from_label) {
  if (from_label != NULL) {
    set_has_from_label();
  } else {
    clear_has_from_label();
  }
  from_label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_label);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.LoginState.from_label)
}

// optional int64 advert_sitename = 6;
inline bool LoginState::has_advert_sitename() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginState::set_has_advert_sitename() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginState::clear_has_advert_sitename() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginState::clear_advert_sitename() {
  advert_sitename_ = GOOGLE_LONGLONG(0);
  clear_has_advert_sitename();
}
inline ::google::protobuf::int64 LoginState::advert_sitename() const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.advert_sitename)
  return advert_sitename_;
}
inline void LoginState::set_advert_sitename(::google::protobuf::int64 value) {
  set_has_advert_sitename();
  advert_sitename_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.advert_sitename)
}

// optional string category_ids = 7;
inline bool LoginState::has_category_ids() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginState::set_has_category_ids() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginState::clear_has_category_ids() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginState::clear_category_ids() {
  category_ids_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_category_ids();
}
inline const ::std::string& LoginState::category_ids() const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.category_ids)
  return category_ids_.GetNoArena();
}
inline void LoginState::set_category_ids(const ::std::string& value) {
  set_has_category_ids();
  category_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.category_ids)
}
#if LANG_CXX11
inline void LoginState::set_category_ids(::std::string&& value) {
  set_has_category_ids();
  category_ids_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.LoginState.category_ids)
}
#endif
inline void LoginState::set_category_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_category_ids();
  category_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.LoginState.category_ids)
}
inline void LoginState::set_category_ids(const char* value, size_t size) {
  set_has_category_ids();
  category_ids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.LoginState.category_ids)
}
inline ::std::string* LoginState::mutable_category_ids() {
  set_has_category_ids();
  // @@protoc_insertion_point(field_mutable:recostream.pb.LoginState.category_ids)
  return category_ids_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginState::release_category_ids() {
  // @@protoc_insertion_point(field_release:recostream.pb.LoginState.category_ids)
  clear_has_category_ids();
  return category_ids_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginState::set_allocated_category_ids(::std::string* category_ids) {
  if (category_ids != NULL) {
    set_has_category_ids();
  } else {
    clear_has_category_ids();
  }
  category_ids_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), category_ids);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.LoginState.category_ids)
}

// repeated string many_vids = 8;
inline int LoginState::many_vids_size() const {
  return many_vids_.size();
}
inline void LoginState::clear_many_vids() {
  many_vids_.Clear();
}
inline const ::std::string& LoginState::many_vids(int index) const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.many_vids)
  return many_vids_.Get(index);
}
inline ::std::string* LoginState::mutable_many_vids(int index) {
  // @@protoc_insertion_point(field_mutable:recostream.pb.LoginState.many_vids)
  return many_vids_.Mutable(index);
}
inline void LoginState::set_many_vids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.many_vids)
  many_vids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LoginState::set_many_vids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.many_vids)
  many_vids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LoginState::set_many_vids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  many_vids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:recostream.pb.LoginState.many_vids)
}
inline void LoginState::set_many_vids(int index, const char* value, size_t size) {
  many_vids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.LoginState.many_vids)
}
inline ::std::string* LoginState::add_many_vids() {
  // @@protoc_insertion_point(field_add_mutable:recostream.pb.LoginState.many_vids)
  return many_vids_.Add();
}
inline void LoginState::add_many_vids(const ::std::string& value) {
  many_vids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:recostream.pb.LoginState.many_vids)
}
#if LANG_CXX11
inline void LoginState::add_many_vids(::std::string&& value) {
  many_vids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:recostream.pb.LoginState.many_vids)
}
#endif
inline void LoginState::add_many_vids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  many_vids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:recostream.pb.LoginState.many_vids)
}
inline void LoginState::add_many_vids(const char* value, size_t size) {
  many_vids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:recostream.pb.LoginState.many_vids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LoginState::many_vids() const {
  // @@protoc_insertion_point(field_list:recostream.pb.LoginState.many_vids)
  return many_vids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LoginState::mutable_many_vids() {
  // @@protoc_insertion_point(field_mutable_list:recostream.pb.LoginState.many_vids)
  return &many_vids_;
}

// repeated string many_emails = 9;
inline int LoginState::many_emails_size() const {
  return many_emails_.size();
}
inline void LoginState::clear_many_emails() {
  many_emails_.Clear();
}
inline const ::std::string& LoginState::many_emails(int index) const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.many_emails)
  return many_emails_.Get(index);
}
inline ::std::string* LoginState::mutable_many_emails(int index) {
  // @@protoc_insertion_point(field_mutable:recostream.pb.LoginState.many_emails)
  return many_emails_.Mutable(index);
}
inline void LoginState::set_many_emails(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.many_emails)
  many_emails_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LoginState::set_many_emails(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.many_emails)
  many_emails_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LoginState::set_many_emails(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  many_emails_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:recostream.pb.LoginState.many_emails)
}
inline void LoginState::set_many_emails(int index, const char* value, size_t size) {
  many_emails_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.LoginState.many_emails)
}
inline ::std::string* LoginState::add_many_emails() {
  // @@protoc_insertion_point(field_add_mutable:recostream.pb.LoginState.many_emails)
  return many_emails_.Add();
}
inline void LoginState::add_many_emails(const ::std::string& value) {
  many_emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:recostream.pb.LoginState.many_emails)
}
#if LANG_CXX11
inline void LoginState::add_many_emails(::std::string&& value) {
  many_emails_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:recostream.pb.LoginState.many_emails)
}
#endif
inline void LoginState::add_many_emails(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  many_emails_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:recostream.pb.LoginState.many_emails)
}
inline void LoginState::add_many_emails(const char* value, size_t size) {
  many_emails_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:recostream.pb.LoginState.many_emails)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LoginState::many_emails() const {
  // @@protoc_insertion_point(field_list:recostream.pb.LoginState.many_emails)
  return many_emails_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LoginState::mutable_many_emails() {
  // @@protoc_insertion_point(field_mutable_list:recostream.pb.LoginState.many_emails)
  return &many_emails_;
}

// optional string vk_id = 10;
inline bool LoginState::has_vk_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginState::set_has_vk_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginState::clear_has_vk_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginState::clear_vk_id() {
  vk_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vk_id();
}
inline const ::std::string& LoginState::vk_id() const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.vk_id)
  return vk_id_.GetNoArena();
}
inline void LoginState::set_vk_id(const ::std::string& value) {
  set_has_vk_id();
  vk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.vk_id)
}
#if LANG_CXX11
inline void LoginState::set_vk_id(::std::string&& value) {
  set_has_vk_id();
  vk_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.LoginState.vk_id)
}
#endif
inline void LoginState::set_vk_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vk_id();
  vk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.LoginState.vk_id)
}
inline void LoginState::set_vk_id(const char* value, size_t size) {
  set_has_vk_id();
  vk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.LoginState.vk_id)
}
inline ::std::string* LoginState::mutable_vk_id() {
  set_has_vk_id();
  // @@protoc_insertion_point(field_mutable:recostream.pb.LoginState.vk_id)
  return vk_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginState::release_vk_id() {
  // @@protoc_insertion_point(field_release:recostream.pb.LoginState.vk_id)
  clear_has_vk_id();
  return vk_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginState::set_allocated_vk_id(::std::string* vk_id) {
  if (vk_id != NULL) {
    set_has_vk_id();
  } else {
    clear_has_vk_id();
  }
  vk_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vk_id);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.LoginState.vk_id)
}

// optional string ok_id = 11;
inline bool LoginState::has_ok_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginState::set_has_ok_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginState::clear_has_ok_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginState::clear_ok_id() {
  ok_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ok_id();
}
inline const ::std::string& LoginState::ok_id() const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.ok_id)
  return ok_id_.GetNoArena();
}
inline void LoginState::set_ok_id(const ::std::string& value) {
  set_has_ok_id();
  ok_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.ok_id)
}
#if LANG_CXX11
inline void LoginState::set_ok_id(::std::string&& value) {
  set_has_ok_id();
  ok_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.LoginState.ok_id)
}
#endif
inline void LoginState::set_ok_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ok_id();
  ok_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.LoginState.ok_id)
}
inline void LoginState::set_ok_id(const char* value, size_t size) {
  set_has_ok_id();
  ok_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.LoginState.ok_id)
}
inline ::std::string* LoginState::mutable_ok_id() {
  set_has_ok_id();
  // @@protoc_insertion_point(field_mutable:recostream.pb.LoginState.ok_id)
  return ok_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginState::release_ok_id() {
  // @@protoc_insertion_point(field_release:recostream.pb.LoginState.ok_id)
  clear_has_ok_id();
  return ok_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginState::set_allocated_ok_id(::std::string* ok_id) {
  if (ok_id != NULL) {
    set_has_ok_id();
  } else {
    clear_has_ok_id();
  }
  ok_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ok_id);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.LoginState.ok_id)
}

// optional string idfa = 12;
inline bool LoginState::has_idfa() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginState::set_has_idfa() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginState::clear_has_idfa() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginState::clear_idfa() {
  idfa_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_idfa();
}
inline const ::std::string& LoginState::idfa() const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.idfa)
  return idfa_.GetNoArena();
}
inline void LoginState::set_idfa(const ::std::string& value) {
  set_has_idfa();
  idfa_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.idfa)
}
#if LANG_CXX11
inline void LoginState::set_idfa(::std::string&& value) {
  set_has_idfa();
  idfa_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.LoginState.idfa)
}
#endif
inline void LoginState::set_idfa(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_idfa();
  idfa_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.LoginState.idfa)
}
inline void LoginState::set_idfa(const char* value, size_t size) {
  set_has_idfa();
  idfa_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.LoginState.idfa)
}
inline ::std::string* LoginState::mutable_idfa() {
  set_has_idfa();
  // @@protoc_insertion_point(field_mutable:recostream.pb.LoginState.idfa)
  return idfa_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginState::release_idfa() {
  // @@protoc_insertion_point(field_release:recostream.pb.LoginState.idfa)
  clear_has_idfa();
  return idfa_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginState::set_allocated_idfa(::std::string* idfa) {
  if (idfa != NULL) {
    set_has_idfa();
  } else {
    clear_has_idfa();
  }
  idfa_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), idfa);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.LoginState.idfa)
}

// optional string gaid = 13;
inline bool LoginState::has_gaid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginState::set_has_gaid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginState::clear_has_gaid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginState::clear_gaid() {
  gaid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gaid();
}
inline const ::std::string& LoginState::gaid() const {
  // @@protoc_insertion_point(field_get:recostream.pb.LoginState.gaid)
  return gaid_.GetNoArena();
}
inline void LoginState::set_gaid(const ::std::string& value) {
  set_has_gaid();
  gaid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.LoginState.gaid)
}
#if LANG_CXX11
inline void LoginState::set_gaid(::std::string&& value) {
  set_has_gaid();
  gaid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.LoginState.gaid)
}
#endif
inline void LoginState::set_gaid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gaid();
  gaid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.LoginState.gaid)
}
inline void LoginState::set_gaid(const char* value, size_t size) {
  set_has_gaid();
  gaid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.LoginState.gaid)
}
inline ::std::string* LoginState::mutable_gaid() {
  set_has_gaid();
  // @@protoc_insertion_point(field_mutable:recostream.pb.LoginState.gaid)
  return gaid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginState::release_gaid() {
  // @@protoc_insertion_point(field_release:recostream.pb.LoginState.gaid)
  clear_has_gaid();
  return gaid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginState::set_allocated_gaid(::std::string* gaid) {
  if (gaid != NULL) {
    set_has_gaid();
  } else {
    clear_has_gaid();
  }
  gaid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gaid);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.LoginState.gaid)
}

// -------------------------------------------------------------------

// CosmoState_CacheCursor

// required string record_id = 1;
inline bool CosmoState_CacheCursor::has_record_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CosmoState_CacheCursor::set_has_record_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CosmoState_CacheCursor::clear_has_record_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CosmoState_CacheCursor::clear_record_id() {
  record_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_record_id();
}
inline const ::std::string& CosmoState_CacheCursor::record_id() const {
  // @@protoc_insertion_point(field_get:recostream.pb.CosmoState.CacheCursor.record_id)
  return record_id_.GetNoArena();
}
inline void CosmoState_CacheCursor::set_record_id(const ::std::string& value) {
  set_has_record_id();
  record_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.CosmoState.CacheCursor.record_id)
}
#if LANG_CXX11
inline void CosmoState_CacheCursor::set_record_id(::std::string&& value) {
  set_has_record_id();
  record_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.CosmoState.CacheCursor.record_id)
}
#endif
inline void CosmoState_CacheCursor::set_record_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_record_id();
  record_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.CosmoState.CacheCursor.record_id)
}
inline void CosmoState_CacheCursor::set_record_id(const char* value, size_t size) {
  set_has_record_id();
  record_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.CosmoState.CacheCursor.record_id)
}
inline ::std::string* CosmoState_CacheCursor::mutable_record_id() {
  set_has_record_id();
  // @@protoc_insertion_point(field_mutable:recostream.pb.CosmoState.CacheCursor.record_id)
  return record_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CosmoState_CacheCursor::release_record_id() {
  // @@protoc_insertion_point(field_release:recostream.pb.CosmoState.CacheCursor.record_id)
  clear_has_record_id();
  return record_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CosmoState_CacheCursor::set_allocated_record_id(::std::string* record_id) {
  if (record_id != NULL) {
    set_has_record_id();
  } else {
    clear_has_record_id();
  }
  record_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), record_id);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.CosmoState.CacheCursor.record_id)
}

// required int32 pos = 2;
inline bool CosmoState_CacheCursor::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CosmoState_CacheCursor::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CosmoState_CacheCursor::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CosmoState_CacheCursor::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 CosmoState_CacheCursor::pos() const {
  // @@protoc_insertion_point(field_get:recostream.pb.CosmoState.CacheCursor.pos)
  return pos_;
}
inline void CosmoState_CacheCursor::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.CosmoState.CacheCursor.pos)
}

// -------------------------------------------------------------------

// CosmoState_Stats

// optional int32 skipped = 1;
inline bool CosmoState_Stats::has_skipped() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CosmoState_Stats::set_has_skipped() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CosmoState_Stats::clear_has_skipped() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CosmoState_Stats::clear_skipped() {
  skipped_ = 0;
  clear_has_skipped();
}
inline ::google::protobuf::int32 CosmoState_Stats::skipped() const {
  // @@protoc_insertion_point(field_get:recostream.pb.CosmoState.Stats.skipped)
  return skipped_;
}
inline void CosmoState_Stats::set_skipped(::google::protobuf::int32 value) {
  set_has_skipped();
  skipped_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.CosmoState.Stats.skipped)
}

// optional int32 bahroma_missed = 2;
inline bool CosmoState_Stats::has_bahroma_missed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CosmoState_Stats::set_has_bahroma_missed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CosmoState_Stats::clear_has_bahroma_missed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CosmoState_Stats::clear_bahroma_missed() {
  bahroma_missed_ = 0;
  clear_has_bahroma_missed();
}
inline ::google::protobuf::int32 CosmoState_Stats::bahroma_missed() const {
  // @@protoc_insertion_point(field_get:recostream.pb.CosmoState.Stats.bahroma_missed)
  return bahroma_missed_;
}
inline void CosmoState_Stats::set_bahroma_missed(::google::protobuf::int32 value) {
  set_has_bahroma_missed();
  bahroma_missed_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.CosmoState.Stats.bahroma_missed)
}

// optional int32 banned = 3;
inline bool CosmoState_Stats::has_banned() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CosmoState_Stats::set_has_banned() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CosmoState_Stats::clear_has_banned() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CosmoState_Stats::clear_banned() {
  banned_ = 0;
  clear_has_banned();
}
inline ::google::protobuf::int32 CosmoState_Stats::banned() const {
  // @@protoc_insertion_point(field_get:recostream.pb.CosmoState.Stats.banned)
  return banned_;
}
inline void CosmoState_Stats::set_banned(::google::protobuf::int32 value) {
  set_has_banned();
  banned_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.CosmoState.Stats.banned)
}

// -------------------------------------------------------------------

// CosmoState_ExperimentInfo

// required uint32 experiment_id = 1;
inline bool CosmoState_ExperimentInfo::has_experiment_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CosmoState_ExperimentInfo::set_has_experiment_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CosmoState_ExperimentInfo::clear_has_experiment_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CosmoState_ExperimentInfo::clear_experiment_id() {
  experiment_id_ = 0u;
  clear_has_experiment_id();
}
inline ::google::protobuf::uint32 CosmoState_ExperimentInfo::experiment_id() const {
  // @@protoc_insertion_point(field_get:recostream.pb.CosmoState.ExperimentInfo.experiment_id)
  return experiment_id_;
}
inline void CosmoState_ExperimentInfo::set_experiment_id(::google::protobuf::uint32 value) {
  set_has_experiment_id();
  experiment_id_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.CosmoState.ExperimentInfo.experiment_id)
}

// -------------------------------------------------------------------

// CosmoState

// optional .recostream.pb.CosmoState.CacheCursor cache_cursor = 1;
inline bool CosmoState::has_cache_cursor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CosmoState::set_has_cache_cursor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CosmoState::clear_has_cache_cursor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CosmoState::clear_cache_cursor() {
  if (cache_cursor_ != NULL) cache_cursor_->::recostream::pb::CosmoState_CacheCursor::Clear();
  clear_has_cache_cursor();
}
inline const ::recostream::pb::CosmoState_CacheCursor& CosmoState::cache_cursor() const {
  const ::recostream::pb::CosmoState_CacheCursor* p = cache_cursor_;
  // @@protoc_insertion_point(field_get:recostream.pb.CosmoState.cache_cursor)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::CosmoState_CacheCursor*>(
      &::recostream::pb::_CosmoState_CacheCursor_default_instance_);
}
inline ::recostream::pb::CosmoState_CacheCursor* CosmoState::mutable_cache_cursor() {
  set_has_cache_cursor();
  if (cache_cursor_ == NULL) {
    cache_cursor_ = new ::recostream::pb::CosmoState_CacheCursor;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.CosmoState.cache_cursor)
  return cache_cursor_;
}
inline ::recostream::pb::CosmoState_CacheCursor* CosmoState::release_cache_cursor() {
  // @@protoc_insertion_point(field_release:recostream.pb.CosmoState.cache_cursor)
  clear_has_cache_cursor();
  ::recostream::pb::CosmoState_CacheCursor* temp = cache_cursor_;
  cache_cursor_ = NULL;
  return temp;
}
inline void CosmoState::set_allocated_cache_cursor(::recostream::pb::CosmoState_CacheCursor* cache_cursor) {
  delete cache_cursor_;
  cache_cursor_ = cache_cursor;
  if (cache_cursor) {
    set_has_cache_cursor();
  } else {
    clear_has_cache_cursor();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.CosmoState.cache_cursor)
}

// optional .recostream.pb.CosmoState.Stats stats = 2;
inline bool CosmoState::has_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CosmoState::set_has_stats() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CosmoState::clear_has_stats() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CosmoState::clear_stats() {
  if (stats_ != NULL) stats_->::recostream::pb::CosmoState_Stats::Clear();
  clear_has_stats();
}
inline const ::recostream::pb::CosmoState_Stats& CosmoState::stats() const {
  const ::recostream::pb::CosmoState_Stats* p = stats_;
  // @@protoc_insertion_point(field_get:recostream.pb.CosmoState.stats)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::CosmoState_Stats*>(
      &::recostream::pb::_CosmoState_Stats_default_instance_);
}
inline ::recostream::pb::CosmoState_Stats* CosmoState::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) {
    stats_ = new ::recostream::pb::CosmoState_Stats;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.CosmoState.stats)
  return stats_;
}
inline ::recostream::pb::CosmoState_Stats* CosmoState::release_stats() {
  // @@protoc_insertion_point(field_release:recostream.pb.CosmoState.stats)
  clear_has_stats();
  ::recostream::pb::CosmoState_Stats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void CosmoState::set_allocated_stats(::recostream::pb::CosmoState_Stats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.CosmoState.stats)
}

// optional .recostream.pb.CosmoState.ExperimentInfo experiment_info = 3;
inline bool CosmoState::has_experiment_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CosmoState::set_has_experiment_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CosmoState::clear_has_experiment_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CosmoState::clear_experiment_info() {
  if (experiment_info_ != NULL) experiment_info_->::recostream::pb::CosmoState_ExperimentInfo::Clear();
  clear_has_experiment_info();
}
inline const ::recostream::pb::CosmoState_ExperimentInfo& CosmoState::experiment_info() const {
  const ::recostream::pb::CosmoState_ExperimentInfo* p = experiment_info_;
  // @@protoc_insertion_point(field_get:recostream.pb.CosmoState.experiment_info)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::CosmoState_ExperimentInfo*>(
      &::recostream::pb::_CosmoState_ExperimentInfo_default_instance_);
}
inline ::recostream::pb::CosmoState_ExperimentInfo* CosmoState::mutable_experiment_info() {
  set_has_experiment_info();
  if (experiment_info_ == NULL) {
    experiment_info_ = new ::recostream::pb::CosmoState_ExperimentInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.CosmoState.experiment_info)
  return experiment_info_;
}
inline ::recostream::pb::CosmoState_ExperimentInfo* CosmoState::release_experiment_info() {
  // @@protoc_insertion_point(field_release:recostream.pb.CosmoState.experiment_info)
  clear_has_experiment_info();
  ::recostream::pb::CosmoState_ExperimentInfo* temp = experiment_info_;
  experiment_info_ = NULL;
  return temp;
}
inline void CosmoState::set_allocated_experiment_info(::recostream::pb::CosmoState_ExperimentInfo* experiment_info) {
  delete experiment_info_;
  experiment_info_ = experiment_info;
  if (experiment_info) {
    set_has_experiment_info();
  } else {
    clear_has_experiment_info();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.CosmoState.experiment_info)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CosmoSources

// map<string, .recostream.pb.CosmoState> states = 1;
inline int CosmoSources::states_size() const {
  return states_.size();
}
inline void CosmoSources::clear_states() {
  states_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::recostream::pb::CosmoState >&
CosmoSources::states() const {
  // @@protoc_insertion_point(field_map:recostream.pb.CosmoSources.states)
  return states_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::recostream::pb::CosmoState >*
CosmoSources::mutable_states() {
  // @@protoc_insertion_point(field_mutable_map:recostream.pb.CosmoSources.states)
  return states_.MutableMap();
}

// -------------------------------------------------------------------

// TargetState

// repeated int32 last_banners = 1;
inline int TargetState::last_banners_size() const {
  return last_banners_.size();
}
inline void TargetState::clear_last_banners() {
  last_banners_.Clear();
}
inline ::google::protobuf::int32 TargetState::last_banners(int index) const {
  // @@protoc_insertion_point(field_get:recostream.pb.TargetState.last_banners)
  return last_banners_.Get(index);
}
inline void TargetState::set_last_banners(int index, ::google::protobuf::int32 value) {
  last_banners_.Set(index, value);
  // @@protoc_insertion_point(field_set:recostream.pb.TargetState.last_banners)
}
inline void TargetState::add_last_banners(::google::protobuf::int32 value) {
  last_banners_.Add(value);
  // @@protoc_insertion_point(field_add:recostream.pb.TargetState.last_banners)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TargetState::last_banners() const {
  // @@protoc_insertion_point(field_list:recostream.pb.TargetState.last_banners)
  return last_banners_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TargetState::mutable_last_banners() {
  // @@protoc_insertion_point(field_mutable_list:recostream.pb.TargetState.last_banners)
  return &last_banners_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TargetSources

// map<string, .recostream.pb.TargetState> states = 1;
inline int TargetSources::states_size() const {
  return states_.size();
}
inline void TargetSources::clear_states() {
  states_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::recostream::pb::TargetState >&
TargetSources::states() const {
  // @@protoc_insertion_point(field_map:recostream.pb.TargetSources.states)
  return states_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::recostream::pb::TargetState >*
TargetSources::mutable_states() {
  // @@protoc_insertion_point(field_mutable_map:recostream.pb.TargetSources.states)
  return states_.MutableMap();
}

// -------------------------------------------------------------------

// ResultsPageState_BlockState

// optional string name = 1;
inline bool ResultsPageState_BlockState::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultsPageState_BlockState::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultsPageState_BlockState::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultsPageState_BlockState::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ResultsPageState_BlockState::name() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultsPageState.BlockState.name)
  return name_.GetNoArena();
}
inline void ResultsPageState_BlockState::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.ResultsPageState.BlockState.name)
}
#if LANG_CXX11
inline void ResultsPageState_BlockState::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.ResultsPageState.BlockState.name)
}
#endif
inline void ResultsPageState_BlockState::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.ResultsPageState.BlockState.name)
}
inline void ResultsPageState_BlockState::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.ResultsPageState.BlockState.name)
}
inline ::std::string* ResultsPageState_BlockState::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:recostream.pb.ResultsPageState.BlockState.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResultsPageState_BlockState::release_name() {
  // @@protoc_insertion_point(field_release:recostream.pb.ResultsPageState.BlockState.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResultsPageState_BlockState::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.ResultsPageState.BlockState.name)
}

// optional int32 used_positions = 2;
inline bool ResultsPageState_BlockState::has_used_positions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResultsPageState_BlockState::set_has_used_positions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResultsPageState_BlockState::clear_has_used_positions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResultsPageState_BlockState::clear_used_positions() {
  used_positions_ = 0;
  clear_has_used_positions();
}
inline ::google::protobuf::int32 ResultsPageState_BlockState::used_positions() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultsPageState.BlockState.used_positions)
  return used_positions_;
}
inline void ResultsPageState_BlockState::set_used_positions(::google::protobuf::int32 value) {
  set_has_used_positions();
  used_positions_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultsPageState.BlockState.used_positions)
}

// optional int32 block_layout_position = 3;
inline bool ResultsPageState_BlockState::has_block_layout_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResultsPageState_BlockState::set_has_block_layout_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResultsPageState_BlockState::clear_has_block_layout_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResultsPageState_BlockState::clear_block_layout_position() {
  block_layout_position_ = 0;
  clear_has_block_layout_position();
}
inline ::google::protobuf::int32 ResultsPageState_BlockState::block_layout_position() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultsPageState.BlockState.block_layout_position)
  return block_layout_position_;
}
inline void ResultsPageState_BlockState::set_block_layout_position(::google::protobuf::int32 value) {
  set_has_block_layout_position();
  block_layout_position_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultsPageState.BlockState.block_layout_position)
}

// -------------------------------------------------------------------

// ResultsPageState

// optional int32 layout_position = 1;
inline bool ResultsPageState::has_layout_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultsPageState::set_has_layout_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultsPageState::clear_has_layout_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultsPageState::clear_layout_position() {
  layout_position_ = 0;
  clear_has_layout_position();
}
inline ::google::protobuf::int32 ResultsPageState::layout_position() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultsPageState.layout_position)
  return layout_position_;
}
inline void ResultsPageState::set_layout_position(::google::protobuf::int32 value) {
  set_has_layout_position();
  layout_position_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.ResultsPageState.layout_position)
}

// repeated .recostream.pb.ResultsPageState.BlockState blocks = 3;
inline int ResultsPageState::blocks_size() const {
  return blocks_.size();
}
inline void ResultsPageState::clear_blocks() {
  blocks_.Clear();
}
inline const ::recostream::pb::ResultsPageState_BlockState& ResultsPageState::blocks(int index) const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultsPageState.blocks)
  return blocks_.Get(index);
}
inline ::recostream::pb::ResultsPageState_BlockState* ResultsPageState::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:recostream.pb.ResultsPageState.blocks)
  return blocks_.Mutable(index);
}
inline ::recostream::pb::ResultsPageState_BlockState* ResultsPageState::add_blocks() {
  // @@protoc_insertion_point(field_add:recostream.pb.ResultsPageState.blocks)
  return blocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::recostream::pb::ResultsPageState_BlockState >*
ResultsPageState::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:recostream.pb.ResultsPageState.blocks)
  return &blocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::recostream::pb::ResultsPageState_BlockState >&
ResultsPageState::blocks() const {
  // @@protoc_insertion_point(field_list:recostream.pb.ResultsPageState.blocks)
  return blocks_;
}

// repeated string terminated_providers = 5;
inline int ResultsPageState::terminated_providers_size() const {
  return terminated_providers_.size();
}
inline void ResultsPageState::clear_terminated_providers() {
  terminated_providers_.Clear();
}
inline const ::std::string& ResultsPageState::terminated_providers(int index) const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultsPageState.terminated_providers)
  return terminated_providers_.Get(index);
}
inline ::std::string* ResultsPageState::mutable_terminated_providers(int index) {
  // @@protoc_insertion_point(field_mutable:recostream.pb.ResultsPageState.terminated_providers)
  return terminated_providers_.Mutable(index);
}
inline void ResultsPageState::set_terminated_providers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:recostream.pb.ResultsPageState.terminated_providers)
  terminated_providers_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ResultsPageState::set_terminated_providers(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:recostream.pb.ResultsPageState.terminated_providers)
  terminated_providers_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ResultsPageState::set_terminated_providers(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  terminated_providers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:recostream.pb.ResultsPageState.terminated_providers)
}
inline void ResultsPageState::set_terminated_providers(int index, const char* value, size_t size) {
  terminated_providers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.ResultsPageState.terminated_providers)
}
inline ::std::string* ResultsPageState::add_terminated_providers() {
  // @@protoc_insertion_point(field_add_mutable:recostream.pb.ResultsPageState.terminated_providers)
  return terminated_providers_.Add();
}
inline void ResultsPageState::add_terminated_providers(const ::std::string& value) {
  terminated_providers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:recostream.pb.ResultsPageState.terminated_providers)
}
#if LANG_CXX11
inline void ResultsPageState::add_terminated_providers(::std::string&& value) {
  terminated_providers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:recostream.pb.ResultsPageState.terminated_providers)
}
#endif
inline void ResultsPageState::add_terminated_providers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  terminated_providers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:recostream.pb.ResultsPageState.terminated_providers)
}
inline void ResultsPageState::add_terminated_providers(const char* value, size_t size) {
  terminated_providers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:recostream.pb.ResultsPageState.terminated_providers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResultsPageState::terminated_providers() const {
  // @@protoc_insertion_point(field_list:recostream.pb.ResultsPageState.terminated_providers)
  return terminated_providers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResultsPageState::mutable_terminated_providers() {
  // @@protoc_insertion_point(field_mutable_list:recostream.pb.ResultsPageState.terminated_providers)
  return &terminated_providers_;
}

// repeated uint32 lenta = 6;
inline int ResultsPageState::lenta_size() const {
  return lenta_.size();
}
inline void ResultsPageState::clear_lenta() {
  lenta_.Clear();
}
inline ::google::protobuf::uint32 ResultsPageState::lenta(int index) const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultsPageState.lenta)
  return lenta_.Get(index);
}
inline void ResultsPageState::set_lenta(int index, ::google::protobuf::uint32 value) {
  lenta_.Set(index, value);
  // @@protoc_insertion_point(field_set:recostream.pb.ResultsPageState.lenta)
}
inline void ResultsPageState::add_lenta(::google::protobuf::uint32 value) {
  lenta_.Add(value);
  // @@protoc_insertion_point(field_add:recostream.pb.ResultsPageState.lenta)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ResultsPageState::lenta() const {
  // @@protoc_insertion_point(field_list:recostream.pb.ResultsPageState.lenta)
  return lenta_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ResultsPageState::mutable_lenta() {
  // @@protoc_insertion_point(field_mutable_list:recostream.pb.ResultsPageState.lenta)
  return &lenta_;
}

// repeated int64 document_hashes = 7;
inline int ResultsPageState::document_hashes_size() const {
  return document_hashes_.size();
}
inline void ResultsPageState::clear_document_hashes() {
  document_hashes_.Clear();
}
inline ::google::protobuf::int64 ResultsPageState::document_hashes(int index) const {
  // @@protoc_insertion_point(field_get:recostream.pb.ResultsPageState.document_hashes)
  return document_hashes_.Get(index);
}
inline void ResultsPageState::set_document_hashes(int index, ::google::protobuf::int64 value) {
  document_hashes_.Set(index, value);
  // @@protoc_insertion_point(field_set:recostream.pb.ResultsPageState.document_hashes)
}
inline void ResultsPageState::add_document_hashes(::google::protobuf::int64 value) {
  document_hashes_.Add(value);
  // @@protoc_insertion_point(field_add:recostream.pb.ResultsPageState.document_hashes)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ResultsPageState::document_hashes() const {
  // @@protoc_insertion_point(field_list:recostream.pb.ResultsPageState.document_hashes)
  return document_hashes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ResultsPageState::mutable_document_hashes() {
  // @@protoc_insertion_point(field_mutable_list:recostream.pb.ResultsPageState.document_hashes)
  return &document_hashes_;
}

// -------------------------------------------------------------------

// PPNState

// optional string results_hash = 1;
inline bool PPNState::has_results_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PPNState::set_has_results_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PPNState::clear_has_results_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PPNState::clear_results_hash() {
  results_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_results_hash();
}
inline const ::std::string& PPNState::results_hash() const {
  // @@protoc_insertion_point(field_get:recostream.pb.PPNState.results_hash)
  return results_hash_.GetNoArena();
}
inline void PPNState::set_results_hash(const ::std::string& value) {
  set_has_results_hash();
  results_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.PPNState.results_hash)
}
#if LANG_CXX11
inline void PPNState::set_results_hash(::std::string&& value) {
  set_has_results_hash();
  results_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.PPNState.results_hash)
}
#endif
inline void PPNState::set_results_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_results_hash();
  results_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.PPNState.results_hash)
}
inline void PPNState::set_results_hash(const char* value, size_t size) {
  set_has_results_hash();
  results_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.PPNState.results_hash)
}
inline ::std::string* PPNState::mutable_results_hash() {
  set_has_results_hash();
  // @@protoc_insertion_point(field_mutable:recostream.pb.PPNState.results_hash)
  return results_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PPNState::release_results_hash() {
  // @@protoc_insertion_point(field_release:recostream.pb.PPNState.results_hash)
  clear_has_results_hash();
  return results_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PPNState::set_allocated_results_hash(::std::string* results_hash) {
  if (results_hash != NULL) {
    set_has_results_hash();
  } else {
    clear_has_results_hash();
  }
  results_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), results_hash);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.PPNState.results_hash)
}

// optional int32 position = 2;
inline bool PPNState::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PPNState::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PPNState::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PPNState::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 PPNState::position() const {
  // @@protoc_insertion_point(field_get:recostream.pb.PPNState.position)
  return position_;
}
inline void PPNState::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.PPNState.position)
}

// optional int64 creation_ts = 3 [deprecated = true];
inline bool PPNState::has_creation_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PPNState::set_has_creation_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PPNState::clear_has_creation_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PPNState::clear_creation_ts() {
  creation_ts_ = GOOGLE_LONGLONG(0);
  clear_has_creation_ts();
}
inline ::google::protobuf::int64 PPNState::creation_ts() const {
  // @@protoc_insertion_point(field_get:recostream.pb.PPNState.creation_ts)
  return creation_ts_;
}
inline void PPNState::set_creation_ts(::google::protobuf::int64 value) {
  set_has_creation_ts();
  creation_ts_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.PPNState.creation_ts)
}

// -------------------------------------------------------------------

// SubscriptionState_SubscriptionInfo

// required uint32 cnt = 1;
inline bool SubscriptionState_SubscriptionInfo::has_cnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubscriptionState_SubscriptionInfo::set_has_cnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubscriptionState_SubscriptionInfo::clear_has_cnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubscriptionState_SubscriptionInfo::clear_cnt() {
  cnt_ = 0u;
  clear_has_cnt();
}
inline ::google::protobuf::uint32 SubscriptionState_SubscriptionInfo::cnt() const {
  // @@protoc_insertion_point(field_get:recostream.pb.SubscriptionState.SubscriptionInfo.cnt)
  return cnt_;
}
inline void SubscriptionState_SubscriptionInfo::set_cnt(::google::protobuf::uint32 value) {
  set_has_cnt();
  cnt_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.SubscriptionState.SubscriptionInfo.cnt)
}

// optional int64 last_ts = 2;
inline bool SubscriptionState_SubscriptionInfo::has_last_ts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscriptionState_SubscriptionInfo::set_has_last_ts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscriptionState_SubscriptionInfo::clear_has_last_ts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscriptionState_SubscriptionInfo::clear_last_ts() {
  last_ts_ = GOOGLE_LONGLONG(0);
  clear_has_last_ts();
}
inline ::google::protobuf::int64 SubscriptionState_SubscriptionInfo::last_ts() const {
  // @@protoc_insertion_point(field_get:recostream.pb.SubscriptionState.SubscriptionInfo.last_ts)
  return last_ts_;
}
inline void SubscriptionState_SubscriptionInfo::set_last_ts(::google::protobuf::int64 value) {
  set_has_last_ts();
  last_ts_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.SubscriptionState.SubscriptionInfo.last_ts)
}

// -------------------------------------------------------------------

// SubscriptionState

// optional string block_name = 1;
inline bool SubscriptionState::has_block_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscriptionState::set_has_block_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscriptionState::clear_has_block_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscriptionState::clear_block_name() {
  block_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_block_name();
}
inline const ::std::string& SubscriptionState::block_name() const {
  // @@protoc_insertion_point(field_get:recostream.pb.SubscriptionState.block_name)
  return block_name_.GetNoArena();
}
inline void SubscriptionState::set_block_name(const ::std::string& value) {
  set_has_block_name();
  block_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.SubscriptionState.block_name)
}
#if LANG_CXX11
inline void SubscriptionState::set_block_name(::std::string&& value) {
  set_has_block_name();
  block_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.SubscriptionState.block_name)
}
#endif
inline void SubscriptionState::set_block_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_block_name();
  block_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.SubscriptionState.block_name)
}
inline void SubscriptionState::set_block_name(const char* value, size_t size) {
  set_has_block_name();
  block_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.SubscriptionState.block_name)
}
inline ::std::string* SubscriptionState::mutable_block_name() {
  set_has_block_name();
  // @@protoc_insertion_point(field_mutable:recostream.pb.SubscriptionState.block_name)
  return block_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscriptionState::release_block_name() {
  // @@protoc_insertion_point(field_release:recostream.pb.SubscriptionState.block_name)
  clear_has_block_name();
  return block_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscriptionState::set_allocated_block_name(::std::string* block_name) {
  if (block_name != NULL) {
    set_has_block_name();
  } else {
    clear_has_block_name();
  }
  block_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), block_name);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.SubscriptionState.block_name)
}

// optional bool show_category_subscription = 3;
inline bool SubscriptionState::has_show_category_subscription() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubscriptionState::set_has_show_category_subscription() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubscriptionState::clear_has_show_category_subscription() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubscriptionState::clear_show_category_subscription() {
  show_category_subscription_ = false;
  clear_has_show_category_subscription();
}
inline bool SubscriptionState::show_category_subscription() const {
  // @@protoc_insertion_point(field_get:recostream.pb.SubscriptionState.show_category_subscription)
  return show_category_subscription_;
}
inline void SubscriptionState::set_show_category_subscription(bool value) {
  set_has_show_category_subscription();
  show_category_subscription_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.SubscriptionState.show_category_subscription)
}

// optional bool show_cold_sources_subscription = 4;
inline bool SubscriptionState::has_show_cold_sources_subscription() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SubscriptionState::set_has_show_cold_sources_subscription() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SubscriptionState::clear_has_show_cold_sources_subscription() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SubscriptionState::clear_show_cold_sources_subscription() {
  show_cold_sources_subscription_ = false;
  clear_has_show_cold_sources_subscription();
}
inline bool SubscriptionState::show_cold_sources_subscription() const {
  // @@protoc_insertion_point(field_get:recostream.pb.SubscriptionState.show_cold_sources_subscription)
  return show_cold_sources_subscription_;
}
inline void SubscriptionState::set_show_cold_sources_subscription(bool value) {
  set_has_show_cold_sources_subscription();
  show_cold_sources_subscription_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.SubscriptionState.show_cold_sources_subscription)
}

// repeated int64 user_source_subscriptions = 5;
inline int SubscriptionState::user_source_subscriptions_size() const {
  return user_source_subscriptions_.size();
}
inline void SubscriptionState::clear_user_source_subscriptions() {
  user_source_subscriptions_.Clear();
}
inline ::google::protobuf::int64 SubscriptionState::user_source_subscriptions(int index) const {
  // @@protoc_insertion_point(field_get:recostream.pb.SubscriptionState.user_source_subscriptions)
  return user_source_subscriptions_.Get(index);
}
inline void SubscriptionState::set_user_source_subscriptions(int index, ::google::protobuf::int64 value) {
  user_source_subscriptions_.Set(index, value);
  // @@protoc_insertion_point(field_set:recostream.pb.SubscriptionState.user_source_subscriptions)
}
inline void SubscriptionState::add_user_source_subscriptions(::google::protobuf::int64 value) {
  user_source_subscriptions_.Add(value);
  // @@protoc_insertion_point(field_add:recostream.pb.SubscriptionState.user_source_subscriptions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SubscriptionState::user_source_subscriptions() const {
  // @@protoc_insertion_point(field_list:recostream.pb.SubscriptionState.user_source_subscriptions)
  return user_source_subscriptions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SubscriptionState::mutable_user_source_subscriptions() {
  // @@protoc_insertion_point(field_mutable_list:recostream.pb.SubscriptionState.user_source_subscriptions)
  return &user_source_subscriptions_;
}

// optional .recostream.pb.SubscriptionState.SubscriptionInfo category_subscription = 6;
inline bool SubscriptionState::has_category_subscription() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubscriptionState::set_has_category_subscription() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubscriptionState::clear_has_category_subscription() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubscriptionState::clear_category_subscription() {
  if (category_subscription_ != NULL) category_subscription_->::recostream::pb::SubscriptionState_SubscriptionInfo::Clear();
  clear_has_category_subscription();
}
inline const ::recostream::pb::SubscriptionState_SubscriptionInfo& SubscriptionState::category_subscription() const {
  const ::recostream::pb::SubscriptionState_SubscriptionInfo* p = category_subscription_;
  // @@protoc_insertion_point(field_get:recostream.pb.SubscriptionState.category_subscription)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::SubscriptionState_SubscriptionInfo*>(
      &::recostream::pb::_SubscriptionState_SubscriptionInfo_default_instance_);
}
inline ::recostream::pb::SubscriptionState_SubscriptionInfo* SubscriptionState::mutable_category_subscription() {
  set_has_category_subscription();
  if (category_subscription_ == NULL) {
    category_subscription_ = new ::recostream::pb::SubscriptionState_SubscriptionInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.SubscriptionState.category_subscription)
  return category_subscription_;
}
inline ::recostream::pb::SubscriptionState_SubscriptionInfo* SubscriptionState::release_category_subscription() {
  // @@protoc_insertion_point(field_release:recostream.pb.SubscriptionState.category_subscription)
  clear_has_category_subscription();
  ::recostream::pb::SubscriptionState_SubscriptionInfo* temp = category_subscription_;
  category_subscription_ = NULL;
  return temp;
}
inline void SubscriptionState::set_allocated_category_subscription(::recostream::pb::SubscriptionState_SubscriptionInfo* category_subscription) {
  delete category_subscription_;
  category_subscription_ = category_subscription;
  if (category_subscription) {
    set_has_category_subscription();
  } else {
    clear_has_category_subscription();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.SubscriptionState.category_subscription)
}

// optional .recostream.pb.SubscriptionState.SubscriptionInfo cold_sources_subscription = 7;
inline bool SubscriptionState::has_cold_sources_subscription() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubscriptionState::set_has_cold_sources_subscription() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubscriptionState::clear_has_cold_sources_subscription() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubscriptionState::clear_cold_sources_subscription() {
  if (cold_sources_subscription_ != NULL) cold_sources_subscription_->::recostream::pb::SubscriptionState_SubscriptionInfo::Clear();
  clear_has_cold_sources_subscription();
}
inline const ::recostream::pb::SubscriptionState_SubscriptionInfo& SubscriptionState::cold_sources_subscription() const {
  const ::recostream::pb::SubscriptionState_SubscriptionInfo* p = cold_sources_subscription_;
  // @@protoc_insertion_point(field_get:recostream.pb.SubscriptionState.cold_sources_subscription)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::SubscriptionState_SubscriptionInfo*>(
      &::recostream::pb::_SubscriptionState_SubscriptionInfo_default_instance_);
}
inline ::recostream::pb::SubscriptionState_SubscriptionInfo* SubscriptionState::mutable_cold_sources_subscription() {
  set_has_cold_sources_subscription();
  if (cold_sources_subscription_ == NULL) {
    cold_sources_subscription_ = new ::recostream::pb::SubscriptionState_SubscriptionInfo;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.SubscriptionState.cold_sources_subscription)
  return cold_sources_subscription_;
}
inline ::recostream::pb::SubscriptionState_SubscriptionInfo* SubscriptionState::release_cold_sources_subscription() {
  // @@protoc_insertion_point(field_release:recostream.pb.SubscriptionState.cold_sources_subscription)
  clear_has_cold_sources_subscription();
  ::recostream::pb::SubscriptionState_SubscriptionInfo* temp = cold_sources_subscription_;
  cold_sources_subscription_ = NULL;
  return temp;
}
inline void SubscriptionState::set_allocated_cold_sources_subscription(::recostream::pb::SubscriptionState_SubscriptionInfo* cold_sources_subscription) {
  delete cold_sources_subscription_;
  cold_sources_subscription_ = cold_sources_subscription;
  if (cold_sources_subscription) {
    set_has_cold_sources_subscription();
  } else {
    clear_has_cold_sources_subscription();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.SubscriptionState.cold_sources_subscription)
}

// -------------------------------------------------------------------

// RecoSessionState

// optional .recostream.pb.LoginState login_state = 1;
inline bool RecoSessionState::has_login_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecoSessionState::set_has_login_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecoSessionState::clear_has_login_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecoSessionState::clear_login_state() {
  if (login_state_ != NULL) login_state_->::recostream::pb::LoginState::Clear();
  clear_has_login_state();
}
inline const ::recostream::pb::LoginState& RecoSessionState::login_state() const {
  const ::recostream::pb::LoginState* p = login_state_;
  // @@protoc_insertion_point(field_get:recostream.pb.RecoSessionState.login_state)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::LoginState*>(
      &::recostream::pb::_LoginState_default_instance_);
}
inline ::recostream::pb::LoginState* RecoSessionState::mutable_login_state() {
  set_has_login_state();
  if (login_state_ == NULL) {
    login_state_ = new ::recostream::pb::LoginState;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.RecoSessionState.login_state)
  return login_state_;
}
inline ::recostream::pb::LoginState* RecoSessionState::release_login_state() {
  // @@protoc_insertion_point(field_release:recostream.pb.RecoSessionState.login_state)
  clear_has_login_state();
  ::recostream::pb::LoginState* temp = login_state_;
  login_state_ = NULL;
  return temp;
}
inline void RecoSessionState::set_allocated_login_state(::recostream::pb::LoginState* login_state) {
  delete login_state_;
  login_state_ = login_state;
  if (login_state) {
    set_has_login_state();
  } else {
    clear_has_login_state();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.RecoSessionState.login_state)
}

// optional .recostream.pb.ResultsPageState results_page_state = 3;
inline bool RecoSessionState::has_results_page_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecoSessionState::set_has_results_page_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecoSessionState::clear_has_results_page_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecoSessionState::clear_results_page_state() {
  if (results_page_state_ != NULL) results_page_state_->::recostream::pb::ResultsPageState::Clear();
  clear_has_results_page_state();
}
inline const ::recostream::pb::ResultsPageState& RecoSessionState::results_page_state() const {
  const ::recostream::pb::ResultsPageState* p = results_page_state_;
  // @@protoc_insertion_point(field_get:recostream.pb.RecoSessionState.results_page_state)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::ResultsPageState*>(
      &::recostream::pb::_ResultsPageState_default_instance_);
}
inline ::recostream::pb::ResultsPageState* RecoSessionState::mutable_results_page_state() {
  set_has_results_page_state();
  if (results_page_state_ == NULL) {
    results_page_state_ = new ::recostream::pb::ResultsPageState;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.RecoSessionState.results_page_state)
  return results_page_state_;
}
inline ::recostream::pb::ResultsPageState* RecoSessionState::release_results_page_state() {
  // @@protoc_insertion_point(field_release:recostream.pb.RecoSessionState.results_page_state)
  clear_has_results_page_state();
  ::recostream::pb::ResultsPageState* temp = results_page_state_;
  results_page_state_ = NULL;
  return temp;
}
inline void RecoSessionState::set_allocated_results_page_state(::recostream::pb::ResultsPageState* results_page_state) {
  delete results_page_state_;
  results_page_state_ = results_page_state;
  if (results_page_state) {
    set_has_results_page_state();
  } else {
    clear_has_results_page_state();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.RecoSessionState.results_page_state)
}

// optional .recostream.pb.CosmoSources cosmo_sources = 4;
inline bool RecoSessionState::has_cosmo_sources() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecoSessionState::set_has_cosmo_sources() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecoSessionState::clear_has_cosmo_sources() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecoSessionState::clear_cosmo_sources() {
  if (cosmo_sources_ != NULL) cosmo_sources_->::recostream::pb::CosmoSources::Clear();
  clear_has_cosmo_sources();
}
inline const ::recostream::pb::CosmoSources& RecoSessionState::cosmo_sources() const {
  const ::recostream::pb::CosmoSources* p = cosmo_sources_;
  // @@protoc_insertion_point(field_get:recostream.pb.RecoSessionState.cosmo_sources)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::CosmoSources*>(
      &::recostream::pb::_CosmoSources_default_instance_);
}
inline ::recostream::pb::CosmoSources* RecoSessionState::mutable_cosmo_sources() {
  set_has_cosmo_sources();
  if (cosmo_sources_ == NULL) {
    cosmo_sources_ = new ::recostream::pb::CosmoSources;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.RecoSessionState.cosmo_sources)
  return cosmo_sources_;
}
inline ::recostream::pb::CosmoSources* RecoSessionState::release_cosmo_sources() {
  // @@protoc_insertion_point(field_release:recostream.pb.RecoSessionState.cosmo_sources)
  clear_has_cosmo_sources();
  ::recostream::pb::CosmoSources* temp = cosmo_sources_;
  cosmo_sources_ = NULL;
  return temp;
}
inline void RecoSessionState::set_allocated_cosmo_sources(::recostream::pb::CosmoSources* cosmo_sources) {
  delete cosmo_sources_;
  cosmo_sources_ = cosmo_sources;
  if (cosmo_sources) {
    set_has_cosmo_sources();
  } else {
    clear_has_cosmo_sources();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.RecoSessionState.cosmo_sources)
}

// optional .recostream.pb.PPNState ppn_state = 5;
inline bool RecoSessionState::has_ppn_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecoSessionState::set_has_ppn_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecoSessionState::clear_has_ppn_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecoSessionState::clear_ppn_state() {
  if (ppn_state_ != NULL) ppn_state_->::recostream::pb::PPNState::Clear();
  clear_has_ppn_state();
}
inline const ::recostream::pb::PPNState& RecoSessionState::ppn_state() const {
  const ::recostream::pb::PPNState* p = ppn_state_;
  // @@protoc_insertion_point(field_get:recostream.pb.RecoSessionState.ppn_state)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::PPNState*>(
      &::recostream::pb::_PPNState_default_instance_);
}
inline ::recostream::pb::PPNState* RecoSessionState::mutable_ppn_state() {
  set_has_ppn_state();
  if (ppn_state_ == NULL) {
    ppn_state_ = new ::recostream::pb::PPNState;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.RecoSessionState.ppn_state)
  return ppn_state_;
}
inline ::recostream::pb::PPNState* RecoSessionState::release_ppn_state() {
  // @@protoc_insertion_point(field_release:recostream.pb.RecoSessionState.ppn_state)
  clear_has_ppn_state();
  ::recostream::pb::PPNState* temp = ppn_state_;
  ppn_state_ = NULL;
  return temp;
}
inline void RecoSessionState::set_allocated_ppn_state(::recostream::pb::PPNState* ppn_state) {
  delete ppn_state_;
  ppn_state_ = ppn_state;
  if (ppn_state) {
    set_has_ppn_state();
  } else {
    clear_has_ppn_state();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.RecoSessionState.ppn_state)
}

// optional .recostream.pb.TargetSources target_sources = 6;
inline bool RecoSessionState::has_target_sources() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecoSessionState::set_has_target_sources() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecoSessionState::clear_has_target_sources() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecoSessionState::clear_target_sources() {
  if (target_sources_ != NULL) target_sources_->::recostream::pb::TargetSources::Clear();
  clear_has_target_sources();
}
inline const ::recostream::pb::TargetSources& RecoSessionState::target_sources() const {
  const ::recostream::pb::TargetSources* p = target_sources_;
  // @@protoc_insertion_point(field_get:recostream.pb.RecoSessionState.target_sources)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::TargetSources*>(
      &::recostream::pb::_TargetSources_default_instance_);
}
inline ::recostream::pb::TargetSources* RecoSessionState::mutable_target_sources() {
  set_has_target_sources();
  if (target_sources_ == NULL) {
    target_sources_ = new ::recostream::pb::TargetSources;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.RecoSessionState.target_sources)
  return target_sources_;
}
inline ::recostream::pb::TargetSources* RecoSessionState::release_target_sources() {
  // @@protoc_insertion_point(field_release:recostream.pb.RecoSessionState.target_sources)
  clear_has_target_sources();
  ::recostream::pb::TargetSources* temp = target_sources_;
  target_sources_ = NULL;
  return temp;
}
inline void RecoSessionState::set_allocated_target_sources(::recostream::pb::TargetSources* target_sources) {
  delete target_sources_;
  target_sources_ = target_sources;
  if (target_sources) {
    set_has_target_sources();
  } else {
    clear_has_target_sources();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.RecoSessionState.target_sources)
}

// optional .recostream.pb.SubscriptionState subscription_state = 7;
inline bool RecoSessionState::has_subscription_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecoSessionState::set_has_subscription_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RecoSessionState::clear_has_subscription_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RecoSessionState::clear_subscription_state() {
  if (subscription_state_ != NULL) subscription_state_->::recostream::pb::SubscriptionState::Clear();
  clear_has_subscription_state();
}
inline const ::recostream::pb::SubscriptionState& RecoSessionState::subscription_state() const {
  const ::recostream::pb::SubscriptionState* p = subscription_state_;
  // @@protoc_insertion_point(field_get:recostream.pb.RecoSessionState.subscription_state)
  return p != NULL ? *p : *reinterpret_cast<const ::recostream::pb::SubscriptionState*>(
      &::recostream::pb::_SubscriptionState_default_instance_);
}
inline ::recostream::pb::SubscriptionState* RecoSessionState::mutable_subscription_state() {
  set_has_subscription_state();
  if (subscription_state_ == NULL) {
    subscription_state_ = new ::recostream::pb::SubscriptionState;
  }
  // @@protoc_insertion_point(field_mutable:recostream.pb.RecoSessionState.subscription_state)
  return subscription_state_;
}
inline ::recostream::pb::SubscriptionState* RecoSessionState::release_subscription_state() {
  // @@protoc_insertion_point(field_release:recostream.pb.RecoSessionState.subscription_state)
  clear_has_subscription_state();
  ::recostream::pb::SubscriptionState* temp = subscription_state_;
  subscription_state_ = NULL;
  return temp;
}
inline void RecoSessionState::set_allocated_subscription_state(::recostream::pb::SubscriptionState* subscription_state) {
  delete subscription_state_;
  subscription_state_ = subscription_state;
  if (subscription_state) {
    set_has_subscription_state();
  } else {
    clear_has_subscription_state();
  }
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.RecoSessionState.subscription_state)
}

// optional bool cold_lenta = 8;
inline bool RecoSessionState::has_cold_lenta() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RecoSessionState::set_has_cold_lenta() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RecoSessionState::clear_has_cold_lenta() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RecoSessionState::clear_cold_lenta() {
  cold_lenta_ = false;
  clear_has_cold_lenta();
}
inline bool RecoSessionState::cold_lenta() const {
  // @@protoc_insertion_point(field_get:recostream.pb.RecoSessionState.cold_lenta)
  return cold_lenta_;
}
inline void RecoSessionState::set_cold_lenta(bool value) {
  set_has_cold_lenta();
  cold_lenta_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.RecoSessionState.cold_lenta)
}

// optional int64 creation_ts = 100;
inline bool RecoSessionState::has_creation_ts() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RecoSessionState::set_has_creation_ts() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RecoSessionState::clear_has_creation_ts() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RecoSessionState::clear_creation_ts() {
  creation_ts_ = GOOGLE_LONGLONG(0);
  clear_has_creation_ts();
}
inline ::google::protobuf::int64 RecoSessionState::creation_ts() const {
  // @@protoc_insertion_point(field_get:recostream.pb.RecoSessionState.creation_ts)
  return creation_ts_;
}
inline void RecoSessionState::set_creation_ts(::google::protobuf::int64 value) {
  set_has_creation_ts();
  creation_ts_ = value;
  // @@protoc_insertion_point(field_set:recostream.pb.RecoSessionState.creation_ts)
}

// -------------------------------------------------------------------

// ProfileSettingField

// required string key = 1;
inline bool ProfileSettingField::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProfileSettingField::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProfileSettingField::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProfileSettingField::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& ProfileSettingField::key() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ProfileSettingField.key)
  return key_.GetNoArena();
}
inline void ProfileSettingField::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.ProfileSettingField.key)
}
#if LANG_CXX11
inline void ProfileSettingField::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.ProfileSettingField.key)
}
#endif
inline void ProfileSettingField::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.ProfileSettingField.key)
}
inline void ProfileSettingField::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.ProfileSettingField.key)
}
inline ::std::string* ProfileSettingField::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:recostream.pb.ProfileSettingField.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProfileSettingField::release_key() {
  // @@protoc_insertion_point(field_release:recostream.pb.ProfileSettingField.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProfileSettingField::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.ProfileSettingField.key)
}

// required string value = 2;
inline bool ProfileSettingField::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProfileSettingField::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProfileSettingField::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProfileSettingField::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& ProfileSettingField::value() const {
  // @@protoc_insertion_point(field_get:recostream.pb.ProfileSettingField.value)
  return value_.GetNoArena();
}
inline void ProfileSettingField::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:recostream.pb.ProfileSettingField.value)
}
#if LANG_CXX11
inline void ProfileSettingField::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:recostream.pb.ProfileSettingField.value)
}
#endif
inline void ProfileSettingField::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:recostream.pb.ProfileSettingField.value)
}
inline void ProfileSettingField::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:recostream.pb.ProfileSettingField.value)
}
inline ::std::string* ProfileSettingField::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:recostream.pb.ProfileSettingField.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProfileSettingField::release_value() {
  // @@protoc_insertion_point(field_release:recostream.pb.ProfileSettingField.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProfileSettingField::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:recostream.pb.ProfileSettingField.value)
}

// -------------------------------------------------------------------

// ProfileSettings

// repeated .recostream.pb.ProfileSettingField settings = 1;
inline int ProfileSettings::settings_size() const {
  return settings_.size();
}
inline void ProfileSettings::clear_settings() {
  settings_.Clear();
}
inline const ::recostream::pb::ProfileSettingField& ProfileSettings::settings(int index) const {
  // @@protoc_insertion_point(field_get:recostream.pb.ProfileSettings.settings)
  return settings_.Get(index);
}
inline ::recostream::pb::ProfileSettingField* ProfileSettings::mutable_settings(int index) {
  // @@protoc_insertion_point(field_mutable:recostream.pb.ProfileSettings.settings)
  return settings_.Mutable(index);
}
inline ::recostream::pb::ProfileSettingField* ProfileSettings::add_settings() {
  // @@protoc_insertion_point(field_add:recostream.pb.ProfileSettings.settings)
  return settings_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::recostream::pb::ProfileSettingField >*
ProfileSettings::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_list:recostream.pb.ProfileSettings.settings)
  return &settings_;
}
inline const ::google::protobuf::RepeatedPtrField< ::recostream::pb::ProfileSettingField >&
ProfileSettings::settings() const {
  // @@protoc_insertion_point(field_list:recostream.pb.ProfileSettings.settings)
  return settings_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace pb
}  // namespace recostream

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_recostream_5fsession_2eproto__INCLUDED
