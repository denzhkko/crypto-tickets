// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spellchecker.proto

#ifndef PROTOBUF_spellchecker_2eproto__INCLUDED
#define PROTOBUF_spellchecker_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace gogo {
namespace chell_specker {
class ConfidencePack;
class ConfidencePackDefaultTypeInternal;
extern ConfidencePackDefaultTypeInternal _ConfidencePack_default_instance_;
class FixConfidencePack;
class FixConfidencePackDefaultTypeInternal;
extern FixConfidencePackDefaultTypeInternal _FixConfidencePack_default_instance_;
class SpcComment;
class SpcCommentDefaultTypeInternal;
extern SpcCommentDefaultTypeInternal _SpcComment_default_instance_;
class SpcCommentItem;
class SpcCommentItemDefaultTypeInternal;
extern SpcCommentItemDefaultTypeInternal _SpcCommentItem_default_instance_;
class SpcInterleavingInfo;
class SpcInterleavingInfoDefaultTypeInternal;
extern SpcInterleavingInfoDefaultTypeInternal _SpcInterleavingInfo_default_instance_;
class SpcReply;
class SpcReplyDefaultTypeInternal;
extern SpcReplyDefaultTypeInternal _SpcReply_default_instance_;
class SpcResponse;
class SpcResponseDefaultTypeInternal;
extern SpcResponseDefaultTypeInternal _SpcResponse_default_instance_;
class SpcWnfInfo;
class SpcWnfInfoDefaultTypeInternal;
extern SpcWnfInfoDefaultTypeInternal _SpcWnfInfo_default_instance_;
class VersionInfo;
class VersionInfoDefaultTypeInternal;
extern VersionInfoDefaultTypeInternal _VersionInfo_default_instance_;
}  // namespace chell_specker
}  // namespace gogo

namespace gogo {
namespace chell_specker {

namespace protobuf_spellchecker_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_spellchecker_2eproto

// ===================================================================

class VersionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.chell_specker.VersionInfo) */ {
 public:
  VersionInfo();
  virtual ~VersionInfo();

  VersionInfo(const VersionInfo& from);

  inline VersionInfo& operator=(const VersionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VersionInfo(VersionInfo&& from) noexcept
    : VersionInfo() {
    *this = ::std::move(from);
  }

  inline VersionInfo& operator=(VersionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionInfo& default_instance();

  static inline const VersionInfo* internal_default_instance() {
    return reinterpret_cast<const VersionInfo*>(
               &_VersionInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(VersionInfo* other);
  friend void swap(VersionInfo& a, VersionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VersionInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  VersionInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VersionInfo& from);
  void MergeFrom(const VersionInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VersionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string revision = 1;
  bool has_revision() const;
  void clear_revision();
  static const int kRevisionFieldNumber = 1;
  const ::std::string& revision() const;
  void set_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_revision(::std::string&& value);
  #endif
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  ::std::string* mutable_revision();
  ::std::string* release_revision();
  void set_allocated_revision(::std::string* revision);

  // optional string path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional string release_tag = 3;
  bool has_release_tag() const;
  void clear_release_tag();
  static const int kReleaseTagFieldNumber = 3;
  const ::std::string& release_tag() const;
  void set_release_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_release_tag(::std::string&& value);
  #endif
  void set_release_tag(const char* value);
  void set_release_tag(const char* value, size_t size);
  ::std::string* mutable_release_tag();
  ::std::string* release_release_tag();
  void set_allocated_release_tag(::std::string* release_tag);

  // optional string patch_info = 4;
  bool has_patch_info() const;
  void clear_patch_info();
  static const int kPatchInfoFieldNumber = 4;
  const ::std::string& patch_info() const;
  void set_patch_info(const ::std::string& value);
  #if LANG_CXX11
  void set_patch_info(::std::string&& value);
  #endif
  void set_patch_info(const char* value);
  void set_patch_info(const char* value, size_t size);
  ::std::string* mutable_patch_info();
  ::std::string* release_patch_info();
  void set_allocated_patch_info(::std::string* patch_info);

  // optional string db_tag = 5;
  bool has_db_tag() const;
  void clear_db_tag();
  static const int kDbTagFieldNumber = 5;
  const ::std::string& db_tag() const;
  void set_db_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_db_tag(::std::string&& value);
  #endif
  void set_db_tag(const char* value);
  void set_db_tag(const char* value, size_t size);
  ::std::string* mutable_db_tag();
  ::std::string* release_db_tag();
  void set_allocated_db_tag(::std::string* db_tag);

  // @@protoc_insertion_point(class_scope:gogo.chell_specker.VersionInfo)
 private:
  void set_has_revision();
  void clear_has_revision();
  void set_has_path();
  void clear_has_path();
  void set_has_release_tag();
  void clear_has_release_tag();
  void set_has_patch_info();
  void clear_has_patch_info();
  void set_has_db_tag();
  void clear_has_db_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr revision_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr release_tag_;
  ::google::protobuf::internal::ArenaStringPtr patch_info_;
  ::google::protobuf::internal::ArenaStringPtr db_tag_;
  friend struct protobuf_spellchecker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpcInterleavingInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.chell_specker.SpcInterleavingInfo) */ {
 public:
  SpcInterleavingInfo();
  virtual ~SpcInterleavingInfo();

  SpcInterleavingInfo(const SpcInterleavingInfo& from);

  inline SpcInterleavingInfo& operator=(const SpcInterleavingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpcInterleavingInfo(SpcInterleavingInfo&& from) noexcept
    : SpcInterleavingInfo() {
    *this = ::std::move(from);
  }

  inline SpcInterleavingInfo& operator=(SpcInterleavingInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpcInterleavingInfo& default_instance();

  static inline const SpcInterleavingInfo* internal_default_instance() {
    return reinterpret_cast<const SpcInterleavingInfo*>(
               &_SpcInterleavingInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SpcInterleavingInfo* other);
  friend void swap(SpcInterleavingInfo& a, SpcInterleavingInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpcInterleavingInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SpcInterleavingInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpcInterleavingInfo& from);
  void MergeFrom(const SpcInterleavingInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpcInterleavingInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string interleaving_type = 2;
  bool has_interleaving_type() const;
  void clear_interleaving_type();
  static const int kInterleavingTypeFieldNumber = 2;
  const ::std::string& interleaving_type() const;
  void set_interleaving_type(const ::std::string& value);
  #if LANG_CXX11
  void set_interleaving_type(::std::string&& value);
  #endif
  void set_interleaving_type(const char* value);
  void set_interleaving_type(const char* value, size_t size);
  ::std::string* mutable_interleaving_type();
  ::std::string* release_interleaving_type();
  void set_allocated_interleaving_type(::std::string* interleaving_type);

  // required uint32 exp_id = 1;
  bool has_exp_id() const;
  void clear_exp_id();
  static const int kExpIdFieldNumber = 1;
  ::google::protobuf::uint32 exp_id() const;
  void set_exp_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:gogo.chell_specker.SpcInterleavingInfo)
 private:
  void set_has_exp_id();
  void clear_has_exp_id();
  void set_has_interleaving_type();
  void clear_has_interleaving_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr interleaving_type_;
  ::google::protobuf::uint32 exp_id_;
  friend struct protobuf_spellchecker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConfidencePack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.chell_specker.ConfidencePack) */ {
 public:
  ConfidencePack();
  virtual ~ConfidencePack();

  ConfidencePack(const ConfidencePack& from);

  inline ConfidencePack& operator=(const ConfidencePack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfidencePack(ConfidencePack&& from) noexcept
    : ConfidencePack() {
    *this = ::std::move(from);
  }

  inline ConfidencePack& operator=(ConfidencePack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfidencePack& default_instance();

  static inline const ConfidencePack* internal_default_instance() {
    return reinterpret_cast<const ConfidencePack*>(
               &_ConfidencePack_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ConfidencePack* other);
  friend void swap(ConfidencePack& a, ConfidencePack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfidencePack* New() const PROTOBUF_FINAL { return New(NULL); }

  ConfidencePack* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConfidencePack& from);
  void MergeFrom(const ConfidencePack& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConfidencePack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double word = 1;
  bool has_word() const;
  void clear_word();
  static const int kWordFieldNumber = 1;
  double word() const;
  void set_word(double value);

  // required double split = 2;
  bool has_split() const;
  void clear_split();
  static const int kSplitFieldNumber = 2;
  double split() const;
  void set_split(double value);

  // required double join = 3;
  bool has_join() const;
  void clear_join();
  static const int kJoinFieldNumber = 3;
  double join() const;
  void set_join(double value);

  // required double layout = 4;
  bool has_layout() const;
  void clear_layout();
  static const int kLayoutFieldNumber = 4;
  double layout() const;
  void set_layout(double value);

  // @@protoc_insertion_point(class_scope:gogo.chell_specker.ConfidencePack)
 private:
  void set_has_word();
  void clear_has_word();
  void set_has_split();
  void clear_has_split();
  void set_has_join();
  void clear_has_join();
  void set_has_layout();
  void clear_has_layout();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double word_;
  double split_;
  double join_;
  double layout_;
  friend struct protobuf_spellchecker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FixConfidencePack : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.chell_specker.FixConfidencePack) */ {
 public:
  FixConfidencePack();
  virtual ~FixConfidencePack();

  FixConfidencePack(const FixConfidencePack& from);

  inline FixConfidencePack& operator=(const FixConfidencePack& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FixConfidencePack(FixConfidencePack&& from) noexcept
    : FixConfidencePack() {
    *this = ::std::move(from);
  }

  inline FixConfidencePack& operator=(FixConfidencePack&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FixConfidencePack& default_instance();

  static inline const FixConfidencePack* internal_default_instance() {
    return reinterpret_cast<const FixConfidencePack*>(
               &_FixConfidencePack_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(FixConfidencePack* other);
  friend void swap(FixConfidencePack& a, FixConfidencePack& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FixConfidencePack* New() const PROTOBUF_FINAL { return New(NULL); }

  FixConfidencePack* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FixConfidencePack& from);
  void MergeFrom(const FixConfidencePack& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FixConfidencePack* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .gogo.chell_specker.ConfidencePack low_fix = 1;
  bool has_low_fix() const;
  void clear_low_fix();
  static const int kLowFixFieldNumber = 1;
  const ::gogo::chell_specker::ConfidencePack& low_fix() const;
  ::gogo::chell_specker::ConfidencePack* mutable_low_fix();
  ::gogo::chell_specker::ConfidencePack* release_low_fix();
  void set_allocated_low_fix(::gogo::chell_specker::ConfidencePack* low_fix);

  // required .gogo.chell_specker.ConfidencePack high_fix = 2;
  bool has_high_fix() const;
  void clear_high_fix();
  static const int kHighFixFieldNumber = 2;
  const ::gogo::chell_specker::ConfidencePack& high_fix() const;
  ::gogo::chell_specker::ConfidencePack* mutable_high_fix();
  ::gogo::chell_specker::ConfidencePack* release_high_fix();
  void set_allocated_high_fix(::gogo::chell_specker::ConfidencePack* high_fix);

  // required .gogo.chell_specker.ConfidencePack high_auto = 3;
  bool has_high_auto() const;
  void clear_high_auto();
  static const int kHighAutoFieldNumber = 3;
  const ::gogo::chell_specker::ConfidencePack& high_auto() const;
  ::gogo::chell_specker::ConfidencePack* mutable_high_auto();
  ::gogo::chell_specker::ConfidencePack* release_high_auto();
  void set_allocated_high_auto(::gogo::chell_specker::ConfidencePack* high_auto);

  // @@protoc_insertion_point(class_scope:gogo.chell_specker.FixConfidencePack)
 private:
  void set_has_low_fix();
  void clear_has_low_fix();
  void set_has_high_fix();
  void clear_has_high_fix();
  void set_has_high_auto();
  void clear_has_high_auto();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::gogo::chell_specker::ConfidencePack* low_fix_;
  ::gogo::chell_specker::ConfidencePack* high_fix_;
  ::gogo::chell_specker::ConfidencePack* high_auto_;
  friend struct protobuf_spellchecker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpcWnfInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.chell_specker.SpcWnfInfo) */ {
 public:
  SpcWnfInfo();
  virtual ~SpcWnfInfo();

  SpcWnfInfo(const SpcWnfInfo& from);

  inline SpcWnfInfo& operator=(const SpcWnfInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpcWnfInfo(SpcWnfInfo&& from) noexcept
    : SpcWnfInfo() {
    *this = ::std::move(from);
  }

  inline SpcWnfInfo& operator=(SpcWnfInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpcWnfInfo& default_instance();

  static inline const SpcWnfInfo* internal_default_instance() {
    return reinterpret_cast<const SpcWnfInfo*>(
               &_SpcWnfInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SpcWnfInfo* other);
  friend void swap(SpcWnfInfo& a, SpcWnfInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpcWnfInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SpcWnfInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpcWnfInfo& from);
  void MergeFrom(const SpcWnfInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpcWnfInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string wnf_tag = 1;
  bool has_wnf_tag() const;
  void clear_wnf_tag();
  static const int kWnfTagFieldNumber = 1;
  const ::std::string& wnf_tag() const;
  void set_wnf_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_wnf_tag(::std::string&& value);
  #endif
  void set_wnf_tag(const char* value);
  void set_wnf_tag(const char* value, size_t size);
  ::std::string* mutable_wnf_tag();
  ::std::string* release_wnf_tag();
  void set_allocated_wnf_tag(::std::string* wnf_tag);

  // optional string wnf_report = 2;
  bool has_wnf_report() const;
  void clear_wnf_report();
  static const int kWnfReportFieldNumber = 2;
  const ::std::string& wnf_report() const;
  void set_wnf_report(const ::std::string& value);
  #if LANG_CXX11
  void set_wnf_report(::std::string&& value);
  #endif
  void set_wnf_report(const char* value);
  void set_wnf_report(const char* value, size_t size);
  ::std::string* mutable_wnf_report();
  ::std::string* release_wnf_report();
  void set_allocated_wnf_report(::std::string* wnf_report);

  // @@protoc_insertion_point(class_scope:gogo.chell_specker.SpcWnfInfo)
 private:
  void set_has_wnf_tag();
  void clear_has_wnf_tag();
  void set_has_wnf_report();
  void clear_has_wnf_report();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr wnf_tag_;
  ::google::protobuf::internal::ArenaStringPtr wnf_report_;
  friend struct protobuf_spellchecker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpcReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.chell_specker.SpcReply) */ {
 public:
  SpcReply();
  virtual ~SpcReply();

  SpcReply(const SpcReply& from);

  inline SpcReply& operator=(const SpcReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpcReply(SpcReply&& from) noexcept
    : SpcReply() {
    *this = ::std::move(from);
  }

  inline SpcReply& operator=(SpcReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpcReply& default_instance();

  static inline const SpcReply* internal_default_instance() {
    return reinterpret_cast<const SpcReply*>(
               &_SpcReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(SpcReply* other);
  friend void swap(SpcReply& a, SpcReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpcReply* New() const PROTOBUF_FINAL { return New(NULL); }

  SpcReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpcReply& from);
  void MergeFrom(const SpcReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpcReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fixed_query = 2;
  bool has_fixed_query() const;
  void clear_fixed_query();
  static const int kFixedQueryFieldNumber = 2;
  const ::std::string& fixed_query() const;
  void set_fixed_query(const ::std::string& value);
  #if LANG_CXX11
  void set_fixed_query(::std::string&& value);
  #endif
  void set_fixed_query(const char* value);
  void set_fixed_query(const char* value, size_t size);
  ::std::string* mutable_fixed_query();
  ::std::string* release_fixed_query();
  void set_allocated_fixed_query(::std::string* fixed_query);

  // optional string orig_highlight = 3;
  bool has_orig_highlight() const;
  void clear_orig_highlight();
  static const int kOrigHighlightFieldNumber = 3;
  const ::std::string& orig_highlight() const;
  void set_orig_highlight(const ::std::string& value);
  #if LANG_CXX11
  void set_orig_highlight(::std::string&& value);
  #endif
  void set_orig_highlight(const char* value);
  void set_orig_highlight(const char* value, size_t size);
  ::std::string* mutable_orig_highlight();
  ::std::string* release_orig_highlight();
  void set_allocated_orig_highlight(::std::string* orig_highlight);

  // optional string fixed_highlight = 4;
  bool has_fixed_highlight() const;
  void clear_fixed_highlight();
  static const int kFixedHighlightFieldNumber = 4;
  const ::std::string& fixed_highlight() const;
  void set_fixed_highlight(const ::std::string& value);
  #if LANG_CXX11
  void set_fixed_highlight(::std::string&& value);
  #endif
  void set_fixed_highlight(const char* value);
  void set_fixed_highlight(const char* value, size_t size);
  ::std::string* mutable_fixed_highlight();
  ::std::string* release_fixed_highlight();
  void set_allocated_fixed_highlight(::std::string* fixed_highlight);

  // optional string fix_tags = 8;
  bool has_fix_tags() const;
  void clear_fix_tags();
  static const int kFixTagsFieldNumber = 8;
  const ::std::string& fix_tags() const;
  void set_fix_tags(const ::std::string& value);
  #if LANG_CXX11
  void set_fix_tags(::std::string&& value);
  #endif
  void set_fix_tags(const char* value);
  void set_fix_tags(const char* value, size_t size);
  ::std::string* mutable_fix_tags();
  ::std::string* release_fix_tags();
  void set_allocated_fix_tags(::std::string* fix_tags);

  // optional string porno_fixed_query = 9;
  bool has_porno_fixed_query() const;
  void clear_porno_fixed_query();
  static const int kPornoFixedQueryFieldNumber = 9;
  const ::std::string& porno_fixed_query() const;
  void set_porno_fixed_query(const ::std::string& value);
  #if LANG_CXX11
  void set_porno_fixed_query(::std::string&& value);
  #endif
  void set_porno_fixed_query(const char* value);
  void set_porno_fixed_query(const char* value, size_t size);
  ::std::string* mutable_porno_fixed_query();
  ::std::string* release_porno_fixed_query();
  void set_allocated_porno_fixed_query(::std::string* porno_fixed_query);

  // optional string transliter_fixed_query = 11;
  bool has_transliter_fixed_query() const;
  void clear_transliter_fixed_query();
  static const int kTransliterFixedQueryFieldNumber = 11;
  const ::std::string& transliter_fixed_query() const;
  void set_transliter_fixed_query(const ::std::string& value);
  #if LANG_CXX11
  void set_transliter_fixed_query(::std::string&& value);
  #endif
  void set_transliter_fixed_query(const char* value);
  void set_transliter_fixed_query(const char* value, size_t size);
  ::std::string* mutable_transliter_fixed_query();
  ::std::string* release_transliter_fixed_query();
  void set_allocated_transliter_fixed_query(::std::string* transliter_fixed_query);

  // optional .gogo.chell_specker.SpcInterleavingInfo interleaving_info = 7;
  bool has_interleaving_info() const;
  void clear_interleaving_info();
  static const int kInterleavingInfoFieldNumber = 7;
  const ::gogo::chell_specker::SpcInterleavingInfo& interleaving_info() const;
  ::gogo::chell_specker::SpcInterleavingInfo* mutable_interleaving_info();
  ::gogo::chell_specker::SpcInterleavingInfo* release_interleaving_info();
  void set_allocated_interleaving_info(::gogo::chell_specker::SpcInterleavingInfo* interleaving_info);

  // optional .gogo.chell_specker.FixConfidencePack fix_confidence_pack = 10;
  bool has_fix_confidence_pack() const;
  void clear_fix_confidence_pack();
  static const int kFixConfidencePackFieldNumber = 10;
  const ::gogo::chell_specker::FixConfidencePack& fix_confidence_pack() const;
  ::gogo::chell_specker::FixConfidencePack* mutable_fix_confidence_pack();
  ::gogo::chell_specker::FixConfidencePack* release_fix_confidence_pack();
  void set_allocated_fix_confidence_pack(::gogo::chell_specker::FixConfidencePack* fix_confidence_pack);

  // optional .gogo.chell_specker.VersionInfo version_info = 13;
  bool has_version_info() const;
  void clear_version_info();
  static const int kVersionInfoFieldNumber = 13;
  const ::gogo::chell_specker::VersionInfo& version_info() const;
  ::gogo::chell_specker::VersionInfo* mutable_version_info();
  ::gogo::chell_specker::VersionInfo* release_version_info();
  void set_allocated_version_info(::gogo::chell_specker::VersionInfo* version_info);

  // optional .gogo.chell_specker.SpcWnfInfo wnf_info = 15;
  bool has_wnf_info() const;
  void clear_wnf_info();
  static const int kWnfInfoFieldNumber = 15;
  const ::gogo::chell_specker::SpcWnfInfo& wnf_info() const;
  ::gogo::chell_specker::SpcWnfInfo* mutable_wnf_info();
  ::gogo::chell_specker::SpcWnfInfo* release_wnf_info();
  void set_allocated_wnf_info(::gogo::chell_specker::SpcWnfInfo* wnf_info);

  // optional double fix_confidence = 5;
  bool has_fix_confidence() const;
  void clear_fix_confidence();
  static const int kFixConfidenceFieldNumber = 5;
  double fix_confidence() const;
  void set_fix_confidence(double value);

  // optional double auto_confidence = 6;
  bool has_auto_confidence() const;
  void clear_auto_confidence();
  static const int kAutoConfidenceFieldNumber = 6;
  double auto_confidence() const;
  void set_auto_confidence(double value);

  // required bool autoreplace = 1;
  bool has_autoreplace() const;
  void clear_autoreplace();
  static const int kAutoreplaceFieldNumber = 1;
  bool autoreplace() const;
  void set_autoreplace(bool value);

  // optional int32 iteration_count = 14;
  bool has_iteration_count() const;
  void clear_iteration_count();
  static const int kIterationCountFieldNumber = 14;
  ::google::protobuf::int32 iteration_count() const;
  void set_iteration_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gogo.chell_specker.SpcReply)
 private:
  void set_has_autoreplace();
  void clear_has_autoreplace();
  void set_has_fixed_query();
  void clear_has_fixed_query();
  void set_has_orig_highlight();
  void clear_has_orig_highlight();
  void set_has_fixed_highlight();
  void clear_has_fixed_highlight();
  void set_has_fix_confidence();
  void clear_has_fix_confidence();
  void set_has_auto_confidence();
  void clear_has_auto_confidence();
  void set_has_interleaving_info();
  void clear_has_interleaving_info();
  void set_has_fix_tags();
  void clear_has_fix_tags();
  void set_has_porno_fixed_query();
  void clear_has_porno_fixed_query();
  void set_has_fix_confidence_pack();
  void clear_has_fix_confidence_pack();
  void set_has_transliter_fixed_query();
  void clear_has_transliter_fixed_query();
  void set_has_version_info();
  void clear_has_version_info();
  void set_has_iteration_count();
  void clear_has_iteration_count();
  void set_has_wnf_info();
  void clear_has_wnf_info();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fixed_query_;
  ::google::protobuf::internal::ArenaStringPtr orig_highlight_;
  ::google::protobuf::internal::ArenaStringPtr fixed_highlight_;
  ::google::protobuf::internal::ArenaStringPtr fix_tags_;
  ::google::protobuf::internal::ArenaStringPtr porno_fixed_query_;
  ::google::protobuf::internal::ArenaStringPtr transliter_fixed_query_;
  ::gogo::chell_specker::SpcInterleavingInfo* interleaving_info_;
  ::gogo::chell_specker::FixConfidencePack* fix_confidence_pack_;
  ::gogo::chell_specker::VersionInfo* version_info_;
  ::gogo::chell_specker::SpcWnfInfo* wnf_info_;
  double fix_confidence_;
  double auto_confidence_;
  bool autoreplace_;
  ::google::protobuf::int32 iteration_count_;
  friend struct protobuf_spellchecker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpcCommentItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.chell_specker.SpcCommentItem) */ {
 public:
  SpcCommentItem();
  virtual ~SpcCommentItem();

  SpcCommentItem(const SpcCommentItem& from);

  inline SpcCommentItem& operator=(const SpcCommentItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpcCommentItem(SpcCommentItem&& from) noexcept
    : SpcCommentItem() {
    *this = ::std::move(from);
  }

  inline SpcCommentItem& operator=(SpcCommentItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpcCommentItem& default_instance();

  static inline const SpcCommentItem* internal_default_instance() {
    return reinterpret_cast<const SpcCommentItem*>(
               &_SpcCommentItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(SpcCommentItem* other);
  friend void swap(SpcCommentItem& a, SpcCommentItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpcCommentItem* New() const PROTOBUF_FINAL { return New(NULL); }

  SpcCommentItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpcCommentItem& from);
  void MergeFrom(const SpcCommentItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpcCommentItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:gogo.chell_specker.SpcCommentItem)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct protobuf_spellchecker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpcComment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.chell_specker.SpcComment) */ {
 public:
  SpcComment();
  virtual ~SpcComment();

  SpcComment(const SpcComment& from);

  inline SpcComment& operator=(const SpcComment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpcComment(SpcComment&& from) noexcept
    : SpcComment() {
    *this = ::std::move(from);
  }

  inline SpcComment& operator=(SpcComment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpcComment& default_instance();

  static inline const SpcComment* internal_default_instance() {
    return reinterpret_cast<const SpcComment*>(
               &_SpcComment_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(SpcComment* other);
  friend void swap(SpcComment& a, SpcComment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpcComment* New() const PROTOBUF_FINAL { return New(NULL); }

  SpcComment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpcComment& from);
  void MergeFrom(const SpcComment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpcComment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gogo.chell_specker.SpcCommentItem data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::gogo::chell_specker::SpcCommentItem& data(int index) const;
  ::gogo::chell_specker::SpcCommentItem* mutable_data(int index);
  ::gogo::chell_specker::SpcCommentItem* add_data();
  ::google::protobuf::RepeatedPtrField< ::gogo::chell_specker::SpcCommentItem >*
      mutable_data();
  const ::google::protobuf::RepeatedPtrField< ::gogo::chell_specker::SpcCommentItem >&
      data() const;

  // @@protoc_insertion_point(class_scope:gogo.chell_specker.SpcComment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::gogo::chell_specker::SpcCommentItem > data_;
  friend struct protobuf_spellchecker_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpcResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gogo.chell_specker.SpcResponse) */ {
 public:
  SpcResponse();
  virtual ~SpcResponse();

  SpcResponse(const SpcResponse& from);

  inline SpcResponse& operator=(const SpcResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpcResponse(SpcResponse&& from) noexcept
    : SpcResponse() {
    *this = ::std::move(from);
  }

  inline SpcResponse& operator=(SpcResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpcResponse& default_instance();

  static inline const SpcResponse* internal_default_instance() {
    return reinterpret_cast<const SpcResponse*>(
               &_SpcResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SpcResponse* other);
  friend void swap(SpcResponse& a, SpcResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpcResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SpcResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpcResponse& from);
  void MergeFrom(const SpcResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpcResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .gogo.chell_specker.SpcReply reply = 1;
  bool has_reply() const;
  void clear_reply();
  static const int kReplyFieldNumber = 1;
  const ::gogo::chell_specker::SpcReply& reply() const;
  ::gogo::chell_specker::SpcReply* mutable_reply();
  ::gogo::chell_specker::SpcReply* release_reply();
  void set_allocated_reply(::gogo::chell_specker::SpcReply* reply);

  // optional .gogo.chell_specker.SpcComment comment = 2;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 2;
  const ::gogo::chell_specker::SpcComment& comment() const;
  ::gogo::chell_specker::SpcComment* mutable_comment();
  ::gogo::chell_specker::SpcComment* release_comment();
  void set_allocated_comment(::gogo::chell_specker::SpcComment* comment);

  // @@protoc_insertion_point(class_scope:gogo.chell_specker.SpcResponse)
 private:
  void set_has_reply();
  void clear_has_reply();
  void set_has_comment();
  void clear_has_comment();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::gogo::chell_specker::SpcReply* reply_;
  ::gogo::chell_specker::SpcComment* comment_;
  friend struct protobuf_spellchecker_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VersionInfo

// optional string revision = 1;
inline bool VersionInfo::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionInfo::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VersionInfo::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VersionInfo::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_revision();
}
inline const ::std::string& VersionInfo::revision() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.VersionInfo.revision)
  return revision_.GetNoArena();
}
inline void VersionInfo::set_revision(const ::std::string& value) {
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.VersionInfo.revision)
}
#if LANG_CXX11
inline void VersionInfo::set_revision(::std::string&& value) {
  set_has_revision();
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.VersionInfo.revision)
}
#endif
inline void VersionInfo::set_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.VersionInfo.revision)
}
inline void VersionInfo::set_revision(const char* value, size_t size) {
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.VersionInfo.revision)
}
inline ::std::string* VersionInfo::mutable_revision() {
  set_has_revision();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.VersionInfo.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VersionInfo::release_revision() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.VersionInfo.revision)
  clear_has_revision();
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VersionInfo::set_allocated_revision(::std::string* revision) {
  if (revision != NULL) {
    set_has_revision();
  } else {
    clear_has_revision();
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.VersionInfo.revision)
}

// optional string path = 2;
inline bool VersionInfo::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VersionInfo::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VersionInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VersionInfo::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& VersionInfo::path() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.VersionInfo.path)
  return path_.GetNoArena();
}
inline void VersionInfo::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.VersionInfo.path)
}
#if LANG_CXX11
inline void VersionInfo::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.VersionInfo.path)
}
#endif
inline void VersionInfo::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.VersionInfo.path)
}
inline void VersionInfo::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.VersionInfo.path)
}
inline ::std::string* VersionInfo::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.VersionInfo.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VersionInfo::release_path() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.VersionInfo.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VersionInfo::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.VersionInfo.path)
}

// optional string release_tag = 3;
inline bool VersionInfo::has_release_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VersionInfo::set_has_release_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VersionInfo::clear_has_release_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VersionInfo::clear_release_tag() {
  release_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_release_tag();
}
inline const ::std::string& VersionInfo::release_tag() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.VersionInfo.release_tag)
  return release_tag_.GetNoArena();
}
inline void VersionInfo::set_release_tag(const ::std::string& value) {
  set_has_release_tag();
  release_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.VersionInfo.release_tag)
}
#if LANG_CXX11
inline void VersionInfo::set_release_tag(::std::string&& value) {
  set_has_release_tag();
  release_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.VersionInfo.release_tag)
}
#endif
inline void VersionInfo::set_release_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_release_tag();
  release_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.VersionInfo.release_tag)
}
inline void VersionInfo::set_release_tag(const char* value, size_t size) {
  set_has_release_tag();
  release_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.VersionInfo.release_tag)
}
inline ::std::string* VersionInfo::mutable_release_tag() {
  set_has_release_tag();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.VersionInfo.release_tag)
  return release_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VersionInfo::release_release_tag() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.VersionInfo.release_tag)
  clear_has_release_tag();
  return release_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VersionInfo::set_allocated_release_tag(::std::string* release_tag) {
  if (release_tag != NULL) {
    set_has_release_tag();
  } else {
    clear_has_release_tag();
  }
  release_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), release_tag);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.VersionInfo.release_tag)
}

// optional string patch_info = 4;
inline bool VersionInfo::has_patch_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VersionInfo::set_has_patch_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VersionInfo::clear_has_patch_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VersionInfo::clear_patch_info() {
  patch_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_patch_info();
}
inline const ::std::string& VersionInfo::patch_info() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.VersionInfo.patch_info)
  return patch_info_.GetNoArena();
}
inline void VersionInfo::set_patch_info(const ::std::string& value) {
  set_has_patch_info();
  patch_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.VersionInfo.patch_info)
}
#if LANG_CXX11
inline void VersionInfo::set_patch_info(::std::string&& value) {
  set_has_patch_info();
  patch_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.VersionInfo.patch_info)
}
#endif
inline void VersionInfo::set_patch_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_patch_info();
  patch_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.VersionInfo.patch_info)
}
inline void VersionInfo::set_patch_info(const char* value, size_t size) {
  set_has_patch_info();
  patch_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.VersionInfo.patch_info)
}
inline ::std::string* VersionInfo::mutable_patch_info() {
  set_has_patch_info();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.VersionInfo.patch_info)
  return patch_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VersionInfo::release_patch_info() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.VersionInfo.patch_info)
  clear_has_patch_info();
  return patch_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VersionInfo::set_allocated_patch_info(::std::string* patch_info) {
  if (patch_info != NULL) {
    set_has_patch_info();
  } else {
    clear_has_patch_info();
  }
  patch_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), patch_info);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.VersionInfo.patch_info)
}

// optional string db_tag = 5;
inline bool VersionInfo::has_db_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VersionInfo::set_has_db_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VersionInfo::clear_has_db_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VersionInfo::clear_db_tag() {
  db_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_db_tag();
}
inline const ::std::string& VersionInfo::db_tag() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.VersionInfo.db_tag)
  return db_tag_.GetNoArena();
}
inline void VersionInfo::set_db_tag(const ::std::string& value) {
  set_has_db_tag();
  db_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.VersionInfo.db_tag)
}
#if LANG_CXX11
inline void VersionInfo::set_db_tag(::std::string&& value) {
  set_has_db_tag();
  db_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.VersionInfo.db_tag)
}
#endif
inline void VersionInfo::set_db_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_db_tag();
  db_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.VersionInfo.db_tag)
}
inline void VersionInfo::set_db_tag(const char* value, size_t size) {
  set_has_db_tag();
  db_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.VersionInfo.db_tag)
}
inline ::std::string* VersionInfo::mutable_db_tag() {
  set_has_db_tag();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.VersionInfo.db_tag)
  return db_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VersionInfo::release_db_tag() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.VersionInfo.db_tag)
  clear_has_db_tag();
  return db_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VersionInfo::set_allocated_db_tag(::std::string* db_tag) {
  if (db_tag != NULL) {
    set_has_db_tag();
  } else {
    clear_has_db_tag();
  }
  db_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_tag);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.VersionInfo.db_tag)
}

// -------------------------------------------------------------------

// SpcInterleavingInfo

// required uint32 exp_id = 1;
inline bool SpcInterleavingInfo::has_exp_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpcInterleavingInfo::set_has_exp_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpcInterleavingInfo::clear_has_exp_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpcInterleavingInfo::clear_exp_id() {
  exp_id_ = 0u;
  clear_has_exp_id();
}
inline ::google::protobuf::uint32 SpcInterleavingInfo::exp_id() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcInterleavingInfo.exp_id)
  return exp_id_;
}
inline void SpcInterleavingInfo::set_exp_id(::google::protobuf::uint32 value) {
  set_has_exp_id();
  exp_id_ = value;
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcInterleavingInfo.exp_id)
}

// required string interleaving_type = 2;
inline bool SpcInterleavingInfo::has_interleaving_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpcInterleavingInfo::set_has_interleaving_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpcInterleavingInfo::clear_has_interleaving_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpcInterleavingInfo::clear_interleaving_type() {
  interleaving_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_interleaving_type();
}
inline const ::std::string& SpcInterleavingInfo::interleaving_type() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcInterleavingInfo.interleaving_type)
  return interleaving_type_.GetNoArena();
}
inline void SpcInterleavingInfo::set_interleaving_type(const ::std::string& value) {
  set_has_interleaving_type();
  interleaving_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcInterleavingInfo.interleaving_type)
}
#if LANG_CXX11
inline void SpcInterleavingInfo::set_interleaving_type(::std::string&& value) {
  set_has_interleaving_type();
  interleaving_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.SpcInterleavingInfo.interleaving_type)
}
#endif
inline void SpcInterleavingInfo::set_interleaving_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_interleaving_type();
  interleaving_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.SpcInterleavingInfo.interleaving_type)
}
inline void SpcInterleavingInfo::set_interleaving_type(const char* value, size_t size) {
  set_has_interleaving_type();
  interleaving_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.SpcInterleavingInfo.interleaving_type)
}
inline ::std::string* SpcInterleavingInfo::mutable_interleaving_type() {
  set_has_interleaving_type();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcInterleavingInfo.interleaving_type)
  return interleaving_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpcInterleavingInfo::release_interleaving_type() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcInterleavingInfo.interleaving_type)
  clear_has_interleaving_type();
  return interleaving_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpcInterleavingInfo::set_allocated_interleaving_type(::std::string* interleaving_type) {
  if (interleaving_type != NULL) {
    set_has_interleaving_type();
  } else {
    clear_has_interleaving_type();
  }
  interleaving_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), interleaving_type);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcInterleavingInfo.interleaving_type)
}

// -------------------------------------------------------------------

// ConfidencePack

// required double word = 1;
inline bool ConfidencePack::has_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfidencePack::set_has_word() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfidencePack::clear_has_word() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfidencePack::clear_word() {
  word_ = 0;
  clear_has_word();
}
inline double ConfidencePack::word() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.ConfidencePack.word)
  return word_;
}
inline void ConfidencePack::set_word(double value) {
  set_has_word();
  word_ = value;
  // @@protoc_insertion_point(field_set:gogo.chell_specker.ConfidencePack.word)
}

// required double split = 2;
inline bool ConfidencePack::has_split() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfidencePack::set_has_split() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfidencePack::clear_has_split() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfidencePack::clear_split() {
  split_ = 0;
  clear_has_split();
}
inline double ConfidencePack::split() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.ConfidencePack.split)
  return split_;
}
inline void ConfidencePack::set_split(double value) {
  set_has_split();
  split_ = value;
  // @@protoc_insertion_point(field_set:gogo.chell_specker.ConfidencePack.split)
}

// required double join = 3;
inline bool ConfidencePack::has_join() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfidencePack::set_has_join() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfidencePack::clear_has_join() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfidencePack::clear_join() {
  join_ = 0;
  clear_has_join();
}
inline double ConfidencePack::join() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.ConfidencePack.join)
  return join_;
}
inline void ConfidencePack::set_join(double value) {
  set_has_join();
  join_ = value;
  // @@protoc_insertion_point(field_set:gogo.chell_specker.ConfidencePack.join)
}

// required double layout = 4;
inline bool ConfidencePack::has_layout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConfidencePack::set_has_layout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConfidencePack::clear_has_layout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConfidencePack::clear_layout() {
  layout_ = 0;
  clear_has_layout();
}
inline double ConfidencePack::layout() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.ConfidencePack.layout)
  return layout_;
}
inline void ConfidencePack::set_layout(double value) {
  set_has_layout();
  layout_ = value;
  // @@protoc_insertion_point(field_set:gogo.chell_specker.ConfidencePack.layout)
}

// -------------------------------------------------------------------

// FixConfidencePack

// required .gogo.chell_specker.ConfidencePack low_fix = 1;
inline bool FixConfidencePack::has_low_fix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FixConfidencePack::set_has_low_fix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FixConfidencePack::clear_has_low_fix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FixConfidencePack::clear_low_fix() {
  if (low_fix_ != NULL) low_fix_->::gogo::chell_specker::ConfidencePack::Clear();
  clear_has_low_fix();
}
inline const ::gogo::chell_specker::ConfidencePack& FixConfidencePack::low_fix() const {
  const ::gogo::chell_specker::ConfidencePack* p = low_fix_;
  // @@protoc_insertion_point(field_get:gogo.chell_specker.FixConfidencePack.low_fix)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::chell_specker::ConfidencePack*>(
      &::gogo::chell_specker::_ConfidencePack_default_instance_);
}
inline ::gogo::chell_specker::ConfidencePack* FixConfidencePack::mutable_low_fix() {
  set_has_low_fix();
  if (low_fix_ == NULL) {
    low_fix_ = new ::gogo::chell_specker::ConfidencePack;
  }
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.FixConfidencePack.low_fix)
  return low_fix_;
}
inline ::gogo::chell_specker::ConfidencePack* FixConfidencePack::release_low_fix() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.FixConfidencePack.low_fix)
  clear_has_low_fix();
  ::gogo::chell_specker::ConfidencePack* temp = low_fix_;
  low_fix_ = NULL;
  return temp;
}
inline void FixConfidencePack::set_allocated_low_fix(::gogo::chell_specker::ConfidencePack* low_fix) {
  delete low_fix_;
  low_fix_ = low_fix;
  if (low_fix) {
    set_has_low_fix();
  } else {
    clear_has_low_fix();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.FixConfidencePack.low_fix)
}

// required .gogo.chell_specker.ConfidencePack high_fix = 2;
inline bool FixConfidencePack::has_high_fix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FixConfidencePack::set_has_high_fix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FixConfidencePack::clear_has_high_fix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FixConfidencePack::clear_high_fix() {
  if (high_fix_ != NULL) high_fix_->::gogo::chell_specker::ConfidencePack::Clear();
  clear_has_high_fix();
}
inline const ::gogo::chell_specker::ConfidencePack& FixConfidencePack::high_fix() const {
  const ::gogo::chell_specker::ConfidencePack* p = high_fix_;
  // @@protoc_insertion_point(field_get:gogo.chell_specker.FixConfidencePack.high_fix)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::chell_specker::ConfidencePack*>(
      &::gogo::chell_specker::_ConfidencePack_default_instance_);
}
inline ::gogo::chell_specker::ConfidencePack* FixConfidencePack::mutable_high_fix() {
  set_has_high_fix();
  if (high_fix_ == NULL) {
    high_fix_ = new ::gogo::chell_specker::ConfidencePack;
  }
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.FixConfidencePack.high_fix)
  return high_fix_;
}
inline ::gogo::chell_specker::ConfidencePack* FixConfidencePack::release_high_fix() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.FixConfidencePack.high_fix)
  clear_has_high_fix();
  ::gogo::chell_specker::ConfidencePack* temp = high_fix_;
  high_fix_ = NULL;
  return temp;
}
inline void FixConfidencePack::set_allocated_high_fix(::gogo::chell_specker::ConfidencePack* high_fix) {
  delete high_fix_;
  high_fix_ = high_fix;
  if (high_fix) {
    set_has_high_fix();
  } else {
    clear_has_high_fix();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.FixConfidencePack.high_fix)
}

// required .gogo.chell_specker.ConfidencePack high_auto = 3;
inline bool FixConfidencePack::has_high_auto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FixConfidencePack::set_has_high_auto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FixConfidencePack::clear_has_high_auto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FixConfidencePack::clear_high_auto() {
  if (high_auto_ != NULL) high_auto_->::gogo::chell_specker::ConfidencePack::Clear();
  clear_has_high_auto();
}
inline const ::gogo::chell_specker::ConfidencePack& FixConfidencePack::high_auto() const {
  const ::gogo::chell_specker::ConfidencePack* p = high_auto_;
  // @@protoc_insertion_point(field_get:gogo.chell_specker.FixConfidencePack.high_auto)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::chell_specker::ConfidencePack*>(
      &::gogo::chell_specker::_ConfidencePack_default_instance_);
}
inline ::gogo::chell_specker::ConfidencePack* FixConfidencePack::mutable_high_auto() {
  set_has_high_auto();
  if (high_auto_ == NULL) {
    high_auto_ = new ::gogo::chell_specker::ConfidencePack;
  }
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.FixConfidencePack.high_auto)
  return high_auto_;
}
inline ::gogo::chell_specker::ConfidencePack* FixConfidencePack::release_high_auto() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.FixConfidencePack.high_auto)
  clear_has_high_auto();
  ::gogo::chell_specker::ConfidencePack* temp = high_auto_;
  high_auto_ = NULL;
  return temp;
}
inline void FixConfidencePack::set_allocated_high_auto(::gogo::chell_specker::ConfidencePack* high_auto) {
  delete high_auto_;
  high_auto_ = high_auto;
  if (high_auto) {
    set_has_high_auto();
  } else {
    clear_has_high_auto();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.FixConfidencePack.high_auto)
}

// -------------------------------------------------------------------

// SpcWnfInfo

// optional string wnf_tag = 1;
inline bool SpcWnfInfo::has_wnf_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpcWnfInfo::set_has_wnf_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpcWnfInfo::clear_has_wnf_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpcWnfInfo::clear_wnf_tag() {
  wnf_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_wnf_tag();
}
inline const ::std::string& SpcWnfInfo::wnf_tag() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcWnfInfo.wnf_tag)
  return wnf_tag_.GetNoArena();
}
inline void SpcWnfInfo::set_wnf_tag(const ::std::string& value) {
  set_has_wnf_tag();
  wnf_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcWnfInfo.wnf_tag)
}
#if LANG_CXX11
inline void SpcWnfInfo::set_wnf_tag(::std::string&& value) {
  set_has_wnf_tag();
  wnf_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.SpcWnfInfo.wnf_tag)
}
#endif
inline void SpcWnfInfo::set_wnf_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_wnf_tag();
  wnf_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.SpcWnfInfo.wnf_tag)
}
inline void SpcWnfInfo::set_wnf_tag(const char* value, size_t size) {
  set_has_wnf_tag();
  wnf_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.SpcWnfInfo.wnf_tag)
}
inline ::std::string* SpcWnfInfo::mutable_wnf_tag() {
  set_has_wnf_tag();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcWnfInfo.wnf_tag)
  return wnf_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpcWnfInfo::release_wnf_tag() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcWnfInfo.wnf_tag)
  clear_has_wnf_tag();
  return wnf_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpcWnfInfo::set_allocated_wnf_tag(::std::string* wnf_tag) {
  if (wnf_tag != NULL) {
    set_has_wnf_tag();
  } else {
    clear_has_wnf_tag();
  }
  wnf_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wnf_tag);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcWnfInfo.wnf_tag)
}

// optional string wnf_report = 2;
inline bool SpcWnfInfo::has_wnf_report() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpcWnfInfo::set_has_wnf_report() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpcWnfInfo::clear_has_wnf_report() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpcWnfInfo::clear_wnf_report() {
  wnf_report_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_wnf_report();
}
inline const ::std::string& SpcWnfInfo::wnf_report() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcWnfInfo.wnf_report)
  return wnf_report_.GetNoArena();
}
inline void SpcWnfInfo::set_wnf_report(const ::std::string& value) {
  set_has_wnf_report();
  wnf_report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcWnfInfo.wnf_report)
}
#if LANG_CXX11
inline void SpcWnfInfo::set_wnf_report(::std::string&& value) {
  set_has_wnf_report();
  wnf_report_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.SpcWnfInfo.wnf_report)
}
#endif
inline void SpcWnfInfo::set_wnf_report(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_wnf_report();
  wnf_report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.SpcWnfInfo.wnf_report)
}
inline void SpcWnfInfo::set_wnf_report(const char* value, size_t size) {
  set_has_wnf_report();
  wnf_report_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.SpcWnfInfo.wnf_report)
}
inline ::std::string* SpcWnfInfo::mutable_wnf_report() {
  set_has_wnf_report();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcWnfInfo.wnf_report)
  return wnf_report_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpcWnfInfo::release_wnf_report() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcWnfInfo.wnf_report)
  clear_has_wnf_report();
  return wnf_report_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpcWnfInfo::set_allocated_wnf_report(::std::string* wnf_report) {
  if (wnf_report != NULL) {
    set_has_wnf_report();
  } else {
    clear_has_wnf_report();
  }
  wnf_report_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wnf_report);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcWnfInfo.wnf_report)
}

// -------------------------------------------------------------------

// SpcReply

// required bool autoreplace = 1;
inline bool SpcReply::has_autoreplace() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SpcReply::set_has_autoreplace() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SpcReply::clear_has_autoreplace() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SpcReply::clear_autoreplace() {
  autoreplace_ = false;
  clear_has_autoreplace();
}
inline bool SpcReply::autoreplace() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.autoreplace)
  return autoreplace_;
}
inline void SpcReply::set_autoreplace(bool value) {
  set_has_autoreplace();
  autoreplace_ = value;
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcReply.autoreplace)
}

// required string fixed_query = 2;
inline bool SpcReply::has_fixed_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpcReply::set_has_fixed_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpcReply::clear_has_fixed_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpcReply::clear_fixed_query() {
  fixed_query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fixed_query();
}
inline const ::std::string& SpcReply::fixed_query() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.fixed_query)
  return fixed_query_.GetNoArena();
}
inline void SpcReply::set_fixed_query(const ::std::string& value) {
  set_has_fixed_query();
  fixed_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcReply.fixed_query)
}
#if LANG_CXX11
inline void SpcReply::set_fixed_query(::std::string&& value) {
  set_has_fixed_query();
  fixed_query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.SpcReply.fixed_query)
}
#endif
inline void SpcReply::set_fixed_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fixed_query();
  fixed_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.SpcReply.fixed_query)
}
inline void SpcReply::set_fixed_query(const char* value, size_t size) {
  set_has_fixed_query();
  fixed_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.SpcReply.fixed_query)
}
inline ::std::string* SpcReply::mutable_fixed_query() {
  set_has_fixed_query();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcReply.fixed_query)
  return fixed_query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpcReply::release_fixed_query() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcReply.fixed_query)
  clear_has_fixed_query();
  return fixed_query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpcReply::set_allocated_fixed_query(::std::string* fixed_query) {
  if (fixed_query != NULL) {
    set_has_fixed_query();
  } else {
    clear_has_fixed_query();
  }
  fixed_query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fixed_query);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcReply.fixed_query)
}

// optional string orig_highlight = 3;
inline bool SpcReply::has_orig_highlight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpcReply::set_has_orig_highlight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpcReply::clear_has_orig_highlight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpcReply::clear_orig_highlight() {
  orig_highlight_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_orig_highlight();
}
inline const ::std::string& SpcReply::orig_highlight() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.orig_highlight)
  return orig_highlight_.GetNoArena();
}
inline void SpcReply::set_orig_highlight(const ::std::string& value) {
  set_has_orig_highlight();
  orig_highlight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcReply.orig_highlight)
}
#if LANG_CXX11
inline void SpcReply::set_orig_highlight(::std::string&& value) {
  set_has_orig_highlight();
  orig_highlight_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.SpcReply.orig_highlight)
}
#endif
inline void SpcReply::set_orig_highlight(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_orig_highlight();
  orig_highlight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.SpcReply.orig_highlight)
}
inline void SpcReply::set_orig_highlight(const char* value, size_t size) {
  set_has_orig_highlight();
  orig_highlight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.SpcReply.orig_highlight)
}
inline ::std::string* SpcReply::mutable_orig_highlight() {
  set_has_orig_highlight();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcReply.orig_highlight)
  return orig_highlight_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpcReply::release_orig_highlight() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcReply.orig_highlight)
  clear_has_orig_highlight();
  return orig_highlight_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpcReply::set_allocated_orig_highlight(::std::string* orig_highlight) {
  if (orig_highlight != NULL) {
    set_has_orig_highlight();
  } else {
    clear_has_orig_highlight();
  }
  orig_highlight_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), orig_highlight);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcReply.orig_highlight)
}

// optional string fixed_highlight = 4;
inline bool SpcReply::has_fixed_highlight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpcReply::set_has_fixed_highlight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpcReply::clear_has_fixed_highlight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpcReply::clear_fixed_highlight() {
  fixed_highlight_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fixed_highlight();
}
inline const ::std::string& SpcReply::fixed_highlight() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.fixed_highlight)
  return fixed_highlight_.GetNoArena();
}
inline void SpcReply::set_fixed_highlight(const ::std::string& value) {
  set_has_fixed_highlight();
  fixed_highlight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcReply.fixed_highlight)
}
#if LANG_CXX11
inline void SpcReply::set_fixed_highlight(::std::string&& value) {
  set_has_fixed_highlight();
  fixed_highlight_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.SpcReply.fixed_highlight)
}
#endif
inline void SpcReply::set_fixed_highlight(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fixed_highlight();
  fixed_highlight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.SpcReply.fixed_highlight)
}
inline void SpcReply::set_fixed_highlight(const char* value, size_t size) {
  set_has_fixed_highlight();
  fixed_highlight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.SpcReply.fixed_highlight)
}
inline ::std::string* SpcReply::mutable_fixed_highlight() {
  set_has_fixed_highlight();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcReply.fixed_highlight)
  return fixed_highlight_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpcReply::release_fixed_highlight() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcReply.fixed_highlight)
  clear_has_fixed_highlight();
  return fixed_highlight_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpcReply::set_allocated_fixed_highlight(::std::string* fixed_highlight) {
  if (fixed_highlight != NULL) {
    set_has_fixed_highlight();
  } else {
    clear_has_fixed_highlight();
  }
  fixed_highlight_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fixed_highlight);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcReply.fixed_highlight)
}

// optional double fix_confidence = 5;
inline bool SpcReply::has_fix_confidence() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SpcReply::set_has_fix_confidence() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SpcReply::clear_has_fix_confidence() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SpcReply::clear_fix_confidence() {
  fix_confidence_ = 0;
  clear_has_fix_confidence();
}
inline double SpcReply::fix_confidence() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.fix_confidence)
  return fix_confidence_;
}
inline void SpcReply::set_fix_confidence(double value) {
  set_has_fix_confidence();
  fix_confidence_ = value;
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcReply.fix_confidence)
}

// optional double auto_confidence = 6;
inline bool SpcReply::has_auto_confidence() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SpcReply::set_has_auto_confidence() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SpcReply::clear_has_auto_confidence() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SpcReply::clear_auto_confidence() {
  auto_confidence_ = 0;
  clear_has_auto_confidence();
}
inline double SpcReply::auto_confidence() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.auto_confidence)
  return auto_confidence_;
}
inline void SpcReply::set_auto_confidence(double value) {
  set_has_auto_confidence();
  auto_confidence_ = value;
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcReply.auto_confidence)
}

// optional .gogo.chell_specker.SpcInterleavingInfo interleaving_info = 7;
inline bool SpcReply::has_interleaving_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SpcReply::set_has_interleaving_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SpcReply::clear_has_interleaving_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SpcReply::clear_interleaving_info() {
  if (interleaving_info_ != NULL) interleaving_info_->::gogo::chell_specker::SpcInterleavingInfo::Clear();
  clear_has_interleaving_info();
}
inline const ::gogo::chell_specker::SpcInterleavingInfo& SpcReply::interleaving_info() const {
  const ::gogo::chell_specker::SpcInterleavingInfo* p = interleaving_info_;
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.interleaving_info)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::chell_specker::SpcInterleavingInfo*>(
      &::gogo::chell_specker::_SpcInterleavingInfo_default_instance_);
}
inline ::gogo::chell_specker::SpcInterleavingInfo* SpcReply::mutable_interleaving_info() {
  set_has_interleaving_info();
  if (interleaving_info_ == NULL) {
    interleaving_info_ = new ::gogo::chell_specker::SpcInterleavingInfo;
  }
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcReply.interleaving_info)
  return interleaving_info_;
}
inline ::gogo::chell_specker::SpcInterleavingInfo* SpcReply::release_interleaving_info() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcReply.interleaving_info)
  clear_has_interleaving_info();
  ::gogo::chell_specker::SpcInterleavingInfo* temp = interleaving_info_;
  interleaving_info_ = NULL;
  return temp;
}
inline void SpcReply::set_allocated_interleaving_info(::gogo::chell_specker::SpcInterleavingInfo* interleaving_info) {
  delete interleaving_info_;
  interleaving_info_ = interleaving_info;
  if (interleaving_info) {
    set_has_interleaving_info();
  } else {
    clear_has_interleaving_info();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcReply.interleaving_info)
}

// optional string fix_tags = 8;
inline bool SpcReply::has_fix_tags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpcReply::set_has_fix_tags() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpcReply::clear_has_fix_tags() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpcReply::clear_fix_tags() {
  fix_tags_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fix_tags();
}
inline const ::std::string& SpcReply::fix_tags() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.fix_tags)
  return fix_tags_.GetNoArena();
}
inline void SpcReply::set_fix_tags(const ::std::string& value) {
  set_has_fix_tags();
  fix_tags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcReply.fix_tags)
}
#if LANG_CXX11
inline void SpcReply::set_fix_tags(::std::string&& value) {
  set_has_fix_tags();
  fix_tags_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.SpcReply.fix_tags)
}
#endif
inline void SpcReply::set_fix_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fix_tags();
  fix_tags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.SpcReply.fix_tags)
}
inline void SpcReply::set_fix_tags(const char* value, size_t size) {
  set_has_fix_tags();
  fix_tags_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.SpcReply.fix_tags)
}
inline ::std::string* SpcReply::mutable_fix_tags() {
  set_has_fix_tags();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcReply.fix_tags)
  return fix_tags_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpcReply::release_fix_tags() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcReply.fix_tags)
  clear_has_fix_tags();
  return fix_tags_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpcReply::set_allocated_fix_tags(::std::string* fix_tags) {
  if (fix_tags != NULL) {
    set_has_fix_tags();
  } else {
    clear_has_fix_tags();
  }
  fix_tags_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fix_tags);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcReply.fix_tags)
}

// optional string porno_fixed_query = 9;
inline bool SpcReply::has_porno_fixed_query() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpcReply::set_has_porno_fixed_query() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpcReply::clear_has_porno_fixed_query() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpcReply::clear_porno_fixed_query() {
  porno_fixed_query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_porno_fixed_query();
}
inline const ::std::string& SpcReply::porno_fixed_query() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.porno_fixed_query)
  return porno_fixed_query_.GetNoArena();
}
inline void SpcReply::set_porno_fixed_query(const ::std::string& value) {
  set_has_porno_fixed_query();
  porno_fixed_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcReply.porno_fixed_query)
}
#if LANG_CXX11
inline void SpcReply::set_porno_fixed_query(::std::string&& value) {
  set_has_porno_fixed_query();
  porno_fixed_query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.SpcReply.porno_fixed_query)
}
#endif
inline void SpcReply::set_porno_fixed_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_porno_fixed_query();
  porno_fixed_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.SpcReply.porno_fixed_query)
}
inline void SpcReply::set_porno_fixed_query(const char* value, size_t size) {
  set_has_porno_fixed_query();
  porno_fixed_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.SpcReply.porno_fixed_query)
}
inline ::std::string* SpcReply::mutable_porno_fixed_query() {
  set_has_porno_fixed_query();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcReply.porno_fixed_query)
  return porno_fixed_query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpcReply::release_porno_fixed_query() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcReply.porno_fixed_query)
  clear_has_porno_fixed_query();
  return porno_fixed_query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpcReply::set_allocated_porno_fixed_query(::std::string* porno_fixed_query) {
  if (porno_fixed_query != NULL) {
    set_has_porno_fixed_query();
  } else {
    clear_has_porno_fixed_query();
  }
  porno_fixed_query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), porno_fixed_query);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcReply.porno_fixed_query)
}

// optional .gogo.chell_specker.FixConfidencePack fix_confidence_pack = 10;
inline bool SpcReply::has_fix_confidence_pack() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SpcReply::set_has_fix_confidence_pack() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SpcReply::clear_has_fix_confidence_pack() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SpcReply::clear_fix_confidence_pack() {
  if (fix_confidence_pack_ != NULL) fix_confidence_pack_->::gogo::chell_specker::FixConfidencePack::Clear();
  clear_has_fix_confidence_pack();
}
inline const ::gogo::chell_specker::FixConfidencePack& SpcReply::fix_confidence_pack() const {
  const ::gogo::chell_specker::FixConfidencePack* p = fix_confidence_pack_;
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.fix_confidence_pack)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::chell_specker::FixConfidencePack*>(
      &::gogo::chell_specker::_FixConfidencePack_default_instance_);
}
inline ::gogo::chell_specker::FixConfidencePack* SpcReply::mutable_fix_confidence_pack() {
  set_has_fix_confidence_pack();
  if (fix_confidence_pack_ == NULL) {
    fix_confidence_pack_ = new ::gogo::chell_specker::FixConfidencePack;
  }
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcReply.fix_confidence_pack)
  return fix_confidence_pack_;
}
inline ::gogo::chell_specker::FixConfidencePack* SpcReply::release_fix_confidence_pack() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcReply.fix_confidence_pack)
  clear_has_fix_confidence_pack();
  ::gogo::chell_specker::FixConfidencePack* temp = fix_confidence_pack_;
  fix_confidence_pack_ = NULL;
  return temp;
}
inline void SpcReply::set_allocated_fix_confidence_pack(::gogo::chell_specker::FixConfidencePack* fix_confidence_pack) {
  delete fix_confidence_pack_;
  fix_confidence_pack_ = fix_confidence_pack;
  if (fix_confidence_pack) {
    set_has_fix_confidence_pack();
  } else {
    clear_has_fix_confidence_pack();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcReply.fix_confidence_pack)
}

// optional string transliter_fixed_query = 11;
inline bool SpcReply::has_transliter_fixed_query() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SpcReply::set_has_transliter_fixed_query() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SpcReply::clear_has_transliter_fixed_query() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SpcReply::clear_transliter_fixed_query() {
  transliter_fixed_query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_transliter_fixed_query();
}
inline const ::std::string& SpcReply::transliter_fixed_query() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.transliter_fixed_query)
  return transliter_fixed_query_.GetNoArena();
}
inline void SpcReply::set_transliter_fixed_query(const ::std::string& value) {
  set_has_transliter_fixed_query();
  transliter_fixed_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcReply.transliter_fixed_query)
}
#if LANG_CXX11
inline void SpcReply::set_transliter_fixed_query(::std::string&& value) {
  set_has_transliter_fixed_query();
  transliter_fixed_query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.SpcReply.transliter_fixed_query)
}
#endif
inline void SpcReply::set_transliter_fixed_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_transliter_fixed_query();
  transliter_fixed_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.SpcReply.transliter_fixed_query)
}
inline void SpcReply::set_transliter_fixed_query(const char* value, size_t size) {
  set_has_transliter_fixed_query();
  transliter_fixed_query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.SpcReply.transliter_fixed_query)
}
inline ::std::string* SpcReply::mutable_transliter_fixed_query() {
  set_has_transliter_fixed_query();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcReply.transliter_fixed_query)
  return transliter_fixed_query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpcReply::release_transliter_fixed_query() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcReply.transliter_fixed_query)
  clear_has_transliter_fixed_query();
  return transliter_fixed_query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpcReply::set_allocated_transliter_fixed_query(::std::string* transliter_fixed_query) {
  if (transliter_fixed_query != NULL) {
    set_has_transliter_fixed_query();
  } else {
    clear_has_transliter_fixed_query();
  }
  transliter_fixed_query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transliter_fixed_query);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcReply.transliter_fixed_query)
}

// optional .gogo.chell_specker.VersionInfo version_info = 13;
inline bool SpcReply::has_version_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SpcReply::set_has_version_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SpcReply::clear_has_version_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SpcReply::clear_version_info() {
  if (version_info_ != NULL) version_info_->::gogo::chell_specker::VersionInfo::Clear();
  clear_has_version_info();
}
inline const ::gogo::chell_specker::VersionInfo& SpcReply::version_info() const {
  const ::gogo::chell_specker::VersionInfo* p = version_info_;
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.version_info)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::chell_specker::VersionInfo*>(
      &::gogo::chell_specker::_VersionInfo_default_instance_);
}
inline ::gogo::chell_specker::VersionInfo* SpcReply::mutable_version_info() {
  set_has_version_info();
  if (version_info_ == NULL) {
    version_info_ = new ::gogo::chell_specker::VersionInfo;
  }
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcReply.version_info)
  return version_info_;
}
inline ::gogo::chell_specker::VersionInfo* SpcReply::release_version_info() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcReply.version_info)
  clear_has_version_info();
  ::gogo::chell_specker::VersionInfo* temp = version_info_;
  version_info_ = NULL;
  return temp;
}
inline void SpcReply::set_allocated_version_info(::gogo::chell_specker::VersionInfo* version_info) {
  delete version_info_;
  version_info_ = version_info;
  if (version_info) {
    set_has_version_info();
  } else {
    clear_has_version_info();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcReply.version_info)
}

// optional int32 iteration_count = 14;
inline bool SpcReply::has_iteration_count() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SpcReply::set_has_iteration_count() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SpcReply::clear_has_iteration_count() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SpcReply::clear_iteration_count() {
  iteration_count_ = 0;
  clear_has_iteration_count();
}
inline ::google::protobuf::int32 SpcReply::iteration_count() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.iteration_count)
  return iteration_count_;
}
inline void SpcReply::set_iteration_count(::google::protobuf::int32 value) {
  set_has_iteration_count();
  iteration_count_ = value;
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcReply.iteration_count)
}

// optional .gogo.chell_specker.SpcWnfInfo wnf_info = 15;
inline bool SpcReply::has_wnf_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SpcReply::set_has_wnf_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SpcReply::clear_has_wnf_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SpcReply::clear_wnf_info() {
  if (wnf_info_ != NULL) wnf_info_->::gogo::chell_specker::SpcWnfInfo::Clear();
  clear_has_wnf_info();
}
inline const ::gogo::chell_specker::SpcWnfInfo& SpcReply::wnf_info() const {
  const ::gogo::chell_specker::SpcWnfInfo* p = wnf_info_;
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcReply.wnf_info)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::chell_specker::SpcWnfInfo*>(
      &::gogo::chell_specker::_SpcWnfInfo_default_instance_);
}
inline ::gogo::chell_specker::SpcWnfInfo* SpcReply::mutable_wnf_info() {
  set_has_wnf_info();
  if (wnf_info_ == NULL) {
    wnf_info_ = new ::gogo::chell_specker::SpcWnfInfo;
  }
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcReply.wnf_info)
  return wnf_info_;
}
inline ::gogo::chell_specker::SpcWnfInfo* SpcReply::release_wnf_info() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcReply.wnf_info)
  clear_has_wnf_info();
  ::gogo::chell_specker::SpcWnfInfo* temp = wnf_info_;
  wnf_info_ = NULL;
  return temp;
}
inline void SpcReply::set_allocated_wnf_info(::gogo::chell_specker::SpcWnfInfo* wnf_info) {
  delete wnf_info_;
  wnf_info_ = wnf_info;
  if (wnf_info) {
    set_has_wnf_info();
  } else {
    clear_has_wnf_info();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcReply.wnf_info)
}

// -------------------------------------------------------------------

// SpcCommentItem

// required string key = 1;
inline bool SpcCommentItem::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpcCommentItem::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpcCommentItem::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpcCommentItem::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& SpcCommentItem::key() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcCommentItem.key)
  return key_.GetNoArena();
}
inline void SpcCommentItem::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcCommentItem.key)
}
#if LANG_CXX11
inline void SpcCommentItem::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.SpcCommentItem.key)
}
#endif
inline void SpcCommentItem::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.SpcCommentItem.key)
}
inline void SpcCommentItem::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.SpcCommentItem.key)
}
inline ::std::string* SpcCommentItem::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcCommentItem.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpcCommentItem::release_key() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcCommentItem.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpcCommentItem::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcCommentItem.key)
}

// required string value = 2;
inline bool SpcCommentItem::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpcCommentItem::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpcCommentItem::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpcCommentItem::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& SpcCommentItem::value() const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcCommentItem.value)
  return value_.GetNoArena();
}
inline void SpcCommentItem::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gogo.chell_specker.SpcCommentItem.value)
}
#if LANG_CXX11
inline void SpcCommentItem::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gogo.chell_specker.SpcCommentItem.value)
}
#endif
inline void SpcCommentItem::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gogo.chell_specker.SpcCommentItem.value)
}
inline void SpcCommentItem::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gogo.chell_specker.SpcCommentItem.value)
}
inline ::std::string* SpcCommentItem::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcCommentItem.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpcCommentItem::release_value() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcCommentItem.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpcCommentItem::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcCommentItem.value)
}

// -------------------------------------------------------------------

// SpcComment

// repeated .gogo.chell_specker.SpcCommentItem data = 1;
inline int SpcComment::data_size() const {
  return data_.size();
}
inline void SpcComment::clear_data() {
  data_.Clear();
}
inline const ::gogo::chell_specker::SpcCommentItem& SpcComment::data(int index) const {
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcComment.data)
  return data_.Get(index);
}
inline ::gogo::chell_specker::SpcCommentItem* SpcComment::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcComment.data)
  return data_.Mutable(index);
}
inline ::gogo::chell_specker::SpcCommentItem* SpcComment::add_data() {
  // @@protoc_insertion_point(field_add:gogo.chell_specker.SpcComment.data)
  return data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gogo::chell_specker::SpcCommentItem >*
SpcComment::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:gogo.chell_specker.SpcComment.data)
  return &data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gogo::chell_specker::SpcCommentItem >&
SpcComment::data() const {
  // @@protoc_insertion_point(field_list:gogo.chell_specker.SpcComment.data)
  return data_;
}

// -------------------------------------------------------------------

// SpcResponse

// required .gogo.chell_specker.SpcReply reply = 1;
inline bool SpcResponse::has_reply() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpcResponse::set_has_reply() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpcResponse::clear_has_reply() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpcResponse::clear_reply() {
  if (reply_ != NULL) reply_->::gogo::chell_specker::SpcReply::Clear();
  clear_has_reply();
}
inline const ::gogo::chell_specker::SpcReply& SpcResponse::reply() const {
  const ::gogo::chell_specker::SpcReply* p = reply_;
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcResponse.reply)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::chell_specker::SpcReply*>(
      &::gogo::chell_specker::_SpcReply_default_instance_);
}
inline ::gogo::chell_specker::SpcReply* SpcResponse::mutable_reply() {
  set_has_reply();
  if (reply_ == NULL) {
    reply_ = new ::gogo::chell_specker::SpcReply;
  }
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcResponse.reply)
  return reply_;
}
inline ::gogo::chell_specker::SpcReply* SpcResponse::release_reply() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcResponse.reply)
  clear_has_reply();
  ::gogo::chell_specker::SpcReply* temp = reply_;
  reply_ = NULL;
  return temp;
}
inline void SpcResponse::set_allocated_reply(::gogo::chell_specker::SpcReply* reply) {
  delete reply_;
  reply_ = reply;
  if (reply) {
    set_has_reply();
  } else {
    clear_has_reply();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcResponse.reply)
}

// optional .gogo.chell_specker.SpcComment comment = 2;
inline bool SpcResponse::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpcResponse::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpcResponse::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpcResponse::clear_comment() {
  if (comment_ != NULL) comment_->::gogo::chell_specker::SpcComment::Clear();
  clear_has_comment();
}
inline const ::gogo::chell_specker::SpcComment& SpcResponse::comment() const {
  const ::gogo::chell_specker::SpcComment* p = comment_;
  // @@protoc_insertion_point(field_get:gogo.chell_specker.SpcResponse.comment)
  return p != NULL ? *p : *reinterpret_cast<const ::gogo::chell_specker::SpcComment*>(
      &::gogo::chell_specker::_SpcComment_default_instance_);
}
inline ::gogo::chell_specker::SpcComment* SpcResponse::mutable_comment() {
  set_has_comment();
  if (comment_ == NULL) {
    comment_ = new ::gogo::chell_specker::SpcComment;
  }
  // @@protoc_insertion_point(field_mutable:gogo.chell_specker.SpcResponse.comment)
  return comment_;
}
inline ::gogo::chell_specker::SpcComment* SpcResponse::release_comment() {
  // @@protoc_insertion_point(field_release:gogo.chell_specker.SpcResponse.comment)
  clear_has_comment();
  ::gogo::chell_specker::SpcComment* temp = comment_;
  comment_ = NULL;
  return temp;
}
inline void SpcResponse::set_allocated_comment(::gogo::chell_specker::SpcComment* comment) {
  delete comment_;
  comment_ = comment;
  if (comment) {
    set_has_comment();
  } else {
    clear_has_comment();
  }
  // @@protoc_insertion_point(field_set_allocated:gogo.chell_specker.SpcResponse.comment)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace chell_specker
}  // namespace gogo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_spellchecker_2eproto__INCLUDED
