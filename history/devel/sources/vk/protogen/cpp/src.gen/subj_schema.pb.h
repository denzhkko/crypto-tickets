// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: subj_schema.proto

#ifndef PROTOBUF_subj_5fschema_2eproto__INCLUDED
#define PROTOBUF_subj_5fschema_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "image_defs.pb.h"
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {
class AggregateRating;
class AggregateRatingDefaultTypeInternal;
extern AggregateRatingDefaultTypeInternal _AggregateRating_default_instance_;
class CreativeWork;
class CreativeWorkDefaultTypeInternal;
extern CreativeWorkDefaultTypeInternal _CreativeWork_default_instance_;
class Movie;
class MovieDefaultTypeInternal;
extern MovieDefaultTypeInternal _Movie_default_instance_;
class MovieArray;
class MovieArrayDefaultTypeInternal;
extern MovieArrayDefaultTypeInternal _MovieArray_default_instance_;
class ParsedSubject;
class ParsedSubjectDefaultTypeInternal;
extern ParsedSubjectDefaultTypeInternal _ParsedSubject_default_instance_;
class Person;
class PersonDefaultTypeInternal;
extern PersonDefaultTypeInternal _Person_default_instance_;
class PersonArray;
class PersonArrayDefaultTypeInternal;
extern PersonArrayDefaultTypeInternal _PersonArray_default_instance_;
class Rating;
class RatingDefaultTypeInternal;
extern RatingDefaultTypeInternal _Rating_default_instance_;
class StringArray;
class StringArrayDefaultTypeInternal;
extern StringArrayDefaultTypeInternal _StringArray_default_instance_;
class TVEpisode;
class TVEpisodeDefaultTypeInternal;
extern TVEpisodeDefaultTypeInternal _TVEpisode_default_instance_;
class TVEpisodeArray;
class TVEpisodeArrayDefaultTypeInternal;
extern TVEpisodeArrayDefaultTypeInternal _TVEpisodeArray_default_instance_;
class TVSeason;
class TVSeasonDefaultTypeInternal;
extern TVSeasonDefaultTypeInternal _TVSeason_default_instance_;
class TVSeasonArray;
class TVSeasonArrayDefaultTypeInternal;
extern TVSeasonArrayDefaultTypeInternal _TVSeasonArray_default_instance_;
class TVSeries;
class TVSeriesDefaultTypeInternal;
extern TVSeriesDefaultTypeInternal _TVSeries_default_instance_;
class Thing;
class ThingDefaultTypeInternal;
extern ThingDefaultTypeInternal _Thing_default_instance_;
class ThumbArray;
class ThumbArrayDefaultTypeInternal;
extern ThumbArrayDefaultTypeInternal _ThumbArray_default_instance_;
class UrlArray;
class UrlArrayDefaultTypeInternal;
extern UrlArrayDefaultTypeInternal _UrlArray_default_instance_;
}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {

namespace protobuf_subj_5fschema_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_subj_5fschema_2eproto

enum ParsedSubject_Type {
  ParsedSubject_Type_Thing = 2,
  ParsedSubject_Type_Person = 3,
  ParsedSubject_Type_Movie = 4,
  ParsedSubject_Type_TVEpisode = 5,
  ParsedSubject_Type_TVSeason = 6,
  ParsedSubject_Type_Telecast = 7
};
bool ParsedSubject_Type_IsValid(int value);
const ParsedSubject_Type ParsedSubject_Type_Type_MIN = ParsedSubject_Type_Thing;
const ParsedSubject_Type ParsedSubject_Type_Type_MAX = ParsedSubject_Type_Telecast;
const int ParsedSubject_Type_Type_ARRAYSIZE = ParsedSubject_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParsedSubject_Type_descriptor();
inline const ::std::string& ParsedSubject_Type_Name(ParsedSubject_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParsedSubject_Type_descriptor(), value);
}
inline bool ParsedSubject_Type_Parse(
    const ::std::string& name, ParsedSubject_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParsedSubject_Type>(
    ParsedSubject_Type_descriptor(), name, value);
}
// ===================================================================

class Thing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.Thing) */ {
 public:
  Thing();
  virtual ~Thing();

  Thing(const Thing& from);

  inline Thing& operator=(const Thing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Thing(Thing&& from) noexcept
    : Thing() {
    *this = ::std::move(from);
  }

  inline Thing& operator=(Thing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Thing& default_instance();

  static inline const Thing* internal_default_instance() {
    return reinterpret_cast<const Thing*>(
               &_Thing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Thing* other);
  friend void swap(Thing& a, Thing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Thing* New() const PROTOBUF_FINAL { return New(NULL); }

  Thing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Thing& from);
  void MergeFrom(const Thing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Thing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional string description = 2;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.Thing)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_description();
  void clear_has_description();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Rating : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.Rating) */ {
 public:
  Rating();
  virtual ~Rating();

  Rating(const Rating& from);

  inline Rating& operator=(const Rating& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rating(Rating&& from) noexcept
    : Rating() {
    *this = ::std::move(from);
  }

  inline Rating& operator=(Rating&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rating& default_instance();

  static inline const Rating* internal_default_instance() {
    return reinterpret_cast<const Rating*>(
               &_Rating_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Rating* other);
  friend void swap(Rating& a, Rating& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rating* New() const PROTOBUF_FINAL { return New(NULL); }

  Rating* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Rating& from);
  void MergeFrom(const Rating& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Rating* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ratingValue = 1;
  bool has_ratingvalue() const;
  void clear_ratingvalue();
  static const int kRatingValueFieldNumber = 1;
  const ::std::string& ratingvalue() const;
  void set_ratingvalue(const ::std::string& value);
  #if LANG_CXX11
  void set_ratingvalue(::std::string&& value);
  #endif
  void set_ratingvalue(const char* value);
  void set_ratingvalue(const char* value, size_t size);
  ::std::string* mutable_ratingvalue();
  ::std::string* release_ratingvalue();
  void set_allocated_ratingvalue(::std::string* ratingvalue);

  // optional string bestRating = 2;
  bool has_bestrating() const;
  void clear_bestrating();
  static const int kBestRatingFieldNumber = 2;
  const ::std::string& bestrating() const;
  void set_bestrating(const ::std::string& value);
  #if LANG_CXX11
  void set_bestrating(::std::string&& value);
  #endif
  void set_bestrating(const char* value);
  void set_bestrating(const char* value, size_t size);
  ::std::string* mutable_bestrating();
  ::std::string* release_bestrating();
  void set_allocated_bestrating(::std::string* bestrating);

  // optional string worstRating = 3;
  bool has_worstrating() const;
  void clear_worstrating();
  static const int kWorstRatingFieldNumber = 3;
  const ::std::string& worstrating() const;
  void set_worstrating(const ::std::string& value);
  #if LANG_CXX11
  void set_worstrating(::std::string&& value);
  #endif
  void set_worstrating(const char* value);
  void set_worstrating(const char* value, size_t size);
  ::std::string* mutable_worstrating();
  ::std::string* release_worstrating();
  void set_allocated_worstrating(::std::string* worstrating);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.Rating)
 private:
  void set_has_ratingvalue();
  void clear_has_ratingvalue();
  void set_has_bestrating();
  void clear_has_bestrating();
  void set_has_worstrating();
  void clear_has_worstrating();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ratingvalue_;
  ::google::protobuf::internal::ArenaStringPtr bestrating_;
  ::google::protobuf::internal::ArenaStringPtr worstrating_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AggregateRating : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.AggregateRating) */ {
 public:
  AggregateRating();
  virtual ~AggregateRating();

  AggregateRating(const AggregateRating& from);

  inline AggregateRating& operator=(const AggregateRating& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AggregateRating(AggregateRating&& from) noexcept
    : AggregateRating() {
    *this = ::std::move(from);
  }

  inline AggregateRating& operator=(AggregateRating&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AggregateRating& default_instance();

  static inline const AggregateRating* internal_default_instance() {
    return reinterpret_cast<const AggregateRating*>(
               &_AggregateRating_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AggregateRating* other);
  friend void swap(AggregateRating& a, AggregateRating& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AggregateRating* New() const PROTOBUF_FINAL { return New(NULL); }

  AggregateRating* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AggregateRating& from);
  void MergeFrom(const AggregateRating& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AggregateRating* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ru.mail.go.webbase.blobs.Rating rating = 1;
  bool has_rating() const;
  void clear_rating();
  static const int kRatingFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::Rating& rating() const;
  ::ru::mail::go::webbase::blobs::Rating* mutable_rating();
  ::ru::mail::go::webbase::blobs::Rating* release_rating();
  void set_allocated_rating(::ru::mail::go::webbase::blobs::Rating* rating);

  // required uint32 ratingCount = 2;
  bool has_ratingcount() const;
  void clear_ratingcount();
  static const int kRatingCountFieldNumber = 2;
  ::google::protobuf::uint32 ratingcount() const;
  void set_ratingcount(::google::protobuf::uint32 value);

  // optional uint32 reviewCount = 3;
  bool has_reviewcount() const;
  void clear_reviewcount();
  static const int kReviewCountFieldNumber = 3;
  ::google::protobuf::uint32 reviewcount() const;
  void set_reviewcount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.AggregateRating)
 private:
  void set_has_rating();
  void clear_has_rating();
  void set_has_ratingcount();
  void clear_has_ratingcount();
  void set_has_reviewcount();
  void clear_has_reviewcount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ru::mail::go::webbase::blobs::Rating* rating_;
  ::google::protobuf::uint32 ratingcount_;
  ::google::protobuf::uint32 reviewcount_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UrlArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.UrlArray) */ {
 public:
  UrlArray();
  virtual ~UrlArray();

  UrlArray(const UrlArray& from);

  inline UrlArray& operator=(const UrlArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UrlArray(UrlArray&& from) noexcept
    : UrlArray() {
    *this = ::std::move(from);
  }

  inline UrlArray& operator=(UrlArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UrlArray& default_instance();

  static inline const UrlArray* internal_default_instance() {
    return reinterpret_cast<const UrlArray*>(
               &_UrlArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(UrlArray* other);
  friend void swap(UrlArray& a, UrlArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UrlArray* New() const PROTOBUF_FINAL { return New(NULL); }

  UrlArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UrlArray& from);
  void MergeFrom(const UrlArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UrlArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string urls = 1;
  int urls_size() const;
  void clear_urls();
  static const int kUrlsFieldNumber = 1;
  const ::std::string& urls(int index) const;
  ::std::string* mutable_urls(int index);
  void set_urls(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_urls(int index, ::std::string&& value);
  #endif
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  ::std::string* add_urls();
  void add_urls(const ::std::string& value);
  #if LANG_CXX11
  void add_urls(::std::string&& value);
  #endif
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& urls() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_urls();

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.UrlArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> urls_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.StringArray) */ {
 public:
  StringArray();
  virtual ~StringArray();

  StringArray(const StringArray& from);

  inline StringArray& operator=(const StringArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringArray(StringArray&& from) noexcept
    : StringArray() {
    *this = ::std::move(from);
  }

  inline StringArray& operator=(StringArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringArray& default_instance();

  static inline const StringArray* internal_default_instance() {
    return reinterpret_cast<const StringArray*>(
               &_StringArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(StringArray* other);
  friend void swap(StringArray& a, StringArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringArray* New() const PROTOBUF_FINAL { return New(NULL); }

  StringArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StringArray& from);
  void MergeFrom(const StringArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StringArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.StringArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThumbArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ThumbArray) */ {
 public:
  ThumbArray();
  virtual ~ThumbArray();

  ThumbArray(const ThumbArray& from);

  inline ThumbArray& operator=(const ThumbArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThumbArray(ThumbArray&& from) noexcept
    : ThumbArray() {
    *this = ::std::move(from);
  }

  inline ThumbArray& operator=(ThumbArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThumbArray& default_instance();

  static inline const ThumbArray* internal_default_instance() {
    return reinterpret_cast<const ThumbArray*>(
               &_ThumbArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ThumbArray* other);
  friend void swap(ThumbArray& a, ThumbArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThumbArray* New() const PROTOBUF_FINAL { return New(NULL); }

  ThumbArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ThumbArray& from);
  void MergeFrom(const ThumbArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ThumbArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.parsing.img.Thumb thumbs = 1;
  int thumbs_size() const;
  void clear_thumbs();
  static const int kThumbsFieldNumber = 1;
  const ::ru::mail::go::webbase::parsing::img::Thumb& thumbs(int index) const;
  ::ru::mail::go::webbase::parsing::img::Thumb* mutable_thumbs(int index);
  ::ru::mail::go::webbase::parsing::img::Thumb* add_thumbs();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >*
      mutable_thumbs();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >&
      thumbs() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ThumbArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb > thumbs_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreativeWork : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.CreativeWork) */ {
 public:
  CreativeWork();
  virtual ~CreativeWork();

  CreativeWork(const CreativeWork& from);

  inline CreativeWork& operator=(const CreativeWork& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreativeWork(CreativeWork&& from) noexcept
    : CreativeWork() {
    *this = ::std::move(from);
  }

  inline CreativeWork& operator=(CreativeWork&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreativeWork& default_instance();

  static inline const CreativeWork* internal_default_instance() {
    return reinterpret_cast<const CreativeWork*>(
               &_CreativeWork_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(CreativeWork* other);
  friend void swap(CreativeWork& a, CreativeWork& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreativeWork* New() const PROTOBUF_FINAL { return New(NULL); }

  CreativeWork* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreativeWork& from);
  void MergeFrom(const CreativeWork& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreativeWork* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string headline = 2;
  bool has_headline() const;
  void clear_headline();
  static const int kHeadlineFieldNumber = 2;
  const ::std::string& headline() const;
  void set_headline(const ::std::string& value);
  #if LANG_CXX11
  void set_headline(::std::string&& value);
  #endif
  void set_headline(const char* value);
  void set_headline(const char* value, size_t size);
  ::std::string* mutable_headline();
  ::std::string* release_headline();
  void set_allocated_headline(::std::string* headline);

  // optional string alternativeHeadline = 3;
  bool has_alternativeheadline() const;
  void clear_alternativeheadline();
  static const int kAlternativeHeadlineFieldNumber = 3;
  const ::std::string& alternativeheadline() const;
  void set_alternativeheadline(const ::std::string& value);
  #if LANG_CXX11
  void set_alternativeheadline(::std::string&& value);
  #endif
  void set_alternativeheadline(const char* value);
  void set_alternativeheadline(const char* value, size_t size);
  ::std::string* mutable_alternativeheadline();
  ::std::string* release_alternativeheadline();
  void set_allocated_alternativeheadline(::std::string* alternativeheadline);

  // optional string datePublished = 4;
  bool has_datepublished() const;
  void clear_datepublished();
  static const int kDatePublishedFieldNumber = 4;
  const ::std::string& datepublished() const;
  void set_datepublished(const ::std::string& value);
  #if LANG_CXX11
  void set_datepublished(::std::string&& value);
  #endif
  void set_datepublished(const char* value);
  void set_datepublished(const char* value, size_t size);
  ::std::string* mutable_datepublished();
  ::std::string* release_datepublished();
  void set_allocated_datepublished(::std::string* datepublished);

  // optional string year = 5;
  bool has_year() const;
  void clear_year();
  static const int kYearFieldNumber = 5;
  const ::std::string& year() const;
  void set_year(const ::std::string& value);
  #if LANG_CXX11
  void set_year(::std::string&& value);
  #endif
  void set_year(const char* value);
  void set_year(const char* value, size_t size);
  ::std::string* mutable_year();
  ::std::string* release_year();
  void set_allocated_year(::std::string* year);

  // optional .ru.mail.go.webbase.blobs.Thing thing = 1;
  bool has_thing() const;
  void clear_thing();
  static const int kThingFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::Thing& thing() const;
  ::ru::mail::go::webbase::blobs::Thing* mutable_thing();
  ::ru::mail::go::webbase::blobs::Thing* release_thing();
  void set_allocated_thing(::ru::mail::go::webbase::blobs::Thing* thing);

  // optional .ru.mail.go.webbase.blobs.Rating rating = 6;
  bool has_rating() const;
  void clear_rating();
  static const int kRatingFieldNumber = 6;
  const ::ru::mail::go::webbase::blobs::Rating& rating() const;
  ::ru::mail::go::webbase::blobs::Rating* mutable_rating();
  ::ru::mail::go::webbase::blobs::Rating* release_rating();
  void set_allocated_rating(::ru::mail::go::webbase::blobs::Rating* rating);

  // optional .ru.mail.go.webbase.blobs.StringArray genres = 7;
  bool has_genres() const;
  void clear_genres();
  static const int kGenresFieldNumber = 7;
  const ::ru::mail::go::webbase::blobs::StringArray& genres() const;
  ::ru::mail::go::webbase::blobs::StringArray* mutable_genres();
  ::ru::mail::go::webbase::blobs::StringArray* release_genres();
  void set_allocated_genres(::ru::mail::go::webbase::blobs::StringArray* genres);

  // optional .ru.mail.go.webbase.blobs.UrlArray thumbnailUrls = 8;
  bool has_thumbnailurls() const;
  void clear_thumbnailurls();
  static const int kThumbnailUrlsFieldNumber = 8;
  const ::ru::mail::go::webbase::blobs::UrlArray& thumbnailurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_thumbnailurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_thumbnailurls();
  void set_allocated_thumbnailurls(::ru::mail::go::webbase::blobs::UrlArray* thumbnailurls);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.CreativeWork)
 private:
  void set_has_thing();
  void clear_has_thing();
  void set_has_headline();
  void clear_has_headline();
  void set_has_alternativeheadline();
  void clear_has_alternativeheadline();
  void set_has_datepublished();
  void clear_has_datepublished();
  void set_has_year();
  void clear_has_year();
  void set_has_rating();
  void clear_has_rating();
  void set_has_genres();
  void clear_has_genres();
  void set_has_thumbnailurls();
  void clear_has_thumbnailurls();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr headline_;
  ::google::protobuf::internal::ArenaStringPtr alternativeheadline_;
  ::google::protobuf::internal::ArenaStringPtr datepublished_;
  ::google::protobuf::internal::ArenaStringPtr year_;
  ::ru::mail::go::webbase::blobs::Thing* thing_;
  ::ru::mail::go::webbase::blobs::Rating* rating_;
  ::ru::mail::go::webbase::blobs::StringArray* genres_;
  ::ru::mail::go::webbase::blobs::UrlArray* thumbnailurls_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Person : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.Person) */ {
 public:
  Person();
  virtual ~Person();

  Person(const Person& from);

  inline Person& operator=(const Person& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Person(Person&& from) noexcept
    : Person() {
    *this = ::std::move(from);
  }

  inline Person& operator=(Person&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Person& default_instance();

  static inline const Person* internal_default_instance() {
    return reinterpret_cast<const Person*>(
               &_Person_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Person* other);
  friend void swap(Person& a, Person& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Person* New() const PROTOBUF_FINAL { return New(NULL); }

  Person* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Person& from);
  void MergeFrom(const Person& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Person* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string altName = 2;
  bool has_altname() const;
  void clear_altname();
  static const int kAltNameFieldNumber = 2;
  const ::std::string& altname() const;
  void set_altname(const ::std::string& value);
  #if LANG_CXX11
  void set_altname(::std::string&& value);
  #endif
  void set_altname(const char* value);
  void set_altname(const char* value, size_t size);
  ::std::string* mutable_altname();
  ::std::string* release_altname();
  void set_allocated_altname(::std::string* altname);

  // required string givenName = 3;
  bool has_givenname() const;
  void clear_givenname();
  static const int kGivenNameFieldNumber = 3;
  const ::std::string& givenname() const;
  void set_givenname(const ::std::string& value);
  #if LANG_CXX11
  void set_givenname(::std::string&& value);
  #endif
  void set_givenname(const char* value);
  void set_givenname(const char* value, size_t size);
  ::std::string* mutable_givenname();
  ::std::string* release_givenname();
  void set_allocated_givenname(::std::string* givenname);

  // optional string familyName = 4;
  bool has_familyname() const;
  void clear_familyname();
  static const int kFamilyNameFieldNumber = 4;
  const ::std::string& familyname() const;
  void set_familyname(const ::std::string& value);
  #if LANG_CXX11
  void set_familyname(::std::string&& value);
  #endif
  void set_familyname(const char* value);
  void set_familyname(const char* value, size_t size);
  ::std::string* mutable_familyname();
  ::std::string* release_familyname();
  void set_allocated_familyname(::std::string* familyname);

  // optional string additionalName = 5;
  bool has_additionalname() const;
  void clear_additionalname();
  static const int kAdditionalNameFieldNumber = 5;
  const ::std::string& additionalname() const;
  void set_additionalname(const ::std::string& value);
  #if LANG_CXX11
  void set_additionalname(::std::string&& value);
  #endif
  void set_additionalname(const char* value);
  void set_additionalname(const char* value, size_t size);
  ::std::string* mutable_additionalname();
  ::std::string* release_additionalname();
  void set_allocated_additionalname(::std::string* additionalname);

  // optional string gender = 6;
  bool has_gender() const;
  void clear_gender();
  static const int kGenderFieldNumber = 6;
  const ::std::string& gender() const;
  void set_gender(const ::std::string& value);
  #if LANG_CXX11
  void set_gender(::std::string&& value);
  #endif
  void set_gender(const char* value);
  void set_gender(const char* value, size_t size);
  ::std::string* mutable_gender();
  ::std::string* release_gender();
  void set_allocated_gender(::std::string* gender);

  // optional string birthDate = 7;
  bool has_birthdate() const;
  void clear_birthdate();
  static const int kBirthDateFieldNumber = 7;
  const ::std::string& birthdate() const;
  void set_birthdate(const ::std::string& value);
  #if LANG_CXX11
  void set_birthdate(::std::string&& value);
  #endif
  void set_birthdate(const char* value);
  void set_birthdate(const char* value, size_t size);
  ::std::string* mutable_birthdate();
  ::std::string* release_birthdate();
  void set_allocated_birthdate(::std::string* birthdate);

  // optional string deathDate = 8;
  bool has_deathdate() const;
  void clear_deathdate();
  static const int kDeathDateFieldNumber = 8;
  const ::std::string& deathdate() const;
  void set_deathdate(const ::std::string& value);
  #if LANG_CXX11
  void set_deathdate(::std::string&& value);
  #endif
  void set_deathdate(const char* value);
  void set_deathdate(const char* value, size_t size);
  ::std::string* mutable_deathdate();
  ::std::string* release_deathdate();
  void set_allocated_deathdate(::std::string* deathdate);

  // optional .ru.mail.go.webbase.blobs.Thing thing = 1;
  bool has_thing() const;
  void clear_thing();
  static const int kThingFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::Thing& thing() const;
  ::ru::mail::go::webbase::blobs::Thing* mutable_thing();
  ::ru::mail::go::webbase::blobs::Thing* release_thing();
  void set_allocated_thing(::ru::mail::go::webbase::blobs::Thing* thing);

  // optional .ru.mail.go.webbase.blobs.UrlArray thumbnailUrls = 9;
  bool has_thumbnailurls() const;
  void clear_thumbnailurls();
  static const int kThumbnailUrlsFieldNumber = 9;
  const ::ru::mail::go::webbase::blobs::UrlArray& thumbnailurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_thumbnailurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_thumbnailurls();
  void set_allocated_thumbnailurls(::ru::mail::go::webbase::blobs::UrlArray* thumbnailurls);

  // optional .ru.mail.go.webbase.blobs.UrlArray imagesUrls = 20;
  bool has_imagesurls() const;
  void clear_imagesurls();
  static const int kImagesUrlsFieldNumber = 20;
  const ::ru::mail::go::webbase::blobs::UrlArray& imagesurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_imagesurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_imagesurls();
  void set_allocated_imagesurls(::ru::mail::go::webbase::blobs::UrlArray* imagesurls);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.Person)
 private:
  void set_has_thing();
  void clear_has_thing();
  void set_has_altname();
  void clear_has_altname();
  void set_has_givenname();
  void clear_has_givenname();
  void set_has_familyname();
  void clear_has_familyname();
  void set_has_additionalname();
  void clear_has_additionalname();
  void set_has_gender();
  void clear_has_gender();
  void set_has_birthdate();
  void clear_has_birthdate();
  void set_has_deathdate();
  void clear_has_deathdate();
  void set_has_thumbnailurls();
  void clear_has_thumbnailurls();
  void set_has_imagesurls();
  void clear_has_imagesurls();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr altname_;
  ::google::protobuf::internal::ArenaStringPtr givenname_;
  ::google::protobuf::internal::ArenaStringPtr familyname_;
  ::google::protobuf::internal::ArenaStringPtr additionalname_;
  ::google::protobuf::internal::ArenaStringPtr gender_;
  ::google::protobuf::internal::ArenaStringPtr birthdate_;
  ::google::protobuf::internal::ArenaStringPtr deathdate_;
  ::ru::mail::go::webbase::blobs::Thing* thing_;
  ::ru::mail::go::webbase::blobs::UrlArray* thumbnailurls_;
  ::ru::mail::go::webbase::blobs::UrlArray* imagesurls_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PersonArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.PersonArray) */ {
 public:
  PersonArray();
  virtual ~PersonArray();

  PersonArray(const PersonArray& from);

  inline PersonArray& operator=(const PersonArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PersonArray(PersonArray&& from) noexcept
    : PersonArray() {
    *this = ::std::move(from);
  }

  inline PersonArray& operator=(PersonArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PersonArray& default_instance();

  static inline const PersonArray* internal_default_instance() {
    return reinterpret_cast<const PersonArray*>(
               &_PersonArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(PersonArray* other);
  friend void swap(PersonArray& a, PersonArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PersonArray* New() const PROTOBUF_FINAL { return New(NULL); }

  PersonArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PersonArray& from);
  void MergeFrom(const PersonArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PersonArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.Person persons = 1;
  int persons_size() const;
  void clear_persons();
  static const int kPersonsFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::Person& persons(int index) const;
  ::ru::mail::go::webbase::blobs::Person* mutable_persons(int index);
  ::ru::mail::go::webbase::blobs::Person* add_persons();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Person >*
      mutable_persons();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Person >&
      persons() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.PersonArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Person > persons_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Movie : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.Movie) */ {
 public:
  Movie();
  virtual ~Movie();

  Movie(const Movie& from);

  inline Movie& operator=(const Movie& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Movie(Movie&& from) noexcept
    : Movie() {
    *this = ::std::move(from);
  }

  inline Movie& operator=(Movie&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Movie& default_instance();

  static inline const Movie* internal_default_instance() {
    return reinterpret_cast<const Movie*>(
               &_Movie_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Movie* other);
  friend void swap(Movie& a, Movie& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Movie* New() const PROTOBUF_FINAL { return New(NULL); }

  Movie* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Movie& from);
  void MergeFrom(const Movie& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Movie* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  const ::std::string& duration() const;
  void set_duration(const ::std::string& value);
  #if LANG_CXX11
  void set_duration(::std::string&& value);
  #endif
  void set_duration(const char* value);
  void set_duration(const char* value, size_t size);
  ::std::string* mutable_duration();
  ::std::string* release_duration();
  void set_allocated_duration(::std::string* duration);

  // optional .ru.mail.go.webbase.blobs.CreativeWork work = 1;
  bool has_work() const;
  void clear_work();
  static const int kWorkFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::CreativeWork& work() const;
  ::ru::mail::go::webbase::blobs::CreativeWork* mutable_work();
  ::ru::mail::go::webbase::blobs::CreativeWork* release_work();
  void set_allocated_work(::ru::mail::go::webbase::blobs::CreativeWork* work);

  // optional .ru.mail.go.webbase.blobs.StringArray countries = 3;
  bool has_countries() const;
  void clear_countries();
  static const int kCountriesFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::StringArray& countries() const;
  ::ru::mail::go::webbase::blobs::StringArray* mutable_countries();
  ::ru::mail::go::webbase::blobs::StringArray* release_countries();
  void set_allocated_countries(::ru::mail::go::webbase::blobs::StringArray* countries);

  // optional .ru.mail.go.webbase.blobs.StringArray actors = 4;
  bool has_actors() const;
  void clear_actors();
  static const int kActorsFieldNumber = 4;
  const ::ru::mail::go::webbase::blobs::StringArray& actors() const;
  ::ru::mail::go::webbase::blobs::StringArray* mutable_actors();
  ::ru::mail::go::webbase::blobs::StringArray* release_actors();
  void set_allocated_actors(::ru::mail::go::webbase::blobs::StringArray* actors);

  // optional .ru.mail.go.webbase.blobs.StringArray directors = 5;
  bool has_directors() const;
  void clear_directors();
  static const int kDirectorsFieldNumber = 5;
  const ::ru::mail::go::webbase::blobs::StringArray& directors() const;
  ::ru::mail::go::webbase::blobs::StringArray* mutable_directors();
  ::ru::mail::go::webbase::blobs::StringArray* release_directors();
  void set_allocated_directors(::ru::mail::go::webbase::blobs::StringArray* directors);

  // optional .ru.mail.go.webbase.blobs.StringArray persons = 6;
  bool has_persons() const;
  void clear_persons();
  static const int kPersonsFieldNumber = 6;
  const ::ru::mail::go::webbase::blobs::StringArray& persons() const;
  ::ru::mail::go::webbase::blobs::StringArray* mutable_persons();
  ::ru::mail::go::webbase::blobs::StringArray* release_persons();
  void set_allocated_persons(::ru::mail::go::webbase::blobs::StringArray* persons);

  // optional .ru.mail.go.webbase.blobs.StringArray screenwriters = 7;
  bool has_screenwriters() const;
  void clear_screenwriters();
  static const int kScreenwritersFieldNumber = 7;
  const ::ru::mail::go::webbase::blobs::StringArray& screenwriters() const;
  ::ru::mail::go::webbase::blobs::StringArray* mutable_screenwriters();
  ::ru::mail::go::webbase::blobs::StringArray* release_screenwriters();
  void set_allocated_screenwriters(::ru::mail::go::webbase::blobs::StringArray* screenwriters);

  // optional .ru.mail.go.webbase.blobs.UrlArray imagesUrls = 20;
  bool has_imagesurls() const;
  void clear_imagesurls();
  static const int kImagesUrlsFieldNumber = 20;
  const ::ru::mail::go::webbase::blobs::UrlArray& imagesurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_imagesurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_imagesurls();
  void set_allocated_imagesurls(::ru::mail::go::webbase::blobs::UrlArray* imagesurls);

  // optional .ru.mail.go.webbase.blobs.UrlArray stillsUrls = 21;
  bool has_stillsurls() const;
  void clear_stillsurls();
  static const int kStillsUrlsFieldNumber = 21;
  const ::ru::mail::go::webbase::blobs::UrlArray& stillsurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_stillsurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_stillsurls();
  void set_allocated_stillsurls(::ru::mail::go::webbase::blobs::UrlArray* stillsurls);

  // optional .ru.mail.go.webbase.blobs.UrlArray trailerUrls = 22;
  bool has_trailerurls() const;
  void clear_trailerurls();
  static const int kTrailerUrlsFieldNumber = 22;
  const ::ru::mail::go::webbase::blobs::UrlArray& trailerurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_trailerurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_trailerurls();
  void set_allocated_trailerurls(::ru::mail::go::webbase::blobs::UrlArray* trailerurls);

  // optional .ru.mail.go.webbase.blobs.UrlArray officialUrls = 23;
  bool has_officialurls() const;
  void clear_officialurls();
  static const int kOfficialUrlsFieldNumber = 23;
  const ::ru::mail::go::webbase::blobs::UrlArray& officialurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_officialurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_officialurls();
  void set_allocated_officialurls(::ru::mail::go::webbase::blobs::UrlArray* officialurls);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.Movie)
 private:
  void set_has_work();
  void clear_has_work();
  void set_has_duration();
  void clear_has_duration();
  void set_has_countries();
  void clear_has_countries();
  void set_has_actors();
  void clear_has_actors();
  void set_has_directors();
  void clear_has_directors();
  void set_has_persons();
  void clear_has_persons();
  void set_has_screenwriters();
  void clear_has_screenwriters();
  void set_has_imagesurls();
  void clear_has_imagesurls();
  void set_has_stillsurls();
  void clear_has_stillsurls();
  void set_has_trailerurls();
  void clear_has_trailerurls();
  void set_has_officialurls();
  void clear_has_officialurls();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr duration_;
  ::ru::mail::go::webbase::blobs::CreativeWork* work_;
  ::ru::mail::go::webbase::blobs::StringArray* countries_;
  ::ru::mail::go::webbase::blobs::StringArray* actors_;
  ::ru::mail::go::webbase::blobs::StringArray* directors_;
  ::ru::mail::go::webbase::blobs::StringArray* persons_;
  ::ru::mail::go::webbase::blobs::StringArray* screenwriters_;
  ::ru::mail::go::webbase::blobs::UrlArray* imagesurls_;
  ::ru::mail::go::webbase::blobs::UrlArray* stillsurls_;
  ::ru::mail::go::webbase::blobs::UrlArray* trailerurls_;
  ::ru::mail::go::webbase::blobs::UrlArray* officialurls_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MovieArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.MovieArray) */ {
 public:
  MovieArray();
  virtual ~MovieArray();

  MovieArray(const MovieArray& from);

  inline MovieArray& operator=(const MovieArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MovieArray(MovieArray&& from) noexcept
    : MovieArray() {
    *this = ::std::move(from);
  }

  inline MovieArray& operator=(MovieArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MovieArray& default_instance();

  static inline const MovieArray* internal_default_instance() {
    return reinterpret_cast<const MovieArray*>(
               &_MovieArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(MovieArray* other);
  friend void swap(MovieArray& a, MovieArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MovieArray* New() const PROTOBUF_FINAL { return New(NULL); }

  MovieArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MovieArray& from);
  void MergeFrom(const MovieArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MovieArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.Movie movies = 1;
  int movies_size() const;
  void clear_movies();
  static const int kMoviesFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::Movie& movies(int index) const;
  ::ru::mail::go::webbase::blobs::Movie* mutable_movies(int index);
  ::ru::mail::go::webbase::blobs::Movie* add_movies();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Movie >*
      mutable_movies();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Movie >&
      movies() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.MovieArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Movie > movies_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TVEpisode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.TVEpisode) */ {
 public:
  TVEpisode();
  virtual ~TVEpisode();

  TVEpisode(const TVEpisode& from);

  inline TVEpisode& operator=(const TVEpisode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TVEpisode(TVEpisode&& from) noexcept
    : TVEpisode() {
    *this = ::std::move(from);
  }

  inline TVEpisode& operator=(TVEpisode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVEpisode& default_instance();

  static inline const TVEpisode* internal_default_instance() {
    return reinterpret_cast<const TVEpisode*>(
               &_TVEpisode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(TVEpisode* other);
  friend void swap(TVEpisode& a, TVEpisode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TVEpisode* New() const PROTOBUF_FINAL { return New(NULL); }

  TVEpisode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TVEpisode& from);
  void MergeFrom(const TVEpisode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TVEpisode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string startDate = 2;
  bool has_startdate() const;
  void clear_startdate();
  static const int kStartDateFieldNumber = 2;
  const ::std::string& startdate() const;
  void set_startdate(const ::std::string& value);
  #if LANG_CXX11
  void set_startdate(::std::string&& value);
  #endif
  void set_startdate(const char* value);
  void set_startdate(const char* value, size_t size);
  ::std::string* mutable_startdate();
  ::std::string* release_startdate();
  void set_allocated_startdate(::std::string* startdate);

  // optional .ru.mail.go.webbase.blobs.CreativeWork work = 1;
  bool has_work() const;
  void clear_work();
  static const int kWorkFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::CreativeWork& work() const;
  ::ru::mail::go::webbase::blobs::CreativeWork* mutable_work();
  ::ru::mail::go::webbase::blobs::CreativeWork* release_work();
  void set_allocated_work(::ru::mail::go::webbase::blobs::CreativeWork* work);

  // optional .ru.mail.go.webbase.blobs.UrlArray imagesUrls = 20;
  bool has_imagesurls() const;
  void clear_imagesurls();
  static const int kImagesUrlsFieldNumber = 20;
  const ::ru::mail::go::webbase::blobs::UrlArray& imagesurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_imagesurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_imagesurls();
  void set_allocated_imagesurls(::ru::mail::go::webbase::blobs::UrlArray* imagesurls);

  // optional .ru.mail.go.webbase.blobs.UrlArray stillsUrls = 21;
  bool has_stillsurls() const;
  void clear_stillsurls();
  static const int kStillsUrlsFieldNumber = 21;
  const ::ru::mail::go::webbase::blobs::UrlArray& stillsurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_stillsurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_stillsurls();
  void set_allocated_stillsurls(::ru::mail::go::webbase::blobs::UrlArray* stillsurls);

  // optional .ru.mail.go.webbase.blobs.UrlArray trailerUrls = 22;
  bool has_trailerurls() const;
  void clear_trailerurls();
  static const int kTrailerUrlsFieldNumber = 22;
  const ::ru::mail::go::webbase::blobs::UrlArray& trailerurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_trailerurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_trailerurls();
  void set_allocated_trailerurls(::ru::mail::go::webbase::blobs::UrlArray* trailerurls);

  // optional uint32 episodeNumber = 3;
  bool has_episodenumber() const;
  void clear_episodenumber();
  static const int kEpisodeNumberFieldNumber = 3;
  ::google::protobuf::uint32 episodenumber() const;
  void set_episodenumber(::google::protobuf::uint32 value);

  // optional uint32 partOfSeason = 4;
  bool has_partofseason() const;
  void clear_partofseason();
  static const int kPartOfSeasonFieldNumber = 4;
  ::google::protobuf::uint32 partofseason() const;
  void set_partofseason(::google::protobuf::uint32 value);

  // optional uint32 partOfTVSeries = 5;
  bool has_partoftvseries() const;
  void clear_partoftvseries();
  static const int kPartOfTVSeriesFieldNumber = 5;
  ::google::protobuf::uint32 partoftvseries() const;
  void set_partoftvseries(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.TVEpisode)
 private:
  void set_has_work();
  void clear_has_work();
  void set_has_startdate();
  void clear_has_startdate();
  void set_has_episodenumber();
  void clear_has_episodenumber();
  void set_has_partofseason();
  void clear_has_partofseason();
  void set_has_partoftvseries();
  void clear_has_partoftvseries();
  void set_has_imagesurls();
  void clear_has_imagesurls();
  void set_has_stillsurls();
  void clear_has_stillsurls();
  void set_has_trailerurls();
  void clear_has_trailerurls();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr startdate_;
  ::ru::mail::go::webbase::blobs::CreativeWork* work_;
  ::ru::mail::go::webbase::blobs::UrlArray* imagesurls_;
  ::ru::mail::go::webbase::blobs::UrlArray* stillsurls_;
  ::ru::mail::go::webbase::blobs::UrlArray* trailerurls_;
  ::google::protobuf::uint32 episodenumber_;
  ::google::protobuf::uint32 partofseason_;
  ::google::protobuf::uint32 partoftvseries_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TVEpisodeArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.TVEpisodeArray) */ {
 public:
  TVEpisodeArray();
  virtual ~TVEpisodeArray();

  TVEpisodeArray(const TVEpisodeArray& from);

  inline TVEpisodeArray& operator=(const TVEpisodeArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TVEpisodeArray(TVEpisodeArray&& from) noexcept
    : TVEpisodeArray() {
    *this = ::std::move(from);
  }

  inline TVEpisodeArray& operator=(TVEpisodeArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVEpisodeArray& default_instance();

  static inline const TVEpisodeArray* internal_default_instance() {
    return reinterpret_cast<const TVEpisodeArray*>(
               &_TVEpisodeArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(TVEpisodeArray* other);
  friend void swap(TVEpisodeArray& a, TVEpisodeArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TVEpisodeArray* New() const PROTOBUF_FINAL { return New(NULL); }

  TVEpisodeArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TVEpisodeArray& from);
  void MergeFrom(const TVEpisodeArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TVEpisodeArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.TVEpisode episodes = 1;
  int episodes_size() const;
  void clear_episodes();
  static const int kEpisodesFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::TVEpisode& episodes(int index) const;
  ::ru::mail::go::webbase::blobs::TVEpisode* mutable_episodes(int index);
  ::ru::mail::go::webbase::blobs::TVEpisode* add_episodes();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TVEpisode >*
      mutable_episodes();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TVEpisode >&
      episodes() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.TVEpisodeArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TVEpisode > episodes_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TVSeason : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.TVSeason) */ {
 public:
  TVSeason();
  virtual ~TVSeason();

  TVSeason(const TVSeason& from);

  inline TVSeason& operator=(const TVSeason& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TVSeason(TVSeason&& from) noexcept
    : TVSeason() {
    *this = ::std::move(from);
  }

  inline TVSeason& operator=(TVSeason&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVSeason& default_instance();

  static inline const TVSeason* internal_default_instance() {
    return reinterpret_cast<const TVSeason*>(
               &_TVSeason_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(TVSeason* other);
  friend void swap(TVSeason& a, TVSeason& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TVSeason* New() const PROTOBUF_FINAL { return New(NULL); }

  TVSeason* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TVSeason& from);
  void MergeFrom(const TVSeason& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TVSeason* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string startDate = 3;
  bool has_startdate() const;
  void clear_startdate();
  static const int kStartDateFieldNumber = 3;
  const ::std::string& startdate() const;
  void set_startdate(const ::std::string& value);
  #if LANG_CXX11
  void set_startdate(::std::string&& value);
  #endif
  void set_startdate(const char* value);
  void set_startdate(const char* value, size_t size);
  ::std::string* mutable_startdate();
  ::std::string* release_startdate();
  void set_allocated_startdate(::std::string* startdate);

  // optional string endDate = 4;
  bool has_enddate() const;
  void clear_enddate();
  static const int kEndDateFieldNumber = 4;
  const ::std::string& enddate() const;
  void set_enddate(const ::std::string& value);
  #if LANG_CXX11
  void set_enddate(::std::string&& value);
  #endif
  void set_enddate(const char* value);
  void set_enddate(const char* value, size_t size);
  ::std::string* mutable_enddate();
  ::std::string* release_enddate();
  void set_allocated_enddate(::std::string* enddate);

  // optional .ru.mail.go.webbase.blobs.CreativeWork work = 1;
  bool has_work() const;
  void clear_work();
  static const int kWorkFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::CreativeWork& work() const;
  ::ru::mail::go::webbase::blobs::CreativeWork* mutable_work();
  ::ru::mail::go::webbase::blobs::CreativeWork* release_work();
  void set_allocated_work(::ru::mail::go::webbase::blobs::CreativeWork* work);

  // required uint32 seasonNumber = 2;
  bool has_seasonnumber() const;
  void clear_seasonnumber();
  static const int kSeasonNumberFieldNumber = 2;
  ::google::protobuf::uint32 seasonnumber() const;
  void set_seasonnumber(::google::protobuf::uint32 value);

  // optional uint32 partOfTVSeries = 5;
  bool has_partoftvseries() const;
  void clear_partoftvseries();
  static const int kPartOfTVSeriesFieldNumber = 5;
  ::google::protobuf::uint32 partoftvseries() const;
  void set_partoftvseries(::google::protobuf::uint32 value);

  // optional uint32 numberOfEpisodes = 6;
  bool has_numberofepisodes() const;
  void clear_numberofepisodes();
  static const int kNumberOfEpisodesFieldNumber = 6;
  ::google::protobuf::uint32 numberofepisodes() const;
  void set_numberofepisodes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.TVSeason)
 private:
  void set_has_work();
  void clear_has_work();
  void set_has_seasonnumber();
  void clear_has_seasonnumber();
  void set_has_startdate();
  void clear_has_startdate();
  void set_has_enddate();
  void clear_has_enddate();
  void set_has_partoftvseries();
  void clear_has_partoftvseries();
  void set_has_numberofepisodes();
  void clear_has_numberofepisodes();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr startdate_;
  ::google::protobuf::internal::ArenaStringPtr enddate_;
  ::ru::mail::go::webbase::blobs::CreativeWork* work_;
  ::google::protobuf::uint32 seasonnumber_;
  ::google::protobuf::uint32 partoftvseries_;
  ::google::protobuf::uint32 numberofepisodes_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TVSeasonArray : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.TVSeasonArray) */ {
 public:
  TVSeasonArray();
  virtual ~TVSeasonArray();

  TVSeasonArray(const TVSeasonArray& from);

  inline TVSeasonArray& operator=(const TVSeasonArray& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TVSeasonArray(TVSeasonArray&& from) noexcept
    : TVSeasonArray() {
    *this = ::std::move(from);
  }

  inline TVSeasonArray& operator=(TVSeasonArray&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVSeasonArray& default_instance();

  static inline const TVSeasonArray* internal_default_instance() {
    return reinterpret_cast<const TVSeasonArray*>(
               &_TVSeasonArray_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(TVSeasonArray* other);
  friend void swap(TVSeasonArray& a, TVSeasonArray& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TVSeasonArray* New() const PROTOBUF_FINAL { return New(NULL); }

  TVSeasonArray* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TVSeasonArray& from);
  void MergeFrom(const TVSeasonArray& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TVSeasonArray* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.TVSeason seasons = 1;
  int seasons_size() const;
  void clear_seasons();
  static const int kSeasonsFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::TVSeason& seasons(int index) const;
  ::ru::mail::go::webbase::blobs::TVSeason* mutable_seasons(int index);
  ::ru::mail::go::webbase::blobs::TVSeason* add_seasons();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TVSeason >*
      mutable_seasons();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TVSeason >&
      seasons() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.TVSeasonArray)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TVSeason > seasons_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TVSeries : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.TVSeries) */ {
 public:
  TVSeries();
  virtual ~TVSeries();

  TVSeries(const TVSeries& from);

  inline TVSeries& operator=(const TVSeries& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TVSeries(TVSeries&& from) noexcept
    : TVSeries() {
    *this = ::std::move(from);
  }

  inline TVSeries& operator=(TVSeries&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TVSeries& default_instance();

  static inline const TVSeries* internal_default_instance() {
    return reinterpret_cast<const TVSeries*>(
               &_TVSeries_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(TVSeries* other);
  friend void swap(TVSeries& a, TVSeries& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TVSeries* New() const PROTOBUF_FINAL { return New(NULL); }

  TVSeries* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TVSeries& from);
  void MergeFrom(const TVSeries& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TVSeries* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string startDate = 2;
  bool has_startdate() const;
  void clear_startdate();
  static const int kStartDateFieldNumber = 2;
  const ::std::string& startdate() const;
  void set_startdate(const ::std::string& value);
  #if LANG_CXX11
  void set_startdate(::std::string&& value);
  #endif
  void set_startdate(const char* value);
  void set_startdate(const char* value, size_t size);
  ::std::string* mutable_startdate();
  ::std::string* release_startdate();
  void set_allocated_startdate(::std::string* startdate);

  // optional string endDate = 3;
  bool has_enddate() const;
  void clear_enddate();
  static const int kEndDateFieldNumber = 3;
  const ::std::string& enddate() const;
  void set_enddate(const ::std::string& value);
  #if LANG_CXX11
  void set_enddate(::std::string&& value);
  #endif
  void set_enddate(const char* value);
  void set_enddate(const char* value, size_t size);
  ::std::string* mutable_enddate();
  ::std::string* release_enddate();
  void set_allocated_enddate(::std::string* enddate);

  // optional .ru.mail.go.webbase.blobs.CreativeWork work = 1;
  bool has_work() const;
  void clear_work();
  static const int kWorkFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::CreativeWork& work() const;
  ::ru::mail::go::webbase::blobs::CreativeWork* mutable_work();
  ::ru::mail::go::webbase::blobs::CreativeWork* release_work();
  void set_allocated_work(::ru::mail::go::webbase::blobs::CreativeWork* work);

  // optional .ru.mail.go.webbase.blobs.StringArray actors = 5;
  bool has_actors() const;
  void clear_actors();
  static const int kActorsFieldNumber = 5;
  const ::ru::mail::go::webbase::blobs::StringArray& actors() const;
  ::ru::mail::go::webbase::blobs::StringArray* mutable_actors();
  ::ru::mail::go::webbase::blobs::StringArray* release_actors();
  void set_allocated_actors(::ru::mail::go::webbase::blobs::StringArray* actors);

  // optional .ru.mail.go.webbase.blobs.StringArray directors = 6;
  bool has_directors() const;
  void clear_directors();
  static const int kDirectorsFieldNumber = 6;
  const ::ru::mail::go::webbase::blobs::StringArray& directors() const;
  ::ru::mail::go::webbase::blobs::StringArray* mutable_directors();
  ::ru::mail::go::webbase::blobs::StringArray* release_directors();
  void set_allocated_directors(::ru::mail::go::webbase::blobs::StringArray* directors);

  // optional .ru.mail.go.webbase.blobs.StringArray persons = 7;
  bool has_persons() const;
  void clear_persons();
  static const int kPersonsFieldNumber = 7;
  const ::ru::mail::go::webbase::blobs::StringArray& persons() const;
  ::ru::mail::go::webbase::blobs::StringArray* mutable_persons();
  ::ru::mail::go::webbase::blobs::StringArray* release_persons();
  void set_allocated_persons(::ru::mail::go::webbase::blobs::StringArray* persons);

  // optional .ru.mail.go.webbase.blobs.StringArray screenwriters = 8;
  bool has_screenwriters() const;
  void clear_screenwriters();
  static const int kScreenwritersFieldNumber = 8;
  const ::ru::mail::go::webbase::blobs::StringArray& screenwriters() const;
  ::ru::mail::go::webbase::blobs::StringArray* mutable_screenwriters();
  ::ru::mail::go::webbase::blobs::StringArray* release_screenwriters();
  void set_allocated_screenwriters(::ru::mail::go::webbase::blobs::StringArray* screenwriters);

  // optional .ru.mail.go.webbase.blobs.UrlArray imagesUrls = 20;
  bool has_imagesurls() const;
  void clear_imagesurls();
  static const int kImagesUrlsFieldNumber = 20;
  const ::ru::mail::go::webbase::blobs::UrlArray& imagesurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_imagesurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_imagesurls();
  void set_allocated_imagesurls(::ru::mail::go::webbase::blobs::UrlArray* imagesurls);

  // optional .ru.mail.go.webbase.blobs.UrlArray stillsUrls = 21;
  bool has_stillsurls() const;
  void clear_stillsurls();
  static const int kStillsUrlsFieldNumber = 21;
  const ::ru::mail::go::webbase::blobs::UrlArray& stillsurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_stillsurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_stillsurls();
  void set_allocated_stillsurls(::ru::mail::go::webbase::blobs::UrlArray* stillsurls);

  // optional .ru.mail.go.webbase.blobs.UrlArray trailerUrls = 22;
  bool has_trailerurls() const;
  void clear_trailerurls();
  static const int kTrailerUrlsFieldNumber = 22;
  const ::ru::mail::go::webbase::blobs::UrlArray& trailerurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_trailerurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_trailerurls();
  void set_allocated_trailerurls(::ru::mail::go::webbase::blobs::UrlArray* trailerurls);

  // optional .ru.mail.go.webbase.blobs.UrlArray officialUrls = 23;
  bool has_officialurls() const;
  void clear_officialurls();
  static const int kOfficialUrlsFieldNumber = 23;
  const ::ru::mail::go::webbase::blobs::UrlArray& officialurls() const;
  ::ru::mail::go::webbase::blobs::UrlArray* mutable_officialurls();
  ::ru::mail::go::webbase::blobs::UrlArray* release_officialurls();
  void set_allocated_officialurls(::ru::mail::go::webbase::blobs::UrlArray* officialurls);

  // optional uint32 numberOfEpisodes = 4;
  bool has_numberofepisodes() const;
  void clear_numberofepisodes();
  static const int kNumberOfEpisodesFieldNumber = 4;
  ::google::protobuf::uint32 numberofepisodes() const;
  void set_numberofepisodes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.TVSeries)
 private:
  void set_has_work();
  void clear_has_work();
  void set_has_startdate();
  void clear_has_startdate();
  void set_has_enddate();
  void clear_has_enddate();
  void set_has_numberofepisodes();
  void clear_has_numberofepisodes();
  void set_has_actors();
  void clear_has_actors();
  void set_has_directors();
  void clear_has_directors();
  void set_has_persons();
  void clear_has_persons();
  void set_has_screenwriters();
  void clear_has_screenwriters();
  void set_has_imagesurls();
  void clear_has_imagesurls();
  void set_has_stillsurls();
  void clear_has_stillsurls();
  void set_has_trailerurls();
  void clear_has_trailerurls();
  void set_has_officialurls();
  void clear_has_officialurls();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr startdate_;
  ::google::protobuf::internal::ArenaStringPtr enddate_;
  ::ru::mail::go::webbase::blobs::CreativeWork* work_;
  ::ru::mail::go::webbase::blobs::StringArray* actors_;
  ::ru::mail::go::webbase::blobs::StringArray* directors_;
  ::ru::mail::go::webbase::blobs::StringArray* persons_;
  ::ru::mail::go::webbase::blobs::StringArray* screenwriters_;
  ::ru::mail::go::webbase::blobs::UrlArray* imagesurls_;
  ::ru::mail::go::webbase::blobs::UrlArray* stillsurls_;
  ::ru::mail::go::webbase::blobs::UrlArray* trailerurls_;
  ::ru::mail::go::webbase::blobs::UrlArray* officialurls_;
  ::google::protobuf::uint32 numberofepisodes_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParsedSubject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ParsedSubject) */ {
 public:
  ParsedSubject();
  virtual ~ParsedSubject();

  ParsedSubject(const ParsedSubject& from);

  inline ParsedSubject& operator=(const ParsedSubject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParsedSubject(ParsedSubject&& from) noexcept
    : ParsedSubject() {
    *this = ::std::move(from);
  }

  inline ParsedSubject& operator=(ParsedSubject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParsedSubject& default_instance();

  static inline const ParsedSubject* internal_default_instance() {
    return reinterpret_cast<const ParsedSubject*>(
               &_ParsedSubject_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(ParsedSubject* other);
  friend void swap(ParsedSubject& a, ParsedSubject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParsedSubject* New() const PROTOBUF_FINAL { return New(NULL); }

  ParsedSubject* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParsedSubject& from);
  void MergeFrom(const ParsedSubject& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParsedSubject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ParsedSubject_Type Type;
  static const Type Thing =
    ParsedSubject_Type_Thing;
  static const Type Person =
    ParsedSubject_Type_Person;
  static const Type Movie =
    ParsedSubject_Type_Movie;
  static const Type TVEpisode =
    ParsedSubject_Type_TVEpisode;
  static const Type TVSeason =
    ParsedSubject_Type_TVSeason;
  static const Type Telecast =
    ParsedSubject_Type_Telecast;
  static inline bool Type_IsValid(int value) {
    return ParsedSubject_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ParsedSubject_Type_Type_MIN;
  static const Type Type_MAX =
    ParsedSubject_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ParsedSubject_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ParsedSubject_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ParsedSubject_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ParsedSubject_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ru.mail.go.webbase.blobs.Thing thing = 2;
  bool has_thing() const;
  void clear_thing();
  static const int kThingFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::Thing& thing() const;
  ::ru::mail::go::webbase::blobs::Thing* mutable_thing();
  ::ru::mail::go::webbase::blobs::Thing* release_thing();
  void set_allocated_thing(::ru::mail::go::webbase::blobs::Thing* thing);

  // optional .ru.mail.go.webbase.blobs.Person person = 3;
  bool has_person() const;
  void clear_person();
  static const int kPersonFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::Person& person() const;
  ::ru::mail::go::webbase::blobs::Person* mutable_person();
  ::ru::mail::go::webbase::blobs::Person* release_person();
  void set_allocated_person(::ru::mail::go::webbase::blobs::Person* person);

  // optional .ru.mail.go.webbase.blobs.Movie movie = 4;
  bool has_movie() const;
  void clear_movie();
  static const int kMovieFieldNumber = 4;
  const ::ru::mail::go::webbase::blobs::Movie& movie() const;
  ::ru::mail::go::webbase::blobs::Movie* mutable_movie();
  ::ru::mail::go::webbase::blobs::Movie* release_movie();
  void set_allocated_movie(::ru::mail::go::webbase::blobs::Movie* movie);

  // optional .ru.mail.go.webbase.blobs.TVEpisode tvepisode = 5;
  bool has_tvepisode() const;
  void clear_tvepisode();
  static const int kTvepisodeFieldNumber = 5;
  const ::ru::mail::go::webbase::blobs::TVEpisode& tvepisode() const;
  ::ru::mail::go::webbase::blobs::TVEpisode* mutable_tvepisode();
  ::ru::mail::go::webbase::blobs::TVEpisode* release_tvepisode();
  void set_allocated_tvepisode(::ru::mail::go::webbase::blobs::TVEpisode* tvepisode);

  // optional .ru.mail.go.webbase.blobs.TVSeason tvseason = 6;
  bool has_tvseason() const;
  void clear_tvseason();
  static const int kTvseasonFieldNumber = 6;
  const ::ru::mail::go::webbase::blobs::TVSeason& tvseason() const;
  ::ru::mail::go::webbase::blobs::TVSeason* mutable_tvseason();
  ::ru::mail::go::webbase::blobs::TVSeason* release_tvseason();
  void set_allocated_tvseason(::ru::mail::go::webbase::blobs::TVSeason* tvseason);

  // optional .ru.mail.go.webbase.blobs.TVSeries telecast = 7;
  bool has_telecast() const;
  void clear_telecast();
  static const int kTelecastFieldNumber = 7;
  const ::ru::mail::go::webbase::blobs::TVSeries& telecast() const;
  ::ru::mail::go::webbase::blobs::TVSeries* mutable_telecast();
  ::ru::mail::go::webbase::blobs::TVSeries* release_telecast();
  void set_allocated_telecast(::ru::mail::go::webbase::blobs::TVSeries* telecast);

  // required .ru.mail.go.webbase.blobs.ParsedSubject.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::ParsedSubject_Type type() const;
  void set_type(::ru::mail::go::webbase::blobs::ParsedSubject_Type value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ParsedSubject)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_thing();
  void clear_has_thing();
  void set_has_person();
  void clear_has_person();
  void set_has_movie();
  void clear_has_movie();
  void set_has_tvepisode();
  void clear_has_tvepisode();
  void set_has_tvseason();
  void clear_has_tvseason();
  void set_has_telecast();
  void clear_has_telecast();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ru::mail::go::webbase::blobs::Thing* thing_;
  ::ru::mail::go::webbase::blobs::Person* person_;
  ::ru::mail::go::webbase::blobs::Movie* movie_;
  ::ru::mail::go::webbase::blobs::TVEpisode* tvepisode_;
  ::ru::mail::go::webbase::blobs::TVSeason* tvseason_;
  ::ru::mail::go::webbase::blobs::TVSeries* telecast_;
  int type_;
  friend struct protobuf_subj_5fschema_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Thing

// optional string url = 1;
inline bool Thing::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Thing::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Thing::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Thing::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& Thing::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Thing.url)
  return url_.GetNoArena();
}
inline void Thing::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Thing.url)
}
#if LANG_CXX11
inline void Thing::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Thing.url)
}
#endif
inline void Thing::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Thing.url)
}
inline void Thing::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Thing.url)
}
inline ::std::string* Thing::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Thing.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Thing::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Thing.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Thing::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Thing.url)
}

// optional string description = 2;
inline bool Thing::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Thing::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Thing::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Thing::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& Thing::description() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Thing.description)
  return description_.GetNoArena();
}
inline void Thing::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Thing.description)
}
#if LANG_CXX11
inline void Thing::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Thing.description)
}
#endif
inline void Thing::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Thing.description)
}
inline void Thing::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Thing.description)
}
inline ::std::string* Thing::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Thing.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Thing::release_description() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Thing.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Thing::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Thing.description)
}

// -------------------------------------------------------------------

// Rating

// required string ratingValue = 1;
inline bool Rating::has_ratingvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rating::set_has_ratingvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rating::clear_has_ratingvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rating::clear_ratingvalue() {
  ratingvalue_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ratingvalue();
}
inline const ::std::string& Rating::ratingvalue() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Rating.ratingValue)
  return ratingvalue_.GetNoArena();
}
inline void Rating::set_ratingvalue(const ::std::string& value) {
  set_has_ratingvalue();
  ratingvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Rating.ratingValue)
}
#if LANG_CXX11
inline void Rating::set_ratingvalue(::std::string&& value) {
  set_has_ratingvalue();
  ratingvalue_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Rating.ratingValue)
}
#endif
inline void Rating::set_ratingvalue(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ratingvalue();
  ratingvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Rating.ratingValue)
}
inline void Rating::set_ratingvalue(const char* value, size_t size) {
  set_has_ratingvalue();
  ratingvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Rating.ratingValue)
}
inline ::std::string* Rating::mutable_ratingvalue() {
  set_has_ratingvalue();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Rating.ratingValue)
  return ratingvalue_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rating::release_ratingvalue() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Rating.ratingValue)
  clear_has_ratingvalue();
  return ratingvalue_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rating::set_allocated_ratingvalue(::std::string* ratingvalue) {
  if (ratingvalue != NULL) {
    set_has_ratingvalue();
  } else {
    clear_has_ratingvalue();
  }
  ratingvalue_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ratingvalue);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Rating.ratingValue)
}

// optional string bestRating = 2;
inline bool Rating::has_bestrating() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rating::set_has_bestrating() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rating::clear_has_bestrating() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rating::clear_bestrating() {
  bestrating_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bestrating();
}
inline const ::std::string& Rating::bestrating() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Rating.bestRating)
  return bestrating_.GetNoArena();
}
inline void Rating::set_bestrating(const ::std::string& value) {
  set_has_bestrating();
  bestrating_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Rating.bestRating)
}
#if LANG_CXX11
inline void Rating::set_bestrating(::std::string&& value) {
  set_has_bestrating();
  bestrating_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Rating.bestRating)
}
#endif
inline void Rating::set_bestrating(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bestrating();
  bestrating_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Rating.bestRating)
}
inline void Rating::set_bestrating(const char* value, size_t size) {
  set_has_bestrating();
  bestrating_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Rating.bestRating)
}
inline ::std::string* Rating::mutable_bestrating() {
  set_has_bestrating();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Rating.bestRating)
  return bestrating_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rating::release_bestrating() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Rating.bestRating)
  clear_has_bestrating();
  return bestrating_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rating::set_allocated_bestrating(::std::string* bestrating) {
  if (bestrating != NULL) {
    set_has_bestrating();
  } else {
    clear_has_bestrating();
  }
  bestrating_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bestrating);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Rating.bestRating)
}

// optional string worstRating = 3;
inline bool Rating::has_worstrating() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rating::set_has_worstrating() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rating::clear_has_worstrating() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rating::clear_worstrating() {
  worstrating_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_worstrating();
}
inline const ::std::string& Rating::worstrating() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Rating.worstRating)
  return worstrating_.GetNoArena();
}
inline void Rating::set_worstrating(const ::std::string& value) {
  set_has_worstrating();
  worstrating_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Rating.worstRating)
}
#if LANG_CXX11
inline void Rating::set_worstrating(::std::string&& value) {
  set_has_worstrating();
  worstrating_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Rating.worstRating)
}
#endif
inline void Rating::set_worstrating(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_worstrating();
  worstrating_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Rating.worstRating)
}
inline void Rating::set_worstrating(const char* value, size_t size) {
  set_has_worstrating();
  worstrating_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Rating.worstRating)
}
inline ::std::string* Rating::mutable_worstrating() {
  set_has_worstrating();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Rating.worstRating)
  return worstrating_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Rating::release_worstrating() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Rating.worstRating)
  clear_has_worstrating();
  return worstrating_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Rating::set_allocated_worstrating(::std::string* worstrating) {
  if (worstrating != NULL) {
    set_has_worstrating();
  } else {
    clear_has_worstrating();
  }
  worstrating_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), worstrating);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Rating.worstRating)
}

// -------------------------------------------------------------------

// AggregateRating

// optional .ru.mail.go.webbase.blobs.Rating rating = 1;
inline bool AggregateRating::has_rating() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AggregateRating::set_has_rating() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AggregateRating::clear_has_rating() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AggregateRating::clear_rating() {
  if (rating_ != NULL) rating_->::ru::mail::go::webbase::blobs::Rating::Clear();
  clear_has_rating();
}
inline const ::ru::mail::go::webbase::blobs::Rating& AggregateRating::rating() const {
  const ::ru::mail::go::webbase::blobs::Rating* p = rating_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.AggregateRating.rating)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::Rating*>(
      &::ru::mail::go::webbase::blobs::_Rating_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::Rating* AggregateRating::mutable_rating() {
  set_has_rating();
  if (rating_ == NULL) {
    rating_ = new ::ru::mail::go::webbase::blobs::Rating;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.AggregateRating.rating)
  return rating_;
}
inline ::ru::mail::go::webbase::blobs::Rating* AggregateRating::release_rating() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.AggregateRating.rating)
  clear_has_rating();
  ::ru::mail::go::webbase::blobs::Rating* temp = rating_;
  rating_ = NULL;
  return temp;
}
inline void AggregateRating::set_allocated_rating(::ru::mail::go::webbase::blobs::Rating* rating) {
  delete rating_;
  rating_ = rating;
  if (rating) {
    set_has_rating();
  } else {
    clear_has_rating();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.AggregateRating.rating)
}

// required uint32 ratingCount = 2;
inline bool AggregateRating::has_ratingcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AggregateRating::set_has_ratingcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AggregateRating::clear_has_ratingcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AggregateRating::clear_ratingcount() {
  ratingcount_ = 0u;
  clear_has_ratingcount();
}
inline ::google::protobuf::uint32 AggregateRating::ratingcount() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.AggregateRating.ratingCount)
  return ratingcount_;
}
inline void AggregateRating::set_ratingcount(::google::protobuf::uint32 value) {
  set_has_ratingcount();
  ratingcount_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.AggregateRating.ratingCount)
}

// optional uint32 reviewCount = 3;
inline bool AggregateRating::has_reviewcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AggregateRating::set_has_reviewcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AggregateRating::clear_has_reviewcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AggregateRating::clear_reviewcount() {
  reviewcount_ = 0u;
  clear_has_reviewcount();
}
inline ::google::protobuf::uint32 AggregateRating::reviewcount() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.AggregateRating.reviewCount)
  return reviewcount_;
}
inline void AggregateRating::set_reviewcount(::google::protobuf::uint32 value) {
  set_has_reviewcount();
  reviewcount_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.AggregateRating.reviewCount)
}

// -------------------------------------------------------------------

// UrlArray

// repeated string urls = 1;
inline int UrlArray::urls_size() const {
  return urls_.size();
}
inline void UrlArray::clear_urls() {
  urls_.Clear();
}
inline const ::std::string& UrlArray::urls(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlArray.urls)
  return urls_.Get(index);
}
inline ::std::string* UrlArray::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlArray.urls)
  return urls_.Mutable(index);
}
inline void UrlArray::set_urls(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlArray.urls)
  urls_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void UrlArray::set_urls(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlArray.urls)
  urls_.Mutable(index)->assign(std::move(value));
}
#endif
inline void UrlArray::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.UrlArray.urls)
}
inline void UrlArray::set_urls(int index, const char* value, size_t size) {
  urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.UrlArray.urls)
}
inline ::std::string* UrlArray::add_urls() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.UrlArray.urls)
  return urls_.Add();
}
inline void UrlArray::add_urls(const ::std::string& value) {
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.UrlArray.urls)
}
#if LANG_CXX11
inline void UrlArray::add_urls(::std::string&& value) {
  urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.UrlArray.urls)
}
#endif
inline void UrlArray::add_urls(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.UrlArray.urls)
}
inline void UrlArray::add_urls(const char* value, size_t size) {
  urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.UrlArray.urls)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UrlArray::urls() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.UrlArray.urls)
  return urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UrlArray::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.UrlArray.urls)
  return &urls_;
}

// -------------------------------------------------------------------

// StringArray

// repeated string values = 1;
inline int StringArray::values_size() const {
  return values_.size();
}
inline void StringArray::clear_values() {
  values_.Clear();
}
inline const ::std::string& StringArray::values(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.StringArray.values)
  return values_.Get(index);
}
inline ::std::string* StringArray::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.StringArray.values)
  return values_.Mutable(index);
}
inline void StringArray::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.StringArray.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StringArray::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.StringArray.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StringArray::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.StringArray.values)
}
inline void StringArray::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.StringArray.values)
}
inline ::std::string* StringArray::add_values() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.StringArray.values)
  return values_.Add();
}
inline void StringArray::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.StringArray.values)
}
#if LANG_CXX11
inline void StringArray::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.StringArray.values)
}
#endif
inline void StringArray::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.StringArray.values)
}
inline void StringArray::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.StringArray.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringArray::values() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.StringArray.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringArray::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.StringArray.values)
  return &values_;
}

// -------------------------------------------------------------------

// ThumbArray

// repeated .ru.mail.go.webbase.parsing.img.Thumb thumbs = 1;
inline int ThumbArray::thumbs_size() const {
  return thumbs_.size();
}
inline void ThumbArray::clear_thumbs() {
  thumbs_.Clear();
}
inline const ::ru::mail::go::webbase::parsing::img::Thumb& ThumbArray::thumbs(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ThumbArray.thumbs)
  return thumbs_.Get(index);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ThumbArray::mutable_thumbs(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ThumbArray.thumbs)
  return thumbs_.Mutable(index);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ThumbArray::add_thumbs() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ThumbArray.thumbs)
  return thumbs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >*
ThumbArray::mutable_thumbs() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ThumbArray.thumbs)
  return &thumbs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >&
ThumbArray::thumbs() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ThumbArray.thumbs)
  return thumbs_;
}

// -------------------------------------------------------------------

// CreativeWork

// optional .ru.mail.go.webbase.blobs.Thing thing = 1;
inline bool CreativeWork::has_thing() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreativeWork::set_has_thing() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreativeWork::clear_has_thing() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreativeWork::clear_thing() {
  if (thing_ != NULL) thing_->::ru::mail::go::webbase::blobs::Thing::Clear();
  clear_has_thing();
}
inline const ::ru::mail::go::webbase::blobs::Thing& CreativeWork::thing() const {
  const ::ru::mail::go::webbase::blobs::Thing* p = thing_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CreativeWork.thing)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::Thing*>(
      &::ru::mail::go::webbase::blobs::_Thing_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::Thing* CreativeWork::mutable_thing() {
  set_has_thing();
  if (thing_ == NULL) {
    thing_ = new ::ru::mail::go::webbase::blobs::Thing;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CreativeWork.thing)
  return thing_;
}
inline ::ru::mail::go::webbase::blobs::Thing* CreativeWork::release_thing() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CreativeWork.thing)
  clear_has_thing();
  ::ru::mail::go::webbase::blobs::Thing* temp = thing_;
  thing_ = NULL;
  return temp;
}
inline void CreativeWork::set_allocated_thing(::ru::mail::go::webbase::blobs::Thing* thing) {
  delete thing_;
  thing_ = thing;
  if (thing) {
    set_has_thing();
  } else {
    clear_has_thing();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CreativeWork.thing)
}

// optional string headline = 2;
inline bool CreativeWork::has_headline() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreativeWork::set_has_headline() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreativeWork::clear_has_headline() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreativeWork::clear_headline() {
  headline_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_headline();
}
inline const ::std::string& CreativeWork::headline() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CreativeWork.headline)
  return headline_.GetNoArena();
}
inline void CreativeWork::set_headline(const ::std::string& value) {
  set_has_headline();
  headline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CreativeWork.headline)
}
#if LANG_CXX11
inline void CreativeWork::set_headline(::std::string&& value) {
  set_has_headline();
  headline_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.CreativeWork.headline)
}
#endif
inline void CreativeWork::set_headline(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_headline();
  headline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.CreativeWork.headline)
}
inline void CreativeWork::set_headline(const char* value, size_t size) {
  set_has_headline();
  headline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.CreativeWork.headline)
}
inline ::std::string* CreativeWork::mutable_headline() {
  set_has_headline();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CreativeWork.headline)
  return headline_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreativeWork::release_headline() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CreativeWork.headline)
  clear_has_headline();
  return headline_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreativeWork::set_allocated_headline(::std::string* headline) {
  if (headline != NULL) {
    set_has_headline();
  } else {
    clear_has_headline();
  }
  headline_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headline);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CreativeWork.headline)
}

// optional string alternativeHeadline = 3;
inline bool CreativeWork::has_alternativeheadline() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreativeWork::set_has_alternativeheadline() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreativeWork::clear_has_alternativeheadline() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreativeWork::clear_alternativeheadline() {
  alternativeheadline_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alternativeheadline();
}
inline const ::std::string& CreativeWork::alternativeheadline() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CreativeWork.alternativeHeadline)
  return alternativeheadline_.GetNoArena();
}
inline void CreativeWork::set_alternativeheadline(const ::std::string& value) {
  set_has_alternativeheadline();
  alternativeheadline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CreativeWork.alternativeHeadline)
}
#if LANG_CXX11
inline void CreativeWork::set_alternativeheadline(::std::string&& value) {
  set_has_alternativeheadline();
  alternativeheadline_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.CreativeWork.alternativeHeadline)
}
#endif
inline void CreativeWork::set_alternativeheadline(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_alternativeheadline();
  alternativeheadline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.CreativeWork.alternativeHeadline)
}
inline void CreativeWork::set_alternativeheadline(const char* value, size_t size) {
  set_has_alternativeheadline();
  alternativeheadline_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.CreativeWork.alternativeHeadline)
}
inline ::std::string* CreativeWork::mutable_alternativeheadline() {
  set_has_alternativeheadline();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CreativeWork.alternativeHeadline)
  return alternativeheadline_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreativeWork::release_alternativeheadline() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CreativeWork.alternativeHeadline)
  clear_has_alternativeheadline();
  return alternativeheadline_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreativeWork::set_allocated_alternativeheadline(::std::string* alternativeheadline) {
  if (alternativeheadline != NULL) {
    set_has_alternativeheadline();
  } else {
    clear_has_alternativeheadline();
  }
  alternativeheadline_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alternativeheadline);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CreativeWork.alternativeHeadline)
}

// optional string datePublished = 4;
inline bool CreativeWork::has_datepublished() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreativeWork::set_has_datepublished() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreativeWork::clear_has_datepublished() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreativeWork::clear_datepublished() {
  datepublished_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_datepublished();
}
inline const ::std::string& CreativeWork::datepublished() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CreativeWork.datePublished)
  return datepublished_.GetNoArena();
}
inline void CreativeWork::set_datepublished(const ::std::string& value) {
  set_has_datepublished();
  datepublished_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CreativeWork.datePublished)
}
#if LANG_CXX11
inline void CreativeWork::set_datepublished(::std::string&& value) {
  set_has_datepublished();
  datepublished_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.CreativeWork.datePublished)
}
#endif
inline void CreativeWork::set_datepublished(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_datepublished();
  datepublished_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.CreativeWork.datePublished)
}
inline void CreativeWork::set_datepublished(const char* value, size_t size) {
  set_has_datepublished();
  datepublished_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.CreativeWork.datePublished)
}
inline ::std::string* CreativeWork::mutable_datepublished() {
  set_has_datepublished();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CreativeWork.datePublished)
  return datepublished_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreativeWork::release_datepublished() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CreativeWork.datePublished)
  clear_has_datepublished();
  return datepublished_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreativeWork::set_allocated_datepublished(::std::string* datepublished) {
  if (datepublished != NULL) {
    set_has_datepublished();
  } else {
    clear_has_datepublished();
  }
  datepublished_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), datepublished);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CreativeWork.datePublished)
}

// optional string year = 5;
inline bool CreativeWork::has_year() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreativeWork::set_has_year() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreativeWork::clear_has_year() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreativeWork::clear_year() {
  year_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_year();
}
inline const ::std::string& CreativeWork::year() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CreativeWork.year)
  return year_.GetNoArena();
}
inline void CreativeWork::set_year(const ::std::string& value) {
  set_has_year();
  year_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CreativeWork.year)
}
#if LANG_CXX11
inline void CreativeWork::set_year(::std::string&& value) {
  set_has_year();
  year_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.CreativeWork.year)
}
#endif
inline void CreativeWork::set_year(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_year();
  year_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.CreativeWork.year)
}
inline void CreativeWork::set_year(const char* value, size_t size) {
  set_has_year();
  year_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.CreativeWork.year)
}
inline ::std::string* CreativeWork::mutable_year() {
  set_has_year();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CreativeWork.year)
  return year_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreativeWork::release_year() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CreativeWork.year)
  clear_has_year();
  return year_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreativeWork::set_allocated_year(::std::string* year) {
  if (year != NULL) {
    set_has_year();
  } else {
    clear_has_year();
  }
  year_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), year);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CreativeWork.year)
}

// optional .ru.mail.go.webbase.blobs.Rating rating = 6;
inline bool CreativeWork::has_rating() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreativeWork::set_has_rating() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreativeWork::clear_has_rating() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreativeWork::clear_rating() {
  if (rating_ != NULL) rating_->::ru::mail::go::webbase::blobs::Rating::Clear();
  clear_has_rating();
}
inline const ::ru::mail::go::webbase::blobs::Rating& CreativeWork::rating() const {
  const ::ru::mail::go::webbase::blobs::Rating* p = rating_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CreativeWork.rating)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::Rating*>(
      &::ru::mail::go::webbase::blobs::_Rating_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::Rating* CreativeWork::mutable_rating() {
  set_has_rating();
  if (rating_ == NULL) {
    rating_ = new ::ru::mail::go::webbase::blobs::Rating;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CreativeWork.rating)
  return rating_;
}
inline ::ru::mail::go::webbase::blobs::Rating* CreativeWork::release_rating() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CreativeWork.rating)
  clear_has_rating();
  ::ru::mail::go::webbase::blobs::Rating* temp = rating_;
  rating_ = NULL;
  return temp;
}
inline void CreativeWork::set_allocated_rating(::ru::mail::go::webbase::blobs::Rating* rating) {
  delete rating_;
  rating_ = rating;
  if (rating) {
    set_has_rating();
  } else {
    clear_has_rating();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CreativeWork.rating)
}

// optional .ru.mail.go.webbase.blobs.StringArray genres = 7;
inline bool CreativeWork::has_genres() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreativeWork::set_has_genres() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreativeWork::clear_has_genres() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreativeWork::clear_genres() {
  if (genres_ != NULL) genres_->::ru::mail::go::webbase::blobs::StringArray::Clear();
  clear_has_genres();
}
inline const ::ru::mail::go::webbase::blobs::StringArray& CreativeWork::genres() const {
  const ::ru::mail::go::webbase::blobs::StringArray* p = genres_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CreativeWork.genres)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::StringArray*>(
      &::ru::mail::go::webbase::blobs::_StringArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::StringArray* CreativeWork::mutable_genres() {
  set_has_genres();
  if (genres_ == NULL) {
    genres_ = new ::ru::mail::go::webbase::blobs::StringArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CreativeWork.genres)
  return genres_;
}
inline ::ru::mail::go::webbase::blobs::StringArray* CreativeWork::release_genres() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CreativeWork.genres)
  clear_has_genres();
  ::ru::mail::go::webbase::blobs::StringArray* temp = genres_;
  genres_ = NULL;
  return temp;
}
inline void CreativeWork::set_allocated_genres(::ru::mail::go::webbase::blobs::StringArray* genres) {
  delete genres_;
  genres_ = genres;
  if (genres) {
    set_has_genres();
  } else {
    clear_has_genres();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CreativeWork.genres)
}

// optional .ru.mail.go.webbase.blobs.UrlArray thumbnailUrls = 8;
inline bool CreativeWork::has_thumbnailurls() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreativeWork::set_has_thumbnailurls() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreativeWork::clear_has_thumbnailurls() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreativeWork::clear_thumbnailurls() {
  if (thumbnailurls_ != NULL) thumbnailurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_thumbnailurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& CreativeWork::thumbnailurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = thumbnailurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CreativeWork.thumbnailUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* CreativeWork::mutable_thumbnailurls() {
  set_has_thumbnailurls();
  if (thumbnailurls_ == NULL) {
    thumbnailurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CreativeWork.thumbnailUrls)
  return thumbnailurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* CreativeWork::release_thumbnailurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CreativeWork.thumbnailUrls)
  clear_has_thumbnailurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = thumbnailurls_;
  thumbnailurls_ = NULL;
  return temp;
}
inline void CreativeWork::set_allocated_thumbnailurls(::ru::mail::go::webbase::blobs::UrlArray* thumbnailurls) {
  delete thumbnailurls_;
  thumbnailurls_ = thumbnailurls;
  if (thumbnailurls) {
    set_has_thumbnailurls();
  } else {
    clear_has_thumbnailurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CreativeWork.thumbnailUrls)
}

// -------------------------------------------------------------------

// Person

// optional .ru.mail.go.webbase.blobs.Thing thing = 1;
inline bool Person::has_thing() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Person::set_has_thing() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Person::clear_has_thing() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Person::clear_thing() {
  if (thing_ != NULL) thing_->::ru::mail::go::webbase::blobs::Thing::Clear();
  clear_has_thing();
}
inline const ::ru::mail::go::webbase::blobs::Thing& Person::thing() const {
  const ::ru::mail::go::webbase::blobs::Thing* p = thing_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Person.thing)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::Thing*>(
      &::ru::mail::go::webbase::blobs::_Thing_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::Thing* Person::mutable_thing() {
  set_has_thing();
  if (thing_ == NULL) {
    thing_ = new ::ru::mail::go::webbase::blobs::Thing;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Person.thing)
  return thing_;
}
inline ::ru::mail::go::webbase::blobs::Thing* Person::release_thing() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Person.thing)
  clear_has_thing();
  ::ru::mail::go::webbase::blobs::Thing* temp = thing_;
  thing_ = NULL;
  return temp;
}
inline void Person::set_allocated_thing(::ru::mail::go::webbase::blobs::Thing* thing) {
  delete thing_;
  thing_ = thing;
  if (thing) {
    set_has_thing();
  } else {
    clear_has_thing();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Person.thing)
}

// optional string altName = 2;
inline bool Person::has_altname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Person::set_has_altname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Person::clear_has_altname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Person::clear_altname() {
  altname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_altname();
}
inline const ::std::string& Person::altname() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Person.altName)
  return altname_.GetNoArena();
}
inline void Person::set_altname(const ::std::string& value) {
  set_has_altname();
  altname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Person.altName)
}
#if LANG_CXX11
inline void Person::set_altname(::std::string&& value) {
  set_has_altname();
  altname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Person.altName)
}
#endif
inline void Person::set_altname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_altname();
  altname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Person.altName)
}
inline void Person::set_altname(const char* value, size_t size) {
  set_has_altname();
  altname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Person.altName)
}
inline ::std::string* Person::mutable_altname() {
  set_has_altname();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Person.altName)
  return altname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Person::release_altname() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Person.altName)
  clear_has_altname();
  return altname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Person::set_allocated_altname(::std::string* altname) {
  if (altname != NULL) {
    set_has_altname();
  } else {
    clear_has_altname();
  }
  altname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), altname);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Person.altName)
}

// required string givenName = 3;
inline bool Person::has_givenname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Person::set_has_givenname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Person::clear_has_givenname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Person::clear_givenname() {
  givenname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_givenname();
}
inline const ::std::string& Person::givenname() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Person.givenName)
  return givenname_.GetNoArena();
}
inline void Person::set_givenname(const ::std::string& value) {
  set_has_givenname();
  givenname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Person.givenName)
}
#if LANG_CXX11
inline void Person::set_givenname(::std::string&& value) {
  set_has_givenname();
  givenname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Person.givenName)
}
#endif
inline void Person::set_givenname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_givenname();
  givenname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Person.givenName)
}
inline void Person::set_givenname(const char* value, size_t size) {
  set_has_givenname();
  givenname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Person.givenName)
}
inline ::std::string* Person::mutable_givenname() {
  set_has_givenname();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Person.givenName)
  return givenname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Person::release_givenname() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Person.givenName)
  clear_has_givenname();
  return givenname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Person::set_allocated_givenname(::std::string* givenname) {
  if (givenname != NULL) {
    set_has_givenname();
  } else {
    clear_has_givenname();
  }
  givenname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), givenname);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Person.givenName)
}

// optional string familyName = 4;
inline bool Person::has_familyname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Person::set_has_familyname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Person::clear_has_familyname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Person::clear_familyname() {
  familyname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_familyname();
}
inline const ::std::string& Person::familyname() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Person.familyName)
  return familyname_.GetNoArena();
}
inline void Person::set_familyname(const ::std::string& value) {
  set_has_familyname();
  familyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Person.familyName)
}
#if LANG_CXX11
inline void Person::set_familyname(::std::string&& value) {
  set_has_familyname();
  familyname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Person.familyName)
}
#endif
inline void Person::set_familyname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_familyname();
  familyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Person.familyName)
}
inline void Person::set_familyname(const char* value, size_t size) {
  set_has_familyname();
  familyname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Person.familyName)
}
inline ::std::string* Person::mutable_familyname() {
  set_has_familyname();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Person.familyName)
  return familyname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Person::release_familyname() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Person.familyName)
  clear_has_familyname();
  return familyname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Person::set_allocated_familyname(::std::string* familyname) {
  if (familyname != NULL) {
    set_has_familyname();
  } else {
    clear_has_familyname();
  }
  familyname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), familyname);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Person.familyName)
}

// optional string additionalName = 5;
inline bool Person::has_additionalname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Person::set_has_additionalname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Person::clear_has_additionalname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Person::clear_additionalname() {
  additionalname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_additionalname();
}
inline const ::std::string& Person::additionalname() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Person.additionalName)
  return additionalname_.GetNoArena();
}
inline void Person::set_additionalname(const ::std::string& value) {
  set_has_additionalname();
  additionalname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Person.additionalName)
}
#if LANG_CXX11
inline void Person::set_additionalname(::std::string&& value) {
  set_has_additionalname();
  additionalname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Person.additionalName)
}
#endif
inline void Person::set_additionalname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_additionalname();
  additionalname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Person.additionalName)
}
inline void Person::set_additionalname(const char* value, size_t size) {
  set_has_additionalname();
  additionalname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Person.additionalName)
}
inline ::std::string* Person::mutable_additionalname() {
  set_has_additionalname();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Person.additionalName)
  return additionalname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Person::release_additionalname() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Person.additionalName)
  clear_has_additionalname();
  return additionalname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Person::set_allocated_additionalname(::std::string* additionalname) {
  if (additionalname != NULL) {
    set_has_additionalname();
  } else {
    clear_has_additionalname();
  }
  additionalname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), additionalname);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Person.additionalName)
}

// optional string gender = 6;
inline bool Person::has_gender() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Person::set_has_gender() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Person::clear_has_gender() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Person::clear_gender() {
  gender_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gender();
}
inline const ::std::string& Person::gender() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Person.gender)
  return gender_.GetNoArena();
}
inline void Person::set_gender(const ::std::string& value) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Person.gender)
}
#if LANG_CXX11
inline void Person::set_gender(::std::string&& value) {
  set_has_gender();
  gender_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Person.gender)
}
#endif
inline void Person::set_gender(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Person.gender)
}
inline void Person::set_gender(const char* value, size_t size) {
  set_has_gender();
  gender_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Person.gender)
}
inline ::std::string* Person::mutable_gender() {
  set_has_gender();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Person.gender)
  return gender_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Person::release_gender() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Person.gender)
  clear_has_gender();
  return gender_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Person::set_allocated_gender(::std::string* gender) {
  if (gender != NULL) {
    set_has_gender();
  } else {
    clear_has_gender();
  }
  gender_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gender);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Person.gender)
}

// optional string birthDate = 7;
inline bool Person::has_birthdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Person::set_has_birthdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Person::clear_has_birthdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Person::clear_birthdate() {
  birthdate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_birthdate();
}
inline const ::std::string& Person::birthdate() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Person.birthDate)
  return birthdate_.GetNoArena();
}
inline void Person::set_birthdate(const ::std::string& value) {
  set_has_birthdate();
  birthdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Person.birthDate)
}
#if LANG_CXX11
inline void Person::set_birthdate(::std::string&& value) {
  set_has_birthdate();
  birthdate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Person.birthDate)
}
#endif
inline void Person::set_birthdate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_birthdate();
  birthdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Person.birthDate)
}
inline void Person::set_birthdate(const char* value, size_t size) {
  set_has_birthdate();
  birthdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Person.birthDate)
}
inline ::std::string* Person::mutable_birthdate() {
  set_has_birthdate();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Person.birthDate)
  return birthdate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Person::release_birthdate() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Person.birthDate)
  clear_has_birthdate();
  return birthdate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Person::set_allocated_birthdate(::std::string* birthdate) {
  if (birthdate != NULL) {
    set_has_birthdate();
  } else {
    clear_has_birthdate();
  }
  birthdate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), birthdate);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Person.birthDate)
}

// optional string deathDate = 8;
inline bool Person::has_deathdate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Person::set_has_deathdate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Person::clear_has_deathdate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Person::clear_deathdate() {
  deathdate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_deathdate();
}
inline const ::std::string& Person::deathdate() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Person.deathDate)
  return deathdate_.GetNoArena();
}
inline void Person::set_deathdate(const ::std::string& value) {
  set_has_deathdate();
  deathdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Person.deathDate)
}
#if LANG_CXX11
inline void Person::set_deathdate(::std::string&& value) {
  set_has_deathdate();
  deathdate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Person.deathDate)
}
#endif
inline void Person::set_deathdate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_deathdate();
  deathdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Person.deathDate)
}
inline void Person::set_deathdate(const char* value, size_t size) {
  set_has_deathdate();
  deathdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Person.deathDate)
}
inline ::std::string* Person::mutable_deathdate() {
  set_has_deathdate();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Person.deathDate)
  return deathdate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Person::release_deathdate() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Person.deathDate)
  clear_has_deathdate();
  return deathdate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Person::set_allocated_deathdate(::std::string* deathdate) {
  if (deathdate != NULL) {
    set_has_deathdate();
  } else {
    clear_has_deathdate();
  }
  deathdate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deathdate);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Person.deathDate)
}

// optional .ru.mail.go.webbase.blobs.UrlArray thumbnailUrls = 9;
inline bool Person::has_thumbnailurls() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Person::set_has_thumbnailurls() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Person::clear_has_thumbnailurls() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Person::clear_thumbnailurls() {
  if (thumbnailurls_ != NULL) thumbnailurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_thumbnailurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& Person::thumbnailurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = thumbnailurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Person.thumbnailUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Person::mutable_thumbnailurls() {
  set_has_thumbnailurls();
  if (thumbnailurls_ == NULL) {
    thumbnailurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Person.thumbnailUrls)
  return thumbnailurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Person::release_thumbnailurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Person.thumbnailUrls)
  clear_has_thumbnailurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = thumbnailurls_;
  thumbnailurls_ = NULL;
  return temp;
}
inline void Person::set_allocated_thumbnailurls(::ru::mail::go::webbase::blobs::UrlArray* thumbnailurls) {
  delete thumbnailurls_;
  thumbnailurls_ = thumbnailurls;
  if (thumbnailurls) {
    set_has_thumbnailurls();
  } else {
    clear_has_thumbnailurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Person.thumbnailUrls)
}

// optional .ru.mail.go.webbase.blobs.UrlArray imagesUrls = 20;
inline bool Person::has_imagesurls() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Person::set_has_imagesurls() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Person::clear_has_imagesurls() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Person::clear_imagesurls() {
  if (imagesurls_ != NULL) imagesurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_imagesurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& Person::imagesurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = imagesurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Person.imagesUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Person::mutable_imagesurls() {
  set_has_imagesurls();
  if (imagesurls_ == NULL) {
    imagesurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Person.imagesUrls)
  return imagesurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Person::release_imagesurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Person.imagesUrls)
  clear_has_imagesurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = imagesurls_;
  imagesurls_ = NULL;
  return temp;
}
inline void Person::set_allocated_imagesurls(::ru::mail::go::webbase::blobs::UrlArray* imagesurls) {
  delete imagesurls_;
  imagesurls_ = imagesurls;
  if (imagesurls) {
    set_has_imagesurls();
  } else {
    clear_has_imagesurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Person.imagesUrls)
}

// -------------------------------------------------------------------

// PersonArray

// repeated .ru.mail.go.webbase.blobs.Person persons = 1;
inline int PersonArray::persons_size() const {
  return persons_.size();
}
inline void PersonArray::clear_persons() {
  persons_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::Person& PersonArray::persons(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PersonArray.persons)
  return persons_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::Person* PersonArray::mutable_persons(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.PersonArray.persons)
  return persons_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::Person* PersonArray::add_persons() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.PersonArray.persons)
  return persons_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Person >*
PersonArray::mutable_persons() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.PersonArray.persons)
  return &persons_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Person >&
PersonArray::persons() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.PersonArray.persons)
  return persons_;
}

// -------------------------------------------------------------------

// Movie

// optional .ru.mail.go.webbase.blobs.CreativeWork work = 1;
inline bool Movie::has_work() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Movie::set_has_work() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Movie::clear_has_work() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Movie::clear_work() {
  if (work_ != NULL) work_->::ru::mail::go::webbase::blobs::CreativeWork::Clear();
  clear_has_work();
}
inline const ::ru::mail::go::webbase::blobs::CreativeWork& Movie::work() const {
  const ::ru::mail::go::webbase::blobs::CreativeWork* p = work_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Movie.work)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::CreativeWork*>(
      &::ru::mail::go::webbase::blobs::_CreativeWork_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::CreativeWork* Movie::mutable_work() {
  set_has_work();
  if (work_ == NULL) {
    work_ = new ::ru::mail::go::webbase::blobs::CreativeWork;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Movie.work)
  return work_;
}
inline ::ru::mail::go::webbase::blobs::CreativeWork* Movie::release_work() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Movie.work)
  clear_has_work();
  ::ru::mail::go::webbase::blobs::CreativeWork* temp = work_;
  work_ = NULL;
  return temp;
}
inline void Movie::set_allocated_work(::ru::mail::go::webbase::blobs::CreativeWork* work) {
  delete work_;
  work_ = work;
  if (work) {
    set_has_work();
  } else {
    clear_has_work();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Movie.work)
}

// optional string duration = 2;
inline bool Movie::has_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Movie::set_has_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Movie::clear_has_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Movie::clear_duration() {
  duration_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_duration();
}
inline const ::std::string& Movie::duration() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Movie.duration)
  return duration_.GetNoArena();
}
inline void Movie::set_duration(const ::std::string& value) {
  set_has_duration();
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Movie.duration)
}
#if LANG_CXX11
inline void Movie::set_duration(::std::string&& value) {
  set_has_duration();
  duration_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Movie.duration)
}
#endif
inline void Movie::set_duration(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_duration();
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Movie.duration)
}
inline void Movie::set_duration(const char* value, size_t size) {
  set_has_duration();
  duration_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Movie.duration)
}
inline ::std::string* Movie::mutable_duration() {
  set_has_duration();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Movie.duration)
  return duration_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Movie::release_duration() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Movie.duration)
  clear_has_duration();
  return duration_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Movie::set_allocated_duration(::std::string* duration) {
  if (duration != NULL) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  duration_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), duration);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Movie.duration)
}

// optional .ru.mail.go.webbase.blobs.StringArray countries = 3;
inline bool Movie::has_countries() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Movie::set_has_countries() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Movie::clear_has_countries() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Movie::clear_countries() {
  if (countries_ != NULL) countries_->::ru::mail::go::webbase::blobs::StringArray::Clear();
  clear_has_countries();
}
inline const ::ru::mail::go::webbase::blobs::StringArray& Movie::countries() const {
  const ::ru::mail::go::webbase::blobs::StringArray* p = countries_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Movie.countries)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::StringArray*>(
      &::ru::mail::go::webbase::blobs::_StringArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::StringArray* Movie::mutable_countries() {
  set_has_countries();
  if (countries_ == NULL) {
    countries_ = new ::ru::mail::go::webbase::blobs::StringArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Movie.countries)
  return countries_;
}
inline ::ru::mail::go::webbase::blobs::StringArray* Movie::release_countries() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Movie.countries)
  clear_has_countries();
  ::ru::mail::go::webbase::blobs::StringArray* temp = countries_;
  countries_ = NULL;
  return temp;
}
inline void Movie::set_allocated_countries(::ru::mail::go::webbase::blobs::StringArray* countries) {
  delete countries_;
  countries_ = countries;
  if (countries) {
    set_has_countries();
  } else {
    clear_has_countries();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Movie.countries)
}

// optional .ru.mail.go.webbase.blobs.StringArray actors = 4;
inline bool Movie::has_actors() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Movie::set_has_actors() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Movie::clear_has_actors() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Movie::clear_actors() {
  if (actors_ != NULL) actors_->::ru::mail::go::webbase::blobs::StringArray::Clear();
  clear_has_actors();
}
inline const ::ru::mail::go::webbase::blobs::StringArray& Movie::actors() const {
  const ::ru::mail::go::webbase::blobs::StringArray* p = actors_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Movie.actors)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::StringArray*>(
      &::ru::mail::go::webbase::blobs::_StringArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::StringArray* Movie::mutable_actors() {
  set_has_actors();
  if (actors_ == NULL) {
    actors_ = new ::ru::mail::go::webbase::blobs::StringArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Movie.actors)
  return actors_;
}
inline ::ru::mail::go::webbase::blobs::StringArray* Movie::release_actors() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Movie.actors)
  clear_has_actors();
  ::ru::mail::go::webbase::blobs::StringArray* temp = actors_;
  actors_ = NULL;
  return temp;
}
inline void Movie::set_allocated_actors(::ru::mail::go::webbase::blobs::StringArray* actors) {
  delete actors_;
  actors_ = actors;
  if (actors) {
    set_has_actors();
  } else {
    clear_has_actors();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Movie.actors)
}

// optional .ru.mail.go.webbase.blobs.StringArray directors = 5;
inline bool Movie::has_directors() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Movie::set_has_directors() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Movie::clear_has_directors() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Movie::clear_directors() {
  if (directors_ != NULL) directors_->::ru::mail::go::webbase::blobs::StringArray::Clear();
  clear_has_directors();
}
inline const ::ru::mail::go::webbase::blobs::StringArray& Movie::directors() const {
  const ::ru::mail::go::webbase::blobs::StringArray* p = directors_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Movie.directors)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::StringArray*>(
      &::ru::mail::go::webbase::blobs::_StringArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::StringArray* Movie::mutable_directors() {
  set_has_directors();
  if (directors_ == NULL) {
    directors_ = new ::ru::mail::go::webbase::blobs::StringArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Movie.directors)
  return directors_;
}
inline ::ru::mail::go::webbase::blobs::StringArray* Movie::release_directors() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Movie.directors)
  clear_has_directors();
  ::ru::mail::go::webbase::blobs::StringArray* temp = directors_;
  directors_ = NULL;
  return temp;
}
inline void Movie::set_allocated_directors(::ru::mail::go::webbase::blobs::StringArray* directors) {
  delete directors_;
  directors_ = directors;
  if (directors) {
    set_has_directors();
  } else {
    clear_has_directors();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Movie.directors)
}

// optional .ru.mail.go.webbase.blobs.StringArray persons = 6;
inline bool Movie::has_persons() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Movie::set_has_persons() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Movie::clear_has_persons() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Movie::clear_persons() {
  if (persons_ != NULL) persons_->::ru::mail::go::webbase::blobs::StringArray::Clear();
  clear_has_persons();
}
inline const ::ru::mail::go::webbase::blobs::StringArray& Movie::persons() const {
  const ::ru::mail::go::webbase::blobs::StringArray* p = persons_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Movie.persons)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::StringArray*>(
      &::ru::mail::go::webbase::blobs::_StringArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::StringArray* Movie::mutable_persons() {
  set_has_persons();
  if (persons_ == NULL) {
    persons_ = new ::ru::mail::go::webbase::blobs::StringArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Movie.persons)
  return persons_;
}
inline ::ru::mail::go::webbase::blobs::StringArray* Movie::release_persons() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Movie.persons)
  clear_has_persons();
  ::ru::mail::go::webbase::blobs::StringArray* temp = persons_;
  persons_ = NULL;
  return temp;
}
inline void Movie::set_allocated_persons(::ru::mail::go::webbase::blobs::StringArray* persons) {
  delete persons_;
  persons_ = persons;
  if (persons) {
    set_has_persons();
  } else {
    clear_has_persons();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Movie.persons)
}

// optional .ru.mail.go.webbase.blobs.StringArray screenwriters = 7;
inline bool Movie::has_screenwriters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Movie::set_has_screenwriters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Movie::clear_has_screenwriters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Movie::clear_screenwriters() {
  if (screenwriters_ != NULL) screenwriters_->::ru::mail::go::webbase::blobs::StringArray::Clear();
  clear_has_screenwriters();
}
inline const ::ru::mail::go::webbase::blobs::StringArray& Movie::screenwriters() const {
  const ::ru::mail::go::webbase::blobs::StringArray* p = screenwriters_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Movie.screenwriters)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::StringArray*>(
      &::ru::mail::go::webbase::blobs::_StringArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::StringArray* Movie::mutable_screenwriters() {
  set_has_screenwriters();
  if (screenwriters_ == NULL) {
    screenwriters_ = new ::ru::mail::go::webbase::blobs::StringArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Movie.screenwriters)
  return screenwriters_;
}
inline ::ru::mail::go::webbase::blobs::StringArray* Movie::release_screenwriters() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Movie.screenwriters)
  clear_has_screenwriters();
  ::ru::mail::go::webbase::blobs::StringArray* temp = screenwriters_;
  screenwriters_ = NULL;
  return temp;
}
inline void Movie::set_allocated_screenwriters(::ru::mail::go::webbase::blobs::StringArray* screenwriters) {
  delete screenwriters_;
  screenwriters_ = screenwriters;
  if (screenwriters) {
    set_has_screenwriters();
  } else {
    clear_has_screenwriters();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Movie.screenwriters)
}

// optional .ru.mail.go.webbase.blobs.UrlArray imagesUrls = 20;
inline bool Movie::has_imagesurls() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Movie::set_has_imagesurls() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Movie::clear_has_imagesurls() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Movie::clear_imagesurls() {
  if (imagesurls_ != NULL) imagesurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_imagesurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& Movie::imagesurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = imagesurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Movie.imagesUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Movie::mutable_imagesurls() {
  set_has_imagesurls();
  if (imagesurls_ == NULL) {
    imagesurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Movie.imagesUrls)
  return imagesurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Movie::release_imagesurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Movie.imagesUrls)
  clear_has_imagesurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = imagesurls_;
  imagesurls_ = NULL;
  return temp;
}
inline void Movie::set_allocated_imagesurls(::ru::mail::go::webbase::blobs::UrlArray* imagesurls) {
  delete imagesurls_;
  imagesurls_ = imagesurls;
  if (imagesurls) {
    set_has_imagesurls();
  } else {
    clear_has_imagesurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Movie.imagesUrls)
}

// optional .ru.mail.go.webbase.blobs.UrlArray stillsUrls = 21;
inline bool Movie::has_stillsurls() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Movie::set_has_stillsurls() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Movie::clear_has_stillsurls() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Movie::clear_stillsurls() {
  if (stillsurls_ != NULL) stillsurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_stillsurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& Movie::stillsurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = stillsurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Movie.stillsUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Movie::mutable_stillsurls() {
  set_has_stillsurls();
  if (stillsurls_ == NULL) {
    stillsurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Movie.stillsUrls)
  return stillsurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Movie::release_stillsurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Movie.stillsUrls)
  clear_has_stillsurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = stillsurls_;
  stillsurls_ = NULL;
  return temp;
}
inline void Movie::set_allocated_stillsurls(::ru::mail::go::webbase::blobs::UrlArray* stillsurls) {
  delete stillsurls_;
  stillsurls_ = stillsurls;
  if (stillsurls) {
    set_has_stillsurls();
  } else {
    clear_has_stillsurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Movie.stillsUrls)
}

// optional .ru.mail.go.webbase.blobs.UrlArray trailerUrls = 22;
inline bool Movie::has_trailerurls() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Movie::set_has_trailerurls() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Movie::clear_has_trailerurls() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Movie::clear_trailerurls() {
  if (trailerurls_ != NULL) trailerurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_trailerurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& Movie::trailerurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = trailerurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Movie.trailerUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Movie::mutable_trailerurls() {
  set_has_trailerurls();
  if (trailerurls_ == NULL) {
    trailerurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Movie.trailerUrls)
  return trailerurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Movie::release_trailerurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Movie.trailerUrls)
  clear_has_trailerurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = trailerurls_;
  trailerurls_ = NULL;
  return temp;
}
inline void Movie::set_allocated_trailerurls(::ru::mail::go::webbase::blobs::UrlArray* trailerurls) {
  delete trailerurls_;
  trailerurls_ = trailerurls;
  if (trailerurls) {
    set_has_trailerurls();
  } else {
    clear_has_trailerurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Movie.trailerUrls)
}

// optional .ru.mail.go.webbase.blobs.UrlArray officialUrls = 23;
inline bool Movie::has_officialurls() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Movie::set_has_officialurls() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Movie::clear_has_officialurls() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Movie::clear_officialurls() {
  if (officialurls_ != NULL) officialurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_officialurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& Movie::officialurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = officialurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Movie.officialUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Movie::mutable_officialurls() {
  set_has_officialurls();
  if (officialurls_ == NULL) {
    officialurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Movie.officialUrls)
  return officialurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* Movie::release_officialurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Movie.officialUrls)
  clear_has_officialurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = officialurls_;
  officialurls_ = NULL;
  return temp;
}
inline void Movie::set_allocated_officialurls(::ru::mail::go::webbase::blobs::UrlArray* officialurls) {
  delete officialurls_;
  officialurls_ = officialurls;
  if (officialurls) {
    set_has_officialurls();
  } else {
    clear_has_officialurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Movie.officialUrls)
}

// -------------------------------------------------------------------

// MovieArray

// repeated .ru.mail.go.webbase.blobs.Movie movies = 1;
inline int MovieArray::movies_size() const {
  return movies_.size();
}
inline void MovieArray::clear_movies() {
  movies_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::Movie& MovieArray::movies(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MovieArray.movies)
  return movies_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::Movie* MovieArray::mutable_movies(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.MovieArray.movies)
  return movies_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::Movie* MovieArray::add_movies() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.MovieArray.movies)
  return movies_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Movie >*
MovieArray::mutable_movies() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.MovieArray.movies)
  return &movies_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::Movie >&
MovieArray::movies() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.MovieArray.movies)
  return movies_;
}

// -------------------------------------------------------------------

// TVEpisode

// optional .ru.mail.go.webbase.blobs.CreativeWork work = 1;
inline bool TVEpisode::has_work() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVEpisode::set_has_work() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVEpisode::clear_has_work() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVEpisode::clear_work() {
  if (work_ != NULL) work_->::ru::mail::go::webbase::blobs::CreativeWork::Clear();
  clear_has_work();
}
inline const ::ru::mail::go::webbase::blobs::CreativeWork& TVEpisode::work() const {
  const ::ru::mail::go::webbase::blobs::CreativeWork* p = work_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVEpisode.work)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::CreativeWork*>(
      &::ru::mail::go::webbase::blobs::_CreativeWork_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::CreativeWork* TVEpisode::mutable_work() {
  set_has_work();
  if (work_ == NULL) {
    work_ = new ::ru::mail::go::webbase::blobs::CreativeWork;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVEpisode.work)
  return work_;
}
inline ::ru::mail::go::webbase::blobs::CreativeWork* TVEpisode::release_work() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVEpisode.work)
  clear_has_work();
  ::ru::mail::go::webbase::blobs::CreativeWork* temp = work_;
  work_ = NULL;
  return temp;
}
inline void TVEpisode::set_allocated_work(::ru::mail::go::webbase::blobs::CreativeWork* work) {
  delete work_;
  work_ = work;
  if (work) {
    set_has_work();
  } else {
    clear_has_work();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVEpisode.work)
}

// optional string startDate = 2;
inline bool TVEpisode::has_startdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVEpisode::set_has_startdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVEpisode::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVEpisode::clear_startdate() {
  startdate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_startdate();
}
inline const ::std::string& TVEpisode::startdate() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVEpisode.startDate)
  return startdate_.GetNoArena();
}
inline void TVEpisode::set_startdate(const ::std::string& value) {
  set_has_startdate();
  startdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVEpisode.startDate)
}
#if LANG_CXX11
inline void TVEpisode::set_startdate(::std::string&& value) {
  set_has_startdate();
  startdate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TVEpisode.startDate)
}
#endif
inline void TVEpisode::set_startdate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_startdate();
  startdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TVEpisode.startDate)
}
inline void TVEpisode::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  startdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TVEpisode.startDate)
}
inline ::std::string* TVEpisode::mutable_startdate() {
  set_has_startdate();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVEpisode.startDate)
  return startdate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TVEpisode::release_startdate() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVEpisode.startDate)
  clear_has_startdate();
  return startdate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TVEpisode::set_allocated_startdate(::std::string* startdate) {
  if (startdate != NULL) {
    set_has_startdate();
  } else {
    clear_has_startdate();
  }
  startdate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), startdate);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVEpisode.startDate)
}

// optional uint32 episodeNumber = 3;
inline bool TVEpisode::has_episodenumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVEpisode::set_has_episodenumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVEpisode::clear_has_episodenumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVEpisode::clear_episodenumber() {
  episodenumber_ = 0u;
  clear_has_episodenumber();
}
inline ::google::protobuf::uint32 TVEpisode::episodenumber() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVEpisode.episodeNumber)
  return episodenumber_;
}
inline void TVEpisode::set_episodenumber(::google::protobuf::uint32 value) {
  set_has_episodenumber();
  episodenumber_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVEpisode.episodeNumber)
}

// optional uint32 partOfSeason = 4;
inline bool TVEpisode::has_partofseason() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVEpisode::set_has_partofseason() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVEpisode::clear_has_partofseason() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVEpisode::clear_partofseason() {
  partofseason_ = 0u;
  clear_has_partofseason();
}
inline ::google::protobuf::uint32 TVEpisode::partofseason() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVEpisode.partOfSeason)
  return partofseason_;
}
inline void TVEpisode::set_partofseason(::google::protobuf::uint32 value) {
  set_has_partofseason();
  partofseason_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVEpisode.partOfSeason)
}

// optional uint32 partOfTVSeries = 5;
inline bool TVEpisode::has_partoftvseries() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TVEpisode::set_has_partoftvseries() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TVEpisode::clear_has_partoftvseries() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TVEpisode::clear_partoftvseries() {
  partoftvseries_ = 0u;
  clear_has_partoftvseries();
}
inline ::google::protobuf::uint32 TVEpisode::partoftvseries() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVEpisode.partOfTVSeries)
  return partoftvseries_;
}
inline void TVEpisode::set_partoftvseries(::google::protobuf::uint32 value) {
  set_has_partoftvseries();
  partoftvseries_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVEpisode.partOfTVSeries)
}

// optional .ru.mail.go.webbase.blobs.UrlArray imagesUrls = 20;
inline bool TVEpisode::has_imagesurls() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVEpisode::set_has_imagesurls() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVEpisode::clear_has_imagesurls() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVEpisode::clear_imagesurls() {
  if (imagesurls_ != NULL) imagesurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_imagesurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& TVEpisode::imagesurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = imagesurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVEpisode.imagesUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVEpisode::mutable_imagesurls() {
  set_has_imagesurls();
  if (imagesurls_ == NULL) {
    imagesurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVEpisode.imagesUrls)
  return imagesurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVEpisode::release_imagesurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVEpisode.imagesUrls)
  clear_has_imagesurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = imagesurls_;
  imagesurls_ = NULL;
  return temp;
}
inline void TVEpisode::set_allocated_imagesurls(::ru::mail::go::webbase::blobs::UrlArray* imagesurls) {
  delete imagesurls_;
  imagesurls_ = imagesurls;
  if (imagesurls) {
    set_has_imagesurls();
  } else {
    clear_has_imagesurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVEpisode.imagesUrls)
}

// optional .ru.mail.go.webbase.blobs.UrlArray stillsUrls = 21;
inline bool TVEpisode::has_stillsurls() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVEpisode::set_has_stillsurls() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVEpisode::clear_has_stillsurls() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVEpisode::clear_stillsurls() {
  if (stillsurls_ != NULL) stillsurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_stillsurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& TVEpisode::stillsurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = stillsurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVEpisode.stillsUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVEpisode::mutable_stillsurls() {
  set_has_stillsurls();
  if (stillsurls_ == NULL) {
    stillsurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVEpisode.stillsUrls)
  return stillsurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVEpisode::release_stillsurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVEpisode.stillsUrls)
  clear_has_stillsurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = stillsurls_;
  stillsurls_ = NULL;
  return temp;
}
inline void TVEpisode::set_allocated_stillsurls(::ru::mail::go::webbase::blobs::UrlArray* stillsurls) {
  delete stillsurls_;
  stillsurls_ = stillsurls;
  if (stillsurls) {
    set_has_stillsurls();
  } else {
    clear_has_stillsurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVEpisode.stillsUrls)
}

// optional .ru.mail.go.webbase.blobs.UrlArray trailerUrls = 22;
inline bool TVEpisode::has_trailerurls() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVEpisode::set_has_trailerurls() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVEpisode::clear_has_trailerurls() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVEpisode::clear_trailerurls() {
  if (trailerurls_ != NULL) trailerurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_trailerurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& TVEpisode::trailerurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = trailerurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVEpisode.trailerUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVEpisode::mutable_trailerurls() {
  set_has_trailerurls();
  if (trailerurls_ == NULL) {
    trailerurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVEpisode.trailerUrls)
  return trailerurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVEpisode::release_trailerurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVEpisode.trailerUrls)
  clear_has_trailerurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = trailerurls_;
  trailerurls_ = NULL;
  return temp;
}
inline void TVEpisode::set_allocated_trailerurls(::ru::mail::go::webbase::blobs::UrlArray* trailerurls) {
  delete trailerurls_;
  trailerurls_ = trailerurls;
  if (trailerurls) {
    set_has_trailerurls();
  } else {
    clear_has_trailerurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVEpisode.trailerUrls)
}

// -------------------------------------------------------------------

// TVEpisodeArray

// repeated .ru.mail.go.webbase.blobs.TVEpisode episodes = 1;
inline int TVEpisodeArray::episodes_size() const {
  return episodes_.size();
}
inline void TVEpisodeArray::clear_episodes() {
  episodes_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::TVEpisode& TVEpisodeArray::episodes(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVEpisodeArray.episodes)
  return episodes_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::TVEpisode* TVEpisodeArray::mutable_episodes(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVEpisodeArray.episodes)
  return episodes_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::TVEpisode* TVEpisodeArray::add_episodes() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.TVEpisodeArray.episodes)
  return episodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TVEpisode >*
TVEpisodeArray::mutable_episodes() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.TVEpisodeArray.episodes)
  return &episodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TVEpisode >&
TVEpisodeArray::episodes() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.TVEpisodeArray.episodes)
  return episodes_;
}

// -------------------------------------------------------------------

// TVSeason

// optional .ru.mail.go.webbase.blobs.CreativeWork work = 1;
inline bool TVSeason::has_work() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVSeason::set_has_work() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVSeason::clear_has_work() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVSeason::clear_work() {
  if (work_ != NULL) work_->::ru::mail::go::webbase::blobs::CreativeWork::Clear();
  clear_has_work();
}
inline const ::ru::mail::go::webbase::blobs::CreativeWork& TVSeason::work() const {
  const ::ru::mail::go::webbase::blobs::CreativeWork* p = work_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeason.work)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::CreativeWork*>(
      &::ru::mail::go::webbase::blobs::_CreativeWork_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::CreativeWork* TVSeason::mutable_work() {
  set_has_work();
  if (work_ == NULL) {
    work_ = new ::ru::mail::go::webbase::blobs::CreativeWork;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeason.work)
  return work_;
}
inline ::ru::mail::go::webbase::blobs::CreativeWork* TVSeason::release_work() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeason.work)
  clear_has_work();
  ::ru::mail::go::webbase::blobs::CreativeWork* temp = work_;
  work_ = NULL;
  return temp;
}
inline void TVSeason::set_allocated_work(::ru::mail::go::webbase::blobs::CreativeWork* work) {
  delete work_;
  work_ = work;
  if (work) {
    set_has_work();
  } else {
    clear_has_work();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeason.work)
}

// required uint32 seasonNumber = 2;
inline bool TVSeason::has_seasonnumber() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVSeason::set_has_seasonnumber() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVSeason::clear_has_seasonnumber() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVSeason::clear_seasonnumber() {
  seasonnumber_ = 0u;
  clear_has_seasonnumber();
}
inline ::google::protobuf::uint32 TVSeason::seasonnumber() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeason.seasonNumber)
  return seasonnumber_;
}
inline void TVSeason::set_seasonnumber(::google::protobuf::uint32 value) {
  set_has_seasonnumber();
  seasonnumber_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVSeason.seasonNumber)
}

// optional string startDate = 3;
inline bool TVSeason::has_startdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVSeason::set_has_startdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVSeason::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVSeason::clear_startdate() {
  startdate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_startdate();
}
inline const ::std::string& TVSeason::startdate() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeason.startDate)
  return startdate_.GetNoArena();
}
inline void TVSeason::set_startdate(const ::std::string& value) {
  set_has_startdate();
  startdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVSeason.startDate)
}
#if LANG_CXX11
inline void TVSeason::set_startdate(::std::string&& value) {
  set_has_startdate();
  startdate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TVSeason.startDate)
}
#endif
inline void TVSeason::set_startdate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_startdate();
  startdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TVSeason.startDate)
}
inline void TVSeason::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  startdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TVSeason.startDate)
}
inline ::std::string* TVSeason::mutable_startdate() {
  set_has_startdate();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeason.startDate)
  return startdate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TVSeason::release_startdate() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeason.startDate)
  clear_has_startdate();
  return startdate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TVSeason::set_allocated_startdate(::std::string* startdate) {
  if (startdate != NULL) {
    set_has_startdate();
  } else {
    clear_has_startdate();
  }
  startdate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), startdate);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeason.startDate)
}

// optional string endDate = 4;
inline bool TVSeason::has_enddate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVSeason::set_has_enddate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVSeason::clear_has_enddate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVSeason::clear_enddate() {
  enddate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enddate();
}
inline const ::std::string& TVSeason::enddate() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeason.endDate)
  return enddate_.GetNoArena();
}
inline void TVSeason::set_enddate(const ::std::string& value) {
  set_has_enddate();
  enddate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVSeason.endDate)
}
#if LANG_CXX11
inline void TVSeason::set_enddate(::std::string&& value) {
  set_has_enddate();
  enddate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TVSeason.endDate)
}
#endif
inline void TVSeason::set_enddate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_enddate();
  enddate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TVSeason.endDate)
}
inline void TVSeason::set_enddate(const char* value, size_t size) {
  set_has_enddate();
  enddate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TVSeason.endDate)
}
inline ::std::string* TVSeason::mutable_enddate() {
  set_has_enddate();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeason.endDate)
  return enddate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TVSeason::release_enddate() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeason.endDate)
  clear_has_enddate();
  return enddate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TVSeason::set_allocated_enddate(::std::string* enddate) {
  if (enddate != NULL) {
    set_has_enddate();
  } else {
    clear_has_enddate();
  }
  enddate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enddate);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeason.endDate)
}

// optional uint32 partOfTVSeries = 5;
inline bool TVSeason::has_partoftvseries() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVSeason::set_has_partoftvseries() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVSeason::clear_has_partoftvseries() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVSeason::clear_partoftvseries() {
  partoftvseries_ = 0u;
  clear_has_partoftvseries();
}
inline ::google::protobuf::uint32 TVSeason::partoftvseries() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeason.partOfTVSeries)
  return partoftvseries_;
}
inline void TVSeason::set_partoftvseries(::google::protobuf::uint32 value) {
  set_has_partoftvseries();
  partoftvseries_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVSeason.partOfTVSeries)
}

// optional uint32 numberOfEpisodes = 6;
inline bool TVSeason::has_numberofepisodes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVSeason::set_has_numberofepisodes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVSeason::clear_has_numberofepisodes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVSeason::clear_numberofepisodes() {
  numberofepisodes_ = 0u;
  clear_has_numberofepisodes();
}
inline ::google::protobuf::uint32 TVSeason::numberofepisodes() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeason.numberOfEpisodes)
  return numberofepisodes_;
}
inline void TVSeason::set_numberofepisodes(::google::protobuf::uint32 value) {
  set_has_numberofepisodes();
  numberofepisodes_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVSeason.numberOfEpisodes)
}

// -------------------------------------------------------------------

// TVSeasonArray

// repeated .ru.mail.go.webbase.blobs.TVSeason seasons = 1;
inline int TVSeasonArray::seasons_size() const {
  return seasons_.size();
}
inline void TVSeasonArray::clear_seasons() {
  seasons_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::TVSeason& TVSeasonArray::seasons(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeasonArray.seasons)
  return seasons_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::TVSeason* TVSeasonArray::mutable_seasons(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeasonArray.seasons)
  return seasons_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::TVSeason* TVSeasonArray::add_seasons() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.TVSeasonArray.seasons)
  return seasons_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TVSeason >*
TVSeasonArray::mutable_seasons() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.TVSeasonArray.seasons)
  return &seasons_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TVSeason >&
TVSeasonArray::seasons() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.TVSeasonArray.seasons)
  return seasons_;
}

// -------------------------------------------------------------------

// TVSeries

// optional .ru.mail.go.webbase.blobs.CreativeWork work = 1;
inline bool TVSeries::has_work() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TVSeries::set_has_work() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TVSeries::clear_has_work() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TVSeries::clear_work() {
  if (work_ != NULL) work_->::ru::mail::go::webbase::blobs::CreativeWork::Clear();
  clear_has_work();
}
inline const ::ru::mail::go::webbase::blobs::CreativeWork& TVSeries::work() const {
  const ::ru::mail::go::webbase::blobs::CreativeWork* p = work_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.work)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::CreativeWork*>(
      &::ru::mail::go::webbase::blobs::_CreativeWork_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::CreativeWork* TVSeries::mutable_work() {
  set_has_work();
  if (work_ == NULL) {
    work_ = new ::ru::mail::go::webbase::blobs::CreativeWork;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeries.work)
  return work_;
}
inline ::ru::mail::go::webbase::blobs::CreativeWork* TVSeries::release_work() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeries.work)
  clear_has_work();
  ::ru::mail::go::webbase::blobs::CreativeWork* temp = work_;
  work_ = NULL;
  return temp;
}
inline void TVSeries::set_allocated_work(::ru::mail::go::webbase::blobs::CreativeWork* work) {
  delete work_;
  work_ = work;
  if (work) {
    set_has_work();
  } else {
    clear_has_work();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeries.work)
}

// optional string startDate = 2;
inline bool TVSeries::has_startdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TVSeries::set_has_startdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TVSeries::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TVSeries::clear_startdate() {
  startdate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_startdate();
}
inline const ::std::string& TVSeries::startdate() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.startDate)
  return startdate_.GetNoArena();
}
inline void TVSeries::set_startdate(const ::std::string& value) {
  set_has_startdate();
  startdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVSeries.startDate)
}
#if LANG_CXX11
inline void TVSeries::set_startdate(::std::string&& value) {
  set_has_startdate();
  startdate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TVSeries.startDate)
}
#endif
inline void TVSeries::set_startdate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_startdate();
  startdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TVSeries.startDate)
}
inline void TVSeries::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  startdate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TVSeries.startDate)
}
inline ::std::string* TVSeries::mutable_startdate() {
  set_has_startdate();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeries.startDate)
  return startdate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TVSeries::release_startdate() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeries.startDate)
  clear_has_startdate();
  return startdate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TVSeries::set_allocated_startdate(::std::string* startdate) {
  if (startdate != NULL) {
    set_has_startdate();
  } else {
    clear_has_startdate();
  }
  startdate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), startdate);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeries.startDate)
}

// optional string endDate = 3;
inline bool TVSeries::has_enddate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TVSeries::set_has_enddate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TVSeries::clear_has_enddate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TVSeries::clear_enddate() {
  enddate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enddate();
}
inline const ::std::string& TVSeries::enddate() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.endDate)
  return enddate_.GetNoArena();
}
inline void TVSeries::set_enddate(const ::std::string& value) {
  set_has_enddate();
  enddate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVSeries.endDate)
}
#if LANG_CXX11
inline void TVSeries::set_enddate(::std::string&& value) {
  set_has_enddate();
  enddate_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TVSeries.endDate)
}
#endif
inline void TVSeries::set_enddate(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_enddate();
  enddate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TVSeries.endDate)
}
inline void TVSeries::set_enddate(const char* value, size_t size) {
  set_has_enddate();
  enddate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TVSeries.endDate)
}
inline ::std::string* TVSeries::mutable_enddate() {
  set_has_enddate();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeries.endDate)
  return enddate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TVSeries::release_enddate() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeries.endDate)
  clear_has_enddate();
  return enddate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TVSeries::set_allocated_enddate(::std::string* enddate) {
  if (enddate != NULL) {
    set_has_enddate();
  } else {
    clear_has_enddate();
  }
  enddate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enddate);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeries.endDate)
}

// optional uint32 numberOfEpisodes = 4;
inline bool TVSeries::has_numberofepisodes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TVSeries::set_has_numberofepisodes() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TVSeries::clear_has_numberofepisodes() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TVSeries::clear_numberofepisodes() {
  numberofepisodes_ = 0u;
  clear_has_numberofepisodes();
}
inline ::google::protobuf::uint32 TVSeries::numberofepisodes() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.numberOfEpisodes)
  return numberofepisodes_;
}
inline void TVSeries::set_numberofepisodes(::google::protobuf::uint32 value) {
  set_has_numberofepisodes();
  numberofepisodes_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TVSeries.numberOfEpisodes)
}

// optional .ru.mail.go.webbase.blobs.StringArray actors = 5;
inline bool TVSeries::has_actors() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TVSeries::set_has_actors() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TVSeries::clear_has_actors() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TVSeries::clear_actors() {
  if (actors_ != NULL) actors_->::ru::mail::go::webbase::blobs::StringArray::Clear();
  clear_has_actors();
}
inline const ::ru::mail::go::webbase::blobs::StringArray& TVSeries::actors() const {
  const ::ru::mail::go::webbase::blobs::StringArray* p = actors_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.actors)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::StringArray*>(
      &::ru::mail::go::webbase::blobs::_StringArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::StringArray* TVSeries::mutable_actors() {
  set_has_actors();
  if (actors_ == NULL) {
    actors_ = new ::ru::mail::go::webbase::blobs::StringArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeries.actors)
  return actors_;
}
inline ::ru::mail::go::webbase::blobs::StringArray* TVSeries::release_actors() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeries.actors)
  clear_has_actors();
  ::ru::mail::go::webbase::blobs::StringArray* temp = actors_;
  actors_ = NULL;
  return temp;
}
inline void TVSeries::set_allocated_actors(::ru::mail::go::webbase::blobs::StringArray* actors) {
  delete actors_;
  actors_ = actors;
  if (actors) {
    set_has_actors();
  } else {
    clear_has_actors();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeries.actors)
}

// optional .ru.mail.go.webbase.blobs.StringArray directors = 6;
inline bool TVSeries::has_directors() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TVSeries::set_has_directors() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TVSeries::clear_has_directors() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TVSeries::clear_directors() {
  if (directors_ != NULL) directors_->::ru::mail::go::webbase::blobs::StringArray::Clear();
  clear_has_directors();
}
inline const ::ru::mail::go::webbase::blobs::StringArray& TVSeries::directors() const {
  const ::ru::mail::go::webbase::blobs::StringArray* p = directors_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.directors)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::StringArray*>(
      &::ru::mail::go::webbase::blobs::_StringArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::StringArray* TVSeries::mutable_directors() {
  set_has_directors();
  if (directors_ == NULL) {
    directors_ = new ::ru::mail::go::webbase::blobs::StringArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeries.directors)
  return directors_;
}
inline ::ru::mail::go::webbase::blobs::StringArray* TVSeries::release_directors() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeries.directors)
  clear_has_directors();
  ::ru::mail::go::webbase::blobs::StringArray* temp = directors_;
  directors_ = NULL;
  return temp;
}
inline void TVSeries::set_allocated_directors(::ru::mail::go::webbase::blobs::StringArray* directors) {
  delete directors_;
  directors_ = directors;
  if (directors) {
    set_has_directors();
  } else {
    clear_has_directors();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeries.directors)
}

// optional .ru.mail.go.webbase.blobs.StringArray persons = 7;
inline bool TVSeries::has_persons() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TVSeries::set_has_persons() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TVSeries::clear_has_persons() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TVSeries::clear_persons() {
  if (persons_ != NULL) persons_->::ru::mail::go::webbase::blobs::StringArray::Clear();
  clear_has_persons();
}
inline const ::ru::mail::go::webbase::blobs::StringArray& TVSeries::persons() const {
  const ::ru::mail::go::webbase::blobs::StringArray* p = persons_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.persons)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::StringArray*>(
      &::ru::mail::go::webbase::blobs::_StringArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::StringArray* TVSeries::mutable_persons() {
  set_has_persons();
  if (persons_ == NULL) {
    persons_ = new ::ru::mail::go::webbase::blobs::StringArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeries.persons)
  return persons_;
}
inline ::ru::mail::go::webbase::blobs::StringArray* TVSeries::release_persons() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeries.persons)
  clear_has_persons();
  ::ru::mail::go::webbase::blobs::StringArray* temp = persons_;
  persons_ = NULL;
  return temp;
}
inline void TVSeries::set_allocated_persons(::ru::mail::go::webbase::blobs::StringArray* persons) {
  delete persons_;
  persons_ = persons;
  if (persons) {
    set_has_persons();
  } else {
    clear_has_persons();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeries.persons)
}

// optional .ru.mail.go.webbase.blobs.StringArray screenwriters = 8;
inline bool TVSeries::has_screenwriters() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TVSeries::set_has_screenwriters() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TVSeries::clear_has_screenwriters() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TVSeries::clear_screenwriters() {
  if (screenwriters_ != NULL) screenwriters_->::ru::mail::go::webbase::blobs::StringArray::Clear();
  clear_has_screenwriters();
}
inline const ::ru::mail::go::webbase::blobs::StringArray& TVSeries::screenwriters() const {
  const ::ru::mail::go::webbase::blobs::StringArray* p = screenwriters_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.screenwriters)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::StringArray*>(
      &::ru::mail::go::webbase::blobs::_StringArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::StringArray* TVSeries::mutable_screenwriters() {
  set_has_screenwriters();
  if (screenwriters_ == NULL) {
    screenwriters_ = new ::ru::mail::go::webbase::blobs::StringArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeries.screenwriters)
  return screenwriters_;
}
inline ::ru::mail::go::webbase::blobs::StringArray* TVSeries::release_screenwriters() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeries.screenwriters)
  clear_has_screenwriters();
  ::ru::mail::go::webbase::blobs::StringArray* temp = screenwriters_;
  screenwriters_ = NULL;
  return temp;
}
inline void TVSeries::set_allocated_screenwriters(::ru::mail::go::webbase::blobs::StringArray* screenwriters) {
  delete screenwriters_;
  screenwriters_ = screenwriters;
  if (screenwriters) {
    set_has_screenwriters();
  } else {
    clear_has_screenwriters();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeries.screenwriters)
}

// optional .ru.mail.go.webbase.blobs.UrlArray imagesUrls = 20;
inline bool TVSeries::has_imagesurls() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TVSeries::set_has_imagesurls() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TVSeries::clear_has_imagesurls() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TVSeries::clear_imagesurls() {
  if (imagesurls_ != NULL) imagesurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_imagesurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& TVSeries::imagesurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = imagesurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.imagesUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVSeries::mutable_imagesurls() {
  set_has_imagesurls();
  if (imagesurls_ == NULL) {
    imagesurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeries.imagesUrls)
  return imagesurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVSeries::release_imagesurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeries.imagesUrls)
  clear_has_imagesurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = imagesurls_;
  imagesurls_ = NULL;
  return temp;
}
inline void TVSeries::set_allocated_imagesurls(::ru::mail::go::webbase::blobs::UrlArray* imagesurls) {
  delete imagesurls_;
  imagesurls_ = imagesurls;
  if (imagesurls) {
    set_has_imagesurls();
  } else {
    clear_has_imagesurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeries.imagesUrls)
}

// optional .ru.mail.go.webbase.blobs.UrlArray stillsUrls = 21;
inline bool TVSeries::has_stillsurls() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TVSeries::set_has_stillsurls() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TVSeries::clear_has_stillsurls() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TVSeries::clear_stillsurls() {
  if (stillsurls_ != NULL) stillsurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_stillsurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& TVSeries::stillsurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = stillsurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.stillsUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVSeries::mutable_stillsurls() {
  set_has_stillsurls();
  if (stillsurls_ == NULL) {
    stillsurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeries.stillsUrls)
  return stillsurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVSeries::release_stillsurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeries.stillsUrls)
  clear_has_stillsurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = stillsurls_;
  stillsurls_ = NULL;
  return temp;
}
inline void TVSeries::set_allocated_stillsurls(::ru::mail::go::webbase::blobs::UrlArray* stillsurls) {
  delete stillsurls_;
  stillsurls_ = stillsurls;
  if (stillsurls) {
    set_has_stillsurls();
  } else {
    clear_has_stillsurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeries.stillsUrls)
}

// optional .ru.mail.go.webbase.blobs.UrlArray trailerUrls = 22;
inline bool TVSeries::has_trailerurls() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TVSeries::set_has_trailerurls() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TVSeries::clear_has_trailerurls() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TVSeries::clear_trailerurls() {
  if (trailerurls_ != NULL) trailerurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_trailerurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& TVSeries::trailerurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = trailerurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.trailerUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVSeries::mutable_trailerurls() {
  set_has_trailerurls();
  if (trailerurls_ == NULL) {
    trailerurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeries.trailerUrls)
  return trailerurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVSeries::release_trailerurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeries.trailerUrls)
  clear_has_trailerurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = trailerurls_;
  trailerurls_ = NULL;
  return temp;
}
inline void TVSeries::set_allocated_trailerurls(::ru::mail::go::webbase::blobs::UrlArray* trailerurls) {
  delete trailerurls_;
  trailerurls_ = trailerurls;
  if (trailerurls) {
    set_has_trailerurls();
  } else {
    clear_has_trailerurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeries.trailerUrls)
}

// optional .ru.mail.go.webbase.blobs.UrlArray officialUrls = 23;
inline bool TVSeries::has_officialurls() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TVSeries::set_has_officialurls() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TVSeries::clear_has_officialurls() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TVSeries::clear_officialurls() {
  if (officialurls_ != NULL) officialurls_->::ru::mail::go::webbase::blobs::UrlArray::Clear();
  clear_has_officialurls();
}
inline const ::ru::mail::go::webbase::blobs::UrlArray& TVSeries::officialurls() const {
  const ::ru::mail::go::webbase::blobs::UrlArray* p = officialurls_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TVSeries.officialUrls)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::UrlArray*>(
      &::ru::mail::go::webbase::blobs::_UrlArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVSeries::mutable_officialurls() {
  set_has_officialurls();
  if (officialurls_ == NULL) {
    officialurls_ = new ::ru::mail::go::webbase::blobs::UrlArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TVSeries.officialUrls)
  return officialurls_;
}
inline ::ru::mail::go::webbase::blobs::UrlArray* TVSeries::release_officialurls() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TVSeries.officialUrls)
  clear_has_officialurls();
  ::ru::mail::go::webbase::blobs::UrlArray* temp = officialurls_;
  officialurls_ = NULL;
  return temp;
}
inline void TVSeries::set_allocated_officialurls(::ru::mail::go::webbase::blobs::UrlArray* officialurls) {
  delete officialurls_;
  officialurls_ = officialurls;
  if (officialurls) {
    set_has_officialurls();
  } else {
    clear_has_officialurls();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TVSeries.officialUrls)
}

// -------------------------------------------------------------------

// ParsedSubject

// required .ru.mail.go.webbase.blobs.ParsedSubject.Type type = 1;
inline bool ParsedSubject::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ParsedSubject::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ParsedSubject::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ParsedSubject::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::ru::mail::go::webbase::blobs::ParsedSubject_Type ParsedSubject::type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedSubject.type)
  return static_cast< ::ru::mail::go::webbase::blobs::ParsedSubject_Type >(type_);
}
inline void ParsedSubject::set_type(::ru::mail::go::webbase::blobs::ParsedSubject_Type value) {
  assert(::ru::mail::go::webbase::blobs::ParsedSubject_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParsedSubject.type)
}

// optional .ru.mail.go.webbase.blobs.Thing thing = 2;
inline bool ParsedSubject::has_thing() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParsedSubject::set_has_thing() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParsedSubject::clear_has_thing() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParsedSubject::clear_thing() {
  if (thing_ != NULL) thing_->::ru::mail::go::webbase::blobs::Thing::Clear();
  clear_has_thing();
}
inline const ::ru::mail::go::webbase::blobs::Thing& ParsedSubject::thing() const {
  const ::ru::mail::go::webbase::blobs::Thing* p = thing_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedSubject.thing)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::Thing*>(
      &::ru::mail::go::webbase::blobs::_Thing_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::Thing* ParsedSubject::mutable_thing() {
  set_has_thing();
  if (thing_ == NULL) {
    thing_ = new ::ru::mail::go::webbase::blobs::Thing;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedSubject.thing)
  return thing_;
}
inline ::ru::mail::go::webbase::blobs::Thing* ParsedSubject::release_thing() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedSubject.thing)
  clear_has_thing();
  ::ru::mail::go::webbase::blobs::Thing* temp = thing_;
  thing_ = NULL;
  return temp;
}
inline void ParsedSubject::set_allocated_thing(::ru::mail::go::webbase::blobs::Thing* thing) {
  delete thing_;
  thing_ = thing;
  if (thing) {
    set_has_thing();
  } else {
    clear_has_thing();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedSubject.thing)
}

// optional .ru.mail.go.webbase.blobs.Person person = 3;
inline bool ParsedSubject::has_person() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParsedSubject::set_has_person() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParsedSubject::clear_has_person() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParsedSubject::clear_person() {
  if (person_ != NULL) person_->::ru::mail::go::webbase::blobs::Person::Clear();
  clear_has_person();
}
inline const ::ru::mail::go::webbase::blobs::Person& ParsedSubject::person() const {
  const ::ru::mail::go::webbase::blobs::Person* p = person_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedSubject.person)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::Person*>(
      &::ru::mail::go::webbase::blobs::_Person_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::Person* ParsedSubject::mutable_person() {
  set_has_person();
  if (person_ == NULL) {
    person_ = new ::ru::mail::go::webbase::blobs::Person;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedSubject.person)
  return person_;
}
inline ::ru::mail::go::webbase::blobs::Person* ParsedSubject::release_person() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedSubject.person)
  clear_has_person();
  ::ru::mail::go::webbase::blobs::Person* temp = person_;
  person_ = NULL;
  return temp;
}
inline void ParsedSubject::set_allocated_person(::ru::mail::go::webbase::blobs::Person* person) {
  delete person_;
  person_ = person;
  if (person) {
    set_has_person();
  } else {
    clear_has_person();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedSubject.person)
}

// optional .ru.mail.go.webbase.blobs.Movie movie = 4;
inline bool ParsedSubject::has_movie() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParsedSubject::set_has_movie() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParsedSubject::clear_has_movie() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParsedSubject::clear_movie() {
  if (movie_ != NULL) movie_->::ru::mail::go::webbase::blobs::Movie::Clear();
  clear_has_movie();
}
inline const ::ru::mail::go::webbase::blobs::Movie& ParsedSubject::movie() const {
  const ::ru::mail::go::webbase::blobs::Movie* p = movie_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedSubject.movie)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::Movie*>(
      &::ru::mail::go::webbase::blobs::_Movie_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::Movie* ParsedSubject::mutable_movie() {
  set_has_movie();
  if (movie_ == NULL) {
    movie_ = new ::ru::mail::go::webbase::blobs::Movie;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedSubject.movie)
  return movie_;
}
inline ::ru::mail::go::webbase::blobs::Movie* ParsedSubject::release_movie() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedSubject.movie)
  clear_has_movie();
  ::ru::mail::go::webbase::blobs::Movie* temp = movie_;
  movie_ = NULL;
  return temp;
}
inline void ParsedSubject::set_allocated_movie(::ru::mail::go::webbase::blobs::Movie* movie) {
  delete movie_;
  movie_ = movie;
  if (movie) {
    set_has_movie();
  } else {
    clear_has_movie();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedSubject.movie)
}

// optional .ru.mail.go.webbase.blobs.TVEpisode tvepisode = 5;
inline bool ParsedSubject::has_tvepisode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ParsedSubject::set_has_tvepisode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ParsedSubject::clear_has_tvepisode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ParsedSubject::clear_tvepisode() {
  if (tvepisode_ != NULL) tvepisode_->::ru::mail::go::webbase::blobs::TVEpisode::Clear();
  clear_has_tvepisode();
}
inline const ::ru::mail::go::webbase::blobs::TVEpisode& ParsedSubject::tvepisode() const {
  const ::ru::mail::go::webbase::blobs::TVEpisode* p = tvepisode_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedSubject.tvepisode)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::TVEpisode*>(
      &::ru::mail::go::webbase::blobs::_TVEpisode_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::TVEpisode* ParsedSubject::mutable_tvepisode() {
  set_has_tvepisode();
  if (tvepisode_ == NULL) {
    tvepisode_ = new ::ru::mail::go::webbase::blobs::TVEpisode;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedSubject.tvepisode)
  return tvepisode_;
}
inline ::ru::mail::go::webbase::blobs::TVEpisode* ParsedSubject::release_tvepisode() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedSubject.tvepisode)
  clear_has_tvepisode();
  ::ru::mail::go::webbase::blobs::TVEpisode* temp = tvepisode_;
  tvepisode_ = NULL;
  return temp;
}
inline void ParsedSubject::set_allocated_tvepisode(::ru::mail::go::webbase::blobs::TVEpisode* tvepisode) {
  delete tvepisode_;
  tvepisode_ = tvepisode;
  if (tvepisode) {
    set_has_tvepisode();
  } else {
    clear_has_tvepisode();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedSubject.tvepisode)
}

// optional .ru.mail.go.webbase.blobs.TVSeason tvseason = 6;
inline bool ParsedSubject::has_tvseason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ParsedSubject::set_has_tvseason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ParsedSubject::clear_has_tvseason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ParsedSubject::clear_tvseason() {
  if (tvseason_ != NULL) tvseason_->::ru::mail::go::webbase::blobs::TVSeason::Clear();
  clear_has_tvseason();
}
inline const ::ru::mail::go::webbase::blobs::TVSeason& ParsedSubject::tvseason() const {
  const ::ru::mail::go::webbase::blobs::TVSeason* p = tvseason_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedSubject.tvseason)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::TVSeason*>(
      &::ru::mail::go::webbase::blobs::_TVSeason_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::TVSeason* ParsedSubject::mutable_tvseason() {
  set_has_tvseason();
  if (tvseason_ == NULL) {
    tvseason_ = new ::ru::mail::go::webbase::blobs::TVSeason;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedSubject.tvseason)
  return tvseason_;
}
inline ::ru::mail::go::webbase::blobs::TVSeason* ParsedSubject::release_tvseason() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedSubject.tvseason)
  clear_has_tvseason();
  ::ru::mail::go::webbase::blobs::TVSeason* temp = tvseason_;
  tvseason_ = NULL;
  return temp;
}
inline void ParsedSubject::set_allocated_tvseason(::ru::mail::go::webbase::blobs::TVSeason* tvseason) {
  delete tvseason_;
  tvseason_ = tvseason;
  if (tvseason) {
    set_has_tvseason();
  } else {
    clear_has_tvseason();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedSubject.tvseason)
}

// optional .ru.mail.go.webbase.blobs.TVSeries telecast = 7;
inline bool ParsedSubject::has_telecast() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ParsedSubject::set_has_telecast() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ParsedSubject::clear_has_telecast() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ParsedSubject::clear_telecast() {
  if (telecast_ != NULL) telecast_->::ru::mail::go::webbase::blobs::TVSeries::Clear();
  clear_has_telecast();
}
inline const ::ru::mail::go::webbase::blobs::TVSeries& ParsedSubject::telecast() const {
  const ::ru::mail::go::webbase::blobs::TVSeries* p = telecast_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParsedSubject.telecast)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::TVSeries*>(
      &::ru::mail::go::webbase::blobs::_TVSeries_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::TVSeries* ParsedSubject::mutable_telecast() {
  set_has_telecast();
  if (telecast_ == NULL) {
    telecast_ = new ::ru::mail::go::webbase::blobs::TVSeries;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParsedSubject.telecast)
  return telecast_;
}
inline ::ru::mail::go::webbase::blobs::TVSeries* ParsedSubject::release_telecast() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParsedSubject.telecast)
  clear_has_telecast();
  ::ru::mail::go::webbase::blobs::TVSeries* temp = telecast_;
  telecast_ = NULL;
  return temp;
}
inline void ParsedSubject::set_allocated_telecast(::ru::mail::go::webbase::blobs::TVSeries* telecast) {
  delete telecast_;
  telecast_ = telecast;
  if (telecast) {
    set_has_telecast();
  } else {
    clear_has_telecast();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParsedSubject.telecast)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::ParsedSubject_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::ParsedSubject_Type>() {
  return ::ru::mail::go::webbase::blobs::ParsedSubject_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_subj_5fschema_2eproto__INCLUDED
