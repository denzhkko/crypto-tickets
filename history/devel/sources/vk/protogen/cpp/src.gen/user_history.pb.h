// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user_history.proto

#ifndef PROTOBUF_user_5fhistory_2eproto__INCLUDED
#define PROTOBUF_user_5fhistory_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "urllog_record.pb.h"
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace userhistory {
class Click;
class ClickDefaultTypeInternal;
extern ClickDefaultTypeInternal _Click_default_instance_;
class DayHistory;
class DayHistoryDefaultTypeInternal;
extern DayHistoryDefaultTypeInternal _DayHistory_default_instance_;
class ExpiredInterest;
class ExpiredInterestDefaultTypeInternal;
extern ExpiredInterestDefaultTypeInternal _ExpiredInterest_default_instance_;
class Features;
class FeaturesDefaultTypeInternal;
extern FeaturesDefaultTypeInternal _Features_default_instance_;
class KeyValue;
class KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class LogicalSession;
class LogicalSessionDefaultTypeInternal;
extern LogicalSessionDefaultTypeInternal _LogicalSession_default_instance_;
class QuerySession;
class QuerySessionDefaultTypeInternal;
extern QuerySessionDefaultTypeInternal _QuerySession_default_instance_;
class QuerySessionInLogicalSession;
class QuerySessionInLogicalSessionDefaultTypeInternal;
extern QuerySessionInLogicalSessionDefaultTypeInternal _QuerySessionInLogicalSession_default_instance_;
class SuperSession;
class SuperSessionDefaultTypeInternal;
extern SuperSessionDefaultTypeInternal _SuperSession_default_instance_;
class UserQuerySession;
class UserQuerySessionDefaultTypeInternal;
extern UserQuerySessionDefaultTypeInternal _UserQuerySession_default_instance_;
}  // namespace userhistory
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace userhistory {

namespace protobuf_user_5fhistory_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_user_5fhistory_2eproto

enum LogicalSession_SplitMergeReason {
  LogicalSession_SplitMergeReason_time_gap = 1,
  LogicalSession_SplitMergeReason_urls_match = 2,
  LogicalSession_SplitMergeReason_simple_pattern = 3,
  LogicalSession_SplitMergeReason_geometric = 4,
  LogicalSession_SplitMergeReason_min_time = 5
};
bool LogicalSession_SplitMergeReason_IsValid(int value);
const LogicalSession_SplitMergeReason LogicalSession_SplitMergeReason_SplitMergeReason_MIN = LogicalSession_SplitMergeReason_time_gap;
const LogicalSession_SplitMergeReason LogicalSession_SplitMergeReason_SplitMergeReason_MAX = LogicalSession_SplitMergeReason_min_time;
const int LogicalSession_SplitMergeReason_SplitMergeReason_ARRAYSIZE = LogicalSession_SplitMergeReason_SplitMergeReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogicalSession_SplitMergeReason_descriptor();
inline const ::std::string& LogicalSession_SplitMergeReason_Name(LogicalSession_SplitMergeReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogicalSession_SplitMergeReason_descriptor(), value);
}
inline bool LogicalSession_SplitMergeReason_Parse(
    const ::std::string& name, LogicalSession_SplitMergeReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogicalSession_SplitMergeReason>(
    LogicalSession_SplitMergeReason_descriptor(), name, value);
}
enum UserQuerySession_id_types {
  UserQuerySession_id_types_vid = 0,
  UserQuerySession_id_types_liru = 1,
  UserQuerySession_id_types_youla_id = 2
};
bool UserQuerySession_id_types_IsValid(int value);
const UserQuerySession_id_types UserQuerySession_id_types_id_types_MIN = UserQuerySession_id_types_vid;
const UserQuerySession_id_types UserQuerySession_id_types_id_types_MAX = UserQuerySession_id_types_youla_id;
const int UserQuerySession_id_types_id_types_ARRAYSIZE = UserQuerySession_id_types_id_types_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserQuerySession_id_types_descriptor();
inline const ::std::string& UserQuerySession_id_types_Name(UserQuerySession_id_types value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserQuerySession_id_types_descriptor(), value);
}
inline bool UserQuerySession_id_types_Parse(
    const ::std::string& name, UserQuerySession_id_types* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserQuerySession_id_types>(
    UserQuerySession_id_types_descriptor(), name, value);
}
enum ExpiredInterest_id_types {
  ExpiredInterest_id_types_vid = 0,
  ExpiredInterest_id_types_liru = 1,
  ExpiredInterest_id_types_youla_id = 2
};
bool ExpiredInterest_id_types_IsValid(int value);
const ExpiredInterest_id_types ExpiredInterest_id_types_id_types_MIN = ExpiredInterest_id_types_vid;
const ExpiredInterest_id_types ExpiredInterest_id_types_id_types_MAX = ExpiredInterest_id_types_youla_id;
const int ExpiredInterest_id_types_id_types_ARRAYSIZE = ExpiredInterest_id_types_id_types_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExpiredInterest_id_types_descriptor();
inline const ::std::string& ExpiredInterest_id_types_Name(ExpiredInterest_id_types value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExpiredInterest_id_types_descriptor(), value);
}
inline bool ExpiredInterest_id_types_Parse(
    const ::std::string& name, ExpiredInterest_id_types* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExpiredInterest_id_types>(
    ExpiredInterest_id_types_descriptor(), name, value);
}
// ===================================================================

class DayHistory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.userhistory.DayHistory) */ {
 public:
  DayHistory();
  virtual ~DayHistory();

  DayHistory(const DayHistory& from);

  inline DayHistory& operator=(const DayHistory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DayHistory(DayHistory&& from) noexcept
    : DayHistory() {
    *this = ::std::move(from);
  }

  inline DayHistory& operator=(DayHistory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DayHistory& default_instance();

  static inline const DayHistory* internal_default_instance() {
    return reinterpret_cast<const DayHistory*>(
               &_DayHistory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DayHistory* other);
  friend void swap(DayHistory& a, DayHistory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DayHistory* New() const PROTOBUF_FINAL { return New(NULL); }

  DayHistory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DayHistory& from);
  void MergeFrom(const DayHistory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DayHistory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.userhistory.QuerySession sessions = 3;
  int sessions_size() const;
  void clear_sessions();
  static const int kSessionsFieldNumber = 3;
  const ::ru::mail::go::webbase::userhistory::QuerySession& sessions(int index) const;
  ::ru::mail::go::webbase::userhistory::QuerySession* mutable_sessions(int index);
  ::ru::mail::go::webbase::userhistory::QuerySession* add_sessions();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::QuerySession >*
      mutable_sessions();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::QuerySession >&
      sessions() const;

  // required string date = 1;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 1;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // optional string email = 2;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 2;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.userhistory.DayHistory)
 private:
  void set_has_date();
  void clear_has_date();
  void set_has_email();
  void clear_has_email();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::QuerySession > sessions_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  friend struct protobuf_user_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SuperSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.userhistory.SuperSession) */ {
 public:
  SuperSession();
  virtual ~SuperSession();

  SuperSession(const SuperSession& from);

  inline SuperSession& operator=(const SuperSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SuperSession(SuperSession&& from) noexcept
    : SuperSession() {
    *this = ::std::move(from);
  }

  inline SuperSession& operator=(SuperSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SuperSession& default_instance();

  static inline const SuperSession* internal_default_instance() {
    return reinterpret_cast<const SuperSession*>(
               &_SuperSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SuperSession* other);
  friend void swap(SuperSession& a, SuperSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SuperSession* New() const PROTOBUF_FINAL { return New(NULL); }

  SuperSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SuperSession& from);
  void MergeFrom(const SuperSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SuperSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.userhistory.LogicalSession logicalSessions = 1;
  int logicalsessions_size() const;
  void clear_logicalsessions();
  static const int kLogicalSessionsFieldNumber = 1;
  const ::ru::mail::go::webbase::userhistory::LogicalSession& logicalsessions(int index) const;
  ::ru::mail::go::webbase::userhistory::LogicalSession* mutable_logicalsessions(int index);
  ::ru::mail::go::webbase::userhistory::LogicalSession* add_logicalsessions();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::LogicalSession >*
      mutable_logicalsessions();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::LogicalSession >&
      logicalsessions() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.userhistory.SuperSession)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::LogicalSession > logicalsessions_;
  friend struct protobuf_user_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogicalSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.userhistory.LogicalSession) */ {
 public:
  LogicalSession();
  virtual ~LogicalSession();

  LogicalSession(const LogicalSession& from);

  inline LogicalSession& operator=(const LogicalSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicalSession(LogicalSession&& from) noexcept
    : LogicalSession() {
    *this = ::std::move(from);
  }

  inline LogicalSession& operator=(LogicalSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalSession& default_instance();

  static inline const LogicalSession* internal_default_instance() {
    return reinterpret_cast<const LogicalSession*>(
               &_LogicalSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(LogicalSession* other);
  friend void swap(LogicalSession& a, LogicalSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicalSession* New() const PROTOBUF_FINAL { return New(NULL); }

  LogicalSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogicalSession& from);
  void MergeFrom(const LogicalSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogicalSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LogicalSession_SplitMergeReason SplitMergeReason;
  static const SplitMergeReason time_gap =
    LogicalSession_SplitMergeReason_time_gap;
  static const SplitMergeReason urls_match =
    LogicalSession_SplitMergeReason_urls_match;
  static const SplitMergeReason simple_pattern =
    LogicalSession_SplitMergeReason_simple_pattern;
  static const SplitMergeReason geometric =
    LogicalSession_SplitMergeReason_geometric;
  static const SplitMergeReason min_time =
    LogicalSession_SplitMergeReason_min_time;
  static inline bool SplitMergeReason_IsValid(int value) {
    return LogicalSession_SplitMergeReason_IsValid(value);
  }
  static const SplitMergeReason SplitMergeReason_MIN =
    LogicalSession_SplitMergeReason_SplitMergeReason_MIN;
  static const SplitMergeReason SplitMergeReason_MAX =
    LogicalSession_SplitMergeReason_SplitMergeReason_MAX;
  static const int SplitMergeReason_ARRAYSIZE =
    LogicalSession_SplitMergeReason_SplitMergeReason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SplitMergeReason_descriptor() {
    return LogicalSession_SplitMergeReason_descriptor();
  }
  static inline const ::std::string& SplitMergeReason_Name(SplitMergeReason value) {
    return LogicalSession_SplitMergeReason_Name(value);
  }
  static inline bool SplitMergeReason_Parse(const ::std::string& name,
      SplitMergeReason* value) {
    return LogicalSession_SplitMergeReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession qsils = 1;
  int qsils_size() const;
  void clear_qsils();
  static const int kQsilsFieldNumber = 1;
  const ::ru::mail::go::webbase::userhistory::QuerySessionInLogicalSession& qsils(int index) const;
  ::ru::mail::go::webbase::userhistory::QuerySessionInLogicalSession* mutable_qsils(int index);
  ::ru::mail::go::webbase::userhistory::QuerySessionInLogicalSession* add_qsils();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::QuerySessionInLogicalSession >*
      mutable_qsils();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::QuerySessionInLogicalSession >&
      qsils() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.userhistory.LogicalSession)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::QuerySessionInLogicalSession > qsils_;
  friend struct protobuf_user_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QuerySessionInLogicalSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession) */ {
 public:
  QuerySessionInLogicalSession();
  virtual ~QuerySessionInLogicalSession();

  QuerySessionInLogicalSession(const QuerySessionInLogicalSession& from);

  inline QuerySessionInLogicalSession& operator=(const QuerySessionInLogicalSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QuerySessionInLogicalSession(QuerySessionInLogicalSession&& from) noexcept
    : QuerySessionInLogicalSession() {
    *this = ::std::move(from);
  }

  inline QuerySessionInLogicalSession& operator=(QuerySessionInLogicalSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuerySessionInLogicalSession& default_instance();

  static inline const QuerySessionInLogicalSession* internal_default_instance() {
    return reinterpret_cast<const QuerySessionInLogicalSession*>(
               &_QuerySessionInLogicalSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(QuerySessionInLogicalSession* other);
  friend void swap(QuerySessionInLogicalSession& a, QuerySessionInLogicalSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QuerySessionInLogicalSession* New() const PROTOBUF_FINAL { return New(NULL); }

  QuerySessionInLogicalSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QuerySessionInLogicalSession& from);
  void MergeFrom(const QuerySessionInLogicalSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QuerySessionInLogicalSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ru.mail.go.webbase.userhistory.QuerySession query = 1;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 1;
  const ::ru::mail::go::webbase::userhistory::QuerySession& query() const;
  ::ru::mail::go::webbase::userhistory::QuerySession* mutable_query();
  ::ru::mail::go::webbase::userhistory::QuerySession* release_query();
  void set_allocated_query(::ru::mail::go::webbase::userhistory::QuerySession* query);

  // required bool isSplit = 3;
  bool has_issplit() const;
  void clear_issplit();
  static const int kIsSplitFieldNumber = 3;
  bool issplit() const;
  void set_issplit(bool value);

  // required .ru.mail.go.webbase.userhistory.LogicalSession.SplitMergeReason withNext = 2;
  bool has_withnext() const;
  void clear_withnext();
  static const int kWithNextFieldNumber = 2;
  ::ru::mail::go::webbase::userhistory::LogicalSession_SplitMergeReason withnext() const;
  void set_withnext(::ru::mail::go::webbase::userhistory::LogicalSession_SplitMergeReason value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession)
 private:
  void set_has_query();
  void clear_has_query();
  void set_has_withnext();
  void clear_has_withnext();
  void set_has_issplit();
  void clear_has_issplit();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ru::mail::go::webbase::userhistory::QuerySession* query_;
  bool issplit_;
  int withnext_;
  friend struct protobuf_user_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QuerySession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.userhistory.QuerySession) */ {
 public:
  QuerySession();
  virtual ~QuerySession();

  QuerySession(const QuerySession& from);

  inline QuerySession& operator=(const QuerySession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QuerySession(QuerySession&& from) noexcept
    : QuerySession() {
    *this = ::std::move(from);
  }

  inline QuerySession& operator=(QuerySession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuerySession& default_instance();

  static inline const QuerySession* internal_default_instance() {
    return reinterpret_cast<const QuerySession*>(
               &_QuerySession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(QuerySession* other);
  friend void swap(QuerySession& a, QuerySession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QuerySession* New() const PROTOBUF_FINAL { return New(NULL); }

  QuerySession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QuerySession& from);
  void MergeFrom(const QuerySession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QuerySession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.userhistory.Click clicks = 4;
  int clicks_size() const;
  void clear_clicks();
  static const int kClicksFieldNumber = 4;
  const ::ru::mail::go::webbase::userhistory::Click& clicks(int index) const;
  ::ru::mail::go::webbase::userhistory::Click* mutable_clicks(int index);
  ::ru::mail::go::webbase::userhistory::Click* add_clicks();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::Click >*
      mutable_clicks();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::Click >&
      clicks() const;

  // repeated string urls = 7;
  int urls_size() const;
  void clear_urls();
  static const int kUrlsFieldNumber = 7;
  const ::std::string& urls(int index) const;
  ::std::string* mutable_urls(int index);
  void set_urls(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_urls(int index, ::std::string&& value);
  #endif
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  ::std::string* add_urls();
  void add_urls(const ::std::string& value);
  #if LANG_CXX11
  void add_urls(::std::string&& value);
  #endif
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& urls() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_urls();

  // required string ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // required string query = 3;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 3;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // optional string email = 6;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 6;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // optional string spcq = 9;
  bool has_spcq() const;
  void clear_spcq();
  static const int kSpcqFieldNumber = 9;
  const ::std::string& spcq() const;
  void set_spcq(const ::std::string& value);
  #if LANG_CXX11
  void set_spcq(::std::string&& value);
  #endif
  void set_spcq(const char* value);
  void set_spcq(const char* value, size_t size);
  ::std::string* mutable_spcq();
  ::std::string* release_spcq();
  void set_allocated_spcq(::std::string* spcq);

  // optional string urls_data = 10;
  bool has_urls_data() const;
  void clear_urls_data();
  static const int kUrlsDataFieldNumber = 10;
  const ::std::string& urls_data() const;
  void set_urls_data(const ::std::string& value);
  #if LANG_CXX11
  void set_urls_data(::std::string&& value);
  #endif
  void set_urls_data(const char* value);
  void set_urls_data(const char* value, size_t size);
  ::std::string* mutable_urls_data();
  ::std::string* release_urls_data();
  void set_allocated_urls_data(::std::string* urls_data);

  // optional .ru.mail.go.webbase.ranking.ParamList sessionInfo = 5;
  bool has_sessioninfo() const;
  void clear_sessioninfo();
  static const int kSessionInfoFieldNumber = 5;
  const ::ru::mail::go::webbase::ranking::ParamList& sessioninfo() const;
  ::ru::mail::go::webbase::ranking::ParamList* mutable_sessioninfo();
  ::ru::mail::go::webbase::ranking::ParamList* release_sessioninfo();
  void set_allocated_sessioninfo(::ru::mail::go::webbase::ranking::ParamList* sessioninfo);

  // required uint64 time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // optional uint32 startFrom = 8;
  bool has_startfrom() const;
  void clear_startfrom();
  static const int kStartFromFieldNumber = 8;
  ::google::protobuf::uint32 startfrom() const;
  void set_startfrom(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.userhistory.QuerySession)
 private:
  void set_has_time();
  void clear_has_time();
  void set_has_ip();
  void clear_has_ip();
  void set_has_query();
  void clear_has_query();
  void set_has_sessioninfo();
  void clear_has_sessioninfo();
  void set_has_email();
  void clear_has_email();
  void set_has_startfrom();
  void clear_has_startfrom();
  void set_has_spcq();
  void clear_has_spcq();
  void set_has_urls_data();
  void clear_has_urls_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::Click > clicks_;
  ::google::protobuf::RepeatedPtrField< ::std::string> urls_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr query_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr spcq_;
  ::google::protobuf::internal::ArenaStringPtr urls_data_;
  ::ru::mail::go::webbase::ranking::ParamList* sessioninfo_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 startfrom_;
  friend struct protobuf_user_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Click : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.userhistory.Click) */ {
 public:
  Click();
  virtual ~Click();

  Click(const Click& from);

  inline Click& operator=(const Click& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Click(Click&& from) noexcept
    : Click() {
    *this = ::std::move(from);
  }

  inline Click& operator=(Click&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Click& default_instance();

  static inline const Click* internal_default_instance() {
    return reinterpret_cast<const Click*>(
               &_Click_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Click* other);
  friend void swap(Click& a, Click& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Click* New() const PROTOBUF_FINAL { return New(NULL); }

  Click* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Click& from);
  void MergeFrom(const Click& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Click* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required uint64 time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.userhistory.Click)
 private:
  void set_has_time();
  void clear_has_time();
  void set_has_url();
  void clear_has_url();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::uint64 time_;
  friend struct protobuf_user_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Features : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.userhistory.Features) */ {
 public:
  Features();
  virtual ~Features();

  Features(const Features& from);

  inline Features& operator=(const Features& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Features(Features&& from) noexcept
    : Features() {
    *this = ::std::move(from);
  }

  inline Features& operator=(Features&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Features& default_instance();

  static inline const Features* internal_default_instance() {
    return reinterpret_cast<const Features*>(
               &_Features_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Features* other);
  friend void swap(Features& a, Features& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Features* New() const PROTOBUF_FINAL { return New(NULL); }

  Features* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Features& from);
  void MergeFrom(const Features& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Features* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.userhistory.KeyValue features = 1;
  int features_size() const;
  void clear_features();
  static const int kFeaturesFieldNumber = 1;
  const ::ru::mail::go::webbase::userhistory::KeyValue& features(int index) const;
  ::ru::mail::go::webbase::userhistory::KeyValue* mutable_features(int index);
  ::ru::mail::go::webbase::userhistory::KeyValue* add_features();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::KeyValue >*
      mutable_features();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::KeyValue >&
      features() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.userhistory.Features)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::KeyValue > features_;
  friend struct protobuf_user_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.userhistory.KeyValue) */ {
 public:
  KeyValue();
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValue& default_instance();

  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(KeyValue* other);
  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string field = 1;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  #if LANG_CXX11
  void set_field(::std::string&& value);
  #endif
  void set_field(const char* value);
  void set_field(const char* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // required float value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.userhistory.KeyValue)
 private:
  void set_has_field();
  void clear_has_field();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  float value_;
  friend struct protobuf_user_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserQuerySession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.userhistory.UserQuerySession) */ {
 public:
  UserQuerySession();
  virtual ~UserQuerySession();

  UserQuerySession(const UserQuerySession& from);

  inline UserQuerySession& operator=(const UserQuerySession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserQuerySession(UserQuerySession&& from) noexcept
    : UserQuerySession() {
    *this = ::std::move(from);
  }

  inline UserQuerySession& operator=(UserQuerySession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserQuerySession& default_instance();

  static inline const UserQuerySession* internal_default_instance() {
    return reinterpret_cast<const UserQuerySession*>(
               &_UserQuerySession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(UserQuerySession* other);
  friend void swap(UserQuerySession& a, UserQuerySession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserQuerySession* New() const PROTOBUF_FINAL { return New(NULL); }

  UserQuerySession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserQuerySession& from);
  void MergeFrom(const UserQuerySession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserQuerySession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UserQuerySession_id_types id_types;
  static const id_types vid =
    UserQuerySession_id_types_vid;
  static const id_types liru =
    UserQuerySession_id_types_liru;
  static const id_types youla_id =
    UserQuerySession_id_types_youla_id;
  static inline bool id_types_IsValid(int value) {
    return UserQuerySession_id_types_IsValid(value);
  }
  static const id_types id_types_MIN =
    UserQuerySession_id_types_id_types_MIN;
  static const id_types id_types_MAX =
    UserQuerySession_id_types_id_types_MAX;
  static const int id_types_ARRAYSIZE =
    UserQuerySession_id_types_id_types_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  id_types_descriptor() {
    return UserQuerySession_id_types_descriptor();
  }
  static inline const ::std::string& id_types_Name(id_types value) {
    return UserQuerySession_id_types_Name(value);
  }
  static inline bool id_types_Parse(const ::std::string& name,
      id_types* value) {
    return UserQuerySession_id_types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required .ru.mail.go.webbase.userhistory.QuerySession query_session = 2;
  bool has_query_session() const;
  void clear_query_session();
  static const int kQuerySessionFieldNumber = 2;
  const ::ru::mail::go::webbase::userhistory::QuerySession& query_session() const;
  ::ru::mail::go::webbase::userhistory::QuerySession* mutable_query_session();
  ::ru::mail::go::webbase::userhistory::QuerySession* release_query_session();
  void set_allocated_query_session(::ru::mail::go::webbase::userhistory::QuerySession* query_session);

  // optional .ru.mail.go.webbase.userhistory.UserQuerySession.id_types id_type = 3 [default = vid];
  bool has_id_type() const;
  void clear_id_type();
  static const int kIdTypeFieldNumber = 3;
  ::ru::mail::go::webbase::userhistory::UserQuerySession_id_types id_type() const;
  void set_id_type(::ru::mail::go::webbase::userhistory::UserQuerySession_id_types value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.userhistory.UserQuerySession)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_query_session();
  void clear_has_query_session();
  void set_has_id_type();
  void clear_has_id_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ru::mail::go::webbase::userhistory::QuerySession* query_session_;
  int id_type_;
  friend struct protobuf_user_5fhistory_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExpiredInterest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.userhistory.ExpiredInterest) */ {
 public:
  ExpiredInterest();
  virtual ~ExpiredInterest();

  ExpiredInterest(const ExpiredInterest& from);

  inline ExpiredInterest& operator=(const ExpiredInterest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExpiredInterest(ExpiredInterest&& from) noexcept
    : ExpiredInterest() {
    *this = ::std::move(from);
  }

  inline ExpiredInterest& operator=(ExpiredInterest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExpiredInterest& default_instance();

  static inline const ExpiredInterest* internal_default_instance() {
    return reinterpret_cast<const ExpiredInterest*>(
               &_ExpiredInterest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ExpiredInterest* other);
  friend void swap(ExpiredInterest& a, ExpiredInterest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExpiredInterest* New() const PROTOBUF_FINAL { return New(NULL); }

  ExpiredInterest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExpiredInterest& from);
  void MergeFrom(const ExpiredInterest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExpiredInterest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ExpiredInterest_id_types id_types;
  static const id_types vid =
    ExpiredInterest_id_types_vid;
  static const id_types liru =
    ExpiredInterest_id_types_liru;
  static const id_types youla_id =
    ExpiredInterest_id_types_youla_id;
  static inline bool id_types_IsValid(int value) {
    return ExpiredInterest_id_types_IsValid(value);
  }
  static const id_types id_types_MIN =
    ExpiredInterest_id_types_id_types_MIN;
  static const id_types id_types_MAX =
    ExpiredInterest_id_types_id_types_MAX;
  static const int id_types_ARRAYSIZE =
    ExpiredInterest_id_types_id_types_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  id_types_descriptor() {
    return ExpiredInterest_id_types_descriptor();
  }
  static inline const ::std::string& id_types_Name(id_types value) {
    return ExpiredInterest_id_types_Name(value);
  }
  static inline bool id_types_Parse(const ::std::string& name,
      id_types* value) {
    return ExpiredInterest_id_types_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string interest = 2;
  bool has_interest() const;
  void clear_interest();
  static const int kInterestFieldNumber = 2;
  const ::std::string& interest() const;
  void set_interest(const ::std::string& value);
  #if LANG_CXX11
  void set_interest(::std::string&& value);
  #endif
  void set_interest(const char* value);
  void set_interest(const char* value, size_t size);
  ::std::string* mutable_interest();
  ::std::string* release_interest();
  void set_allocated_interest(::std::string* interest);

  // optional .ru.mail.go.webbase.userhistory.ExpiredInterest.id_types id_type = 3 [default = vid];
  bool has_id_type() const;
  void clear_id_type();
  static const int kIdTypeFieldNumber = 3;
  ::ru::mail::go::webbase::userhistory::ExpiredInterest_id_types id_type() const;
  void set_id_type(::ru::mail::go::webbase::userhistory::ExpiredInterest_id_types value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.userhistory.ExpiredInterest)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_interest();
  void clear_has_interest();
  void set_has_id_type();
  void clear_has_id_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr interest_;
  int id_type_;
  friend struct protobuf_user_5fhistory_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DayHistory

// required string date = 1;
inline bool DayHistory::has_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DayHistory::set_has_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DayHistory::clear_has_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DayHistory::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date();
}
inline const ::std::string& DayHistory::date() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.DayHistory.date)
  return date_.GetNoArena();
}
inline void DayHistory::set_date(const ::std::string& value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.DayHistory.date)
}
#if LANG_CXX11
inline void DayHistory::set_date(::std::string&& value) {
  set_has_date();
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.DayHistory.date)
}
#endif
inline void DayHistory::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.DayHistory.date)
}
inline void DayHistory::set_date(const char* value, size_t size) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.DayHistory.date)
}
inline ::std::string* DayHistory::mutable_date() {
  set_has_date();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.DayHistory.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DayHistory::release_date() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.DayHistory.date)
  clear_has_date();
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DayHistory::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    set_has_date();
  } else {
    clear_has_date();
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.DayHistory.date)
}

// optional string email = 2;
inline bool DayHistory::has_email() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DayHistory::set_has_email() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DayHistory::clear_has_email() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DayHistory::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_email();
}
inline const ::std::string& DayHistory::email() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.DayHistory.email)
  return email_.GetNoArena();
}
inline void DayHistory::set_email(const ::std::string& value) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.DayHistory.email)
}
#if LANG_CXX11
inline void DayHistory::set_email(::std::string&& value) {
  set_has_email();
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.DayHistory.email)
}
#endif
inline void DayHistory::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.DayHistory.email)
}
inline void DayHistory::set_email(const char* value, size_t size) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.DayHistory.email)
}
inline ::std::string* DayHistory::mutable_email() {
  set_has_email();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.DayHistory.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DayHistory::release_email() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.DayHistory.email)
  clear_has_email();
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DayHistory::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    set_has_email();
  } else {
    clear_has_email();
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.DayHistory.email)
}

// repeated .ru.mail.go.webbase.userhistory.QuerySession sessions = 3;
inline int DayHistory::sessions_size() const {
  return sessions_.size();
}
inline void DayHistory::clear_sessions() {
  sessions_.Clear();
}
inline const ::ru::mail::go::webbase::userhistory::QuerySession& DayHistory::sessions(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.DayHistory.sessions)
  return sessions_.Get(index);
}
inline ::ru::mail::go::webbase::userhistory::QuerySession* DayHistory::mutable_sessions(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.DayHistory.sessions)
  return sessions_.Mutable(index);
}
inline ::ru::mail::go::webbase::userhistory::QuerySession* DayHistory::add_sessions() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.userhistory.DayHistory.sessions)
  return sessions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::QuerySession >*
DayHistory::mutable_sessions() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.userhistory.DayHistory.sessions)
  return &sessions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::QuerySession >&
DayHistory::sessions() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.userhistory.DayHistory.sessions)
  return sessions_;
}

// -------------------------------------------------------------------

// SuperSession

// repeated .ru.mail.go.webbase.userhistory.LogicalSession logicalSessions = 1;
inline int SuperSession::logicalsessions_size() const {
  return logicalsessions_.size();
}
inline void SuperSession::clear_logicalsessions() {
  logicalsessions_.Clear();
}
inline const ::ru::mail::go::webbase::userhistory::LogicalSession& SuperSession::logicalsessions(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.SuperSession.logicalSessions)
  return logicalsessions_.Get(index);
}
inline ::ru::mail::go::webbase::userhistory::LogicalSession* SuperSession::mutable_logicalsessions(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.SuperSession.logicalSessions)
  return logicalsessions_.Mutable(index);
}
inline ::ru::mail::go::webbase::userhistory::LogicalSession* SuperSession::add_logicalsessions() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.userhistory.SuperSession.logicalSessions)
  return logicalsessions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::LogicalSession >*
SuperSession::mutable_logicalsessions() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.userhistory.SuperSession.logicalSessions)
  return &logicalsessions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::LogicalSession >&
SuperSession::logicalsessions() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.userhistory.SuperSession.logicalSessions)
  return logicalsessions_;
}

// -------------------------------------------------------------------

// LogicalSession

// repeated .ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession qsils = 1;
inline int LogicalSession::qsils_size() const {
  return qsils_.size();
}
inline void LogicalSession::clear_qsils() {
  qsils_.Clear();
}
inline const ::ru::mail::go::webbase::userhistory::QuerySessionInLogicalSession& LogicalSession::qsils(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.LogicalSession.qsils)
  return qsils_.Get(index);
}
inline ::ru::mail::go::webbase::userhistory::QuerySessionInLogicalSession* LogicalSession::mutable_qsils(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.LogicalSession.qsils)
  return qsils_.Mutable(index);
}
inline ::ru::mail::go::webbase::userhistory::QuerySessionInLogicalSession* LogicalSession::add_qsils() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.userhistory.LogicalSession.qsils)
  return qsils_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::QuerySessionInLogicalSession >*
LogicalSession::mutable_qsils() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.userhistory.LogicalSession.qsils)
  return &qsils_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::QuerySessionInLogicalSession >&
LogicalSession::qsils() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.userhistory.LogicalSession.qsils)
  return qsils_;
}

// -------------------------------------------------------------------

// QuerySessionInLogicalSession

// required .ru.mail.go.webbase.userhistory.QuerySession query = 1;
inline bool QuerySessionInLogicalSession::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuerySessionInLogicalSession::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuerySessionInLogicalSession::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuerySessionInLogicalSession::clear_query() {
  if (query_ != NULL) query_->::ru::mail::go::webbase::userhistory::QuerySession::Clear();
  clear_has_query();
}
inline const ::ru::mail::go::webbase::userhistory::QuerySession& QuerySessionInLogicalSession::query() const {
  const ::ru::mail::go::webbase::userhistory::QuerySession* p = query_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession.query)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::userhistory::QuerySession*>(
      &::ru::mail::go::webbase::userhistory::_QuerySession_default_instance_);
}
inline ::ru::mail::go::webbase::userhistory::QuerySession* QuerySessionInLogicalSession::mutable_query() {
  set_has_query();
  if (query_ == NULL) {
    query_ = new ::ru::mail::go::webbase::userhistory::QuerySession;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession.query)
  return query_;
}
inline ::ru::mail::go::webbase::userhistory::QuerySession* QuerySessionInLogicalSession::release_query() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession.query)
  clear_has_query();
  ::ru::mail::go::webbase::userhistory::QuerySession* temp = query_;
  query_ = NULL;
  return temp;
}
inline void QuerySessionInLogicalSession::set_allocated_query(::ru::mail::go::webbase::userhistory::QuerySession* query) {
  delete query_;
  query_ = query;
  if (query) {
    set_has_query();
  } else {
    clear_has_query();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession.query)
}

// required .ru.mail.go.webbase.userhistory.LogicalSession.SplitMergeReason withNext = 2;
inline bool QuerySessionInLogicalSession::has_withnext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuerySessionInLogicalSession::set_has_withnext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuerySessionInLogicalSession::clear_has_withnext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuerySessionInLogicalSession::clear_withnext() {
  withnext_ = 1;
  clear_has_withnext();
}
inline ::ru::mail::go::webbase::userhistory::LogicalSession_SplitMergeReason QuerySessionInLogicalSession::withnext() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession.withNext)
  return static_cast< ::ru::mail::go::webbase::userhistory::LogicalSession_SplitMergeReason >(withnext_);
}
inline void QuerySessionInLogicalSession::set_withnext(::ru::mail::go::webbase::userhistory::LogicalSession_SplitMergeReason value) {
  assert(::ru::mail::go::webbase::userhistory::LogicalSession_SplitMergeReason_IsValid(value));
  set_has_withnext();
  withnext_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession.withNext)
}

// required bool isSplit = 3;
inline bool QuerySessionInLogicalSession::has_issplit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuerySessionInLogicalSession::set_has_issplit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuerySessionInLogicalSession::clear_has_issplit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuerySessionInLogicalSession::clear_issplit() {
  issplit_ = false;
  clear_has_issplit();
}
inline bool QuerySessionInLogicalSession::issplit() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession.isSplit)
  return issplit_;
}
inline void QuerySessionInLogicalSession::set_issplit(bool value) {
  set_has_issplit();
  issplit_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.QuerySessionInLogicalSession.isSplit)
}

// -------------------------------------------------------------------

// QuerySession

// required uint64 time = 1;
inline bool QuerySession::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void QuerySession::set_has_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void QuerySession::clear_has_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void QuerySession::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 QuerySession::time() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySession.time)
  return time_;
}
inline void QuerySession::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.QuerySession.time)
}

// required string ip = 2;
inline bool QuerySession::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuerySession::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuerySession::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuerySession::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& QuerySession::ip() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySession.ip)
  return ip_.GetNoArena();
}
inline void QuerySession::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.QuerySession.ip)
}
#if LANG_CXX11
inline void QuerySession::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.QuerySession.ip)
}
#endif
inline void QuerySession::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.QuerySession.ip)
}
inline void QuerySession::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.QuerySession.ip)
}
inline ::std::string* QuerySession::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.QuerySession.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuerySession::release_ip() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.QuerySession.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuerySession::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.QuerySession.ip)
}

// required string query = 3;
inline bool QuerySession::has_query() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuerySession::set_has_query() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuerySession::clear_has_query() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuerySession::clear_query() {
  query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_query();
}
inline const ::std::string& QuerySession::query() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySession.query)
  return query_.GetNoArena();
}
inline void QuerySession::set_query(const ::std::string& value) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.QuerySession.query)
}
#if LANG_CXX11
inline void QuerySession::set_query(::std::string&& value) {
  set_has_query();
  query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.QuerySession.query)
}
#endif
inline void QuerySession::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.QuerySession.query)
}
inline void QuerySession::set_query(const char* value, size_t size) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.QuerySession.query)
}
inline ::std::string* QuerySession::mutable_query() {
  set_has_query();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.QuerySession.query)
  return query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuerySession::release_query() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.QuerySession.query)
  clear_has_query();
  return query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuerySession::set_allocated_query(::std::string* query) {
  if (query != NULL) {
    set_has_query();
  } else {
    clear_has_query();
  }
  query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.QuerySession.query)
}

// repeated .ru.mail.go.webbase.userhistory.Click clicks = 4;
inline int QuerySession::clicks_size() const {
  return clicks_.size();
}
inline void QuerySession::clear_clicks() {
  clicks_.Clear();
}
inline const ::ru::mail::go::webbase::userhistory::Click& QuerySession::clicks(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySession.clicks)
  return clicks_.Get(index);
}
inline ::ru::mail::go::webbase::userhistory::Click* QuerySession::mutable_clicks(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.QuerySession.clicks)
  return clicks_.Mutable(index);
}
inline ::ru::mail::go::webbase::userhistory::Click* QuerySession::add_clicks() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.userhistory.QuerySession.clicks)
  return clicks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::Click >*
QuerySession::mutable_clicks() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.userhistory.QuerySession.clicks)
  return &clicks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::Click >&
QuerySession::clicks() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.userhistory.QuerySession.clicks)
  return clicks_;
}

// optional .ru.mail.go.webbase.ranking.ParamList sessionInfo = 5;
inline bool QuerySession::has_sessioninfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void QuerySession::set_has_sessioninfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void QuerySession::clear_has_sessioninfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void QuerySession::clear_sessioninfo() {
  if (sessioninfo_ != NULL) sessioninfo_->::ru::mail::go::webbase::ranking::ParamList::Clear();
  clear_has_sessioninfo();
}
inline const ::ru::mail::go::webbase::ranking::ParamList& QuerySession::sessioninfo() const {
  const ::ru::mail::go::webbase::ranking::ParamList* p = sessioninfo_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySession.sessionInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::ranking::ParamList*>(
      &::ru::mail::go::webbase::ranking::_ParamList_default_instance_);
}
inline ::ru::mail::go::webbase::ranking::ParamList* QuerySession::mutable_sessioninfo() {
  set_has_sessioninfo();
  if (sessioninfo_ == NULL) {
    sessioninfo_ = new ::ru::mail::go::webbase::ranking::ParamList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.QuerySession.sessionInfo)
  return sessioninfo_;
}
inline ::ru::mail::go::webbase::ranking::ParamList* QuerySession::release_sessioninfo() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.QuerySession.sessionInfo)
  clear_has_sessioninfo();
  ::ru::mail::go::webbase::ranking::ParamList* temp = sessioninfo_;
  sessioninfo_ = NULL;
  return temp;
}
inline void QuerySession::set_allocated_sessioninfo(::ru::mail::go::webbase::ranking::ParamList* sessioninfo) {
  delete sessioninfo_;
  sessioninfo_ = sessioninfo;
  if (sessioninfo) {
    set_has_sessioninfo();
  } else {
    clear_has_sessioninfo();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.QuerySession.sessionInfo)
}

// optional string email = 6;
inline bool QuerySession::has_email() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QuerySession::set_has_email() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QuerySession::clear_has_email() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QuerySession::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_email();
}
inline const ::std::string& QuerySession::email() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySession.email)
  return email_.GetNoArena();
}
inline void QuerySession::set_email(const ::std::string& value) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.QuerySession.email)
}
#if LANG_CXX11
inline void QuerySession::set_email(::std::string&& value) {
  set_has_email();
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.QuerySession.email)
}
#endif
inline void QuerySession::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.QuerySession.email)
}
inline void QuerySession::set_email(const char* value, size_t size) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.QuerySession.email)
}
inline ::std::string* QuerySession::mutable_email() {
  set_has_email();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.QuerySession.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuerySession::release_email() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.QuerySession.email)
  clear_has_email();
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuerySession::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    set_has_email();
  } else {
    clear_has_email();
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.QuerySession.email)
}

// repeated string urls = 7;
inline int QuerySession::urls_size() const {
  return urls_.size();
}
inline void QuerySession::clear_urls() {
  urls_.Clear();
}
inline const ::std::string& QuerySession::urls(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySession.urls)
  return urls_.Get(index);
}
inline ::std::string* QuerySession::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.QuerySession.urls)
  return urls_.Mutable(index);
}
inline void QuerySession::set_urls(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.QuerySession.urls)
  urls_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void QuerySession::set_urls(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.QuerySession.urls)
  urls_.Mutable(index)->assign(std::move(value));
}
#endif
inline void QuerySession::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.QuerySession.urls)
}
inline void QuerySession::set_urls(int index, const char* value, size_t size) {
  urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.QuerySession.urls)
}
inline ::std::string* QuerySession::add_urls() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.userhistory.QuerySession.urls)
  return urls_.Add();
}
inline void QuerySession::add_urls(const ::std::string& value) {
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.userhistory.QuerySession.urls)
}
#if LANG_CXX11
inline void QuerySession::add_urls(::std::string&& value) {
  urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.userhistory.QuerySession.urls)
}
#endif
inline void QuerySession::add_urls(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.userhistory.QuerySession.urls)
}
inline void QuerySession::add_urls(const char* value, size_t size) {
  urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.userhistory.QuerySession.urls)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
QuerySession::urls() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.userhistory.QuerySession.urls)
  return urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
QuerySession::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.userhistory.QuerySession.urls)
  return &urls_;
}

// optional uint32 startFrom = 8;
inline bool QuerySession::has_startfrom() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void QuerySession::set_has_startfrom() {
  _has_bits_[0] |= 0x00000080u;
}
inline void QuerySession::clear_has_startfrom() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void QuerySession::clear_startfrom() {
  startfrom_ = 0u;
  clear_has_startfrom();
}
inline ::google::protobuf::uint32 QuerySession::startfrom() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySession.startFrom)
  return startfrom_;
}
inline void QuerySession::set_startfrom(::google::protobuf::uint32 value) {
  set_has_startfrom();
  startfrom_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.QuerySession.startFrom)
}

// optional string spcq = 9;
inline bool QuerySession::has_spcq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QuerySession::set_has_spcq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QuerySession::clear_has_spcq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QuerySession::clear_spcq() {
  spcq_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_spcq();
}
inline const ::std::string& QuerySession::spcq() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySession.spcq)
  return spcq_.GetNoArena();
}
inline void QuerySession::set_spcq(const ::std::string& value) {
  set_has_spcq();
  spcq_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.QuerySession.spcq)
}
#if LANG_CXX11
inline void QuerySession::set_spcq(::std::string&& value) {
  set_has_spcq();
  spcq_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.QuerySession.spcq)
}
#endif
inline void QuerySession::set_spcq(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_spcq();
  spcq_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.QuerySession.spcq)
}
inline void QuerySession::set_spcq(const char* value, size_t size) {
  set_has_spcq();
  spcq_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.QuerySession.spcq)
}
inline ::std::string* QuerySession::mutable_spcq() {
  set_has_spcq();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.QuerySession.spcq)
  return spcq_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuerySession::release_spcq() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.QuerySession.spcq)
  clear_has_spcq();
  return spcq_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuerySession::set_allocated_spcq(::std::string* spcq) {
  if (spcq != NULL) {
    set_has_spcq();
  } else {
    clear_has_spcq();
  }
  spcq_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), spcq);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.QuerySession.spcq)
}

// optional string urls_data = 10;
inline bool QuerySession::has_urls_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QuerySession::set_has_urls_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QuerySession::clear_has_urls_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QuerySession::clear_urls_data() {
  urls_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_urls_data();
}
inline const ::std::string& QuerySession::urls_data() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.QuerySession.urls_data)
  return urls_data_.GetNoArena();
}
inline void QuerySession::set_urls_data(const ::std::string& value) {
  set_has_urls_data();
  urls_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.QuerySession.urls_data)
}
#if LANG_CXX11
inline void QuerySession::set_urls_data(::std::string&& value) {
  set_has_urls_data();
  urls_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.QuerySession.urls_data)
}
#endif
inline void QuerySession::set_urls_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_urls_data();
  urls_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.QuerySession.urls_data)
}
inline void QuerySession::set_urls_data(const char* value, size_t size) {
  set_has_urls_data();
  urls_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.QuerySession.urls_data)
}
inline ::std::string* QuerySession::mutable_urls_data() {
  set_has_urls_data();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.QuerySession.urls_data)
  return urls_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuerySession::release_urls_data() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.QuerySession.urls_data)
  clear_has_urls_data();
  return urls_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuerySession::set_allocated_urls_data(::std::string* urls_data) {
  if (urls_data != NULL) {
    set_has_urls_data();
  } else {
    clear_has_urls_data();
  }
  urls_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), urls_data);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.QuerySession.urls_data)
}

// -------------------------------------------------------------------

// Click

// required uint64 time = 1;
inline bool Click::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Click::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Click::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Click::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 Click::time() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.Click.time)
  return time_;
}
inline void Click::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.Click.time)
}

// required string url = 2;
inline bool Click::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Click::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Click::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Click::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& Click::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.Click.url)
  return url_.GetNoArena();
}
inline void Click::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.Click.url)
}
#if LANG_CXX11
inline void Click::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.Click.url)
}
#endif
inline void Click::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.Click.url)
}
inline void Click::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.Click.url)
}
inline ::std::string* Click::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.Click.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Click::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.Click.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Click::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.Click.url)
}

// -------------------------------------------------------------------

// Features

// repeated .ru.mail.go.webbase.userhistory.KeyValue features = 1;
inline int Features::features_size() const {
  return features_.size();
}
inline void Features::clear_features() {
  features_.Clear();
}
inline const ::ru::mail::go::webbase::userhistory::KeyValue& Features::features(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.Features.features)
  return features_.Get(index);
}
inline ::ru::mail::go::webbase::userhistory::KeyValue* Features::mutable_features(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.Features.features)
  return features_.Mutable(index);
}
inline ::ru::mail::go::webbase::userhistory::KeyValue* Features::add_features() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.userhistory.Features.features)
  return features_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::KeyValue >*
Features::mutable_features() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.userhistory.Features.features)
  return &features_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::userhistory::KeyValue >&
Features::features() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.userhistory.Features.features)
  return features_;
}

// -------------------------------------------------------------------

// KeyValue

// required string field = 1;
inline bool KeyValue::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyValue::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyValue::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyValue::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field();
}
inline const ::std::string& KeyValue::field() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.KeyValue.field)
  return field_.GetNoArena();
}
inline void KeyValue::set_field(const ::std::string& value) {
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.KeyValue.field)
}
#if LANG_CXX11
inline void KeyValue::set_field(::std::string&& value) {
  set_has_field();
  field_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.KeyValue.field)
}
#endif
inline void KeyValue::set_field(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.KeyValue.field)
}
inline void KeyValue::set_field(const char* value, size_t size) {
  set_has_field();
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.KeyValue.field)
}
inline ::std::string* KeyValue::mutable_field() {
  set_has_field();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.KeyValue.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_field() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.KeyValue.field)
  clear_has_field();
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValue::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    set_has_field();
  } else {
    clear_has_field();
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.KeyValue.field)
}

// required float value = 2;
inline bool KeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float KeyValue::value() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.KeyValue.value)
  return value_;
}
inline void KeyValue::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.KeyValue.value)
}

// -------------------------------------------------------------------

// UserQuerySession

// required string id = 1;
inline bool UserQuerySession::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserQuerySession::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserQuerySession::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserQuerySession::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& UserQuerySession::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.UserQuerySession.id)
  return id_.GetNoArena();
}
inline void UserQuerySession::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.UserQuerySession.id)
}
#if LANG_CXX11
inline void UserQuerySession::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.UserQuerySession.id)
}
#endif
inline void UserQuerySession::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.UserQuerySession.id)
}
inline void UserQuerySession::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.UserQuerySession.id)
}
inline ::std::string* UserQuerySession::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.UserQuerySession.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserQuerySession::release_id() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.UserQuerySession.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserQuerySession::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.UserQuerySession.id)
}

// required .ru.mail.go.webbase.userhistory.QuerySession query_session = 2;
inline bool UserQuerySession::has_query_session() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserQuerySession::set_has_query_session() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserQuerySession::clear_has_query_session() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserQuerySession::clear_query_session() {
  if (query_session_ != NULL) query_session_->::ru::mail::go::webbase::userhistory::QuerySession::Clear();
  clear_has_query_session();
}
inline const ::ru::mail::go::webbase::userhistory::QuerySession& UserQuerySession::query_session() const {
  const ::ru::mail::go::webbase::userhistory::QuerySession* p = query_session_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.UserQuerySession.query_session)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::userhistory::QuerySession*>(
      &::ru::mail::go::webbase::userhistory::_QuerySession_default_instance_);
}
inline ::ru::mail::go::webbase::userhistory::QuerySession* UserQuerySession::mutable_query_session() {
  set_has_query_session();
  if (query_session_ == NULL) {
    query_session_ = new ::ru::mail::go::webbase::userhistory::QuerySession;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.UserQuerySession.query_session)
  return query_session_;
}
inline ::ru::mail::go::webbase::userhistory::QuerySession* UserQuerySession::release_query_session() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.UserQuerySession.query_session)
  clear_has_query_session();
  ::ru::mail::go::webbase::userhistory::QuerySession* temp = query_session_;
  query_session_ = NULL;
  return temp;
}
inline void UserQuerySession::set_allocated_query_session(::ru::mail::go::webbase::userhistory::QuerySession* query_session) {
  delete query_session_;
  query_session_ = query_session;
  if (query_session) {
    set_has_query_session();
  } else {
    clear_has_query_session();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.UserQuerySession.query_session)
}

// optional .ru.mail.go.webbase.userhistory.UserQuerySession.id_types id_type = 3 [default = vid];
inline bool UserQuerySession::has_id_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserQuerySession::set_has_id_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserQuerySession::clear_has_id_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserQuerySession::clear_id_type() {
  id_type_ = 0;
  clear_has_id_type();
}
inline ::ru::mail::go::webbase::userhistory::UserQuerySession_id_types UserQuerySession::id_type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.UserQuerySession.id_type)
  return static_cast< ::ru::mail::go::webbase::userhistory::UserQuerySession_id_types >(id_type_);
}
inline void UserQuerySession::set_id_type(::ru::mail::go::webbase::userhistory::UserQuerySession_id_types value) {
  assert(::ru::mail::go::webbase::userhistory::UserQuerySession_id_types_IsValid(value));
  set_has_id_type();
  id_type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.UserQuerySession.id_type)
}

// -------------------------------------------------------------------

// ExpiredInterest

// required string id = 1;
inline bool ExpiredInterest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExpiredInterest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExpiredInterest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExpiredInterest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& ExpiredInterest::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.ExpiredInterest.id)
  return id_.GetNoArena();
}
inline void ExpiredInterest::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.ExpiredInterest.id)
}
#if LANG_CXX11
inline void ExpiredInterest::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.ExpiredInterest.id)
}
#endif
inline void ExpiredInterest::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.ExpiredInterest.id)
}
inline void ExpiredInterest::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.ExpiredInterest.id)
}
inline ::std::string* ExpiredInterest::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.ExpiredInterest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExpiredInterest::release_id() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.ExpiredInterest.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExpiredInterest::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.ExpiredInterest.id)
}

// required string interest = 2;
inline bool ExpiredInterest::has_interest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExpiredInterest::set_has_interest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExpiredInterest::clear_has_interest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExpiredInterest::clear_interest() {
  interest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_interest();
}
inline const ::std::string& ExpiredInterest::interest() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.ExpiredInterest.interest)
  return interest_.GetNoArena();
}
inline void ExpiredInterest::set_interest(const ::std::string& value) {
  set_has_interest();
  interest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.ExpiredInterest.interest)
}
#if LANG_CXX11
inline void ExpiredInterest::set_interest(::std::string&& value) {
  set_has_interest();
  interest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.userhistory.ExpiredInterest.interest)
}
#endif
inline void ExpiredInterest::set_interest(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_interest();
  interest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.userhistory.ExpiredInterest.interest)
}
inline void ExpiredInterest::set_interest(const char* value, size_t size) {
  set_has_interest();
  interest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.userhistory.ExpiredInterest.interest)
}
inline ::std::string* ExpiredInterest::mutable_interest() {
  set_has_interest();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.userhistory.ExpiredInterest.interest)
  return interest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExpiredInterest::release_interest() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.userhistory.ExpiredInterest.interest)
  clear_has_interest();
  return interest_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExpiredInterest::set_allocated_interest(::std::string* interest) {
  if (interest != NULL) {
    set_has_interest();
  } else {
    clear_has_interest();
  }
  interest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), interest);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.userhistory.ExpiredInterest.interest)
}

// optional .ru.mail.go.webbase.userhistory.ExpiredInterest.id_types id_type = 3 [default = vid];
inline bool ExpiredInterest::has_id_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExpiredInterest::set_has_id_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExpiredInterest::clear_has_id_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExpiredInterest::clear_id_type() {
  id_type_ = 0;
  clear_has_id_type();
}
inline ::ru::mail::go::webbase::userhistory::ExpiredInterest_id_types ExpiredInterest::id_type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.userhistory.ExpiredInterest.id_type)
  return static_cast< ::ru::mail::go::webbase::userhistory::ExpiredInterest_id_types >(id_type_);
}
inline void ExpiredInterest::set_id_type(::ru::mail::go::webbase::userhistory::ExpiredInterest_id_types value) {
  assert(::ru::mail::go::webbase::userhistory::ExpiredInterest_id_types_IsValid(value));
  set_has_id_type();
  id_type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.userhistory.ExpiredInterest.id_type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace userhistory
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::webbase::userhistory::LogicalSession_SplitMergeReason> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::userhistory::LogicalSession_SplitMergeReason>() {
  return ::ru::mail::go::webbase::userhistory::LogicalSession_SplitMergeReason_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::userhistory::UserQuerySession_id_types> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::userhistory::UserQuerySession_id_types>() {
  return ::ru::mail::go::webbase::userhistory::UserQuerySession_id_types_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::userhistory::ExpiredInterest_id_types> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::userhistory::ExpiredInterest_id_types>() {
  return ::ru::mail::go::webbase::userhistory::ExpiredInterest_id_types_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_user_5fhistory_2eproto__INCLUDED
