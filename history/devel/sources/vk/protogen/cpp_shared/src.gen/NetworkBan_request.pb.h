// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NetworkBan_request.proto

#ifndef PROTOBUF_NetworkBan_5frequest_2eproto__INCLUDED
#define PROTOBUF_NetworkBan_5frequest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
class NetworkBan_answer;
class NetworkBan_answerDefaultTypeInternal;
extern NetworkBan_answerDefaultTypeInternal _NetworkBan_answer_default_instance_;
class NetworkBan_request;
class NetworkBan_requestDefaultTypeInternal;
extern NetworkBan_requestDefaultTypeInternal _NetworkBan_request_default_instance_;
class metaData;
class metaDataDefaultTypeInternal;
extern metaDataDefaultTypeInternal _metaData_default_instance_;
class tags_cont;
class tags_contDefaultTypeInternal;
extern tags_contDefaultTypeInternal _tags_cont_default_instance_;

namespace protobuf_NetworkBan_5frequest_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_NetworkBan_5frequest_2eproto

enum ListType {
  ALL = 0,
  BAN404_SVN = 1,
  STUB = 2,
  GSB = 3,
  UNKNOWN = 4
};
bool ListType_IsValid(int value);
const ListType ListType_MIN = ALL;
const ListType ListType_MAX = UNKNOWN;
const int ListType_ARRAYSIZE = ListType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ListType_descriptor();
inline const ::std::string& ListType_Name(ListType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ListType_descriptor(), value);
}
inline bool ListType_Parse(
    const ::std::string& name, ListType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ListType>(
    ListType_descriptor(), name, value);
}
enum AnswerCode {
  FOUND = 0,
  CLEAR = 1,
  WAIT_RESOLVE = 3
};
bool AnswerCode_IsValid(int value);
const AnswerCode AnswerCode_MIN = FOUND;
const AnswerCode AnswerCode_MAX = WAIT_RESOLVE;
const int AnswerCode_ARRAYSIZE = AnswerCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* AnswerCode_descriptor();
inline const ::std::string& AnswerCode_Name(AnswerCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    AnswerCode_descriptor(), value);
}
inline bool AnswerCode_Parse(
    const ::std::string& name, AnswerCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnswerCode>(
    AnswerCode_descriptor(), name, value);
}
// ===================================================================

class metaData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:metaData) */ {
 public:
  metaData();
  virtual ~metaData();

  metaData(const metaData& from);

  inline metaData& operator=(const metaData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  metaData(metaData&& from) noexcept
    : metaData() {
    *this = ::std::move(from);
  }

  inline metaData& operator=(metaData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const metaData& default_instance();

  static inline const metaData* internal_default_instance() {
    return reinterpret_cast<const metaData*>(
               &_metaData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(metaData* other);
  friend void swap(metaData& a, metaData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline metaData* New() const PROTOBUF_FINAL { return New(NULL); }

  metaData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const metaData& from);
  void MergeFrom(const metaData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(metaData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string info = 1;
  int info_size() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::std::string& info(int index) const;
  ::std::string* mutable_info(int index);
  void set_info(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_info(int index, ::std::string&& value);
  #endif
  void set_info(int index, const char* value);
  void set_info(int index, const char* value, size_t size);
  ::std::string* add_info();
  void add_info(const ::std::string& value);
  #if LANG_CXX11
  void add_info(::std::string&& value);
  #endif
  void add_info(const char* value);
  void add_info(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& info() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_info();

  // repeated .ListType list_type = 2;
  int list_type_size() const;
  void clear_list_type();
  static const int kListTypeFieldNumber = 2;
  ::ListType list_type(int index) const;
  void set_list_type(int index, ::ListType value);
  void add_list_type(::ListType value);
  const ::google::protobuf::RepeatedField<int>& list_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_list_type();

  // optional bool is_root_ban = 3 [default = false];
  bool has_is_root_ban() const;
  void clear_is_root_ban();
  static const int kIsRootBanFieldNumber = 3;
  bool is_root_ban() const;
  void set_is_root_ban(bool value);

  // @@protoc_insertion_point(class_scope:metaData)
 private:
  void set_has_is_root_ban();
  void clear_has_is_root_ban();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> info_;
  ::google::protobuf::RepeatedField<int> list_type_;
  bool is_root_ban_;
  friend struct protobuf_NetworkBan_5frequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class tags_cont : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tags_cont) */ {
 public:
  tags_cont();
  virtual ~tags_cont();

  tags_cont(const tags_cont& from);

  inline tags_cont& operator=(const tags_cont& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  tags_cont(tags_cont&& from) noexcept
    : tags_cont() {
    *this = ::std::move(from);
  }

  inline tags_cont& operator=(tags_cont&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tags_cont& default_instance();

  static inline const tags_cont* internal_default_instance() {
    return reinterpret_cast<const tags_cont*>(
               &_tags_cont_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(tags_cont* other);
  friend void swap(tags_cont& a, tags_cont& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline tags_cont* New() const PROTOBUF_FINAL { return New(NULL); }

  tags_cont* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const tags_cont& from);
  void MergeFrom(const tags_cont& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(tags_cont* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tag = 1;
  int tag_size() const;
  void clear_tag();
  static const int kTagFieldNumber = 1;
  const ::std::string& tag(int index) const;
  ::std::string* mutable_tag(int index);
  void set_tag(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tag(int index, ::std::string&& value);
  #endif
  void set_tag(int index, const char* value);
  void set_tag(int index, const char* value, size_t size);
  ::std::string* add_tag();
  void add_tag(const ::std::string& value);
  #if LANG_CXX11
  void add_tag(::std::string&& value);
  #endif
  void add_tag(const char* value);
  void add_tag(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tag() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tag();

  // @@protoc_insertion_point(class_scope:tags_cont)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tag_;
  friend struct protobuf_NetworkBan_5frequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NetworkBan_request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetworkBan_request) */ {
 public:
  NetworkBan_request();
  virtual ~NetworkBan_request();

  NetworkBan_request(const NetworkBan_request& from);

  inline NetworkBan_request& operator=(const NetworkBan_request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkBan_request(NetworkBan_request&& from) noexcept
    : NetworkBan_request() {
    *this = ::std::move(from);
  }

  inline NetworkBan_request& operator=(NetworkBan_request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkBan_request& default_instance();

  static inline const NetworkBan_request* internal_default_instance() {
    return reinterpret_cast<const NetworkBan_request*>(
               &_NetworkBan_request_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(NetworkBan_request* other);
  friend void swap(NetworkBan_request& a, NetworkBan_request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkBan_request* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkBan_request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkBan_request& from);
  void MergeFrom(const NetworkBan_request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkBan_request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string urls = 3;
  int urls_size() const;
  void clear_urls();
  static const int kUrlsFieldNumber = 3;
  const ::std::string& urls(int index) const;
  ::std::string* mutable_urls(int index);
  void set_urls(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_urls(int index, ::std::string&& value);
  #endif
  void set_urls(int index, const char* value);
  void set_urls(int index, const char* value, size_t size);
  ::std::string* add_urls();
  void add_urls(const ::std::string& value);
  #if LANG_CXX11
  void add_urls(::std::string&& value);
  #endif
  void add_urls(const char* value);
  void add_urls(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& urls() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_urls();

  // repeated .tags_cont tags = 5;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 5;
  const ::tags_cont& tags(int index) const;
  ::tags_cont* mutable_tags(int index);
  ::tags_cont* add_tags();
  ::google::protobuf::RepeatedPtrField< ::tags_cont >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::tags_cont >&
      tags() const;

  // optional string query = 4;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 4;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // optional string client_name = 7 [default = ""];
  bool has_client_name() const;
  void clear_client_name();
  static const int kClientNameFieldNumber = 7;
  const ::std::string& client_name() const;
  void set_client_name(const ::std::string& value);
  #if LANG_CXX11
  void set_client_name(::std::string&& value);
  #endif
  void set_client_name(const char* value);
  void set_client_name(const char* value, size_t size);
  ::std::string* mutable_client_name();
  ::std::string* release_client_name();
  void set_allocated_client_name(::std::string* client_name);

  // optional bool need_metadata = 1 [default = false];
  bool has_need_metadata() const;
  void clear_need_metadata();
  static const int kNeedMetadataFieldNumber = 1;
  bool need_metadata() const;
  void set_need_metadata(bool value);

  // optional .ListType list_type = 2 [default = ALL];
  bool has_list_type() const;
  void clear_list_type();
  static const int kListTypeFieldNumber = 2;
  ::ListType list_type() const;
  void set_list_type(::ListType value);

  // optional bool need_normalize = 6 [default = true];
  bool has_need_normalize() const;
  void clear_need_normalize();
  static const int kNeedNormalizeFieldNumber = 6;
  bool need_normalize() const;
  void set_need_normalize(bool value);

  // @@protoc_insertion_point(class_scope:NetworkBan_request)
 private:
  void set_has_need_metadata();
  void clear_has_need_metadata();
  void set_has_list_type();
  void clear_has_list_type();
  void set_has_query();
  void clear_has_query();
  void set_has_need_normalize();
  void clear_has_need_normalize();
  void set_has_client_name();
  void clear_has_client_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> urls_;
  ::google::protobuf::RepeatedPtrField< ::tags_cont > tags_;
  ::google::protobuf::internal::ArenaStringPtr query_;
  ::google::protobuf::internal::ArenaStringPtr client_name_;
  bool need_metadata_;
  int list_type_;
  bool need_normalize_;
  friend struct protobuf_NetworkBan_5frequest_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NetworkBan_answer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetworkBan_answer) */ {
 public:
  NetworkBan_answer();
  virtual ~NetworkBan_answer();

  NetworkBan_answer(const NetworkBan_answer& from);

  inline NetworkBan_answer& operator=(const NetworkBan_answer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkBan_answer(NetworkBan_answer&& from) noexcept
    : NetworkBan_answer() {
    *this = ::std::move(from);
  }

  inline NetworkBan_answer& operator=(NetworkBan_answer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkBan_answer& default_instance();

  static inline const NetworkBan_answer* internal_default_instance() {
    return reinterpret_cast<const NetworkBan_answer*>(
               &_NetworkBan_answer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NetworkBan_answer* other);
  friend void swap(NetworkBan_answer& a, NetworkBan_answer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkBan_answer* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkBan_answer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkBan_answer& from);
  void MergeFrom(const NetworkBan_answer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkBan_answer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AnswerCode ans_codes = 1;
  int ans_codes_size() const;
  void clear_ans_codes();
  static const int kAnsCodesFieldNumber = 1;
  ::AnswerCode ans_codes(int index) const;
  void set_ans_codes(int index, ::AnswerCode value);
  void add_ans_codes(::AnswerCode value);
  const ::google::protobuf::RepeatedField<int>& ans_codes() const;
  ::google::protobuf::RepeatedField<int>* mutable_ans_codes();

  // repeated .metaData mata_data = 2;
  int mata_data_size() const;
  void clear_mata_data();
  static const int kMataDataFieldNumber = 2;
  const ::metaData& mata_data(int index) const;
  ::metaData* mutable_mata_data(int index);
  ::metaData* add_mata_data();
  ::google::protobuf::RepeatedPtrField< ::metaData >*
      mutable_mata_data();
  const ::google::protobuf::RepeatedPtrField< ::metaData >&
      mata_data() const;

  // required int64 state_hash = 3;
  bool has_state_hash() const;
  void clear_state_hash();
  static const int kStateHashFieldNumber = 3;
  ::google::protobuf::int64 state_hash() const;
  void set_state_hash(::google::protobuf::int64 value);

  // optional bool ban_all = 4;
  bool has_ban_all() const;
  void clear_ban_all();
  static const int kBanAllFieldNumber = 4;
  bool ban_all() const;
  void set_ban_all(bool value);

  // @@protoc_insertion_point(class_scope:NetworkBan_answer)
 private:
  void set_has_state_hash();
  void clear_has_state_hash();
  void set_has_ban_all();
  void clear_has_ban_all();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> ans_codes_;
  ::google::protobuf::RepeatedPtrField< ::metaData > mata_data_;
  ::google::protobuf::int64 state_hash_;
  bool ban_all_;
  friend struct protobuf_NetworkBan_5frequest_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// metaData

// repeated string info = 1;
inline int metaData::info_size() const {
  return info_.size();
}
inline void metaData::clear_info() {
  info_.Clear();
}
inline const ::std::string& metaData::info(int index) const {
  // @@protoc_insertion_point(field_get:metaData.info)
  return info_.Get(index);
}
inline ::std::string* metaData::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:metaData.info)
  return info_.Mutable(index);
}
inline void metaData::set_info(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:metaData.info)
  info_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void metaData::set_info(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:metaData.info)
  info_.Mutable(index)->assign(std::move(value));
}
#endif
inline void metaData::set_info(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  info_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:metaData.info)
}
inline void metaData::set_info(int index, const char* value, size_t size) {
  info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:metaData.info)
}
inline ::std::string* metaData::add_info() {
  // @@protoc_insertion_point(field_add_mutable:metaData.info)
  return info_.Add();
}
inline void metaData::add_info(const ::std::string& value) {
  info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:metaData.info)
}
#if LANG_CXX11
inline void metaData::add_info(::std::string&& value) {
  info_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:metaData.info)
}
#endif
inline void metaData::add_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:metaData.info)
}
inline void metaData::add_info(const char* value, size_t size) {
  info_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:metaData.info)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
metaData::info() const {
  // @@protoc_insertion_point(field_list:metaData.info)
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
metaData::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:metaData.info)
  return &info_;
}

// repeated .ListType list_type = 2;
inline int metaData::list_type_size() const {
  return list_type_.size();
}
inline void metaData::clear_list_type() {
  list_type_.Clear();
}
inline ::ListType metaData::list_type(int index) const {
  // @@protoc_insertion_point(field_get:metaData.list_type)
  return static_cast< ::ListType >(list_type_.Get(index));
}
inline void metaData::set_list_type(int index, ::ListType value) {
  assert(::ListType_IsValid(value));
  list_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:metaData.list_type)
}
inline void metaData::add_list_type(::ListType value) {
  assert(::ListType_IsValid(value));
  list_type_.Add(value);
  // @@protoc_insertion_point(field_add:metaData.list_type)
}
inline const ::google::protobuf::RepeatedField<int>&
metaData::list_type() const {
  // @@protoc_insertion_point(field_list:metaData.list_type)
  return list_type_;
}
inline ::google::protobuf::RepeatedField<int>*
metaData::mutable_list_type() {
  // @@protoc_insertion_point(field_mutable_list:metaData.list_type)
  return &list_type_;
}

// optional bool is_root_ban = 3 [default = false];
inline bool metaData::has_is_root_ban() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void metaData::set_has_is_root_ban() {
  _has_bits_[0] |= 0x00000001u;
}
inline void metaData::clear_has_is_root_ban() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void metaData::clear_is_root_ban() {
  is_root_ban_ = false;
  clear_has_is_root_ban();
}
inline bool metaData::is_root_ban() const {
  // @@protoc_insertion_point(field_get:metaData.is_root_ban)
  return is_root_ban_;
}
inline void metaData::set_is_root_ban(bool value) {
  set_has_is_root_ban();
  is_root_ban_ = value;
  // @@protoc_insertion_point(field_set:metaData.is_root_ban)
}

// -------------------------------------------------------------------

// tags_cont

// repeated string tag = 1;
inline int tags_cont::tag_size() const {
  return tag_.size();
}
inline void tags_cont::clear_tag() {
  tag_.Clear();
}
inline const ::std::string& tags_cont::tag(int index) const {
  // @@protoc_insertion_point(field_get:tags_cont.tag)
  return tag_.Get(index);
}
inline ::std::string* tags_cont::mutable_tag(int index) {
  // @@protoc_insertion_point(field_mutable:tags_cont.tag)
  return tag_.Mutable(index);
}
inline void tags_cont::set_tag(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tags_cont.tag)
  tag_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void tags_cont::set_tag(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tags_cont.tag)
  tag_.Mutable(index)->assign(std::move(value));
}
#endif
inline void tags_cont::set_tag(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tags_cont.tag)
}
inline void tags_cont::set_tag(int index, const char* value, size_t size) {
  tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tags_cont.tag)
}
inline ::std::string* tags_cont::add_tag() {
  // @@protoc_insertion_point(field_add_mutable:tags_cont.tag)
  return tag_.Add();
}
inline void tags_cont::add_tag(const ::std::string& value) {
  tag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tags_cont.tag)
}
#if LANG_CXX11
inline void tags_cont::add_tag(::std::string&& value) {
  tag_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tags_cont.tag)
}
#endif
inline void tags_cont::add_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tags_cont.tag)
}
inline void tags_cont::add_tag(const char* value, size_t size) {
  tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tags_cont.tag)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
tags_cont::tag() const {
  // @@protoc_insertion_point(field_list:tags_cont.tag)
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
tags_cont::mutable_tag() {
  // @@protoc_insertion_point(field_mutable_list:tags_cont.tag)
  return &tag_;
}

// -------------------------------------------------------------------

// NetworkBan_request

// optional bool need_metadata = 1 [default = false];
inline bool NetworkBan_request::has_need_metadata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkBan_request::set_has_need_metadata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetworkBan_request::clear_has_need_metadata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkBan_request::clear_need_metadata() {
  need_metadata_ = false;
  clear_has_need_metadata();
}
inline bool NetworkBan_request::need_metadata() const {
  // @@protoc_insertion_point(field_get:NetworkBan_request.need_metadata)
  return need_metadata_;
}
inline void NetworkBan_request::set_need_metadata(bool value) {
  set_has_need_metadata();
  need_metadata_ = value;
  // @@protoc_insertion_point(field_set:NetworkBan_request.need_metadata)
}

// optional .ListType list_type = 2 [default = ALL];
inline bool NetworkBan_request::has_list_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetworkBan_request::set_has_list_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetworkBan_request::clear_has_list_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetworkBan_request::clear_list_type() {
  list_type_ = 0;
  clear_has_list_type();
}
inline ::ListType NetworkBan_request::list_type() const {
  // @@protoc_insertion_point(field_get:NetworkBan_request.list_type)
  return static_cast< ::ListType >(list_type_);
}
inline void NetworkBan_request::set_list_type(::ListType value) {
  assert(::ListType_IsValid(value));
  set_has_list_type();
  list_type_ = value;
  // @@protoc_insertion_point(field_set:NetworkBan_request.list_type)
}

// repeated string urls = 3;
inline int NetworkBan_request::urls_size() const {
  return urls_.size();
}
inline void NetworkBan_request::clear_urls() {
  urls_.Clear();
}
inline const ::std::string& NetworkBan_request::urls(int index) const {
  // @@protoc_insertion_point(field_get:NetworkBan_request.urls)
  return urls_.Get(index);
}
inline ::std::string* NetworkBan_request::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkBan_request.urls)
  return urls_.Mutable(index);
}
inline void NetworkBan_request::set_urls(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:NetworkBan_request.urls)
  urls_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NetworkBan_request::set_urls(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:NetworkBan_request.urls)
  urls_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NetworkBan_request::set_urls(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  urls_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:NetworkBan_request.urls)
}
inline void NetworkBan_request::set_urls(int index, const char* value, size_t size) {
  urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NetworkBan_request.urls)
}
inline ::std::string* NetworkBan_request::add_urls() {
  // @@protoc_insertion_point(field_add_mutable:NetworkBan_request.urls)
  return urls_.Add();
}
inline void NetworkBan_request::add_urls(const ::std::string& value) {
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:NetworkBan_request.urls)
}
#if LANG_CXX11
inline void NetworkBan_request::add_urls(::std::string&& value) {
  urls_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:NetworkBan_request.urls)
}
#endif
inline void NetworkBan_request::add_urls(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  urls_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:NetworkBan_request.urls)
}
inline void NetworkBan_request::add_urls(const char* value, size_t size) {
  urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:NetworkBan_request.urls)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkBan_request::urls() const {
  // @@protoc_insertion_point(field_list:NetworkBan_request.urls)
  return urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkBan_request::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:NetworkBan_request.urls)
  return &urls_;
}

// optional string query = 4;
inline bool NetworkBan_request::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkBan_request::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkBan_request::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkBan_request::clear_query() {
  query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_query();
}
inline const ::std::string& NetworkBan_request::query() const {
  // @@protoc_insertion_point(field_get:NetworkBan_request.query)
  return query_.GetNoArena();
}
inline void NetworkBan_request::set_query(const ::std::string& value) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkBan_request.query)
}
#if LANG_CXX11
inline void NetworkBan_request::set_query(::std::string&& value) {
  set_has_query();
  query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NetworkBan_request.query)
}
#endif
inline void NetworkBan_request::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkBan_request.query)
}
inline void NetworkBan_request::set_query(const char* value, size_t size) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkBan_request.query)
}
inline ::std::string* NetworkBan_request::mutable_query() {
  set_has_query();
  // @@protoc_insertion_point(field_mutable:NetworkBan_request.query)
  return query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkBan_request::release_query() {
  // @@protoc_insertion_point(field_release:NetworkBan_request.query)
  clear_has_query();
  return query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkBan_request::set_allocated_query(::std::string* query) {
  if (query != NULL) {
    set_has_query();
  } else {
    clear_has_query();
  }
  query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:NetworkBan_request.query)
}

// repeated .tags_cont tags = 5;
inline int NetworkBan_request::tags_size() const {
  return tags_.size();
}
inline void NetworkBan_request::clear_tags() {
  tags_.Clear();
}
inline const ::tags_cont& NetworkBan_request::tags(int index) const {
  // @@protoc_insertion_point(field_get:NetworkBan_request.tags)
  return tags_.Get(index);
}
inline ::tags_cont* NetworkBan_request::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkBan_request.tags)
  return tags_.Mutable(index);
}
inline ::tags_cont* NetworkBan_request::add_tags() {
  // @@protoc_insertion_point(field_add:NetworkBan_request.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tags_cont >*
NetworkBan_request::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:NetworkBan_request.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tags_cont >&
NetworkBan_request::tags() const {
  // @@protoc_insertion_point(field_list:NetworkBan_request.tags)
  return tags_;
}

// optional bool need_normalize = 6 [default = true];
inline bool NetworkBan_request::has_need_normalize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetworkBan_request::set_has_need_normalize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetworkBan_request::clear_has_need_normalize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetworkBan_request::clear_need_normalize() {
  need_normalize_ = true;
  clear_has_need_normalize();
}
inline bool NetworkBan_request::need_normalize() const {
  // @@protoc_insertion_point(field_get:NetworkBan_request.need_normalize)
  return need_normalize_;
}
inline void NetworkBan_request::set_need_normalize(bool value) {
  set_has_need_normalize();
  need_normalize_ = value;
  // @@protoc_insertion_point(field_set:NetworkBan_request.need_normalize)
}

// optional string client_name = 7 [default = ""];
inline bool NetworkBan_request::has_client_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkBan_request::set_has_client_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkBan_request::clear_has_client_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkBan_request::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_name();
}
inline const ::std::string& NetworkBan_request::client_name() const {
  // @@protoc_insertion_point(field_get:NetworkBan_request.client_name)
  return client_name_.GetNoArena();
}
inline void NetworkBan_request::set_client_name(const ::std::string& value) {
  set_has_client_name();
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkBan_request.client_name)
}
#if LANG_CXX11
inline void NetworkBan_request::set_client_name(::std::string&& value) {
  set_has_client_name();
  client_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NetworkBan_request.client_name)
}
#endif
inline void NetworkBan_request::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_name();
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkBan_request.client_name)
}
inline void NetworkBan_request::set_client_name(const char* value, size_t size) {
  set_has_client_name();
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkBan_request.client_name)
}
inline ::std::string* NetworkBan_request::mutable_client_name() {
  set_has_client_name();
  // @@protoc_insertion_point(field_mutable:NetworkBan_request.client_name)
  return client_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkBan_request::release_client_name() {
  // @@protoc_insertion_point(field_release:NetworkBan_request.client_name)
  clear_has_client_name();
  return client_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkBan_request::set_allocated_client_name(::std::string* client_name) {
  if (client_name != NULL) {
    set_has_client_name();
  } else {
    clear_has_client_name();
  }
  client_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:NetworkBan_request.client_name)
}

// -------------------------------------------------------------------

// NetworkBan_answer

// repeated .AnswerCode ans_codes = 1;
inline int NetworkBan_answer::ans_codes_size() const {
  return ans_codes_.size();
}
inline void NetworkBan_answer::clear_ans_codes() {
  ans_codes_.Clear();
}
inline ::AnswerCode NetworkBan_answer::ans_codes(int index) const {
  // @@protoc_insertion_point(field_get:NetworkBan_answer.ans_codes)
  return static_cast< ::AnswerCode >(ans_codes_.Get(index));
}
inline void NetworkBan_answer::set_ans_codes(int index, ::AnswerCode value) {
  assert(::AnswerCode_IsValid(value));
  ans_codes_.Set(index, value);
  // @@protoc_insertion_point(field_set:NetworkBan_answer.ans_codes)
}
inline void NetworkBan_answer::add_ans_codes(::AnswerCode value) {
  assert(::AnswerCode_IsValid(value));
  ans_codes_.Add(value);
  // @@protoc_insertion_point(field_add:NetworkBan_answer.ans_codes)
}
inline const ::google::protobuf::RepeatedField<int>&
NetworkBan_answer::ans_codes() const {
  // @@protoc_insertion_point(field_list:NetworkBan_answer.ans_codes)
  return ans_codes_;
}
inline ::google::protobuf::RepeatedField<int>*
NetworkBan_answer::mutable_ans_codes() {
  // @@protoc_insertion_point(field_mutable_list:NetworkBan_answer.ans_codes)
  return &ans_codes_;
}

// repeated .metaData mata_data = 2;
inline int NetworkBan_answer::mata_data_size() const {
  return mata_data_.size();
}
inline void NetworkBan_answer::clear_mata_data() {
  mata_data_.Clear();
}
inline const ::metaData& NetworkBan_answer::mata_data(int index) const {
  // @@protoc_insertion_point(field_get:NetworkBan_answer.mata_data)
  return mata_data_.Get(index);
}
inline ::metaData* NetworkBan_answer::mutable_mata_data(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkBan_answer.mata_data)
  return mata_data_.Mutable(index);
}
inline ::metaData* NetworkBan_answer::add_mata_data() {
  // @@protoc_insertion_point(field_add:NetworkBan_answer.mata_data)
  return mata_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::metaData >*
NetworkBan_answer::mutable_mata_data() {
  // @@protoc_insertion_point(field_mutable_list:NetworkBan_answer.mata_data)
  return &mata_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::metaData >&
NetworkBan_answer::mata_data() const {
  // @@protoc_insertion_point(field_list:NetworkBan_answer.mata_data)
  return mata_data_;
}

// required int64 state_hash = 3;
inline bool NetworkBan_answer::has_state_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkBan_answer::set_has_state_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkBan_answer::clear_has_state_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkBan_answer::clear_state_hash() {
  state_hash_ = GOOGLE_LONGLONG(0);
  clear_has_state_hash();
}
inline ::google::protobuf::int64 NetworkBan_answer::state_hash() const {
  // @@protoc_insertion_point(field_get:NetworkBan_answer.state_hash)
  return state_hash_;
}
inline void NetworkBan_answer::set_state_hash(::google::protobuf::int64 value) {
  set_has_state_hash();
  state_hash_ = value;
  // @@protoc_insertion_point(field_set:NetworkBan_answer.state_hash)
}

// optional bool ban_all = 4;
inline bool NetworkBan_answer::has_ban_all() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkBan_answer::set_has_ban_all() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkBan_answer::clear_has_ban_all() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkBan_answer::clear_ban_all() {
  ban_all_ = false;
  clear_has_ban_all();
}
inline bool NetworkBan_answer::ban_all() const {
  // @@protoc_insertion_point(field_get:NetworkBan_answer.ban_all)
  return ban_all_;
}
inline void NetworkBan_answer::set_ban_all(bool value) {
  set_has_ban_all();
  ban_all_ = value;
  // @@protoc_insertion_point(field_set:NetworkBan_answer.ban_all)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ListType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ListType>() {
  return ::ListType_descriptor();
}
template <> struct is_proto_enum< ::AnswerCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AnswerCode>() {
  return ::AnswerCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NetworkBan_5frequest_2eproto__INCLUDED
