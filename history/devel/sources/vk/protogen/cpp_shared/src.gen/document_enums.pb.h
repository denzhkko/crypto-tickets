// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: document_enums.proto

#ifndef PROTOBUF_document_5fenums_2eproto__INCLUDED
#define PROTOBUF_document_5fenums_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {
}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {

namespace protobuf_document_5fenums_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_document_5fenums_2eproto

enum Language {
  lang_unknown = 0,
  lang_russian = 1,
  lang_cyrillic = 2,
  lang_bolgarian = 3,
  lang_ukrainian = 4,
  lang_byelorussian = 5,
  lang_kazakh = 6,
  lang_english = 7,
  lang_error = 8,
  lang_not_enough_info = 9,
  lang_german = 10,
  lang_french = 11,
  lang_spanish = 12,
  lang_finnish = 13,
  lang_czech = 14,
  lang_hungarian = 15,
  lang_italian = 16,
  lang_dutch = 17,
  lang_norwegian = 18,
  lang_polish = 19,
  lang_portuguese = 20,
  lang_romanian = 21,
  lang_swedish = 22,
  lang_turkish = 23,
  lang_rutranslit = 24
};
bool Language_IsValid(int value);
const Language Language_MIN = lang_unknown;
const Language Language_MAX = lang_rutranslit;
const int Language_ARRAYSIZE = Language_MAX + 1;

const ::google::protobuf::EnumDescriptor* Language_descriptor();
inline const ::std::string& Language_Name(Language value) {
  return ::google::protobuf::internal::NameOfEnum(
    Language_descriptor(), value);
}
inline bool Language_Parse(
    const ::std::string& name, Language* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Language>(
    Language_descriptor(), name, value);
}
enum Encoding {
  enc_unknown = 0,
  enc_utf_8 = 1,
  enc_cp1251 = 2,
  enc_koi8_r = 3,
  enc_us_ascii = 4,
  enc_iso_8859_1 = 5,
  enc_iso_8859_2 = 6,
  enc_iso_8859_3 = 7,
  enc_iso_8859_4 = 8,
  enc_iso_8859_5 = 9,
  enc_iso_8859_7 = 10,
  enc_iso_8859_9 = 11,
  enc_iso_8859_10 = 12,
  enc_iso_8859_13 = 13,
  enc_iso_8859_14 = 14,
  enc_iso_8859_15 = 15,
  enc_iso_8859_16 = 16,
  enc_koi8_u = 17,
  enc_cp1250 = 18,
  enc_cp1252 = 19,
  enc_cp1253 = 20,
  enc_cp1254 = 21,
  enc_cp1257 = 22,
  enc_cp850 = 23,
  enc_cp866 = 24,
  enc_cp1131 = 25,
  enc_macroman = 26,
  enc_maccentraleurope = 27,
  enc_maciceland = 28,
  enc_maccroatian = 29,
  enc_macromania = 30,
  enc_maccyrillic = 31,
  enc_macukraine = 32,
  enc_macgreek = 33,
  enc_macturkish = 34,
  enc_macintosh = 35,
  enc_iso_8859_6 = 36,
  enc_iso_8859_8 = 37,
  enc_cp1255 = 38,
  enc_cp1256 = 39,
  enc_cp862 = 40,
  enc_machebrew = 41,
  enc_macarabic = 42,
  enc_euc_jp = 43,
  enc_shift_jis = 44,
  enc_cp932 = 45,
  enc_iso_2022_jp = 46,
  enc_iso_2022_jp_2 = 47,
  enc_iso_2022_jp_1 = 48,
  enc_euc_cn = 49,
  enc_hz = 50,
  enc_gbk = 51,
  enc_cp936 = 52,
  enc_gb18030 = 53,
  enc_euc_tw = 54,
  enc_big5 = 55,
  enc_cp950 = 56,
  enc_big5_hkscs = 57,
  enc_iso_2022_cn = 58,
  enc_iso_2022_cn_ext = 59,
  enc_euc_kr = 60,
  enc_cp949 = 61,
  enc_iso_2022_kr = 62,
  enc_johab = 63,
  enc_armscii_8 = 64,
  enc_georgian_academy = 65,
  enc_georgian_ps = 66,
  enc_koi8_t = 67,
  enc_pt154 = 68,
  enc_rk1048 = 69,
  enc_iso_8859_11 = 70,
  enc_tis_620 = 71,
  enc_cp874 = 72,
  enc_macthai = 73,
  enc_mulelao_1 = 74,
  enc_cp1133 = 75,
  enc_viscii = 76,
  enc_tcvn = 77,
  enc_cp1258 = 78,
  enc_hp_roman8 = 79,
  enc_nextstep = 80,
  enc_ucs_2 = 81,
  enc_ucs_2be = 82,
  enc_ucs_2le = 83,
  enc_ucs_4 = 84,
  enc_ucs_4be = 85,
  enc_ucs_4le = 86,
  enc_utf_16 = 87,
  enc_utf_16be = 88,
  enc_utf_16le = 89,
  enc_utf_32 = 90,
  enc_utf_32be = 91,
  enc_utf_32le = 92,
  enc_utf_7 = 93,
  enc_c99 = 94,
  enc_java = 95,
  enc_ucs_2_internal = 96,
  enc_ucs_4_internal = 97,
  enc_undefined = 99
};
bool Encoding_IsValid(int value);
const Encoding Encoding_MIN = enc_unknown;
const Encoding Encoding_MAX = enc_undefined;
const int Encoding_ARRAYSIZE = Encoding_MAX + 1;

const ::google::protobuf::EnumDescriptor* Encoding_descriptor();
inline const ::std::string& Encoding_Name(Encoding value) {
  return ::google::protobuf::internal::NameOfEnum(
    Encoding_descriptor(), value);
}
inline bool Encoding_Parse(
    const ::std::string& name, Encoding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Encoding>(
    Encoding_descriptor(), name, value);
}
enum ContentType {
  type_unknown = 0,
  type_html = 1,
  type_jpeg = 2,
  type_gif = 3,
  type_png = 4,
  type_pdf = 5,
  type_doc = 6,
  type_docx = 7,
  type_rtf = 8,
  type_ppt = 9,
  type_pptx = 10,
  type_xls = 11,
  type_xlsx = 12,
  type_txt = 13,
  type_xml = 14,
  type_ps = 15,
  type_wml = 16,
  type_atom = 17,
  type_sitemap = 18,
  type_rss = 19,
  type_json = 20,
  type_riff_webp = 21
};
bool ContentType_IsValid(int value);
const ContentType ContentType_MIN = type_unknown;
const ContentType ContentType_MAX = type_riff_webp;
const int ContentType_ARRAYSIZE = ContentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContentType_descriptor();
inline const ::std::string& ContentType_Name(ContentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContentType_descriptor(), value);
}
inline bool ContentType_Parse(
    const ::std::string& name, ContentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContentType>(
    ContentType_descriptor(), name, value);
}
enum MetaRobots {
  r_unknown = 0,
  r_nofollow = 1,
  r_noindex = 2,
  r_noarchive = 4,
  r_nosnippet = 8
};
bool MetaRobots_IsValid(int value);
const MetaRobots MetaRobots_MIN = r_unknown;
const MetaRobots MetaRobots_MAX = r_nosnippet;
const int MetaRobots_ARRAYSIZE = MetaRobots_MAX + 1;

const ::google::protobuf::EnumDescriptor* MetaRobots_descriptor();
inline const ::std::string& MetaRobots_Name(MetaRobots value) {
  return ::google::protobuf::internal::NameOfEnum(
    MetaRobots_descriptor(), value);
}
inline bool MetaRobots_Parse(
    const ::std::string& name, MetaRobots* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MetaRobots>(
    MetaRobots_descriptor(), name, value);
}
enum ForumType {
  unknown = 0,
  topic = 1,
  board = 2,
  other = 3
};
bool ForumType_IsValid(int value);
const ForumType ForumType_MIN = unknown;
const ForumType ForumType_MAX = other;
const int ForumType_ARRAYSIZE = ForumType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ForumType_descriptor();
inline const ::std::string& ForumType_Name(ForumType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ForumType_descriptor(), value);
}
inline bool ForumType_Parse(
    const ::std::string& name, ForumType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ForumType>(
    ForumType_descriptor(), name, value);
}
enum RobotsState {
  not_checked = 0,
  allowed = 1,
  disallowed = 2
};
bool RobotsState_IsValid(int value);
const RobotsState RobotsState_MIN = not_checked;
const RobotsState RobotsState_MAX = disallowed;
const int RobotsState_ARRAYSIZE = RobotsState_MAX + 1;

const ::google::protobuf::EnumDescriptor* RobotsState_descriptor();
inline const ::std::string& RobotsState_Name(RobotsState value) {
  return ::google::protobuf::internal::NameOfEnum(
    RobotsState_descriptor(), value);
}
inline bool RobotsState_Parse(
    const ::std::string& name, RobotsState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotsState>(
    RobotsState_descriptor(), name, value);
}
enum SourceMark {
  FBL = 0,
  STUB = 1,
  RBT = 2,
  CHR = 3
};
bool SourceMark_IsValid(int value);
const SourceMark SourceMark_MIN = FBL;
const SourceMark SourceMark_MAX = CHR;
const int SourceMark_ARRAYSIZE = SourceMark_MAX + 1;

const ::google::protobuf::EnumDescriptor* SourceMark_descriptor();
inline const ::std::string& SourceMark_Name(SourceMark value) {
  return ::google::protobuf::internal::NameOfEnum(
    SourceMark_descriptor(), value);
}
inline bool SourceMark_Parse(
    const ::std::string& name, SourceMark* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SourceMark>(
    SourceMark_descriptor(), name, value);
}
enum RenderType {
  R_NONE = 0,
  R_SIMPLE_CHROME = 1
};
bool RenderType_IsValid(int value);
const RenderType RenderType_MIN = R_NONE;
const RenderType RenderType_MAX = R_SIMPLE_CHROME;
const int RenderType_ARRAYSIZE = RenderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RenderType_descriptor();
inline const ::std::string& RenderType_Name(RenderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RenderType_descriptor(), value);
}
inline bool RenderType_Parse(
    const ::std::string& name, RenderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RenderType>(
    RenderType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)


}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::Language> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::Language>() {
  return ::ru::mail::go::webbase::blobs::Language_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::Encoding> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::Encoding>() {
  return ::ru::mail::go::webbase::blobs::Encoding_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::ContentType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::ContentType>() {
  return ::ru::mail::go::webbase::blobs::ContentType_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::MetaRobots> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::MetaRobots>() {
  return ::ru::mail::go::webbase::blobs::MetaRobots_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::ForumType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::ForumType>() {
  return ::ru::mail::go::webbase::blobs::ForumType_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::RobotsState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::RobotsState>() {
  return ::ru::mail::go::webbase::blobs::RobotsState_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::SourceMark> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::SourceMark>() {
  return ::ru::mail::go::webbase::blobs::SourceMark_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::RenderType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::RenderType>() {
  return ::ru::mail::go::webbase::blobs::RenderType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_document_5fenums_2eproto__INCLUDED
