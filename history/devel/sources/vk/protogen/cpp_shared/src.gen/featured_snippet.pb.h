// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: featured_snippet.proto

#ifndef PROTOBUF_featured_5fsnippet_2eproto__INCLUDED
#define PROTOBUF_featured_5fsnippet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace snippet {
namespace featured {
class Answer;
class AnswerDefaultTypeInternal;
extern AnswerDefaultTypeInternal _Answer_default_instance_;
class AnswerInfo;
class AnswerInfoDefaultTypeInternal;
extern AnswerInfoDefaultTypeInternal _AnswerInfo_default_instance_;
class Document;
class DocumentDefaultTypeInternal;
extern DocumentDefaultTypeInternal _Document_default_instance_;
class Img;
class ImgDefaultTypeInternal;
extern ImgDefaultTypeInternal _Img_default_instance_;
class QAItem;
class QAItemDefaultTypeInternal;
extern QAItemDefaultTypeInternal _QAItem_default_instance_;
class Question;
class QuestionDefaultTypeInternal;
extern QuestionDefaultTypeInternal _Question_default_instance_;
class QuestionComment;
class QuestionCommentDefaultTypeInternal;
extern QuestionCommentDefaultTypeInternal _QuestionComment_default_instance_;
class QuestionInfo;
class QuestionInfoDefaultTypeInternal;
extern QuestionInfoDefaultTypeInternal _QuestionInfo_default_instance_;
}  // namespace featured
}  // namespace snippet
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace snippet {
namespace featured {

namespace protobuf_featured_5fsnippet_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_featured_5fsnippet_2eproto

enum Source {
  NONE = 0,
  OTVET_MAIL_RU = 1,
  BOLSHOY_VOPROS = 2,
  FB = 3,
  ZNANIJA = 4,
  KAK_PROSTO = 5,
  WIKI_RU = 6,
  SYL = 7,
  SOVET_CLUB = 8,
  ELHOW = 9,
  SOVETS = 10,
  OK = 11
};
bool Source_IsValid(int value);
const Source Source_MIN = NONE;
const Source Source_MAX = OK;
const int Source_ARRAYSIZE = Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* Source_descriptor();
inline const ::std::string& Source_Name(Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    Source_descriptor(), value);
}
inline bool Source_Parse(
    const ::std::string& name, Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Source>(
    Source_descriptor(), name, value);
}
// ===================================================================

class Img : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.snippet.featured.Img) */ {
 public:
  Img();
  virtual ~Img();

  Img(const Img& from);

  inline Img& operator=(const Img& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Img(Img&& from) noexcept
    : Img() {
    *this = ::std::move(from);
  }

  inline Img& operator=(Img&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Img& default_instance();

  static inline const Img* internal_default_instance() {
    return reinterpret_cast<const Img*>(
               &_Img_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Img* other);
  friend void swap(Img& a, Img& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Img* New() const PROTOBUF_FINAL { return New(NULL); }

  Img* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Img& from);
  void MergeFrom(const Img& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Img* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:ru.mail.go.snippet.featured.Img)
 private:
  void set_has_url();
  void clear_has_url();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  friend struct protobuf_featured_5fsnippet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QuestionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.snippet.featured.QuestionInfo) */ {
 public:
  QuestionInfo();
  virtual ~QuestionInfo();

  QuestionInfo(const QuestionInfo& from);

  inline QuestionInfo& operator=(const QuestionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QuestionInfo(QuestionInfo&& from) noexcept
    : QuestionInfo() {
    *this = ::std::move(from);
  }

  inline QuestionInfo& operator=(QuestionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuestionInfo& default_instance();

  static inline const QuestionInfo* internal_default_instance() {
    return reinterpret_cast<const QuestionInfo*>(
               &_QuestionInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(QuestionInfo* other);
  friend void swap(QuestionInfo& a, QuestionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QuestionInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  QuestionInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QuestionInfo& from);
  void MergeFrom(const QuestionInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QuestionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string category = 1;
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 1;
  const ::std::string& category() const;
  void set_category(const ::std::string& value);
  #if LANG_CXX11
  void set_category(::std::string&& value);
  #endif
  void set_category(const char* value);
  void set_category(const char* value, size_t size);
  ::std::string* mutable_category();
  ::std::string* release_category();
  void set_allocated_category(::std::string* category);

  // optional string sub_category = 2;
  bool has_sub_category() const;
  void clear_sub_category();
  static const int kSubCategoryFieldNumber = 2;
  const ::std::string& sub_category() const;
  void set_sub_category(const ::std::string& value);
  #if LANG_CXX11
  void set_sub_category(::std::string&& value);
  #endif
  void set_sub_category(const char* value);
  void set_sub_category(const char* value, size_t size);
  ::std::string* mutable_sub_category();
  ::std::string* release_sub_category();
  void set_allocated_sub_category(::std::string* sub_category);

  // @@protoc_insertion_point(class_scope:ru.mail.go.snippet.featured.QuestionInfo)
 private:
  void set_has_category();
  void clear_has_category();
  void set_has_sub_category();
  void clear_has_sub_category();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr category_;
  ::google::protobuf::internal::ArenaStringPtr sub_category_;
  friend struct protobuf_featured_5fsnippet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Question : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.snippet.featured.Question) */ {
 public:
  Question();
  virtual ~Question();

  Question(const Question& from);

  inline Question& operator=(const Question& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Question(Question&& from) noexcept
    : Question() {
    *this = ::std::move(from);
  }

  inline Question& operator=(Question&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Question& default_instance();

  static inline const Question* internal_default_instance() {
    return reinterpret_cast<const Question*>(
               &_Question_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Question* other);
  friend void swap(Question& a, Question& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Question* New() const PROTOBUF_FINAL { return New(NULL); }

  Question* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Question& from);
  void MergeFrom(const Question& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Question* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional .ru.mail.go.snippet.featured.QuestionInfo info = 2;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::ru::mail::go::snippet::featured::QuestionInfo& info() const;
  ::ru::mail::go::snippet::featured::QuestionInfo* mutable_info();
  ::ru::mail::go::snippet::featured::QuestionInfo* release_info();
  void set_allocated_info(::ru::mail::go::snippet::featured::QuestionInfo* info);

  // @@protoc_insertion_point(class_scope:ru.mail.go.snippet.featured.Question)
 private:
  void set_has_text();
  void clear_has_text();
  void set_has_info();
  void clear_has_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::ru::mail::go::snippet::featured::QuestionInfo* info_;
  friend struct protobuf_featured_5fsnippet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QuestionComment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.snippet.featured.QuestionComment) */ {
 public:
  QuestionComment();
  virtual ~QuestionComment();

  QuestionComment(const QuestionComment& from);

  inline QuestionComment& operator=(const QuestionComment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QuestionComment(QuestionComment&& from) noexcept
    : QuestionComment() {
    *this = ::std::move(from);
  }

  inline QuestionComment& operator=(QuestionComment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuestionComment& default_instance();

  static inline const QuestionComment* internal_default_instance() {
    return reinterpret_cast<const QuestionComment*>(
               &_QuestionComment_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(QuestionComment* other);
  friend void swap(QuestionComment& a, QuestionComment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QuestionComment* New() const PROTOBUF_FINAL { return New(NULL); }

  QuestionComment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QuestionComment& from);
  void MergeFrom(const QuestionComment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QuestionComment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:ru.mail.go.snippet.featured.QuestionComment)
 private:
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  friend struct protobuf_featured_5fsnippet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AnswerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.snippet.featured.AnswerInfo) */ {
 public:
  AnswerInfo();
  virtual ~AnswerInfo();

  AnswerInfo(const AnswerInfo& from);

  inline AnswerInfo& operator=(const AnswerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnswerInfo(AnswerInfo&& from) noexcept
    : AnswerInfo() {
    *this = ::std::move(from);
  }

  inline AnswerInfo& operator=(AnswerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnswerInfo& default_instance();

  static inline const AnswerInfo* internal_default_instance() {
    return reinterpret_cast<const AnswerInfo*>(
               &_AnswerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(AnswerInfo* other);
  friend void swap(AnswerInfo& a, AnswerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnswerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  AnswerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnswerInfo& from);
  void MergeFrom(const AnswerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnswerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool is_best = 1;
  bool has_is_best() const;
  void clear_is_best();
  static const int kIsBestFieldNumber = 1;
  bool is_best() const;
  void set_is_best(bool value);

  // optional int32 likes_count = 2;
  bool has_likes_count() const;
  void clear_likes_count();
  static const int kLikesCountFieldNumber = 2;
  ::google::protobuf::int32 likes_count() const;
  void set_likes_count(::google::protobuf::int32 value);

  // optional int32 comments_count = 3;
  bool has_comments_count() const;
  void clear_comments_count();
  static const int kCommentsCountFieldNumber = 3;
  ::google::protobuf::int32 comments_count() const;
  void set_comments_count(::google::protobuf::int32 value);

  // optional int32 author_rating = 4;
  bool has_author_rating() const;
  void clear_author_rating();
  static const int kAuthorRatingFieldNumber = 4;
  ::google::protobuf::int32 author_rating() const;
  void set_author_rating(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.snippet.featured.AnswerInfo)
 private:
  void set_has_is_best();
  void clear_has_is_best();
  void set_has_likes_count();
  void clear_has_likes_count();
  void set_has_comments_count();
  void clear_has_comments_count();
  void set_has_author_rating();
  void clear_has_author_rating();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool is_best_;
  ::google::protobuf::int32 likes_count_;
  ::google::protobuf::int32 comments_count_;
  ::google::protobuf::int32 author_rating_;
  friend struct protobuf_featured_5fsnippet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Answer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.snippet.featured.Answer) */ {
 public:
  Answer();
  virtual ~Answer();

  Answer(const Answer& from);

  inline Answer& operator=(const Answer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Answer(Answer&& from) noexcept
    : Answer() {
    *this = ::std::move(from);
  }

  inline Answer& operator=(Answer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Answer& default_instance();

  static inline const Answer* internal_default_instance() {
    return reinterpret_cast<const Answer*>(
               &_Answer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Answer* other);
  friend void swap(Answer& a, Answer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Answer* New() const PROTOBUF_FINAL { return New(NULL); }

  Answer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Answer& from);
  void MergeFrom(const Answer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Answer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.snippet.featured.Img img = 2;
  int img_size() const;
  void clear_img();
  static const int kImgFieldNumber = 2;
  const ::ru::mail::go::snippet::featured::Img& img(int index) const;
  ::ru::mail::go::snippet::featured::Img* mutable_img(int index);
  ::ru::mail::go::snippet::featured::Img* add_img();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::Img >*
      mutable_img();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::Img >&
      img() const;

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional .ru.mail.go.snippet.featured.AnswerInfo info = 3;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 3;
  const ::ru::mail::go::snippet::featured::AnswerInfo& info() const;
  ::ru::mail::go::snippet::featured::AnswerInfo* mutable_info();
  ::ru::mail::go::snippet::featured::AnswerInfo* release_info();
  void set_allocated_info(::ru::mail::go::snippet::featured::AnswerInfo* info);

  // @@protoc_insertion_point(class_scope:ru.mail.go.snippet.featured.Answer)
 private:
  void set_has_text();
  void clear_has_text();
  void set_has_info();
  void clear_has_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::Img > img_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::ru::mail::go::snippet::featured::AnswerInfo* info_;
  friend struct protobuf_featured_5fsnippet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QAItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.snippet.featured.QAItem) */ {
 public:
  QAItem();
  virtual ~QAItem();

  QAItem(const QAItem& from);

  inline QAItem& operator=(const QAItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QAItem(QAItem&& from) noexcept
    : QAItem() {
    *this = ::std::move(from);
  }

  inline QAItem& operator=(QAItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QAItem& default_instance();

  static inline const QAItem* internal_default_instance() {
    return reinterpret_cast<const QAItem*>(
               &_QAItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(QAItem* other);
  friend void swap(QAItem& a, QAItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QAItem* New() const PROTOBUF_FINAL { return New(NULL); }

  QAItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QAItem& from);
  void MergeFrom(const QAItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QAItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.snippet.featured.Answer answers = 3;
  int answers_size() const;
  void clear_answers();
  static const int kAnswersFieldNumber = 3;
  const ::ru::mail::go::snippet::featured::Answer& answers(int index) const;
  ::ru::mail::go::snippet::featured::Answer* mutable_answers(int index);
  ::ru::mail::go::snippet::featured::Answer* add_answers();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::Answer >*
      mutable_answers();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::Answer >&
      answers() const;

  // required .ru.mail.go.snippet.featured.Question question = 2;
  bool has_question() const;
  void clear_question();
  static const int kQuestionFieldNumber = 2;
  const ::ru::mail::go::snippet::featured::Question& question() const;
  ::ru::mail::go::snippet::featured::Question* mutable_question();
  ::ru::mail::go::snippet::featured::Question* release_question();
  void set_allocated_question(::ru::mail::go::snippet::featured::Question* question);

  // optional .ru.mail.go.snippet.featured.QuestionComment question_comment = 4;
  bool has_question_comment() const;
  void clear_question_comment();
  static const int kQuestionCommentFieldNumber = 4;
  const ::ru::mail::go::snippet::featured::QuestionComment& question_comment() const;
  ::ru::mail::go::snippet::featured::QuestionComment* mutable_question_comment();
  ::ru::mail::go::snippet::featured::QuestionComment* release_question_comment();
  void set_allocated_question_comment(::ru::mail::go::snippet::featured::QuestionComment* question_comment);

  // required .ru.mail.go.snippet.featured.Source source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::ru::mail::go::snippet::featured::Source source() const;
  void set_source(::ru::mail::go::snippet::featured::Source value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.snippet.featured.QAItem)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_question();
  void clear_has_question();
  void set_has_question_comment();
  void clear_has_question_comment();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::Answer > answers_;
  ::ru::mail::go::snippet::featured::Question* question_;
  ::ru::mail::go::snippet::featured::QuestionComment* question_comment_;
  int source_;
  friend struct protobuf_featured_5fsnippet_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Document : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.snippet.featured.Document) */ {
 public:
  Document();
  virtual ~Document();

  Document(const Document& from);

  inline Document& operator=(const Document& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Document(Document&& from) noexcept
    : Document() {
    *this = ::std::move(from);
  }

  inline Document& operator=(Document&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Document& default_instance();

  static inline const Document* internal_default_instance() {
    return reinterpret_cast<const Document*>(
               &_Document_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Document* other);
  friend void swap(Document& a, Document& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Document* New() const PROTOBUF_FINAL { return New(NULL); }

  Document* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Document& from);
  void MergeFrom(const Document& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Document* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.snippet.featured.QAItem qa_items = 2;
  int qa_items_size() const;
  void clear_qa_items();
  static const int kQaItemsFieldNumber = 2;
  const ::ru::mail::go::snippet::featured::QAItem& qa_items(int index) const;
  ::ru::mail::go::snippet::featured::QAItem* mutable_qa_items(int index);
  ::ru::mail::go::snippet::featured::QAItem* add_qa_items();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::QAItem >*
      mutable_qa_items();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::QAItem >&
      qa_items() const;

  // required string uri = 1;
  bool has_uri() const;
  void clear_uri();
  static const int kUriFieldNumber = 1;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // @@protoc_insertion_point(class_scope:ru.mail.go.snippet.featured.Document)
 private:
  void set_has_uri();
  void clear_has_uri();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::QAItem > qa_items_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  friend struct protobuf_featured_5fsnippet_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Img

// required string url = 1;
inline bool Img::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Img::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Img::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Img::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& Img::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.Img.url)
  return url_.GetNoArena();
}
inline void Img::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.Img.url)
}
#if LANG_CXX11
inline void Img::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.snippet.featured.Img.url)
}
#endif
inline void Img::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.snippet.featured.Img.url)
}
inline void Img::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.snippet.featured.Img.url)
}
inline ::std::string* Img::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.Img.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Img::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.snippet.featured.Img.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Img::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.snippet.featured.Img.url)
}

// -------------------------------------------------------------------

// QuestionInfo

// optional string category = 1;
inline bool QuestionInfo::has_category() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuestionInfo::set_has_category() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuestionInfo::clear_has_category() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuestionInfo::clear_category() {
  category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_category();
}
inline const ::std::string& QuestionInfo::category() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.QuestionInfo.category)
  return category_.GetNoArena();
}
inline void QuestionInfo::set_category(const ::std::string& value) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.QuestionInfo.category)
}
#if LANG_CXX11
inline void QuestionInfo::set_category(::std::string&& value) {
  set_has_category();
  category_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.snippet.featured.QuestionInfo.category)
}
#endif
inline void QuestionInfo::set_category(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.snippet.featured.QuestionInfo.category)
}
inline void QuestionInfo::set_category(const char* value, size_t size) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.snippet.featured.QuestionInfo.category)
}
inline ::std::string* QuestionInfo::mutable_category() {
  set_has_category();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.QuestionInfo.category)
  return category_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuestionInfo::release_category() {
  // @@protoc_insertion_point(field_release:ru.mail.go.snippet.featured.QuestionInfo.category)
  clear_has_category();
  return category_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuestionInfo::set_allocated_category(::std::string* category) {
  if (category != NULL) {
    set_has_category();
  } else {
    clear_has_category();
  }
  category_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), category);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.snippet.featured.QuestionInfo.category)
}

// optional string sub_category = 2;
inline bool QuestionInfo::has_sub_category() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuestionInfo::set_has_sub_category() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuestionInfo::clear_has_sub_category() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuestionInfo::clear_sub_category() {
  sub_category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sub_category();
}
inline const ::std::string& QuestionInfo::sub_category() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.QuestionInfo.sub_category)
  return sub_category_.GetNoArena();
}
inline void QuestionInfo::set_sub_category(const ::std::string& value) {
  set_has_sub_category();
  sub_category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.QuestionInfo.sub_category)
}
#if LANG_CXX11
inline void QuestionInfo::set_sub_category(::std::string&& value) {
  set_has_sub_category();
  sub_category_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.snippet.featured.QuestionInfo.sub_category)
}
#endif
inline void QuestionInfo::set_sub_category(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sub_category();
  sub_category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.snippet.featured.QuestionInfo.sub_category)
}
inline void QuestionInfo::set_sub_category(const char* value, size_t size) {
  set_has_sub_category();
  sub_category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.snippet.featured.QuestionInfo.sub_category)
}
inline ::std::string* QuestionInfo::mutable_sub_category() {
  set_has_sub_category();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.QuestionInfo.sub_category)
  return sub_category_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuestionInfo::release_sub_category() {
  // @@protoc_insertion_point(field_release:ru.mail.go.snippet.featured.QuestionInfo.sub_category)
  clear_has_sub_category();
  return sub_category_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuestionInfo::set_allocated_sub_category(::std::string* sub_category) {
  if (sub_category != NULL) {
    set_has_sub_category();
  } else {
    clear_has_sub_category();
  }
  sub_category_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sub_category);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.snippet.featured.QuestionInfo.sub_category)
}

// -------------------------------------------------------------------

// Question

// required string text = 1;
inline bool Question::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Question::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Question::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Question::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Question::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.Question.text)
  return text_.GetNoArena();
}
inline void Question::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.Question.text)
}
#if LANG_CXX11
inline void Question::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.snippet.featured.Question.text)
}
#endif
inline void Question::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.snippet.featured.Question.text)
}
inline void Question::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.snippet.featured.Question.text)
}
inline ::std::string* Question::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.Question.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Question::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.snippet.featured.Question.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Question::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.snippet.featured.Question.text)
}

// optional .ru.mail.go.snippet.featured.QuestionInfo info = 2;
inline bool Question::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Question::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Question::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Question::clear_info() {
  if (info_ != NULL) info_->::ru::mail::go::snippet::featured::QuestionInfo::Clear();
  clear_has_info();
}
inline const ::ru::mail::go::snippet::featured::QuestionInfo& Question::info() const {
  const ::ru::mail::go::snippet::featured::QuestionInfo* p = info_;
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.Question.info)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::snippet::featured::QuestionInfo*>(
      &::ru::mail::go::snippet::featured::_QuestionInfo_default_instance_);
}
inline ::ru::mail::go::snippet::featured::QuestionInfo* Question::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    info_ = new ::ru::mail::go::snippet::featured::QuestionInfo;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.Question.info)
  return info_;
}
inline ::ru::mail::go::snippet::featured::QuestionInfo* Question::release_info() {
  // @@protoc_insertion_point(field_release:ru.mail.go.snippet.featured.Question.info)
  clear_has_info();
  ::ru::mail::go::snippet::featured::QuestionInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void Question::set_allocated_info(::ru::mail::go::snippet::featured::QuestionInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.snippet.featured.Question.info)
}

// -------------------------------------------------------------------

// QuestionComment

// required string text = 1;
inline bool QuestionComment::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuestionComment::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuestionComment::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuestionComment::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& QuestionComment::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.QuestionComment.text)
  return text_.GetNoArena();
}
inline void QuestionComment::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.QuestionComment.text)
}
#if LANG_CXX11
inline void QuestionComment::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.snippet.featured.QuestionComment.text)
}
#endif
inline void QuestionComment::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.snippet.featured.QuestionComment.text)
}
inline void QuestionComment::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.snippet.featured.QuestionComment.text)
}
inline ::std::string* QuestionComment::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.QuestionComment.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QuestionComment::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.snippet.featured.QuestionComment.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QuestionComment::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.snippet.featured.QuestionComment.text)
}

// -------------------------------------------------------------------

// AnswerInfo

// optional bool is_best = 1;
inline bool AnswerInfo::has_is_best() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnswerInfo::set_has_is_best() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnswerInfo::clear_has_is_best() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnswerInfo::clear_is_best() {
  is_best_ = false;
  clear_has_is_best();
}
inline bool AnswerInfo::is_best() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.AnswerInfo.is_best)
  return is_best_;
}
inline void AnswerInfo::set_is_best(bool value) {
  set_has_is_best();
  is_best_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.AnswerInfo.is_best)
}

// optional int32 likes_count = 2;
inline bool AnswerInfo::has_likes_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnswerInfo::set_has_likes_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnswerInfo::clear_has_likes_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnswerInfo::clear_likes_count() {
  likes_count_ = 0;
  clear_has_likes_count();
}
inline ::google::protobuf::int32 AnswerInfo::likes_count() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.AnswerInfo.likes_count)
  return likes_count_;
}
inline void AnswerInfo::set_likes_count(::google::protobuf::int32 value) {
  set_has_likes_count();
  likes_count_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.AnswerInfo.likes_count)
}

// optional int32 comments_count = 3;
inline bool AnswerInfo::has_comments_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnswerInfo::set_has_comments_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnswerInfo::clear_has_comments_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnswerInfo::clear_comments_count() {
  comments_count_ = 0;
  clear_has_comments_count();
}
inline ::google::protobuf::int32 AnswerInfo::comments_count() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.AnswerInfo.comments_count)
  return comments_count_;
}
inline void AnswerInfo::set_comments_count(::google::protobuf::int32 value) {
  set_has_comments_count();
  comments_count_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.AnswerInfo.comments_count)
}

// optional int32 author_rating = 4;
inline bool AnswerInfo::has_author_rating() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnswerInfo::set_has_author_rating() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnswerInfo::clear_has_author_rating() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnswerInfo::clear_author_rating() {
  author_rating_ = 0;
  clear_has_author_rating();
}
inline ::google::protobuf::int32 AnswerInfo::author_rating() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.AnswerInfo.author_rating)
  return author_rating_;
}
inline void AnswerInfo::set_author_rating(::google::protobuf::int32 value) {
  set_has_author_rating();
  author_rating_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.AnswerInfo.author_rating)
}

// -------------------------------------------------------------------

// Answer

// required string text = 1;
inline bool Answer::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Answer::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Answer::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Answer::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Answer::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.Answer.text)
  return text_.GetNoArena();
}
inline void Answer::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.Answer.text)
}
#if LANG_CXX11
inline void Answer::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.snippet.featured.Answer.text)
}
#endif
inline void Answer::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.snippet.featured.Answer.text)
}
inline void Answer::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.snippet.featured.Answer.text)
}
inline ::std::string* Answer::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.Answer.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Answer::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.snippet.featured.Answer.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Answer::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.snippet.featured.Answer.text)
}

// repeated .ru.mail.go.snippet.featured.Img img = 2;
inline int Answer::img_size() const {
  return img_.size();
}
inline void Answer::clear_img() {
  img_.Clear();
}
inline const ::ru::mail::go::snippet::featured::Img& Answer::img(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.Answer.img)
  return img_.Get(index);
}
inline ::ru::mail::go::snippet::featured::Img* Answer::mutable_img(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.Answer.img)
  return img_.Mutable(index);
}
inline ::ru::mail::go::snippet::featured::Img* Answer::add_img() {
  // @@protoc_insertion_point(field_add:ru.mail.go.snippet.featured.Answer.img)
  return img_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::Img >*
Answer::mutable_img() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.snippet.featured.Answer.img)
  return &img_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::Img >&
Answer::img() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.snippet.featured.Answer.img)
  return img_;
}

// optional .ru.mail.go.snippet.featured.AnswerInfo info = 3;
inline bool Answer::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Answer::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Answer::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Answer::clear_info() {
  if (info_ != NULL) info_->::ru::mail::go::snippet::featured::AnswerInfo::Clear();
  clear_has_info();
}
inline const ::ru::mail::go::snippet::featured::AnswerInfo& Answer::info() const {
  const ::ru::mail::go::snippet::featured::AnswerInfo* p = info_;
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.Answer.info)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::snippet::featured::AnswerInfo*>(
      &::ru::mail::go::snippet::featured::_AnswerInfo_default_instance_);
}
inline ::ru::mail::go::snippet::featured::AnswerInfo* Answer::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    info_ = new ::ru::mail::go::snippet::featured::AnswerInfo;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.Answer.info)
  return info_;
}
inline ::ru::mail::go::snippet::featured::AnswerInfo* Answer::release_info() {
  // @@protoc_insertion_point(field_release:ru.mail.go.snippet.featured.Answer.info)
  clear_has_info();
  ::ru::mail::go::snippet::featured::AnswerInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void Answer::set_allocated_info(::ru::mail::go::snippet::featured::AnswerInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.snippet.featured.Answer.info)
}

// -------------------------------------------------------------------

// QAItem

// required .ru.mail.go.snippet.featured.Source source = 1;
inline bool QAItem::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QAItem::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QAItem::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QAItem::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::ru::mail::go::snippet::featured::Source QAItem::source() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.QAItem.source)
  return static_cast< ::ru::mail::go::snippet::featured::Source >(source_);
}
inline void QAItem::set_source(::ru::mail::go::snippet::featured::Source value) {
  assert(::ru::mail::go::snippet::featured::Source_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.QAItem.source)
}

// required .ru.mail.go.snippet.featured.Question question = 2;
inline bool QAItem::has_question() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QAItem::set_has_question() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QAItem::clear_has_question() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QAItem::clear_question() {
  if (question_ != NULL) question_->::ru::mail::go::snippet::featured::Question::Clear();
  clear_has_question();
}
inline const ::ru::mail::go::snippet::featured::Question& QAItem::question() const {
  const ::ru::mail::go::snippet::featured::Question* p = question_;
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.QAItem.question)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::snippet::featured::Question*>(
      &::ru::mail::go::snippet::featured::_Question_default_instance_);
}
inline ::ru::mail::go::snippet::featured::Question* QAItem::mutable_question() {
  set_has_question();
  if (question_ == NULL) {
    question_ = new ::ru::mail::go::snippet::featured::Question;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.QAItem.question)
  return question_;
}
inline ::ru::mail::go::snippet::featured::Question* QAItem::release_question() {
  // @@protoc_insertion_point(field_release:ru.mail.go.snippet.featured.QAItem.question)
  clear_has_question();
  ::ru::mail::go::snippet::featured::Question* temp = question_;
  question_ = NULL;
  return temp;
}
inline void QAItem::set_allocated_question(::ru::mail::go::snippet::featured::Question* question) {
  delete question_;
  question_ = question;
  if (question) {
    set_has_question();
  } else {
    clear_has_question();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.snippet.featured.QAItem.question)
}

// repeated .ru.mail.go.snippet.featured.Answer answers = 3;
inline int QAItem::answers_size() const {
  return answers_.size();
}
inline void QAItem::clear_answers() {
  answers_.Clear();
}
inline const ::ru::mail::go::snippet::featured::Answer& QAItem::answers(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.QAItem.answers)
  return answers_.Get(index);
}
inline ::ru::mail::go::snippet::featured::Answer* QAItem::mutable_answers(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.QAItem.answers)
  return answers_.Mutable(index);
}
inline ::ru::mail::go::snippet::featured::Answer* QAItem::add_answers() {
  // @@protoc_insertion_point(field_add:ru.mail.go.snippet.featured.QAItem.answers)
  return answers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::Answer >*
QAItem::mutable_answers() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.snippet.featured.QAItem.answers)
  return &answers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::Answer >&
QAItem::answers() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.snippet.featured.QAItem.answers)
  return answers_;
}

// optional .ru.mail.go.snippet.featured.QuestionComment question_comment = 4;
inline bool QAItem::has_question_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QAItem::set_has_question_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QAItem::clear_has_question_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QAItem::clear_question_comment() {
  if (question_comment_ != NULL) question_comment_->::ru::mail::go::snippet::featured::QuestionComment::Clear();
  clear_has_question_comment();
}
inline const ::ru::mail::go::snippet::featured::QuestionComment& QAItem::question_comment() const {
  const ::ru::mail::go::snippet::featured::QuestionComment* p = question_comment_;
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.QAItem.question_comment)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::snippet::featured::QuestionComment*>(
      &::ru::mail::go::snippet::featured::_QuestionComment_default_instance_);
}
inline ::ru::mail::go::snippet::featured::QuestionComment* QAItem::mutable_question_comment() {
  set_has_question_comment();
  if (question_comment_ == NULL) {
    question_comment_ = new ::ru::mail::go::snippet::featured::QuestionComment;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.QAItem.question_comment)
  return question_comment_;
}
inline ::ru::mail::go::snippet::featured::QuestionComment* QAItem::release_question_comment() {
  // @@protoc_insertion_point(field_release:ru.mail.go.snippet.featured.QAItem.question_comment)
  clear_has_question_comment();
  ::ru::mail::go::snippet::featured::QuestionComment* temp = question_comment_;
  question_comment_ = NULL;
  return temp;
}
inline void QAItem::set_allocated_question_comment(::ru::mail::go::snippet::featured::QuestionComment* question_comment) {
  delete question_comment_;
  question_comment_ = question_comment;
  if (question_comment) {
    set_has_question_comment();
  } else {
    clear_has_question_comment();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.snippet.featured.QAItem.question_comment)
}

// -------------------------------------------------------------------

// Document

// required string uri = 1;
inline bool Document::has_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Document::set_has_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Document::clear_has_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Document::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uri();
}
inline const ::std::string& Document::uri() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.Document.uri)
  return uri_.GetNoArena();
}
inline void Document::set_uri(const ::std::string& value) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.snippet.featured.Document.uri)
}
#if LANG_CXX11
inline void Document::set_uri(::std::string&& value) {
  set_has_uri();
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.snippet.featured.Document.uri)
}
#endif
inline void Document::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.snippet.featured.Document.uri)
}
inline void Document::set_uri(const char* value, size_t size) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.snippet.featured.Document.uri)
}
inline ::std::string* Document::mutable_uri() {
  set_has_uri();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.Document.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Document::release_uri() {
  // @@protoc_insertion_point(field_release:ru.mail.go.snippet.featured.Document.uri)
  clear_has_uri();
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Document::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    set_has_uri();
  } else {
    clear_has_uri();
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.snippet.featured.Document.uri)
}

// repeated .ru.mail.go.snippet.featured.QAItem qa_items = 2;
inline int Document::qa_items_size() const {
  return qa_items_.size();
}
inline void Document::clear_qa_items() {
  qa_items_.Clear();
}
inline const ::ru::mail::go::snippet::featured::QAItem& Document::qa_items(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.snippet.featured.Document.qa_items)
  return qa_items_.Get(index);
}
inline ::ru::mail::go::snippet::featured::QAItem* Document::mutable_qa_items(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.snippet.featured.Document.qa_items)
  return qa_items_.Mutable(index);
}
inline ::ru::mail::go::snippet::featured::QAItem* Document::add_qa_items() {
  // @@protoc_insertion_point(field_add:ru.mail.go.snippet.featured.Document.qa_items)
  return qa_items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::QAItem >*
Document::mutable_qa_items() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.snippet.featured.Document.qa_items)
  return &qa_items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::snippet::featured::QAItem >&
Document::qa_items() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.snippet.featured.Document.qa_items)
  return qa_items_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace featured
}  // namespace snippet
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::snippet::featured::Source> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::snippet::featured::Source>() {
  return ::ru::mail::go::snippet::featured::Source_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_featured_5fsnippet_2eproto__INCLUDED
