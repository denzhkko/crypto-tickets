// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: image_blobs.proto

#ifndef PROTOBUF_image_5fblobs_2eproto__INCLUDED
#define PROTOBUF_image_5fblobs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "parsed_blobs.pb.h"
#include "image_defs.pb.h"
#include "document_enums.pb.h"
#include "result.pb.h"
#include "doc_parser.pb.h"
#include "content_storage.pb.h"
#include "sekitei.pb.h"
#include "qembedder.pb.h"
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {
class Any;
class AnyDefaultTypeInternal;
extern AnyDefaultTypeInternal _Any_default_instance_;
class BOW;
class BOWDefaultTypeInternal;
extern BOWDefaultTypeInternal _BOW_default_instance_;
class BoundImage;
class BoundImageDefaultTypeInternal;
extern BoundImageDefaultTypeInternal _BoundImage_default_instance_;
class ClusteringResult;
class ClusteringResultDefaultTypeInternal;
extern ClusteringResultDefaultTypeInternal _ClusteringResult_default_instance_;
class CustomItem;
class CustomItemDefaultTypeInternal;
extern CustomItemDefaultTypeInternal _CustomItem_default_instance_;
class DCT;
class DCTDefaultTypeInternal;
extern DCTDefaultTypeInternal _DCT_default_instance_;
class DarkImageLinks;
class DarkImageLinksDefaultTypeInternal;
extern DarkImageLinksDefaultTypeInternal _DarkImageLinks_default_instance_;
class DarkImageLinksItem;
class DarkImageLinksItemDefaultTypeInternal;
extern DarkImageLinksItemDefaultTypeInternal _DarkImageLinksItem_default_instance_;
class DiscoveryVisitUrlInfo;
class DiscoveryVisitUrlInfoDefaultTypeInternal;
extern DiscoveryVisitUrlInfoDefaultTypeInternal _DiscoveryVisitUrlInfo_default_instance_;
class DomainStruct;
class DomainStructDefaultTypeInternal;
extern DomainStructDefaultTypeInternal _DomainStruct_default_instance_;
class EmbeddingData;
class EmbeddingDataDefaultTypeInternal;
extern EmbeddingDataDefaultTypeInternal _EmbeddingData_default_instance_;
class ExplicitDescription;
class ExplicitDescriptionDefaultTypeInternal;
extern ExplicitDescriptionDefaultTypeInternal _ExplicitDescription_default_instance_;
class FaviconObj;
class FaviconObjDefaultTypeInternal;
extern FaviconObjDefaultTypeInternal _FaviconObj_default_instance_;
class FullPage;
class FullPageDefaultTypeInternal;
extern FullPageDefaultTypeInternal _FullPage_default_instance_;
class GifestData;
class GifestDataDefaultTypeInternal;
extern GifestDataDefaultTypeInternal _GifestData_default_instance_;
class HostWithImgUrls;
class HostWithImgUrlsDefaultTypeInternal;
extern HostWithImgUrlsDefaultTypeInternal _HostWithImgUrls_default_instance_;
class HtmlPage;
class HtmlPageDefaultTypeInternal;
extern HtmlPageDefaultTypeInternal _HtmlPage_default_instance_;
class ImageHashItem;
class ImageHashItemDefaultTypeInternal;
extern ImageHashItemDefaultTypeInternal _ImageHashItem_default_instance_;
class ImageIndexObj;
class ImageIndexObjDefaultTypeInternal;
extern ImageIndexObjDefaultTypeInternal _ImageIndexObj_default_instance_;
class ImageItem;
class ImageItemDefaultTypeInternal;
extern ImageItemDefaultTypeInternal _ImageItem_default_instance_;
class ImageKeywords;
class ImageKeywordsDefaultTypeInternal;
extern ImageKeywordsDefaultTypeInternal _ImageKeywords_default_instance_;
class ImageLinks;
class ImageLinksDefaultTypeInternal;
extern ImageLinksDefaultTypeInternal _ImageLinks_default_instance_;
class ImageLinksItem;
class ImageLinksItemDefaultTypeInternal;
extern ImageLinksItemDefaultTypeInternal _ImageLinksItem_default_instance_;
class ImageMarkerUrlTrace;
class ImageMarkerUrlTraceDefaultTypeInternal;
extern ImageMarkerUrlTraceDefaultTypeInternal _ImageMarkerUrlTrace_default_instance_;
class ImageObj;
class ImageObjDefaultTypeInternal;
extern ImageObjDefaultTypeInternal _ImageObj_default_instance_;
class ImageProps;
class ImagePropsDefaultTypeInternal;
extern ImagePropsDefaultTypeInternal _ImageProps_default_instance_;
class ImagePropsWithUrl;
class ImagePropsWithUrlDefaultTypeInternal;
extern ImagePropsWithUrlDefaultTypeInternal _ImagePropsWithUrl_default_instance_;
class ImageStruct;
class ImageStructDefaultTypeInternal;
extern ImageStructDefaultTypeInternal _ImageStruct_default_instance_;
class ImageStructInfo;
class ImageStructInfoDefaultTypeInternal;
extern ImageStructInfoDefaultTypeInternal _ImageStructInfo_default_instance_;
class ImageStruct_AdditionalProps;
class ImageStruct_AdditionalPropsDefaultTypeInternal;
extern ImageStruct_AdditionalPropsDefaultTypeInternal _ImageStruct_AdditionalProps_default_instance_;
class ImageTexts;
class ImageTextsDefaultTypeInternal;
extern ImageTextsDefaultTypeInternal _ImageTexts_default_instance_;
class ImageTexts_PageTexts;
class ImageTexts_PageTextsDefaultTypeInternal;
extern ImageTexts_PageTextsDefaultTypeInternal _ImageTexts_PageTexts_default_instance_;
class ImgParserBlob;
class ImgParserBlobDefaultTypeInternal;
extern ImgParserBlobDefaultTypeInternal _ImgParserBlob_default_instance_;
class ImgParserBlobList;
class ImgParserBlobListDefaultTypeInternal;
extern ImgParserBlobListDefaultTypeInternal _ImgParserBlobList_default_instance_;
class LimitingInfo;
class LimitingInfoDefaultTypeInternal;
extern LimitingInfoDefaultTypeInternal _LimitingInfo_default_instance_;
class MarkersInfo;
class MarkersInfoDefaultTypeInternal;
extern MarkersInfoDefaultTypeInternal _MarkersInfo_default_instance_;
class MarkersInfo_PageInfo;
class MarkersInfo_PageInfoDefaultTypeInternal;
extern MarkersInfo_PageInfoDefaultTypeInternal _MarkersInfo_PageInfo_default_instance_;
class MetaAttr;
class MetaAttrDefaultTypeInternal;
extern MetaAttrDefaultTypeInternal _MetaAttr_default_instance_;
class MetaItem;
class MetaItemDefaultTypeInternal;
extern MetaItemDefaultTypeInternal _MetaItem_default_instance_;
class NewsImageInfo;
class NewsImageInfoDefaultTypeInternal;
extern NewsImageInfoDefaultTypeInternal _NewsImageInfo_default_instance_;
class OCRResult;
class OCRResultDefaultTypeInternal;
extern OCRResultDefaultTypeInternal _OCRResult_default_instance_;
class OCRSentence;
class OCRSentenceDefaultTypeInternal;
extern OCRSentenceDefaultTypeInternal _OCRSentence_default_instance_;
class PageStruct;
class PageStructDefaultTypeInternal;
extern PageStructDefaultTypeInternal _PageStruct_default_instance_;
class ParseHtmlInput;
class ParseHtmlInputDefaultTypeInternal;
extern ParseHtmlInputDefaultTypeInternal _ParseHtmlInput_default_instance_;
class ParserSignature;
class ParserSignatureDefaultTypeInternal;
extern ParserSignatureDefaultTypeInternal _ParserSignature_default_instance_;
class QueryStruct;
class QueryStructDefaultTypeInternal;
extern QueryStructDefaultTypeInternal _QueryStruct_default_instance_;
class RatioStats;
class RatioStatsDefaultTypeInternal;
extern RatioStatsDefaultTypeInternal _RatioStats_default_instance_;
class ResClustInfo;
class ResClustInfoDefaultTypeInternal;
extern ResClustInfoDefaultTypeInternal _ResClustInfo_default_instance_;
class TextBlock;
class TextBlockDefaultTypeInternal;
extern TextBlockDefaultTypeInternal _TextBlock_default_instance_;
class TextIndexKey;
class TextIndexKeyDefaultTypeInternal;
extern TextIndexKeyDefaultTypeInternal _TextIndexKey_default_instance_;
class TextItem;
class TextItemDefaultTypeInternal;
extern TextItemDefaultTypeInternal _TextItem_default_instance_;
class ThumbDoc;
class ThumbDocDefaultTypeInternal;
extern ThumbDocDefaultTypeInternal _ThumbDoc_default_instance_;
class ThumbIndexKey;
class ThumbIndexKeyDefaultTypeInternal;
extern ThumbIndexKeyDefaultTypeInternal _ThumbIndexKey_default_instance_;
class ThumbList;
class ThumbListDefaultTypeInternal;
extern ThumbListDefaultTypeInternal _ThumbList_default_instance_;
class UrlPair;
class UrlPairDefaultTypeInternal;
extern UrlPairDefaultTypeInternal _UrlPair_default_instance_;
class UrlQueryInfo;
class UrlQueryInfoDefaultTypeInternal;
extern UrlQueryInfoDefaultTypeInternal _UrlQueryInfo_default_instance_;
class UrlQueryInfoKey;
class UrlQueryInfoKeyDefaultTypeInternal;
extern UrlQueryInfoKeyDefaultTypeInternal _UrlQueryInfoKey_default_instance_;
class UrlRankInfo;
class UrlRankInfoDefaultTypeInternal;
extern UrlRankInfoDefaultTypeInternal _UrlRankInfo_default_instance_;
class VarItem;
class VarItemDefaultTypeInternal;
extern VarItemDefaultTypeInternal _VarItem_default_instance_;
class VideoFrames;
class VideoFramesDefaultTypeInternal;
extern VideoFramesDefaultTypeInternal _VideoFrames_default_instance_;
class VisitInfo;
class VisitInfoDefaultTypeInternal;
extern VisitInfoDefaultTypeInternal _VisitInfo_default_instance_;
class WOTInfo;
class WOTInfoDefaultTypeInternal;
extern WOTInfoDefaultTypeInternal _WOTInfo_default_instance_;
class WOTInfoObj;
class WOTInfoObjDefaultTypeInternal;
extern WOTInfoObjDefaultTypeInternal _WOTInfoObj_default_instance_;
class WOTInfo_WOTCategory;
class WOTInfo_WOTCategoryDefaultTypeInternal;
extern WOTInfo_WOTCategoryDefaultTypeInternal _WOTInfo_WOTCategory_default_instance_;
class WOTInfo_WOTElement;
class WOTInfo_WOTElementDefaultTypeInternal;
extern WOTInfo_WOTElementDefaultTypeInternal _WOTInfo_WOTElement_default_instance_;
}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace webbase {
namespace blobs {

namespace protobuf_image_5fblobs_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_image_5fblobs_2eproto

enum ImageMarkerUrlTrace_StageInfo {
  ImageMarkerUrlTrace_StageInfo_PassedImageDump = 0,
  ImageMarkerUrlTrace_StageInfo_PassedHtmlJoin = 1,
  ImageMarkerUrlTrace_StageInfo_NotPassedHtmlJoin = 2,
  ImageMarkerUrlTrace_StageInfo_PassedMaxHtmlJoin = 3,
  ImageMarkerUrlTrace_StageInfo_NotPassedMaxPageLimit = 4,
  ImageMarkerUrlTrace_StageInfo_PassedMaxPageLimit = 5,
  ImageMarkerUrlTrace_StageInfo_NotPassedManualSimhash = 6,
  ImageMarkerUrlTrace_StageInfo_PassedManualSimhash = 7,
  ImageMarkerUrlTrace_StageInfo_NotPassedCollectionClustering = 8,
  ImageMarkerUrlTrace_StageInfo_PassedCollectionClustering = 9,
  ImageMarkerUrlTrace_StageInfo_NotPassedSimhashDup = 10,
  ImageMarkerUrlTrace_StageInfo_PassedSimhashDup = 11,
  ImageMarkerUrlTrace_StageInfo_NotPassedSekiteiLimiter = 12,
  ImageMarkerUrlTrace_StageInfo_PassedSekiteiLimiter = 13
};
bool ImageMarkerUrlTrace_StageInfo_IsValid(int value);
const ImageMarkerUrlTrace_StageInfo ImageMarkerUrlTrace_StageInfo_StageInfo_MIN = ImageMarkerUrlTrace_StageInfo_PassedImageDump;
const ImageMarkerUrlTrace_StageInfo ImageMarkerUrlTrace_StageInfo_StageInfo_MAX = ImageMarkerUrlTrace_StageInfo_PassedSekiteiLimiter;
const int ImageMarkerUrlTrace_StageInfo_StageInfo_ARRAYSIZE = ImageMarkerUrlTrace_StageInfo_StageInfo_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageMarkerUrlTrace_StageInfo_descriptor();
inline const ::std::string& ImageMarkerUrlTrace_StageInfo_Name(ImageMarkerUrlTrace_StageInfo value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageMarkerUrlTrace_StageInfo_descriptor(), value);
}
inline bool ImageMarkerUrlTrace_StageInfo_Parse(
    const ::std::string& name, ImageMarkerUrlTrace_StageInfo* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageMarkerUrlTrace_StageInfo>(
    ImageMarkerUrlTrace_StageInfo_descriptor(), name, value);
}
enum RatioStats_Kind {
  RatioStats_Kind_WEB_SHOW = 0,
  RatioStats_Kind_IMG_SHOW = 1
};
bool RatioStats_Kind_IsValid(int value);
const RatioStats_Kind RatioStats_Kind_Kind_MIN = RatioStats_Kind_WEB_SHOW;
const RatioStats_Kind RatioStats_Kind_Kind_MAX = RatioStats_Kind_IMG_SHOW;
const int RatioStats_Kind_Kind_ARRAYSIZE = RatioStats_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* RatioStats_Kind_descriptor();
inline const ::std::string& RatioStats_Kind_Name(RatioStats_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    RatioStats_Kind_descriptor(), value);
}
inline bool RatioStats_Kind_Parse(
    const ::std::string& name, RatioStats_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RatioStats_Kind>(
    RatioStats_Kind_descriptor(), name, value);
}
enum ImageStructInfo_ImageSource {
  ImageStructInfo_ImageSource_NEWS = 0,
  ImageStructInfo_ImageSource_TORG = 1,
  ImageStructInfo_ImageSource_AFISHA = 2,
  ImageStructInfo_ImageSource_APPS = 3,
  ImageStructInfo_ImageSource_GIFEST = 4,
  ImageStructInfo_ImageSource_RESERVED2 = 5,
  ImageStructInfo_ImageSource_RESERVED3 = 6,
  ImageStructInfo_ImageSource_RESERVED4 = 7
};
bool ImageStructInfo_ImageSource_IsValid(int value);
const ImageStructInfo_ImageSource ImageStructInfo_ImageSource_ImageSource_MIN = ImageStructInfo_ImageSource_NEWS;
const ImageStructInfo_ImageSource ImageStructInfo_ImageSource_ImageSource_MAX = ImageStructInfo_ImageSource_RESERVED4;
const int ImageStructInfo_ImageSource_ImageSource_ARRAYSIZE = ImageStructInfo_ImageSource_ImageSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageStructInfo_ImageSource_descriptor();
inline const ::std::string& ImageStructInfo_ImageSource_Name(ImageStructInfo_ImageSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageStructInfo_ImageSource_descriptor(), value);
}
inline bool ImageStructInfo_ImageSource_Parse(
    const ::std::string& name, ImageStructInfo_ImageSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageStructInfo_ImageSource>(
    ImageStructInfo_ImageSource_descriptor(), name, value);
}
enum MarkersInfo_Type {
  MarkersInfo_Type_Domain = 0,
  MarkersInfo_Type_Page = 1
};
bool MarkersInfo_Type_IsValid(int value);
const MarkersInfo_Type MarkersInfo_Type_Type_MIN = MarkersInfo_Type_Domain;
const MarkersInfo_Type MarkersInfo_Type_Type_MAX = MarkersInfo_Type_Page;
const int MarkersInfo_Type_Type_ARRAYSIZE = MarkersInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MarkersInfo_Type_descriptor();
inline const ::std::string& MarkersInfo_Type_Name(MarkersInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MarkersInfo_Type_descriptor(), value);
}
inline bool MarkersInfo_Type_Parse(
    const ::std::string& name, MarkersInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarkersInfo_Type>(
    MarkersInfo_Type_descriptor(), name, value);
}
enum DiscoveryVisitUrlInfo_Source {
  DiscoveryVisitUrlInfo_Source_KVAKIN = 0,
  DiscoveryVisitUrlInfo_Source_TELEMETRY = 1,
  DiscoveryVisitUrlInfo_Source_INTERLEAVING_DOC_A = 2,
  DiscoveryVisitUrlInfo_Source_INTERLEAVING_DOC_B = 3,
  DiscoveryVisitUrlInfo_Source_WPIIDUMP = 4
};
bool DiscoveryVisitUrlInfo_Source_IsValid(int value);
const DiscoveryVisitUrlInfo_Source DiscoveryVisitUrlInfo_Source_Source_MIN = DiscoveryVisitUrlInfo_Source_KVAKIN;
const DiscoveryVisitUrlInfo_Source DiscoveryVisitUrlInfo_Source_Source_MAX = DiscoveryVisitUrlInfo_Source_WPIIDUMP;
const int DiscoveryVisitUrlInfo_Source_Source_ARRAYSIZE = DiscoveryVisitUrlInfo_Source_Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiscoveryVisitUrlInfo_Source_descriptor();
inline const ::std::string& DiscoveryVisitUrlInfo_Source_Name(DiscoveryVisitUrlInfo_Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiscoveryVisitUrlInfo_Source_descriptor(), value);
}
inline bool DiscoveryVisitUrlInfo_Source_Parse(
    const ::std::string& name, DiscoveryVisitUrlInfo_Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiscoveryVisitUrlInfo_Source>(
    DiscoveryVisitUrlInfo_Source_descriptor(), name, value);
}
enum ImageHashItem_Source {
  ImageHashItem_Source_PARSER = 1,
  ImageHashItem_Source_INTERLEAVING_DOC_A = 2,
  ImageHashItem_Source_INTERLEAVING_DOC_B = 3,
  ImageHashItem_Source_WPIIDUMP = 4
};
bool ImageHashItem_Source_IsValid(int value);
const ImageHashItem_Source ImageHashItem_Source_Source_MIN = ImageHashItem_Source_PARSER;
const ImageHashItem_Source ImageHashItem_Source_Source_MAX = ImageHashItem_Source_WPIIDUMP;
const int ImageHashItem_Source_Source_ARRAYSIZE = ImageHashItem_Source_Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageHashItem_Source_descriptor();
inline const ::std::string& ImageHashItem_Source_Name(ImageHashItem_Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageHashItem_Source_descriptor(), value);
}
inline bool ImageHashItem_Source_Parse(
    const ::std::string& name, ImageHashItem_Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageHashItem_Source>(
    ImageHashItem_Source_descriptor(), name, value);
}
enum Tag {
  ALT = 0,
  TITLE = 1,
  STRONG = 2,
  H1 = 3,
  H2 = 4,
  H3 = 5,
  H4 = 6,
  H5 = 7,
  H6 = 8,
  B = 9,
  U = 10,
  A = 11,
  P = 12,
  DIV = 13,
  SPAN = 14,
  TABLE = 15,
  TR = 16,
  TD = 17,
  LINK = 18,
  BR = 19,
  FONT = 20,
  CENTER = 21,
  FAKE_TEXT = 22,
  UL = 23,
  LI = 24,
  IMG = 25,
  SECTION = 26,
  ARTICLE = 27,
  EM = 28,
  BODY = 29,
  HEAD = 30,
  ROOT = 31,
  TBODY = 32
};
bool Tag_IsValid(int value);
const Tag Tag_MIN = ALT;
const Tag Tag_MAX = TBODY;
const int Tag_ARRAYSIZE = Tag_MAX + 1;

const ::google::protobuf::EnumDescriptor* Tag_descriptor();
inline const ::std::string& Tag_Name(Tag value) {
  return ::google::protobuf::internal::NameOfEnum(
    Tag_descriptor(), value);
}
inline bool Tag_Parse(
    const ::std::string& name, Tag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Tag>(
    Tag_descriptor(), name, value);
}
enum ParserID {
  LIRU = 0
};
bool ParserID_IsValid(int value);
const ParserID ParserID_MIN = LIRU;
const ParserID ParserID_MAX = LIRU;
const int ParserID_ARRAYSIZE = ParserID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParserID_descriptor();
inline const ::std::string& ParserID_Name(ParserID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParserID_descriptor(), value);
}
inline bool ParserID_Parse(
    const ::std::string& name, ParserID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParserID>(
    ParserID_descriptor(), name, value);
}
enum ZoneName {
  ZN_ALT = 1,
  ZN_CTX = 2,
  ZN_PAGE_TITLE = 3,
  ZN_H1 = 4,
  ZN_H2 = 5,
  ZN_H3 = 6,
  ZN_PAGE_URL = 7,
  ZN_IMAGE_URL = 8,
  ZN_PH_AUTHOR = 9,
  ZN_PH_CAPTION = 10,
  ZN_PH_PATH = 11,
  ZN_CTX_TEXT = 12,
  ZN_OG = 13
};
bool ZoneName_IsValid(int value);
const ZoneName ZoneName_MIN = ZN_ALT;
const ZoneName ZoneName_MAX = ZN_OG;
const int ZoneName_ARRAYSIZE = ZoneName_MAX + 1;

const ::google::protobuf::EnumDescriptor* ZoneName_descriptor();
inline const ::std::string& ZoneName_Name(ZoneName value) {
  return ::google::protobuf::internal::NameOfEnum(
    ZoneName_descriptor(), value);
}
inline bool ZoneName_Parse(
    const ::std::string& name, ZoneName* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ZoneName>(
    ZoneName_descriptor(), name, value);
}
// ===================================================================

class TextItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.TextItem) */ {
 public:
  TextItem();
  virtual ~TextItem();

  TextItem(const TextItem& from);

  inline TextItem& operator=(const TextItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextItem(TextItem&& from) noexcept
    : TextItem() {
    *this = ::std::move(from);
  }

  inline TextItem& operator=(TextItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextItem& default_instance();

  static inline const TextItem* internal_default_instance() {
    return reinterpret_cast<const TextItem*>(
               &_TextItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TextItem* other);
  friend void swap(TextItem& a, TextItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextItem* New() const PROTOBUF_FINAL { return New(NULL); }

  TextItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TextItem& from);
  void MergeFrom(const TextItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TextItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.Tag tags = 3;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 3;
  ::ru::mail::go::webbase::blobs::Tag tags(int index) const;
  void set_tags(int index, ::ru::mail::go::webbase::blobs::Tag value);
  void add_tags(::ru::mail::go::webbase::blobs::Tag value);
  const ::google::protobuf::RepeatedField<int>& tags() const;
  ::google::protobuf::RepeatedField<int>* mutable_tags();

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional string url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional string title = 5;
  bool has_title() const;
  void clear_title();
  static const int kTitleFieldNumber = 5;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // optional string urlkey = 6;
  bool has_urlkey() const;
  void clear_urlkey();
  static const int kUrlkeyFieldNumber = 6;
  const ::std::string& urlkey() const;
  void set_urlkey(const ::std::string& value);
  #if LANG_CXX11
  void set_urlkey(::std::string&& value);
  #endif
  void set_urlkey(const char* value);
  void set_urlkey(const char* value, size_t size);
  ::std::string* mutable_urlkey();
  ::std::string* release_urlkey();
  void set_allocated_urlkey(::std::string* urlkey);

  // optional bool from_alt = 4 [default = false];
  bool has_from_alt() const;
  void clear_from_alt();
  static const int kFromAltFieldNumber = 4;
  bool from_alt() const;
  void set_from_alt(bool value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.TextItem)
 private:
  void set_has_text();
  void clear_has_text();
  void set_has_url();
  void clear_has_url();
  void set_has_from_alt();
  void clear_has_from_alt();
  void set_has_title();
  void clear_has_title();
  void set_has_urlkey();
  void clear_has_urlkey();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> tags_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr urlkey_;
  bool from_alt_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExplicitDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ExplicitDescription) */ {
 public:
  ExplicitDescription();
  virtual ~ExplicitDescription();

  ExplicitDescription(const ExplicitDescription& from);

  inline ExplicitDescription& operator=(const ExplicitDescription& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExplicitDescription(ExplicitDescription&& from) noexcept
    : ExplicitDescription() {
    *this = ::std::move(from);
  }

  inline ExplicitDescription& operator=(ExplicitDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExplicitDescription& default_instance();

  static inline const ExplicitDescription* internal_default_instance() {
    return reinterpret_cast<const ExplicitDescription*>(
               &_ExplicitDescription_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ExplicitDescription* other);
  friend void swap(ExplicitDescription& a, ExplicitDescription& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExplicitDescription* New() const PROTOBUF_FINAL { return New(NULL); }

  ExplicitDescription* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExplicitDescription& from);
  void MergeFrom(const ExplicitDescription& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExplicitDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keywords = 5;
  int keywords_size() const;
  void clear_keywords();
  static const int kKeywordsFieldNumber = 5;
  const ::std::string& keywords(int index) const;
  ::std::string* mutable_keywords(int index);
  void set_keywords(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keywords(int index, ::std::string&& value);
  #endif
  void set_keywords(int index, const char* value);
  void set_keywords(int index, const char* value, size_t size);
  ::std::string* add_keywords();
  void add_keywords(const ::std::string& value);
  #if LANG_CXX11
  void add_keywords(::std::string&& value);
  #endif
  void add_keywords(const char* value);
  void add_keywords(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keywords() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keywords();

  // optional string caption = 2;
  bool has_caption() const;
  void clear_caption();
  static const int kCaptionFieldNumber = 2;
  const ::std::string& caption() const;
  void set_caption(const ::std::string& value);
  #if LANG_CXX11
  void set_caption(::std::string&& value);
  #endif
  void set_caption(const char* value);
  void set_caption(const char* value, size_t size);
  ::std::string* mutable_caption();
  ::std::string* release_caption();
  void set_allocated_caption(::std::string* caption);

  // optional string author = 3;
  bool has_author() const;
  void clear_author();
  static const int kAuthorFieldNumber = 3;
  const ::std::string& author() const;
  void set_author(const ::std::string& value);
  #if LANG_CXX11
  void set_author(::std::string&& value);
  #endif
  void set_author(const char* value);
  void set_author(const char* value, size_t size);
  ::std::string* mutable_author();
  ::std::string* release_author();
  void set_allocated_author(::std::string* author);

  // optional string path = 4;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 4;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional string imgUrl = 6;
  bool has_imgurl() const;
  void clear_imgurl();
  static const int kImgUrlFieldNumber = 6;
  const ::std::string& imgurl() const;
  void set_imgurl(const ::std::string& value);
  #if LANG_CXX11
  void set_imgurl(::std::string&& value);
  #endif
  void set_imgurl(const char* value);
  void set_imgurl(const char* value, size_t size);
  ::std::string* mutable_imgurl();
  ::std::string* release_imgurl();
  void set_allocated_imgurl(::std::string* imgurl);

  // optional string htmlUrl = 7;
  bool has_htmlurl() const;
  void clear_htmlurl();
  static const int kHtmlUrlFieldNumber = 7;
  const ::std::string& htmlurl() const;
  void set_htmlurl(const ::std::string& value);
  #if LANG_CXX11
  void set_htmlurl(::std::string&& value);
  #endif
  void set_htmlurl(const char* value);
  void set_htmlurl(const char* value, size_t size);
  ::std::string* mutable_htmlurl();
  ::std::string* release_htmlurl();
  void set_allocated_htmlurl(::std::string* htmlurl);

  // required .ru.mail.go.webbase.blobs.ParserID pid = 1;
  bool has_pid() const;
  void clear_pid();
  static const int kPidFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::ParserID pid() const;
  void set_pid(::ru::mail::go::webbase::blobs::ParserID value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ExplicitDescription)
 private:
  void set_has_pid();
  void clear_has_pid();
  void set_has_caption();
  void clear_has_caption();
  void set_has_author();
  void clear_has_author();
  void set_has_path();
  void clear_has_path();
  void set_has_imgurl();
  void clear_has_imgurl();
  void set_has_htmlurl();
  void clear_has_htmlurl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keywords_;
  ::google::protobuf::internal::ArenaStringPtr caption_;
  ::google::protobuf::internal::ArenaStringPtr author_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr imgurl_;
  ::google::protobuf::internal::ArenaStringPtr htmlurl_;
  int pid_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageLinks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageLinks) */ {
 public:
  ImageLinks();
  virtual ~ImageLinks();

  ImageLinks(const ImageLinks& from);

  inline ImageLinks& operator=(const ImageLinks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageLinks(ImageLinks&& from) noexcept
    : ImageLinks() {
    *this = ::std::move(from);
  }

  inline ImageLinks& operator=(ImageLinks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageLinks& default_instance();

  static inline const ImageLinks* internal_default_instance() {
    return reinterpret_cast<const ImageLinks*>(
               &_ImageLinks_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ImageLinks* other);
  friend void swap(ImageLinks& a, ImageLinks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageLinks* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageLinks* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageLinks& from);
  void MergeFrom(const ImageLinks& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageLinks* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.ImageLinksItem links = 1;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::ImageLinksItem& links(int index) const;
  ::ru::mail::go::webbase::blobs::ImageLinksItem* mutable_links(int index);
  ::ru::mail::go::webbase::blobs::ImageLinksItem* add_links();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageLinksItem >*
      mutable_links();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageLinksItem >&
      links() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageLinks)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageLinksItem > links_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageLinksItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageLinksItem) */ {
 public:
  ImageLinksItem();
  virtual ~ImageLinksItem();

  ImageLinksItem(const ImageLinksItem& from);

  inline ImageLinksItem& operator=(const ImageLinksItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageLinksItem(ImageLinksItem&& from) noexcept
    : ImageLinksItem() {
    *this = ::std::move(from);
  }

  inline ImageLinksItem& operator=(ImageLinksItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageLinksItem& default_instance();

  static inline const ImageLinksItem* internal_default_instance() {
    return reinterpret_cast<const ImageLinksItem*>(
               &_ImageLinksItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ImageLinksItem* other);
  friend void swap(ImageLinksItem& a, ImageLinksItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageLinksItem* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageLinksItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageLinksItem& from);
  void MergeFrom(const ImageLinksItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageLinksItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageLinksItem)
 private:
  void set_has_url();
  void clear_has_url();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImagePropsWithUrl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImagePropsWithUrl) */ {
 public:
  ImagePropsWithUrl();
  virtual ~ImagePropsWithUrl();

  ImagePropsWithUrl(const ImagePropsWithUrl& from);

  inline ImagePropsWithUrl& operator=(const ImagePropsWithUrl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImagePropsWithUrl(ImagePropsWithUrl&& from) noexcept
    : ImagePropsWithUrl() {
    *this = ::std::move(from);
  }

  inline ImagePropsWithUrl& operator=(ImagePropsWithUrl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImagePropsWithUrl& default_instance();

  static inline const ImagePropsWithUrl* internal_default_instance() {
    return reinterpret_cast<const ImagePropsWithUrl*>(
               &_ImagePropsWithUrl_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ImagePropsWithUrl* other);
  friend void swap(ImagePropsWithUrl& a, ImagePropsWithUrl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImagePropsWithUrl* New() const PROTOBUF_FINAL { return New(NULL); }

  ImagePropsWithUrl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImagePropsWithUrl& from);
  void MergeFrom(const ImagePropsWithUrl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImagePropsWithUrl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional .ru.mail.go.webbase.blobs.ImageProps imageProps = 2;
  bool has_imageprops() const;
  void clear_imageprops();
  static const int kImagePropsFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::ImageProps& imageprops() const;
  ::ru::mail::go::webbase::blobs::ImageProps* mutable_imageprops();
  ::ru::mail::go::webbase::blobs::ImageProps* release_imageprops();
  void set_allocated_imageprops(::ru::mail::go::webbase::blobs::ImageProps* imageprops);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImagePropsWithUrl)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_imageprops();
  void clear_has_imageprops();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::ru::mail::go::webbase::blobs::ImageProps* imageprops_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageItem) */ {
 public:
  ImageItem();
  virtual ~ImageItem();

  ImageItem(const ImageItem& from);

  inline ImageItem& operator=(const ImageItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageItem(ImageItem&& from) noexcept
    : ImageItem() {
    *this = ::std::move(from);
  }

  inline ImageItem& operator=(ImageItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageItem& default_instance();

  static inline const ImageItem* internal_default_instance() {
    return reinterpret_cast<const ImageItem*>(
               &_ImageItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ImageItem* other);
  friend void swap(ImageItem& a, ImageItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageItem* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageItem& from);
  void MergeFrom(const ImageItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.ExplicitDescription descrs = 5;
  int descrs_size() const;
  void clear_descrs();
  static const int kDescrsFieldNumber = 5;
  const ::ru::mail::go::webbase::blobs::ExplicitDescription& descrs(int index) const;
  ::ru::mail::go::webbase::blobs::ExplicitDescription* mutable_descrs(int index);
  ::ru::mail::go::webbase::blobs::ExplicitDescription* add_descrs();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ExplicitDescription >*
      mutable_descrs();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ExplicitDescription >&
      descrs() const;

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional string alt = 2;
  bool has_alt() const;
  void clear_alt();
  static const int kAltFieldNumber = 2;
  const ::std::string& alt() const;
  void set_alt(const ::std::string& value);
  #if LANG_CXX11
  void set_alt(::std::string&& value);
  #endif
  void set_alt(const char* value);
  void set_alt(const char* value, size_t size);
  ::std::string* mutable_alt();
  ::std::string* release_alt();
  void set_allocated_alt(::std::string* alt);

  // optional string title = 6;
  bool has_title() const;
  void clear_title();
  static const int kTitleFieldNumber = 6;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // optional string urlkey = 7;
  bool has_urlkey() const;
  void clear_urlkey();
  static const int kUrlkeyFieldNumber = 7;
  const ::std::string& urlkey() const;
  void set_urlkey(const ::std::string& value);
  #if LANG_CXX11
  void set_urlkey(::std::string&& value);
  #endif
  void set_urlkey(const char* value);
  void set_urlkey(const char* value, size_t size);
  ::std::string* mutable_urlkey();
  ::std::string* release_urlkey();
  void set_allocated_urlkey(::std::string* urlkey);

  // optional uint32 declaredWidth = 3;
  bool has_declaredwidth() const;
  void clear_declaredwidth();
  static const int kDeclaredWidthFieldNumber = 3;
  ::google::protobuf::uint32 declaredwidth() const;
  void set_declaredwidth(::google::protobuf::uint32 value);

  // optional uint32 declaredHeight = 4;
  bool has_declaredheight() const;
  void clear_declaredheight();
  static const int kDeclaredHeightFieldNumber = 4;
  ::google::protobuf::uint32 declaredheight() const;
  void set_declaredheight(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageItem)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_alt();
  void clear_has_alt();
  void set_has_declaredwidth();
  void clear_has_declaredwidth();
  void set_has_declaredheight();
  void clear_has_declaredheight();
  void set_has_title();
  void clear_has_title();
  void set_has_urlkey();
  void clear_has_urlkey();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ExplicitDescription > descrs_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr alt_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr urlkey_;
  ::google::protobuf::uint32 declaredwidth_;
  ::google::protobuf::uint32 declaredheight_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.VarItem) */ {
 public:
  VarItem();
  virtual ~VarItem();

  VarItem(const VarItem& from);

  inline VarItem& operator=(const VarItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarItem(VarItem&& from) noexcept
    : VarItem() {
    *this = ::std::move(from);
  }

  inline VarItem& operator=(VarItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarItem& default_instance();

  static inline const VarItem* internal_default_instance() {
    return reinterpret_cast<const VarItem*>(
               &_VarItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(VarItem* other);
  friend void swap(VarItem& a, VarItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarItem* New() const PROTOBUF_FINAL { return New(NULL); }

  VarItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VarItem& from);
  void MergeFrom(const VarItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VarItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.VarItem children = 3;
  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::VarItem& children(int index) const;
  ::ru::mail::go::webbase::blobs::VarItem* mutable_children(int index);
  ::ru::mail::go::webbase::blobs::VarItem* add_children();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::VarItem >*
      mutable_children();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::VarItem >&
      children() const;

  // optional .ru.mail.go.webbase.blobs.ImageItem img = 1;
  bool has_img() const;
  void clear_img();
  static const int kImgFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::ImageItem& img() const;
  ::ru::mail::go::webbase::blobs::ImageItem* mutable_img();
  ::ru::mail::go::webbase::blobs::ImageItem* release_img();
  void set_allocated_img(::ru::mail::go::webbase::blobs::ImageItem* img);

  // optional .ru.mail.go.webbase.blobs.TextItem txt = 2;
  bool has_txt() const;
  void clear_txt();
  static const int kTxtFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::TextItem& txt() const;
  ::ru::mail::go::webbase::blobs::TextItem* mutable_txt();
  ::ru::mail::go::webbase::blobs::TextItem* release_txt();
  void set_allocated_txt(::ru::mail::go::webbase::blobs::TextItem* txt);

  // optional .ru.mail.go.webbase.blobs.Tag tag = 4;
  bool has_tag() const;
  void clear_tag();
  static const int kTagFieldNumber = 4;
  ::ru::mail::go::webbase::blobs::Tag tag() const;
  void set_tag(::ru::mail::go::webbase::blobs::Tag value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.VarItem)
 private:
  void set_has_img();
  void clear_has_img();
  void set_has_txt();
  void clear_has_txt();
  void set_has_tag();
  void clear_has_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::VarItem > children_;
  ::ru::mail::go::webbase::blobs::ImageItem* img_;
  ::ru::mail::go::webbase::blobs::TextItem* txt_;
  int tag_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MetaAttr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.MetaAttr) */ {
 public:
  MetaAttr();
  virtual ~MetaAttr();

  MetaAttr(const MetaAttr& from);

  inline MetaAttr& operator=(const MetaAttr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetaAttr(MetaAttr&& from) noexcept
    : MetaAttr() {
    *this = ::std::move(from);
  }

  inline MetaAttr& operator=(MetaAttr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaAttr& default_instance();

  static inline const MetaAttr* internal_default_instance() {
    return reinterpret_cast<const MetaAttr*>(
               &_MetaAttr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(MetaAttr* other);
  friend void swap(MetaAttr& a, MetaAttr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetaAttr* New() const PROTOBUF_FINAL { return New(NULL); }

  MetaAttr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MetaAttr& from);
  void MergeFrom(const MetaAttr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MetaAttr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.MetaAttr)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MetaItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.MetaItem) */ {
 public:
  MetaItem();
  virtual ~MetaItem();

  MetaItem(const MetaItem& from);

  inline MetaItem& operator=(const MetaItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetaItem(MetaItem&& from) noexcept
    : MetaItem() {
    *this = ::std::move(from);
  }

  inline MetaItem& operator=(MetaItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaItem& default_instance();

  static inline const MetaItem* internal_default_instance() {
    return reinterpret_cast<const MetaItem*>(
               &_MetaItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(MetaItem* other);
  friend void swap(MetaItem& a, MetaItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetaItem* New() const PROTOBUF_FINAL { return New(NULL); }

  MetaItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MetaItem& from);
  void MergeFrom(const MetaItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MetaItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.MetaAttr attrs = 1;
  int attrs_size() const;
  void clear_attrs();
  static const int kAttrsFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::MetaAttr& attrs(int index) const;
  ::ru::mail::go::webbase::blobs::MetaAttr* mutable_attrs(int index);
  ::ru::mail::go::webbase::blobs::MetaAttr* add_attrs();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::MetaAttr >*
      mutable_attrs();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::MetaAttr >&
      attrs() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.MetaItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::MetaAttr > attrs_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CustomItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.CustomItem) */ {
 public:
  CustomItem();
  virtual ~CustomItem();

  CustomItem(const CustomItem& from);

  inline CustomItem& operator=(const CustomItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomItem(CustomItem&& from) noexcept
    : CustomItem() {
    *this = ::std::move(from);
  }

  inline CustomItem& operator=(CustomItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomItem& default_instance();

  static inline const CustomItem* internal_default_instance() {
    return reinterpret_cast<const CustomItem*>(
               &_CustomItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(CustomItem* other);
  friend void swap(CustomItem& a, CustomItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomItem* New() const PROTOBUF_FINAL { return New(NULL); }

  CustomItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CustomItem& from);
  void MergeFrom(const CustomItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CustomItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string texts = 2;
  int texts_size() const;
  void clear_texts();
  static const int kTextsFieldNumber = 2;
  const ::std::string& texts(int index) const;
  ::std::string* mutable_texts(int index);
  void set_texts(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_texts(int index, ::std::string&& value);
  #endif
  void set_texts(int index, const char* value);
  void set_texts(int index, const char* value, size_t size);
  ::std::string* add_texts();
  void add_texts(const ::std::string& value);
  #if LANG_CXX11
  void add_texts(::std::string&& value);
  #endif
  void add_texts(const char* value);
  void add_texts(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& texts() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_texts();

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.CustomItem)
 private:
  void set_has_url();
  void clear_has_url();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> texts_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GifestData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.GifestData) */ {
 public:
  GifestData();
  virtual ~GifestData();

  GifestData(const GifestData& from);

  inline GifestData& operator=(const GifestData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GifestData(GifestData&& from) noexcept
    : GifestData() {
    *this = ::std::move(from);
  }

  inline GifestData& operator=(GifestData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GifestData& default_instance();

  static inline const GifestData* internal_default_instance() {
    return reinterpret_cast<const GifestData*>(
               &_GifestData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(GifestData* other);
  friend void swap(GifestData& a, GifestData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GifestData* New() const PROTOBUF_FINAL { return New(NULL); }

  GifestData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GifestData& from);
  void MergeFrom(const GifestData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GifestData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.CustomItem items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::CustomItem& items(int index) const;
  ::ru::mail::go::webbase::blobs::CustomItem* mutable_items(int index);
  ::ru::mail::go::webbase::blobs::CustomItem* add_items();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::CustomItem >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::CustomItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.GifestData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::CustomItem > items_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HtmlPage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.HtmlPage) */ {
 public:
  HtmlPage();
  virtual ~HtmlPage();

  HtmlPage(const HtmlPage& from);

  inline HtmlPage& operator=(const HtmlPage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HtmlPage(HtmlPage&& from) noexcept
    : HtmlPage() {
    *this = ::std::move(from);
  }

  inline HtmlPage& operator=(HtmlPage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HtmlPage& default_instance();

  static inline const HtmlPage* internal_default_instance() {
    return reinterpret_cast<const HtmlPage*>(
               &_HtmlPage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(HtmlPage* other);
  friend void swap(HtmlPage& a, HtmlPage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HtmlPage* New() const PROTOBUF_FINAL { return New(NULL); }

  HtmlPage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HtmlPage& from);
  void MergeFrom(const HtmlPage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HtmlPage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.VarItem items = 3;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::VarItem& items(int index) const;
  ::ru::mail::go::webbase::blobs::VarItem* mutable_items(int index);
  ::ru::mail::go::webbase::blobs::VarItem* add_items();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::VarItem >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::VarItem >&
      items() const;

  // repeated .ru.mail.go.webbase.blobs.MetaItem meta_items = 5;
  int meta_items_size() const;
  void clear_meta_items();
  static const int kMetaItemsFieldNumber = 5;
  const ::ru::mail::go::webbase::blobs::MetaItem& meta_items(int index) const;
  ::ru::mail::go::webbase::blobs::MetaItem* mutable_meta_items(int index);
  ::ru::mail::go::webbase::blobs::MetaItem* add_meta_items();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::MetaItem >*
      mutable_meta_items();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::MetaItem >&
      meta_items() const;

  // optional .ru.mail.go.webbase.blobs.FeatureList features_list = 4;
  bool has_features_list() const;
  void clear_features_list();
  static const int kFeaturesListFieldNumber = 4;
  const ::ru::mail::go::webbase::blobs::FeatureList& features_list() const;
  ::ru::mail::go::webbase::blobs::FeatureList* mutable_features_list();
  ::ru::mail::go::webbase::blobs::FeatureList* release_features_list();
  void set_allocated_features_list(::ru::mail::go::webbase::blobs::FeatureList* features_list);

  // required uint32 porn = 1;
  bool has_porn() const;
  void clear_porn();
  static const int kPornFieldNumber = 1;
  ::google::protobuf::uint32 porn() const;
  void set_porn(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.HtmlPage)
 private:
  void set_has_porn();
  void clear_has_porn();
  void set_has_features_list();
  void clear_has_features_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::VarItem > items_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::MetaItem > meta_items_;
  ::ru::mail::go::webbase::blobs::FeatureList* features_list_;
  ::google::protobuf::uint32 porn_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParseHtmlInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ParseHtmlInput) */ {
 public:
  ParseHtmlInput();
  virtual ~ParseHtmlInput();

  ParseHtmlInput(const ParseHtmlInput& from);

  inline ParseHtmlInput& operator=(const ParseHtmlInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParseHtmlInput(ParseHtmlInput&& from) noexcept
    : ParseHtmlInput() {
    *this = ::std::move(from);
  }

  inline ParseHtmlInput& operator=(ParseHtmlInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParseHtmlInput& default_instance();

  static inline const ParseHtmlInput* internal_default_instance() {
    return reinterpret_cast<const ParseHtmlInput*>(
               &_ParseHtmlInput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ParseHtmlInput* other);
  friend void swap(ParseHtmlInput& a, ParseHtmlInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParseHtmlInput* New() const PROTOBUF_FINAL { return New(NULL); }

  ParseHtmlInput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParseHtmlInput& from);
  void MergeFrom(const ParseHtmlInput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParseHtmlInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required bytes content = 2;
  bool has_content() const;
  void clear_content();
  static const int kContentFieldNumber = 2;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // required .ru.mail.go.webbase.blobs.Encoding enc = 3;
  bool has_enc() const;
  void clear_enc();
  static const int kEncFieldNumber = 3;
  ::ru::mail::go::webbase::blobs::Encoding enc() const;
  void set_enc(::ru::mail::go::webbase::blobs::Encoding value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ParseHtmlInput)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_content();
  void clear_has_content();
  void set_has_enc();
  void clear_has_enc();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  int enc_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BOW : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.BOW) */ {
 public:
  BOW();
  virtual ~BOW();

  BOW(const BOW& from);

  inline BOW& operator=(const BOW& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BOW(BOW&& from) noexcept
    : BOW() {
    *this = ::std::move(from);
  }

  inline BOW& operator=(BOW&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BOW& default_instance();

  static inline const BOW* internal_default_instance() {
    return reinterpret_cast<const BOW*>(
               &_BOW_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(BOW* other);
  friend void swap(BOW& a, BOW& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BOW* New() const PROTOBUF_FINAL { return New(NULL); }

  BOW* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BOW& from);
  void MergeFrom(const BOW& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BOW* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 words = 1;
  int words_size() const;
  void clear_words();
  static const int kWordsFieldNumber = 1;
  ::google::protobuf::uint32 words(int index) const;
  void set_words(int index, ::google::protobuf::uint32 value);
  void add_words(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      words() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_words();

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.BOW)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > words_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DCT : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.DCT) */ {
 public:
  DCT();
  virtual ~DCT();

  DCT(const DCT& from);

  inline DCT& operator=(const DCT& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DCT(DCT&& from) noexcept
    : DCT() {
    *this = ::std::move(from);
  }

  inline DCT& operator=(DCT&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DCT& default_instance();

  static inline const DCT* internal_default_instance() {
    return reinterpret_cast<const DCT*>(
               &_DCT_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(DCT* other);
  friend void swap(DCT& a, DCT& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DCT* New() const PROTOBUF_FINAL { return New(NULL); }

  DCT* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DCT& from);
  void MergeFrom(const DCT& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DCT* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::google::protobuf::RepeatedField< float >&
      values() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.DCT)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > values_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageProps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageProps) */ {
 public:
  ImageProps();
  virtual ~ImageProps();

  ImageProps(const ImageProps& from);

  inline ImageProps& operator=(const ImageProps& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageProps(ImageProps&& from) noexcept
    : ImageProps() {
    *this = ::std::move(from);
  }

  inline ImageProps& operator=(ImageProps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageProps& default_instance();

  static inline const ImageProps* internal_default_instance() {
    return reinterpret_cast<const ImageProps*>(
               &_ImageProps_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(ImageProps* other);
  friend void swap(ImageProps& a, ImageProps& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageProps* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageProps* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageProps& from);
  void MergeFrom(const ImageProps& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageProps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 visual_words = 16;
  int visual_words_size() const;
  void clear_visual_words();
  static const int kVisualWordsFieldNumber = 16;
  ::google::protobuf::uint32 visual_words(int index) const;
  void set_visual_words(int index, ::google::protobuf::uint32 value);
  void add_visual_words(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      visual_words() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_visual_words();

  // optional .ru.mail.go.webbase.parsing.img.Exif exif = 6;
  bool has_exif() const;
  void clear_exif();
  static const int kExifFieldNumber = 6;
  const ::ru::mail::go::webbase::parsing::img::Exif& exif() const;
  ::ru::mail::go::webbase::parsing::img::Exif* mutable_exif();
  ::ru::mail::go::webbase::parsing::img::Exif* release_exif();
  void set_allocated_exif(::ru::mail::go::webbase::parsing::img::Exif* exif);

  // optional .ru.mail.go.webbase.parsing.img.CvFeatures cv_features = 13;
  bool has_cv_features() const;
  void clear_cv_features();
  static const int kCvFeaturesFieldNumber = 13;
  const ::ru::mail::go::webbase::parsing::img::CvFeatures& cv_features() const;
  ::ru::mail::go::webbase::parsing::img::CvFeatures* mutable_cv_features();
  ::ru::mail::go::webbase::parsing::img::CvFeatures* release_cv_features();
  void set_allocated_cv_features(::ru::mail::go::webbase::parsing::img::CvFeatures* cv_features);

  // optional .ru.mail.go.webbase.blobs.BOW bow = 17;
  bool has_bow() const;
  void clear_bow();
  static const int kBowFieldNumber = 17;
  const ::ru::mail::go::webbase::blobs::BOW& bow() const;
  ::ru::mail::go::webbase::blobs::BOW* mutable_bow();
  ::ru::mail::go::webbase::blobs::BOW* release_bow();
  void set_allocated_bow(::ru::mail::go::webbase::blobs::BOW* bow);

  // optional .ru.mail.go.webbase.blobs.DCT dct = 18;
  bool has_dct() const;
  void clear_dct();
  static const int kDctFieldNumber = 18;
  const ::ru::mail::go::webbase::blobs::DCT& dct() const;
  ::ru::mail::go::webbase::blobs::DCT* mutable_dct();
  ::ru::mail::go::webbase::blobs::DCT* release_dct();
  void set_allocated_dct(::ru::mail::go::webbase::blobs::DCT* dct);

  // required uint32 width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required uint64 hash = 4;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 4;
  ::google::protobuf::uint64 hash() const;
  void set_hash(::google::protobuf::uint64 value);

  // required .ru.mail.go.webbase.parsing.img.ImageFormat format = 3;
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 3;
  ::ru::mail::go::webbase::parsing::img::ImageFormat format() const;
  void set_format(::ru::mail::go::webbase::parsing::img::ImageFormat value);

  // required uint32 enthropy = 5;
  bool has_enthropy() const;
  void clear_enthropy();
  static const int kEnthropyFieldNumber = 5;
  ::google::protobuf::uint32 enthropy() const;
  void set_enthropy(::google::protobuf::uint32 value);

  // optional double sharpness = 8;
  bool has_sharpness() const;
  void clear_sharpness();
  static const int kSharpnessFieldNumber = 8;
  double sharpness() const;
  void set_sharpness(double value);

  // required uint32 size = 7;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 7;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // optional uint32 brightness = 9;
  bool has_brightness() const;
  void clear_brightness();
  static const int kBrightnessFieldNumber = 9;
  ::google::protobuf::uint32 brightness() const;
  void set_brightness(::google::protobuf::uint32 value);

  // optional uint32 contrast = 10;
  bool has_contrast() const;
  void clear_contrast();
  static const int kContrastFieldNumber = 10;
  ::google::protobuf::uint32 contrast() const;
  void set_contrast(::google::protobuf::uint32 value);

  // optional uint32 colors = 11;
  bool has_colors() const;
  void clear_colors();
  static const int kColorsFieldNumber = 11;
  ::google::protobuf::uint32 colors() const;
  void set_colors(::google::protobuf::uint32 value);

  // optional uint32 short_hash = 15;
  bool has_short_hash() const;
  void clear_short_hash();
  static const int kShortHashFieldNumber = 15;
  ::google::protobuf::uint32 short_hash() const;
  void set_short_hash(::google::protobuf::uint32 value);

  // optional bool transparent = 12;
  bool has_transparent() const;
  void clear_transparent();
  static const int kTransparentFieldNumber = 12;
  bool transparent() const;
  void set_transparent(bool value);

  // optional bool is_demotivator = 14;
  bool has_is_demotivator() const;
  void clear_is_demotivator();
  static const int kIsDemotivatorFieldNumber = 14;
  bool is_demotivator() const;
  void set_is_demotivator(bool value);

  // optional bool animated = 20;
  bool has_animated() const;
  void clear_animated();
  static const int kAnimatedFieldNumber = 20;
  bool animated() const;
  void set_animated(bool value);

  // optional uint64 animation_length = 21;
  bool has_animation_length() const;
  void clear_animation_length();
  static const int kAnimationLengthFieldNumber = 21;
  ::google::protobuf::uint64 animation_length() const;
  void set_animation_length(::google::protobuf::uint64 value);

  // optional .ru.mail.go.webbase.parsing.img.ImageClass category = 19;
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 19;
  ::ru::mail::go::webbase::parsing::img::ImageClass category() const;
  void set_category(::ru::mail::go::webbase::parsing::img::ImageClass value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageProps)
 private:
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_format();
  void clear_has_format();
  void set_has_hash();
  void clear_has_hash();
  void set_has_enthropy();
  void clear_has_enthropy();
  void set_has_exif();
  void clear_has_exif();
  void set_has_size();
  void clear_has_size();
  void set_has_sharpness();
  void clear_has_sharpness();
  void set_has_brightness();
  void clear_has_brightness();
  void set_has_contrast();
  void clear_has_contrast();
  void set_has_colors();
  void clear_has_colors();
  void set_has_transparent();
  void clear_has_transparent();
  void set_has_cv_features();
  void clear_has_cv_features();
  void set_has_is_demotivator();
  void clear_has_is_demotivator();
  void set_has_short_hash();
  void clear_has_short_hash();
  void set_has_bow();
  void clear_has_bow();
  void set_has_dct();
  void clear_has_dct();
  void set_has_category();
  void clear_has_category();
  void set_has_animated();
  void clear_has_animated();
  void set_has_animation_length();
  void clear_has_animation_length();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > visual_words_;
  ::ru::mail::go::webbase::parsing::img::Exif* exif_;
  ::ru::mail::go::webbase::parsing::img::CvFeatures* cv_features_;
  ::ru::mail::go::webbase::blobs::BOW* bow_;
  ::ru::mail::go::webbase::blobs::DCT* dct_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint64 hash_;
  int format_;
  ::google::protobuf::uint32 enthropy_;
  double sharpness_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint32 brightness_;
  ::google::protobuf::uint32 contrast_;
  ::google::protobuf::uint32 colors_;
  ::google::protobuf::uint32 short_hash_;
  bool transparent_;
  bool is_demotivator_;
  bool animated_;
  ::google::protobuf::uint64 animation_length_;
  int category_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParserSignature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ParserSignature) */ {
 public:
  ParserSignature();
  virtual ~ParserSignature();

  ParserSignature(const ParserSignature& from);

  inline ParserSignature& operator=(const ParserSignature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParserSignature(ParserSignature&& from) noexcept
    : ParserSignature() {
    *this = ::std::move(from);
  }

  inline ParserSignature& operator=(ParserSignature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParserSignature& default_instance();

  static inline const ParserSignature* internal_default_instance() {
    return reinterpret_cast<const ParserSignature*>(
               &_ParserSignature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(ParserSignature* other);
  friend void swap(ParserSignature& a, ParserSignature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParserSignature* New() const PROTOBUF_FINAL { return New(NULL); }

  ParserSignature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ParserSignature& from);
  void MergeFrom(const ParserSignature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ParserSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 time = 3;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // required bool img = 1;
  bool has_img() const;
  void clear_img();
  static const int kImgFieldNumber = 1;
  bool img() const;
  void set_img(bool value);

  // required bool ppl = 2;
  bool has_ppl() const;
  void clear_ppl();
  static const int kPplFieldNumber = 2;
  bool ppl() const;
  void set_ppl(bool value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ParserSignature)
 private:
  void set_has_img();
  void clear_has_img();
  void set_has_ppl();
  void clear_has_ppl();
  void set_has_time();
  void clear_has_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_;
  bool img_;
  bool ppl_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImgParserBlob : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImgParserBlob) */ {
 public:
  ImgParserBlob();
  virtual ~ImgParserBlob();

  ImgParserBlob(const ImgParserBlob& from);

  inline ImgParserBlob& operator=(const ImgParserBlob& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImgParserBlob(ImgParserBlob&& from) noexcept
    : ImgParserBlob() {
    *this = ::std::move(from);
  }

  inline ImgParserBlob& operator=(ImgParserBlob&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImgParserBlob& default_instance();

  static inline const ImgParserBlob* internal_default_instance() {
    return reinterpret_cast<const ImgParserBlob*>(
               &_ImgParserBlob_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(ImgParserBlob* other);
  friend void swap(ImgParserBlob& a, ImgParserBlob& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImgParserBlob* New() const PROTOBUF_FINAL { return New(NULL); }

  ImgParserBlob* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImgParserBlob& from);
  void MergeFrom(const ImgParserBlob& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImgParserBlob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float sifts = 5;
  int sifts_size() const;
  void clear_sifts();
  static const int kSiftsFieldNumber = 5;
  float sifts(int index) const;
  void set_sifts(int index, float value);
  void add_sifts(float value);
  const ::google::protobuf::RepeatedField< float >&
      sifts() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_sifts();

  // required bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required .ru.mail.go.webbase.blobs.ImageProps props = 2;
  bool has_props() const;
  void clear_props();
  static const int kPropsFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::ImageProps& props() const;
  ::ru::mail::go::webbase::blobs::ImageProps* mutable_props();
  ::ru::mail::go::webbase::blobs::ImageProps* release_props();
  void set_allocated_props(::ru::mail::go::webbase::blobs::ImageProps* props);

  // required .ru.mail.go.webbase.parsing.img.Thumb thumb = 3;
  bool has_thumb() const;
  void clear_thumb();
  static const int kThumbFieldNumber = 3;
  const ::ru::mail::go::webbase::parsing::img::Thumb& thumb() const;
  ::ru::mail::go::webbase::parsing::img::Thumb* mutable_thumb();
  ::ru::mail::go::webbase::parsing::img::Thumb* release_thumb();
  void set_allocated_thumb(::ru::mail::go::webbase::parsing::img::Thumb* thumb);

  // optional .ru.mail.go.webbase.parsing.img.VideoClip video_thumb = 4;
  bool has_video_thumb() const;
  void clear_video_thumb();
  static const int kVideoThumbFieldNumber = 4;
  const ::ru::mail::go::webbase::parsing::img::VideoClip& video_thumb() const;
  ::ru::mail::go::webbase::parsing::img::VideoClip* mutable_video_thumb();
  ::ru::mail::go::webbase::parsing::img::VideoClip* release_video_thumb();
  void set_allocated_video_thumb(::ru::mail::go::webbase::parsing::img::VideoClip* video_thumb);

  // optional .ru.mail.go.webbase.parsing.img.Thumb thumb_hidpi = 6;
  bool has_thumb_hidpi() const;
  void clear_thumb_hidpi();
  static const int kThumbHidpiFieldNumber = 6;
  const ::ru::mail::go::webbase::parsing::img::Thumb& thumb_hidpi() const;
  ::ru::mail::go::webbase::parsing::img::Thumb* mutable_thumb_hidpi();
  ::ru::mail::go::webbase::parsing::img::Thumb* release_thumb_hidpi();
  void set_allocated_thumb_hidpi(::ru::mail::go::webbase::parsing::img::Thumb* thumb_hidpi);

  // optional .ru.mail.go.webbase.parsing.img.VideoClip video_thumb_hidpi = 7;
  bool has_video_thumb_hidpi() const;
  void clear_video_thumb_hidpi();
  static const int kVideoThumbHidpiFieldNumber = 7;
  const ::ru::mail::go::webbase::parsing::img::VideoClip& video_thumb_hidpi() const;
  ::ru::mail::go::webbase::parsing::img::VideoClip* mutable_video_thumb_hidpi();
  ::ru::mail::go::webbase::parsing::img::VideoClip* release_video_thumb_hidpi();
  void set_allocated_video_thumb_hidpi(::ru::mail::go::webbase::parsing::img::VideoClip* video_thumb_hidpi);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImgParserBlob)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_props();
  void clear_has_props();
  void set_has_thumb();
  void clear_has_thumb();
  void set_has_video_thumb();
  void clear_has_video_thumb();
  void set_has_thumb_hidpi();
  void clear_has_thumb_hidpi();
  void set_has_video_thumb_hidpi();
  void clear_has_video_thumb_hidpi();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > sifts_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::ru::mail::go::webbase::blobs::ImageProps* props_;
  ::ru::mail::go::webbase::parsing::img::Thumb* thumb_;
  ::ru::mail::go::webbase::parsing::img::VideoClip* video_thumb_;
  ::ru::mail::go::webbase::parsing::img::Thumb* thumb_hidpi_;
  ::ru::mail::go::webbase::parsing::img::VideoClip* video_thumb_hidpi_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImgParserBlobList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImgParserBlobList) */ {
 public:
  ImgParserBlobList();
  virtual ~ImgParserBlobList();

  ImgParserBlobList(const ImgParserBlobList& from);

  inline ImgParserBlobList& operator=(const ImgParserBlobList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImgParserBlobList(ImgParserBlobList&& from) noexcept
    : ImgParserBlobList() {
    *this = ::std::move(from);
  }

  inline ImgParserBlobList& operator=(ImgParserBlobList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImgParserBlobList& default_instance();

  static inline const ImgParserBlobList* internal_default_instance() {
    return reinterpret_cast<const ImgParserBlobList*>(
               &_ImgParserBlobList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ImgParserBlobList* other);
  friend void swap(ImgParserBlobList& a, ImgParserBlobList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImgParserBlobList* New() const PROTOBUF_FINAL { return New(NULL); }

  ImgParserBlobList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImgParserBlobList& from);
  void MergeFrom(const ImgParserBlobList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImgParserBlobList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.ImgParserBlob images = 2;
  int images_size() const;
  void clear_images();
  static const int kImagesFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::ImgParserBlob& images(int index) const;
  ::ru::mail::go::webbase::blobs::ImgParserBlob* mutable_images(int index);
  ::ru::mail::go::webbase::blobs::ImgParserBlob* add_images();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImgParserBlob >*
      mutable_images();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImgParserBlob >&
      images() const;

  // required uint32 num = 1;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 1;
  ::google::protobuf::uint32 num() const;
  void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImgParserBlobList)
 private:
  void set_has_num();
  void clear_has_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImgParserBlob > images_;
  ::google::protobuf::uint32 num_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DomainStruct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.DomainStruct) */ {
 public:
  DomainStruct();
  virtual ~DomainStruct();

  DomainStruct(const DomainStruct& from);

  inline DomainStruct& operator=(const DomainStruct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DomainStruct(DomainStruct&& from) noexcept
    : DomainStruct() {
    *this = ::std::move(from);
  }

  inline DomainStruct& operator=(DomainStruct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DomainStruct& default_instance();

  static inline const DomainStruct* internal_default_instance() {
    return reinterpret_cast<const DomainStruct*>(
               &_DomainStruct_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(DomainStruct* other);
  friend void swap(DomainStruct& a, DomainStruct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DomainStruct* New() const PROTOBUF_FINAL { return New(NULL); }

  DomainStruct* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DomainStruct& from);
  void MergeFrom(const DomainStruct& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DomainStruct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gogo.storage.extra_info domain_extra_info = 8;
  int domain_extra_info_size() const;
  void clear_domain_extra_info();
  static const int kDomainExtraInfoFieldNumber = 8;
  const ::gogo::storage::extra_info& domain_extra_info(int index) const;
  ::gogo::storage::extra_info* mutable_domain_extra_info(int index);
  ::gogo::storage::extra_info* add_domain_extra_info();
  ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >*
      mutable_domain_extra_info();
  const ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >&
      domain_extra_info() const;

  // required string keyDomain = 1;
  bool has_keydomain() const;
  void clear_keydomain();
  static const int kKeyDomainFieldNumber = 1;
  const ::std::string& keydomain() const;
  void set_keydomain(const ::std::string& value);
  #if LANG_CXX11
  void set_keydomain(::std::string&& value);
  #endif
  void set_keydomain(const char* value);
  void set_keydomain(const char* value, size_t size);
  ::std::string* mutable_keydomain();
  ::std::string* release_keydomain();
  void set_allocated_keydomain(::std::string* keydomain);

  // required string fullDomain = 2;
  bool has_fulldomain() const;
  void clear_fulldomain();
  static const int kFullDomainFieldNumber = 2;
  const ::std::string& fulldomain() const;
  void set_fulldomain(const ::std::string& value);
  #if LANG_CXX11
  void set_fulldomain(::std::string&& value);
  #endif
  void set_fulldomain(const char* value);
  void set_fulldomain(const char* value, size_t size);
  ::std::string* mutable_fulldomain();
  ::std::string* release_fulldomain();
  void set_allocated_fulldomain(::std::string* fulldomain);

  // optional .ru.mail.go.webbase.blobs.WOTInfo wot_info = 7;
  bool has_wot_info() const;
  void clear_wot_info();
  static const int kWotInfoFieldNumber = 7;
  const ::ru::mail::go::webbase::blobs::WOTInfo& wot_info() const;
  ::ru::mail::go::webbase::blobs::WOTInfo* mutable_wot_info();
  ::ru::mail::go::webbase::blobs::WOTInfo* release_wot_info();
  void set_allocated_wot_info(::ru::mail::go::webbase::blobs::WOTInfo* wot_info);

  // optional uint32 ic = 3;
  bool has_ic() const;
  void clear_ic();
  static const int kIcFieldNumber = 3;
  ::google::protobuf::uint32 ic() const;
  void set_ic(::google::protobuf::uint32 value);

  // optional uint32 trusted_ic = 4;
  bool has_trusted_ic() const;
  void clear_trusted_ic();
  static const int kTrustedIcFieldNumber = 4;
  ::google::protobuf::uint32 trusted_ic() const;
  void set_trusted_ic(::google::protobuf::uint32 value);

  // optional bool cloaking = 5;
  bool has_cloaking() const;
  void clear_cloaking();
  static const int kCloakingFieldNumber = 5;
  bool cloaking() const;
  void set_cloaking(bool value);

  // optional uint32 nbrsq2 = 6;
  bool has_nbrsq2() const;
  void clear_nbrsq2();
  static const int kNbrsq2FieldNumber = 6;
  ::google::protobuf::uint32 nbrsq2() const;
  void set_nbrsq2(::google::protobuf::uint32 value);

  // optional uint32 spam = 9;
  bool has_spam() const;
  void clear_spam();
  static const int kSpamFieldNumber = 9;
  ::google::protobuf::uint32 spam() const;
  void set_spam(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.DomainStruct)
 private:
  void set_has_keydomain();
  void clear_has_keydomain();
  void set_has_fulldomain();
  void clear_has_fulldomain();
  void set_has_ic();
  void clear_has_ic();
  void set_has_trusted_ic();
  void clear_has_trusted_ic();
  void set_has_cloaking();
  void clear_has_cloaking();
  void set_has_nbrsq2();
  void clear_has_nbrsq2();
  void set_has_wot_info();
  void clear_has_wot_info();
  void set_has_spam();
  void clear_has_spam();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info > domain_extra_info_;
  ::google::protobuf::internal::ArenaStringPtr keydomain_;
  ::google::protobuf::internal::ArenaStringPtr fulldomain_;
  ::ru::mail::go::webbase::blobs::WOTInfo* wot_info_;
  ::google::protobuf::uint32 ic_;
  ::google::protobuf::uint32 trusted_ic_;
  bool cloaking_;
  ::google::protobuf::uint32 nbrsq2_;
  ::google::protobuf::uint32 spam_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageStruct_AdditionalProps : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageStruct.AdditionalProps) */ {
 public:
  ImageStruct_AdditionalProps();
  virtual ~ImageStruct_AdditionalProps();

  ImageStruct_AdditionalProps(const ImageStruct_AdditionalProps& from);

  inline ImageStruct_AdditionalProps& operator=(const ImageStruct_AdditionalProps& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageStruct_AdditionalProps(ImageStruct_AdditionalProps&& from) noexcept
    : ImageStruct_AdditionalProps() {
    *this = ::std::move(from);
  }

  inline ImageStruct_AdditionalProps& operator=(ImageStruct_AdditionalProps&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageStruct_AdditionalProps& default_instance();

  static inline const ImageStruct_AdditionalProps* internal_default_instance() {
    return reinterpret_cast<const ImageStruct_AdditionalProps*>(
               &_ImageStruct_AdditionalProps_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(ImageStruct_AdditionalProps* other);
  friend void swap(ImageStruct_AdditionalProps& a, ImageStruct_AdditionalProps& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageStruct_AdditionalProps* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageStruct_AdditionalProps* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageStruct_AdditionalProps& from);
  void MergeFrom(const ImageStruct_AdditionalProps& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageStruct_AdditionalProps* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float porn_prob = 22;
  bool has_porn_prob() const;
  void clear_porn_prob();
  static const int kPornProbFieldNumber = 22;
  float porn_prob() const;
  void set_porn_prob(float value);

  // optional float porn_prob_v2 = 23;
  bool has_porn_prob_v2() const;
  void clear_porn_prob_v2();
  static const int kPornProbV2FieldNumber = 23;
  float porn_prob_v2() const;
  void set_porn_prob_v2(float value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageStruct.AdditionalProps)
 private:
  void set_has_porn_prob();
  void clear_has_porn_prob();
  void set_has_porn_prob_v2();
  void clear_has_porn_prob_v2();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float porn_prob_;
  float porn_prob_v2_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageStruct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageStruct) */ {
 public:
  ImageStruct();
  virtual ~ImageStruct();

  ImageStruct(const ImageStruct& from);

  inline ImageStruct& operator=(const ImageStruct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageStruct(ImageStruct&& from) noexcept
    : ImageStruct() {
    *this = ::std::move(from);
  }

  inline ImageStruct& operator=(ImageStruct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageStruct& default_instance();

  static inline const ImageStruct* internal_default_instance() {
    return reinterpret_cast<const ImageStruct*>(
               &_ImageStruct_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(ImageStruct* other);
  friend void swap(ImageStruct& a, ImageStruct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageStruct* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageStruct* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageStruct& from);
  void MergeFrom(const ImageStruct& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageStruct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ImageStruct_AdditionalProps AdditionalProps;

  // accessors -------------------------------------------------------

  // required string keyUrl = 1;
  bool has_keyurl() const;
  void clear_keyurl();
  static const int kKeyUrlFieldNumber = 1;
  const ::std::string& keyurl() const;
  void set_keyurl(const ::std::string& value);
  #if LANG_CXX11
  void set_keyurl(::std::string&& value);
  #endif
  void set_keyurl(const char* value);
  void set_keyurl(const char* value, size_t size);
  ::std::string* mutable_keyurl();
  ::std::string* release_keyurl();
  void set_allocated_keyurl(::std::string* keyurl);

  // required string fullUrl = 2;
  bool has_fullurl() const;
  void clear_fullurl();
  static const int kFullUrlFieldNumber = 2;
  const ::std::string& fullurl() const;
  void set_fullurl(const ::std::string& value);
  #if LANG_CXX11
  void set_fullurl(::std::string&& value);
  #endif
  void set_fullurl(const char* value);
  void set_fullurl(const char* value, size_t size);
  ::std::string* mutable_fullurl();
  ::std::string* release_fullurl();
  void set_allocated_fullurl(::std::string* fullurl);

  // optional .ru.mail.go.webbase.parsing.img.Thumb thumb = 3;
  bool has_thumb() const;
  void clear_thumb();
  static const int kThumbFieldNumber = 3;
  const ::ru::mail::go::webbase::parsing::img::Thumb& thumb() const;
  ::ru::mail::go::webbase::parsing::img::Thumb* mutable_thumb();
  ::ru::mail::go::webbase::parsing::img::Thumb* release_thumb();
  void set_allocated_thumb(::ru::mail::go::webbase::parsing::img::Thumb* thumb);

  // required .ru.mail.go.webbase.blobs.ImageProps props = 4;
  bool has_props() const;
  void clear_props();
  static const int kPropsFieldNumber = 4;
  const ::ru::mail::go::webbase::blobs::ImageProps& props() const;
  ::ru::mail::go::webbase::blobs::ImageProps* mutable_props();
  ::ru::mail::go::webbase::blobs::ImageProps* release_props();
  void set_allocated_props(::ru::mail::go::webbase::blobs::ImageProps* props);

  // optional .ru.mail.go.webbase.blobs.ExtraTextArray imageExtraTexts = 6;
  bool has_imageextratexts() const;
  void clear_imageextratexts();
  static const int kImageExtraTextsFieldNumber = 6;
  const ::ru::mail::go::webbase::blobs::ExtraTextArray& imageextratexts() const;
  ::ru::mail::go::webbase::blobs::ExtraTextArray* mutable_imageextratexts();
  ::ru::mail::go::webbase::blobs::ExtraTextArray* release_imageextratexts();
  void set_allocated_imageextratexts(::ru::mail::go::webbase::blobs::ExtraTextArray* imageextratexts);

  // optional .ru.mail.go.webbase.parsing.img.VideoClip video_thumb = 8;
  bool has_video_thumb() const;
  void clear_video_thumb();
  static const int kVideoThumbFieldNumber = 8;
  const ::ru::mail::go::webbase::parsing::img::VideoClip& video_thumb() const;
  ::ru::mail::go::webbase::parsing::img::VideoClip* mutable_video_thumb();
  ::ru::mail::go::webbase::parsing::img::VideoClip* release_video_thumb();
  void set_allocated_video_thumb(::ru::mail::go::webbase::parsing::img::VideoClip* video_thumb);

  // optional .ru.mail.go.webbase.blobs.VisitInfo YGVisitInfo = 9;
  bool has_ygvisitinfo() const;
  void clear_ygvisitinfo();
  static const int kYGVisitInfoFieldNumber = 9;
  const ::ru::mail::go::webbase::blobs::VisitInfo& ygvisitinfo() const;
  ::ru::mail::go::webbase::blobs::VisitInfo* mutable_ygvisitinfo();
  ::ru::mail::go::webbase::blobs::VisitInfo* release_ygvisitinfo();
  void set_allocated_ygvisitinfo(::ru::mail::go::webbase::blobs::VisitInfo* ygvisitinfo);

  // optional .ru.mail.go.webbase.blobs.ImageStruct.AdditionalProps additional_props = 10;
  bool has_additional_props() const;
  void clear_additional_props();
  static const int kAdditionalPropsFieldNumber = 10;
  const ::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps& additional_props() const;
  ::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps* mutable_additional_props();
  ::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps* release_additional_props();
  void set_allocated_additional_props(::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps* additional_props);

  // optional .qembedder.pb.Embedding cnn_embedding = 11;
  bool has_cnn_embedding() const;
  void clear_cnn_embedding();
  static const int kCnnEmbeddingFieldNumber = 11;
  const ::qembedder::pb::Embedding& cnn_embedding() const;
  ::qembedder::pb::Embedding* mutable_cnn_embedding();
  ::qembedder::pb::Embedding* release_cnn_embedding();
  void set_allocated_cnn_embedding(::qembedder::pb::Embedding* cnn_embedding);

  // optional .qembedder.pb.Embedding cnn_serp_embedding = 12;
  bool has_cnn_serp_embedding() const;
  void clear_cnn_serp_embedding();
  static const int kCnnSerpEmbeddingFieldNumber = 12;
  const ::qembedder::pb::Embedding& cnn_serp_embedding() const;
  ::qembedder::pb::Embedding* mutable_cnn_serp_embedding();
  ::qembedder::pb::Embedding* release_cnn_serp_embedding();
  void set_allocated_cnn_serp_embedding(::qembedder::pb::Embedding* cnn_serp_embedding);

  // optional .qembedder.pb.Embedding vit_serp_embedding = 14;
  bool has_vit_serp_embedding() const;
  void clear_vit_serp_embedding();
  static const int kVitSerpEmbeddingFieldNumber = 14;
  const ::qembedder::pb::Embedding& vit_serp_embedding() const;
  ::qembedder::pb::Embedding* mutable_vit_serp_embedding();
  ::qembedder::pb::Embedding* release_vit_serp_embedding();
  void set_allocated_vit_serp_embedding(::qembedder::pb::Embedding* vit_serp_embedding);

  // optional .qembedder.pb.Embedding img_match_embedding = 16;
  bool has_img_match_embedding() const;
  void clear_img_match_embedding();
  static const int kImgMatchEmbeddingFieldNumber = 16;
  const ::qembedder::pb::Embedding& img_match_embedding() const;
  ::qembedder::pb::Embedding* mutable_img_match_embedding();
  ::qembedder::pb::Embedding* release_img_match_embedding();
  void set_allocated_img_match_embedding(::qembedder::pb::Embedding* img_match_embedding);

  // optional uint32 broken = 5;
  bool has_broken() const;
  void clear_broken();
  static const int kBrokenFieldNumber = 5;
  ::google::protobuf::uint32 broken() const;
  void set_broken(::google::protobuf::uint32 value);

  // optional uint32 preview_db = 7;
  bool has_preview_db() const;
  void clear_preview_db();
  static const int kPreviewDbFieldNumber = 7;
  ::google::protobuf::uint32 preview_db() const;
  void set_preview_db(::google::protobuf::uint32 value);

  // optional float aws_probability = 15;
  bool has_aws_probability() const;
  void clear_aws_probability();
  static const int kAwsProbabilityFieldNumber = 15;
  float aws_probability() const;
  void set_aws_probability(float value);

  // optional bool required_for_assessor = 13;
  bool has_required_for_assessor() const;
  void clear_required_for_assessor();
  static const int kRequiredForAssessorFieldNumber = 13;
  bool required_for_assessor() const;
  void set_required_for_assessor(bool value);

  // optional bool previous = 17;
  bool has_previous() const;
  void clear_previous();
  static const int kPreviousFieldNumber = 17;
  bool previous() const;
  void set_previous(bool value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageStruct)
 private:
  void set_has_keyurl();
  void clear_has_keyurl();
  void set_has_fullurl();
  void clear_has_fullurl();
  void set_has_thumb();
  void clear_has_thumb();
  void set_has_props();
  void clear_has_props();
  void set_has_broken();
  void clear_has_broken();
  void set_has_imageextratexts();
  void clear_has_imageextratexts();
  void set_has_preview_db();
  void clear_has_preview_db();
  void set_has_video_thumb();
  void clear_has_video_thumb();
  void set_has_ygvisitinfo();
  void clear_has_ygvisitinfo();
  void set_has_additional_props();
  void clear_has_additional_props();
  void set_has_cnn_embedding();
  void clear_has_cnn_embedding();
  void set_has_cnn_serp_embedding();
  void clear_has_cnn_serp_embedding();
  void set_has_vit_serp_embedding();
  void clear_has_vit_serp_embedding();
  void set_has_required_for_assessor();
  void clear_has_required_for_assessor();
  void set_has_aws_probability();
  void clear_has_aws_probability();
  void set_has_img_match_embedding();
  void clear_has_img_match_embedding();
  void set_has_previous();
  void clear_has_previous();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr keyurl_;
  ::google::protobuf::internal::ArenaStringPtr fullurl_;
  ::ru::mail::go::webbase::parsing::img::Thumb* thumb_;
  ::ru::mail::go::webbase::blobs::ImageProps* props_;
  ::ru::mail::go::webbase::blobs::ExtraTextArray* imageextratexts_;
  ::ru::mail::go::webbase::parsing::img::VideoClip* video_thumb_;
  ::ru::mail::go::webbase::blobs::VisitInfo* ygvisitinfo_;
  ::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps* additional_props_;
  ::qembedder::pb::Embedding* cnn_embedding_;
  ::qembedder::pb::Embedding* cnn_serp_embedding_;
  ::qembedder::pb::Embedding* vit_serp_embedding_;
  ::qembedder::pb::Embedding* img_match_embedding_;
  ::google::protobuf::uint32 broken_;
  ::google::protobuf::uint32 preview_db_;
  float aws_probability_;
  bool required_for_assessor_;
  bool previous_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PageStruct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.PageStruct) */ {
 public:
  PageStruct();
  virtual ~PageStruct();

  PageStruct(const PageStruct& from);

  inline PageStruct& operator=(const PageStruct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PageStruct(PageStruct&& from) noexcept
    : PageStruct() {
    *this = ::std::move(from);
  }

  inline PageStruct& operator=(PageStruct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PageStruct& default_instance();

  static inline const PageStruct* internal_default_instance() {
    return reinterpret_cast<const PageStruct*>(
               &_PageStruct_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(PageStruct* other);
  friend void swap(PageStruct& a, PageStruct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PageStruct* New() const PROTOBUF_FINAL { return New(NULL); }

  PageStruct* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PageStruct& from);
  void MergeFrom(const PageStruct& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PageStruct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .gogo.storage.extra_info page_extra_info = 6;
  int page_extra_info_size() const;
  void clear_page_extra_info();
  static const int kPageExtraInfoFieldNumber = 6;
  const ::gogo::storage::extra_info& page_extra_info(int index) const;
  ::gogo::storage::extra_info* mutable_page_extra_info(int index);
  ::gogo::storage::extra_info* add_page_extra_info();
  ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >*
      mutable_page_extra_info();
  const ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >&
      page_extra_info() const;

  // required string keyUrl = 1;
  bool has_keyurl() const;
  void clear_keyurl();
  static const int kKeyUrlFieldNumber = 1;
  const ::std::string& keyurl() const;
  void set_keyurl(const ::std::string& value);
  #if LANG_CXX11
  void set_keyurl(::std::string&& value);
  #endif
  void set_keyurl(const char* value);
  void set_keyurl(const char* value, size_t size);
  ::std::string* mutable_keyurl();
  ::std::string* release_keyurl();
  void set_allocated_keyurl(::std::string* keyurl);

  // required string fullUrl = 2;
  bool has_fullurl() const;
  void clear_fullurl();
  static const int kFullUrlFieldNumber = 2;
  const ::std::string& fullurl() const;
  void set_fullurl(const ::std::string& value);
  #if LANG_CXX11
  void set_fullurl(::std::string&& value);
  #endif
  void set_fullurl(const char* value);
  void set_fullurl(const char* value, size_t size);
  ::std::string* mutable_fullurl();
  ::std::string* release_fullurl();
  void set_allocated_fullurl(::std::string* fullurl);

  // required .ru.mail.go.webbase.blobs.HtmlPage page = 3;
  bool has_page() const;
  void clear_page();
  static const int kPageFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::HtmlPage& page() const;
  ::ru::mail::go::webbase::blobs::HtmlPage* mutable_page();
  ::ru::mail::go::webbase::blobs::HtmlPage* release_page();
  void set_allocated_page(::ru::mail::go::webbase::blobs::HtmlPage* page);

  // optional .ru.mail.go.webbase.blobs.ExtraTextArray extraTexts = 4;
  bool has_extratexts() const;
  void clear_extratexts();
  static const int kExtraTextsFieldNumber = 4;
  const ::ru::mail::go::webbase::blobs::ExtraTextArray& extratexts() const;
  ::ru::mail::go::webbase::blobs::ExtraTextArray* mutable_extratexts();
  ::ru::mail::go::webbase::blobs::ExtraTextArray* release_extratexts();
  void set_allocated_extratexts(::ru::mail::go::webbase::blobs::ExtraTextArray* extratexts);

  // optional .ru.mail.go.webbase.blobs.ExtraTextArray imageExtraTexts = 5;
  bool has_imageextratexts() const;
  void clear_imageextratexts();
  static const int kImageExtraTextsFieldNumber = 5;
  const ::ru::mail::go::webbase::blobs::ExtraTextArray& imageextratexts() const;
  ::ru::mail::go::webbase::blobs::ExtraTextArray* mutable_imageextratexts();
  ::ru::mail::go::webbase::blobs::ExtraTextArray* release_imageextratexts();
  void set_allocated_imageextratexts(::ru::mail::go::webbase::blobs::ExtraTextArray* imageextratexts);

  // optional uint32 spam = 7;
  bool has_spam() const;
  void clear_spam();
  static const int kSpamFieldNumber = 7;
  ::google::protobuf::uint32 spam() const;
  void set_spam(::google::protobuf::uint32 value);

  // required float limiterRank = 8;
  bool has_limiterrank() const;
  void clear_limiterrank();
  static const int kLimiterRankFieldNumber = 8;
  float limiterrank() const;
  void set_limiterrank(float value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.PageStruct)
 private:
  void set_has_keyurl();
  void clear_has_keyurl();
  void set_has_fullurl();
  void clear_has_fullurl();
  void set_has_page();
  void clear_has_page();
  void set_has_extratexts();
  void clear_has_extratexts();
  void set_has_imageextratexts();
  void clear_has_imageextratexts();
  void set_has_spam();
  void clear_has_spam();
  void set_has_limiterrank();
  void clear_has_limiterrank();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info > page_extra_info_;
  ::google::protobuf::internal::ArenaStringPtr keyurl_;
  ::google::protobuf::internal::ArenaStringPtr fullurl_;
  ::ru::mail::go::webbase::blobs::HtmlPage* page_;
  ::ru::mail::go::webbase::blobs::ExtraTextArray* extratexts_;
  ::ru::mail::go::webbase::blobs::ExtraTextArray* imageextratexts_;
  ::google::protobuf::uint32 spam_;
  float limiterrank_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryStruct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.QueryStruct) */ {
 public:
  QueryStruct();
  virtual ~QueryStruct();

  QueryStruct(const QueryStruct& from);

  inline QueryStruct& operator=(const QueryStruct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryStruct(QueryStruct&& from) noexcept
    : QueryStruct() {
    *this = ::std::move(from);
  }

  inline QueryStruct& operator=(QueryStruct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryStruct& default_instance();

  static inline const QueryStruct* internal_default_instance() {
    return reinterpret_cast<const QueryStruct*>(
               &_QueryStruct_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(QueryStruct* other);
  friend void swap(QueryStruct& a, QueryStruct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryStruct* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryStruct* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryStruct& from);
  void MergeFrom(const QueryStruct& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryStruct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string query = 1;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 1;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // required string keyUrl = 2;
  bool has_keyurl() const;
  void clear_keyurl();
  static const int kKeyUrlFieldNumber = 2;
  const ::std::string& keyurl() const;
  void set_keyurl(const ::std::string& value);
  #if LANG_CXX11
  void set_keyurl(::std::string&& value);
  #endif
  void set_keyurl(const char* value);
  void set_keyurl(const char* value, size_t size);
  ::std::string* mutable_keyurl();
  ::std::string* release_keyurl();
  void set_allocated_keyurl(::std::string* keyurl);

  // required double ctr = 3;
  bool has_ctr() const;
  void clear_ctr();
  static const int kCtrFieldNumber = 3;
  double ctr() const;
  void set_ctr(double value);

  // required uint32 imps = 4;
  bool has_imps() const;
  void clear_imps();
  static const int kImpsFieldNumber = 4;
  ::google::protobuf::uint32 imps() const;
  void set_imps(::google::protobuf::uint32 value);

  // required uint32 gyimps = 5;
  bool has_gyimps() const;
  void clear_gyimps();
  static const int kGyimpsFieldNumber = 5;
  ::google::protobuf::uint32 gyimps() const;
  void set_gyimps(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.QueryStruct)
 private:
  void set_has_query();
  void clear_has_query();
  void set_has_keyurl();
  void clear_has_keyurl();
  void set_has_ctr();
  void clear_has_ctr();
  void set_has_imps();
  void clear_has_imps();
  void set_has_gyimps();
  void clear_has_gyimps();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr query_;
  ::google::protobuf::internal::ArenaStringPtr keyurl_;
  double ctr_;
  ::google::protobuf::uint32 imps_;
  ::google::protobuf::uint32 gyimps_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FullPage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.FullPage) */ {
 public:
  FullPage();
  virtual ~FullPage();

  FullPage(const FullPage& from);

  inline FullPage& operator=(const FullPage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FullPage(FullPage&& from) noexcept
    : FullPage() {
    *this = ::std::move(from);
  }

  inline FullPage& operator=(FullPage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FullPage& default_instance();

  static inline const FullPage* internal_default_instance() {
    return reinterpret_cast<const FullPage*>(
               &_FullPage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(FullPage* other);
  friend void swap(FullPage& a, FullPage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FullPage* New() const PROTOBUF_FINAL { return New(NULL); }

  FullPage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FullPage& from);
  void MergeFrom(const FullPage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FullPage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.ImageStruct image = 3;
  int image_size() const;
  void clear_image();
  static const int kImageFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::ImageStruct& image(int index) const;
  ::ru::mail::go::webbase::blobs::ImageStruct* mutable_image(int index);
  ::ru::mail::go::webbase::blobs::ImageStruct* add_image();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageStruct >*
      mutable_image();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageStruct >&
      image() const;

  // required .ru.mail.go.webbase.blobs.PageStruct page = 2;
  bool has_page() const;
  void clear_page();
  static const int kPageFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::PageStruct& page() const;
  ::ru::mail::go::webbase::blobs::PageStruct* mutable_page();
  ::ru::mail::go::webbase::blobs::PageStruct* release_page();
  void set_allocated_page(::ru::mail::go::webbase::blobs::PageStruct* page);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.FullPage)
 private:
  void set_has_page();
  void clear_has_page();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageStruct > image_;
  ::ru::mail::go::webbase::blobs::PageStruct* page_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LimitingInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.LimitingInfo) */ {
 public:
  LimitingInfo();
  virtual ~LimitingInfo();

  LimitingInfo(const LimitingInfo& from);

  inline LimitingInfo& operator=(const LimitingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LimitingInfo(LimitingInfo&& from) noexcept
    : LimitingInfo() {
    *this = ::std::move(from);
  }

  inline LimitingInfo& operator=(LimitingInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LimitingInfo& default_instance();

  static inline const LimitingInfo* internal_default_instance() {
    return reinterpret_cast<const LimitingInfo*>(
               &_LimitingInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(LimitingInfo* other);
  friend void swap(LimitingInfo& a, LimitingInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LimitingInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LimitingInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LimitingInfo& from);
  void MergeFrom(const LimitingInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LimitingInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string imageKeyUrl = 1;
  bool has_imagekeyurl() const;
  void clear_imagekeyurl();
  static const int kImageKeyUrlFieldNumber = 1;
  const ::std::string& imagekeyurl() const;
  void set_imagekeyurl(const ::std::string& value);
  #if LANG_CXX11
  void set_imagekeyurl(::std::string&& value);
  #endif
  void set_imagekeyurl(const char* value);
  void set_imagekeyurl(const char* value, size_t size);
  ::std::string* mutable_imagekeyurl();
  ::std::string* release_imagekeyurl();
  void set_allocated_imagekeyurl(::std::string* imagekeyurl);

  // required string pageUrl = 2;
  bool has_pageurl() const;
  void clear_pageurl();
  static const int kPageUrlFieldNumber = 2;
  const ::std::string& pageurl() const;
  void set_pageurl(const ::std::string& value);
  #if LANG_CXX11
  void set_pageurl(::std::string&& value);
  #endif
  void set_pageurl(const char* value);
  void set_pageurl(const char* value, size_t size);
  ::std::string* mutable_pageurl();
  ::std::string* release_pageurl();
  void set_allocated_pageurl(::std::string* pageurl);

  // required float limiterRank = 3;
  bool has_limiterrank() const;
  void clear_limiterrank();
  static const int kLimiterRankFieldNumber = 3;
  float limiterrank() const;
  void set_limiterrank(float value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.LimitingInfo)
 private:
  void set_has_imagekeyurl();
  void clear_has_imagekeyurl();
  void set_has_pageurl();
  void clear_has_pageurl();
  void set_has_limiterrank();
  void clear_has_limiterrank();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr imagekeyurl_;
  ::google::protobuf::internal::ArenaStringPtr pageurl_;
  float limiterrank_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BoundImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.BoundImage) */ {
 public:
  BoundImage();
  virtual ~BoundImage();

  BoundImage(const BoundImage& from);

  inline BoundImage& operator=(const BoundImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoundImage(BoundImage&& from) noexcept
    : BoundImage() {
    *this = ::std::move(from);
  }

  inline BoundImage& operator=(BoundImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundImage& default_instance();

  static inline const BoundImage* internal_default_instance() {
    return reinterpret_cast<const BoundImage*>(
               &_BoundImage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(BoundImage* other);
  friend void swap(BoundImage& a, BoundImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoundImage* New() const PROTOBUF_FINAL { return New(NULL); }

  BoundImage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BoundImage& from);
  void MergeFrom(const BoundImage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BoundImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.TextBlock block = 6;
  int block_size() const;
  void clear_block();
  static const int kBlockFieldNumber = 6;
  const ::ru::mail::go::webbase::blobs::TextBlock& block(int index) const;
  ::ru::mail::go::webbase::blobs::TextBlock* mutable_block(int index);
  ::ru::mail::go::webbase::blobs::TextBlock* add_block();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TextBlock >*
      mutable_block();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TextBlock >&
      block() const;

  // repeated .ru.mail.go.webbase.blobs.QueryStruct query = 8;
  int query_size() const;
  void clear_query();
  static const int kQueryFieldNumber = 8;
  const ::ru::mail::go::webbase::blobs::QueryStruct& query(int index) const;
  ::ru::mail::go::webbase::blobs::QueryStruct* mutable_query(int index);
  ::ru::mail::go::webbase::blobs::QueryStruct* add_query();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::QueryStruct >*
      mutable_query();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::QueryStruct >&
      query() const;

  // repeated .gogo.storage.extra_info page_extra_info = 21;
  int page_extra_info_size() const;
  void clear_page_extra_info();
  static const int kPageExtraInfoFieldNumber = 21;
  const ::gogo::storage::extra_info& page_extra_info(int index) const;
  ::gogo::storage::extra_info* mutable_page_extra_info(int index);
  ::gogo::storage::extra_info* add_page_extra_info();
  ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >*
      mutable_page_extra_info();
  const ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >&
      page_extra_info() const;

  // repeated uint32 pornStat = 24;
  int pornstat_size() const;
  void clear_pornstat();
  static const int kPornStatFieldNumber = 24;
  ::google::protobuf::uint32 pornstat(int index) const;
  void set_pornstat(int index, ::google::protobuf::uint32 value);
  void add_pornstat(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      pornstat() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_pornstat();

  // required string pageKeyUrl = 4;
  bool has_pagekeyurl() const;
  void clear_pagekeyurl();
  static const int kPageKeyUrlFieldNumber = 4;
  const ::std::string& pagekeyurl() const;
  void set_pagekeyurl(const ::std::string& value);
  #if LANG_CXX11
  void set_pagekeyurl(::std::string&& value);
  #endif
  void set_pagekeyurl(const char* value);
  void set_pagekeyurl(const char* value, size_t size);
  ::std::string* mutable_pagekeyurl();
  ::std::string* release_pagekeyurl();
  void set_allocated_pagekeyurl(::std::string* pagekeyurl);

  // required string pageFullUrl = 5;
  bool has_pagefullurl() const;
  void clear_pagefullurl();
  static const int kPageFullUrlFieldNumber = 5;
  const ::std::string& pagefullurl() const;
  void set_pagefullurl(const ::std::string& value);
  #if LANG_CXX11
  void set_pagefullurl(::std::string&& value);
  #endif
  void set_pagefullurl(const char* value);
  void set_pagefullurl(const char* value, size_t size);
  ::std::string* mutable_pagefullurl();
  ::std::string* release_pagefullurl();
  void set_allocated_pagefullurl(::std::string* pagefullurl);

  // required .ru.mail.go.webbase.blobs.ImageStruct image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::ImageStruct& image() const;
  ::ru::mail::go::webbase::blobs::ImageStruct* mutable_image();
  ::ru::mail::go::webbase::blobs::ImageStruct* release_image();
  void set_allocated_image(::ru::mail::go::webbase::blobs::ImageStruct* image);

  // optional .ru.mail.go.webbase.blobs.DomainStruct pageDomain = 3;
  bool has_pagedomain() const;
  void clear_pagedomain();
  static const int kPageDomainFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::DomainStruct& pagedomain() const;
  ::ru::mail::go::webbase::blobs::DomainStruct* mutable_pagedomain();
  ::ru::mail::go::webbase::blobs::DomainStruct* release_pagedomain();
  void set_allocated_pagedomain(::ru::mail::go::webbase::blobs::DomainStruct* pagedomain);

  // optional .ru.mail.go.webbase.blobs.ExtraTextArray extraTexts = 7;
  bool has_extratexts() const;
  void clear_extratexts();
  static const int kExtraTextsFieldNumber = 7;
  const ::ru::mail::go::webbase::blobs::ExtraTextArray& extratexts() const;
  ::ru::mail::go::webbase::blobs::ExtraTextArray* mutable_extratexts();
  ::ru::mail::go::webbase::blobs::ExtraTextArray* release_extratexts();
  void set_allocated_extratexts(::ru::mail::go::webbase::blobs::ExtraTextArray* extratexts);

  // optional .ru.mail.go.webbase.blobs.FeatureList featuresList = 17;
  bool has_featureslist() const;
  void clear_featureslist();
  static const int kFeaturesListFieldNumber = 17;
  const ::ru::mail::go::webbase::blobs::FeatureList& featureslist() const;
  ::ru::mail::go::webbase::blobs::FeatureList* mutable_featureslist();
  ::ru::mail::go::webbase::blobs::FeatureList* release_featureslist();
  void set_allocated_featureslist(::ru::mail::go::webbase::blobs::FeatureList* featureslist);

  // optional .ru.mail.go.webbase.blobs.ClusteringResult clusteringResult = 18;
  bool has_clusteringresult() const;
  void clear_clusteringresult();
  static const int kClusteringResultFieldNumber = 18;
  const ::ru::mail::go::webbase::blobs::ClusteringResult& clusteringresult() const;
  ::ru::mail::go::webbase::blobs::ClusteringResult* mutable_clusteringresult();
  ::ru::mail::go::webbase::blobs::ClusteringResult* release_clusteringresult();
  void set_allocated_clusteringresult(::ru::mail::go::webbase::blobs::ClusteringResult* clusteringresult);

  // required uint32 imagesMedium = 10;
  bool has_imagesmedium() const;
  void clear_imagesmedium();
  static const int kImagesMediumFieldNumber = 10;
  ::google::protobuf::uint32 imagesmedium() const;
  void set_imagesmedium(::google::protobuf::uint32 value);

  // required uint32 imagesLarge = 11;
  bool has_imageslarge() const;
  void clear_imageslarge();
  static const int kImagesLargeFieldNumber = 11;
  ::google::protobuf::uint32 imageslarge() const;
  void set_imageslarge(::google::protobuf::uint32 value);

  // optional uint32 imagesDups = 12;
  bool has_imagesdups() const;
  void clear_imagesdups();
  static const int kImagesDupsFieldNumber = 12;
  ::google::protobuf::uint32 imagesdups() const;
  void set_imagesdups(::google::protobuf::uint32 value);

  // required uint32 porn = 13;
  bool has_porn() const;
  void clear_porn();
  static const int kPornFieldNumber = 13;
  ::google::protobuf::uint32 porn() const;
  void set_porn(::google::protobuf::uint32 value);

  // optional uint32 preview_db = 14;
  bool has_preview_db() const;
  void clear_preview_db();
  static const int kPreviewDbFieldNumber = 14;
  ::google::protobuf::uint32 preview_db() const;
  void set_preview_db(::google::protobuf::uint32 value);

  // optional uint32 time = 15 [default = 0];
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 15;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // optional uint32 maxPorn = 16;
  bool has_maxporn() const;
  void clear_maxporn();
  static const int kMaxPornFieldNumber = 16;
  ::google::protobuf::uint32 maxporn() const;
  void set_maxporn(::google::protobuf::uint32 value);

  // optional uint32 imageCopies = 22;
  bool has_imagecopies() const;
  void clear_imagecopies();
  static const int kImageCopiesFieldNumber = 22;
  ::google::protobuf::uint32 imagecopies() const;
  void set_imagecopies(::google::protobuf::uint32 value);

  // optional uint32 numPages = 23;
  bool has_numpages() const;
  void clear_numpages();
  static const int kNumPagesFieldNumber = 23;
  ::google::protobuf::uint32 numpages() const;
  void set_numpages(::google::protobuf::uint32 value);

  // optional uint32 spam = 25;
  bool has_spam() const;
  void clear_spam();
  static const int kSpamFieldNumber = 25;
  ::google::protobuf::uint32 spam() const;
  void set_spam(::google::protobuf::uint32 value);

  // optional float limiterRank = 29;
  bool has_limiterrank() const;
  void clear_limiterrank();
  static const int kLimiterRankFieldNumber = 29;
  float limiterrank() const;
  void set_limiterrank(float value);

  // optional uint64 cluster_id = 27;
  bool has_cluster_id() const;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 27;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // optional uint32 altlen = 26;
  bool has_altlen() const;
  void clear_altlen();
  static const int kAltlenFieldNumber = 26;
  ::google::protobuf::uint32 altlen() const;
  void set_altlen(::google::protobuf::uint32 value);

  // optional uint32 numTextBlocks = 28;
  bool has_numtextblocks() const;
  void clear_numtextblocks();
  static const int kNumTextBlocksFieldNumber = 28;
  ::google::protobuf::uint32 numtextblocks() const;
  void set_numtextblocks(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.BoundImage)
 private:
  void set_has_image();
  void clear_has_image();
  void set_has_pagedomain();
  void clear_has_pagedomain();
  void set_has_pagekeyurl();
  void clear_has_pagekeyurl();
  void set_has_pagefullurl();
  void clear_has_pagefullurl();
  void set_has_extratexts();
  void clear_has_extratexts();
  void set_has_imagesmedium();
  void clear_has_imagesmedium();
  void set_has_imageslarge();
  void clear_has_imageslarge();
  void set_has_imagesdups();
  void clear_has_imagesdups();
  void set_has_porn();
  void clear_has_porn();
  void set_has_preview_db();
  void clear_has_preview_db();
  void set_has_time();
  void clear_has_time();
  void set_has_maxporn();
  void clear_has_maxporn();
  void set_has_featureslist();
  void clear_has_featureslist();
  void set_has_clusteringresult();
  void clear_has_clusteringresult();
  void set_has_imagecopies();
  void clear_has_imagecopies();
  void set_has_numpages();
  void clear_has_numpages();
  void set_has_spam();
  void clear_has_spam();
  void set_has_altlen();
  void clear_has_altlen();
  void set_has_cluster_id();
  void clear_has_cluster_id();
  void set_has_numtextblocks();
  void clear_has_numtextblocks();
  void set_has_limiterrank();
  void clear_has_limiterrank();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TextBlock > block_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::QueryStruct > query_;
  ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info > page_extra_info_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > pornstat_;
  ::google::protobuf::internal::ArenaStringPtr pagekeyurl_;
  ::google::protobuf::internal::ArenaStringPtr pagefullurl_;
  ::ru::mail::go::webbase::blobs::ImageStruct* image_;
  ::ru::mail::go::webbase::blobs::DomainStruct* pagedomain_;
  ::ru::mail::go::webbase::blobs::ExtraTextArray* extratexts_;
  ::ru::mail::go::webbase::blobs::FeatureList* featureslist_;
  ::ru::mail::go::webbase::blobs::ClusteringResult* clusteringresult_;
  ::google::protobuf::uint32 imagesmedium_;
  ::google::protobuf::uint32 imageslarge_;
  ::google::protobuf::uint32 imagesdups_;
  ::google::protobuf::uint32 porn_;
  ::google::protobuf::uint32 preview_db_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 maxporn_;
  ::google::protobuf::uint32 imagecopies_;
  ::google::protobuf::uint32 numpages_;
  ::google::protobuf::uint32 spam_;
  float limiterrank_;
  ::google::protobuf::uint64 cluster_id_;
  ::google::protobuf::uint32 altlen_;
  ::google::protobuf::uint32 numtextblocks_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TextBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.TextBlock) */ {
 public:
  TextBlock();
  virtual ~TextBlock();

  TextBlock(const TextBlock& from);

  inline TextBlock& operator=(const TextBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextBlock(TextBlock&& from) noexcept
    : TextBlock() {
    *this = ::std::move(from);
  }

  inline TextBlock& operator=(TextBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextBlock& default_instance();

  static inline const TextBlock* internal_default_instance() {
    return reinterpret_cast<const TextBlock*>(
               &_TextBlock_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(TextBlock* other);
  friend void swap(TextBlock& a, TextBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  TextBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TextBlock& from);
  void MergeFrom(const TextBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TextBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.Tag tags = 4;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 4;
  ::ru::mail::go::webbase::blobs::Tag tags(int index) const;
  void set_tags(int index, ::ru::mail::go::webbase::blobs::Tag value);
  void add_tags(::ru::mail::go::webbase::blobs::Tag value);
  const ::google::protobuf::RepeatedField<int>& tags() const;
  ::google::protobuf::RepeatedField<int>* mutable_tags();

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional uint32 dist = 3;
  bool has_dist() const;
  void clear_dist();
  static const int kDistFieldNumber = 3;
  ::google::protobuf::uint32 dist() const;
  void set_dist(::google::protobuf::uint32 value);

  // required .ru.mail.go.webbase.blobs.ZoneName zname = 2;
  bool has_zname() const;
  void clear_zname();
  static const int kZnameFieldNumber = 2;
  ::ru::mail::go::webbase::blobs::ZoneName zname() const;
  void set_zname(::ru::mail::go::webbase::blobs::ZoneName value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.TextBlock)
 private:
  void set_has_text();
  void clear_has_text();
  void set_has_zname();
  void clear_has_zname();
  void set_has_dist();
  void clear_has_dist();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> tags_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 dist_;
  int zname_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VisitInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.VisitInfo) */ {
 public:
  VisitInfo();
  virtual ~VisitInfo();

  VisitInfo(const VisitInfo& from);

  inline VisitInfo& operator=(const VisitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VisitInfo(VisitInfo&& from) noexcept
    : VisitInfo() {
    *this = ::std::move(from);
  }

  inline VisitInfo& operator=(VisitInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VisitInfo& default_instance();

  static inline const VisitInfo* internal_default_instance() {
    return reinterpret_cast<const VisitInfo*>(
               &_VisitInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(VisitInfo* other);
  friend void swap(VisitInfo& a, VisitInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VisitInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  VisitInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VisitInfo& from);
  void MergeFrom(const VisitInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VisitInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 lastYVisit = 1;
  bool has_lastyvisit() const;
  void clear_lastyvisit();
  static const int kLastYVisitFieldNumber = 1;
  ::google::protobuf::int64 lastyvisit() const;
  void set_lastyvisit(::google::protobuf::int64 value);

  // required int64 lastGVisit = 2;
  bool has_lastgvisit() const;
  void clear_lastgvisit();
  static const int kLastGVisitFieldNumber = 2;
  ::google::protobuf::int64 lastgvisit() const;
  void set_lastgvisit(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.VisitInfo)
 private:
  void set_has_lastyvisit();
  void clear_has_lastyvisit();
  void set_has_lastgvisit();
  void clear_has_lastgvisit();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 lastyvisit_;
  ::google::protobuf::int64 lastgvisit_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UrlPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.UrlPair) */ {
 public:
  UrlPair();
  virtual ~UrlPair();

  UrlPair(const UrlPair& from);

  inline UrlPair& operator=(const UrlPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UrlPair(UrlPair&& from) noexcept
    : UrlPair() {
    *this = ::std::move(from);
  }

  inline UrlPair& operator=(UrlPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UrlPair& default_instance();

  static inline const UrlPair* internal_default_instance() {
    return reinterpret_cast<const UrlPair*>(
               &_UrlPair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(UrlPair* other);
  friend void swap(UrlPair& a, UrlPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UrlPair* New() const PROTOBUF_FINAL { return New(NULL); }

  UrlPair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UrlPair& from);
  void MergeFrom(const UrlPair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UrlPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const char* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // required string page = 2;
  bool has_page() const;
  void clear_page();
  static const int kPageFieldNumber = 2;
  const ::std::string& page() const;
  void set_page(const ::std::string& value);
  #if LANG_CXX11
  void set_page(::std::string&& value);
  #endif
  void set_page(const char* value);
  void set_page(const char* value, size_t size);
  ::std::string* mutable_page();
  ::std::string* release_page();
  void set_allocated_page(::std::string* page);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.UrlPair)
 private:
  void set_has_image();
  void clear_has_image();
  void set_has_page();
  void clear_has_page();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::internal::ArenaStringPtr page_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Any : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.Any) */ {
 public:
  Any();
  virtual ~Any();

  Any(const Any& from);

  inline Any& operator=(const Any& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Any(Any&& from) noexcept
    : Any() {
    *this = ::std::move(from);
  }

  inline Any& operator=(Any&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Any& default_instance();

  static inline const Any* internal_default_instance() {
    return reinterpret_cast<const Any*>(
               &_Any_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(Any* other);
  friend void swap(Any& a, Any& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Any* New() const PROTOBUF_FINAL { return New(NULL); }

  Any* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Any& from);
  void MergeFrom(const Any& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Any* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.UrlPair duplicates = 11;
  int duplicates_size() const;
  void clear_duplicates();
  static const int kDuplicatesFieldNumber = 11;
  const ::ru::mail::go::webbase::blobs::UrlPair& duplicates(int index) const;
  ::ru::mail::go::webbase::blobs::UrlPair* mutable_duplicates(int index);
  ::ru::mail::go::webbase::blobs::UrlPair* add_duplicates();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::UrlPair >*
      mutable_duplicates();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::UrlPair >&
      duplicates() const;

  // optional string keyDomain = 4;
  bool has_keydomain() const;
  void clear_keydomain();
  static const int kKeyDomainFieldNumber = 4;
  const ::std::string& keydomain() const;
  void set_keydomain(const ::std::string& value);
  #if LANG_CXX11
  void set_keydomain(::std::string&& value);
  #endif
  void set_keydomain(const char* value);
  void set_keydomain(const char* value, size_t size);
  ::std::string* mutable_keydomain();
  ::std::string* release_keydomain();
  void set_allocated_keydomain(::std::string* keydomain);

  // optional string pageKeyUrl = 5;
  bool has_pagekeyurl() const;
  void clear_pagekeyurl();
  static const int kPageKeyUrlFieldNumber = 5;
  const ::std::string& pagekeyurl() const;
  void set_pagekeyurl(const ::std::string& value);
  #if LANG_CXX11
  void set_pagekeyurl(::std::string&& value);
  #endif
  void set_pagekeyurl(const char* value);
  void set_pagekeyurl(const char* value, size_t size);
  ::std::string* mutable_pagekeyurl();
  ::std::string* release_pagekeyurl();
  void set_allocated_pagekeyurl(::std::string* pagekeyurl);

  // optional .ru.mail.go.webbase.blobs.DomainStruct domain = 1;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::DomainStruct& domain() const;
  ::ru::mail::go::webbase::blobs::DomainStruct* mutable_domain();
  ::ru::mail::go::webbase::blobs::DomainStruct* release_domain();
  void set_allocated_domain(::ru::mail::go::webbase::blobs::DomainStruct* domain);

  // optional .ru.mail.go.webbase.blobs.ImageStruct image = 2;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::ImageStruct& image() const;
  ::ru::mail::go::webbase::blobs::ImageStruct* mutable_image();
  ::ru::mail::go::webbase::blobs::ImageStruct* release_image();
  void set_allocated_image(::ru::mail::go::webbase::blobs::ImageStruct* image);

  // optional .ru.mail.go.webbase.blobs.PageStruct page = 3;
  bool has_page() const;
  void clear_page();
  static const int kPageFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::PageStruct& page() const;
  ::ru::mail::go::webbase::blobs::PageStruct* mutable_page();
  ::ru::mail::go::webbase::blobs::PageStruct* release_page();
  void set_allocated_page(::ru::mail::go::webbase::blobs::PageStruct* page);

  // optional .ru.mail.go.webbase.blobs.FullPage fullPage = 6;
  bool has_fullpage() const;
  void clear_fullpage();
  static const int kFullPageFieldNumber = 6;
  const ::ru::mail::go::webbase::blobs::FullPage& fullpage() const;
  ::ru::mail::go::webbase::blobs::FullPage* mutable_fullpage();
  ::ru::mail::go::webbase::blobs::FullPage* release_fullpage();
  void set_allocated_fullpage(::ru::mail::go::webbase::blobs::FullPage* fullpage);

  // optional .ru.mail.go.webbase.blobs.BoundImage boundImage = 7;
  bool has_boundimage() const;
  void clear_boundimage();
  static const int kBoundImageFieldNumber = 7;
  const ::ru::mail::go::webbase::blobs::BoundImage& boundimage() const;
  ::ru::mail::go::webbase::blobs::BoundImage* mutable_boundimage();
  ::ru::mail::go::webbase::blobs::BoundImage* release_boundimage();
  void set_allocated_boundimage(::ru::mail::go::webbase::blobs::BoundImage* boundimage);

  // optional .ru.mail.go.webbase.blobs.LimitingInfo limitingInfo = 8;
  bool has_limitinginfo() const;
  void clear_limitinginfo();
  static const int kLimitingInfoFieldNumber = 8;
  const ::ru::mail::go::webbase::blobs::LimitingInfo& limitinginfo() const;
  ::ru::mail::go::webbase::blobs::LimitingInfo* mutable_limitinginfo();
  ::ru::mail::go::webbase::blobs::LimitingInfo* release_limitinginfo();
  void set_allocated_limitinginfo(::ru::mail::go::webbase::blobs::LimitingInfo* limitinginfo);

  // optional .ru.mail.go.webbase.sekitei.Sekitei_m sekitei = 10;
  bool has_sekitei() const;
  void clear_sekitei();
  static const int kSekiteiFieldNumber = 10;
  const ::ru::mail::go::webbase::sekitei::Sekitei_m& sekitei() const;
  ::ru::mail::go::webbase::sekitei::Sekitei_m* mutable_sekitei();
  ::ru::mail::go::webbase::sekitei::Sekitei_m* release_sekitei();
  void set_allocated_sekitei(::ru::mail::go::webbase::sekitei::Sekitei_m* sekitei);

  // optional uint64 cluster_id = 9;
  bool has_cluster_id() const;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 9;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.Any)
 private:
  void set_has_domain();
  void clear_has_domain();
  void set_has_image();
  void clear_has_image();
  void set_has_page();
  void clear_has_page();
  void set_has_keydomain();
  void clear_has_keydomain();
  void set_has_pagekeyurl();
  void clear_has_pagekeyurl();
  void set_has_fullpage();
  void clear_has_fullpage();
  void set_has_boundimage();
  void clear_has_boundimage();
  void set_has_limitinginfo();
  void clear_has_limitinginfo();
  void set_has_cluster_id();
  void clear_has_cluster_id();
  void set_has_sekitei();
  void clear_has_sekitei();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::UrlPair > duplicates_;
  ::google::protobuf::internal::ArenaStringPtr keydomain_;
  ::google::protobuf::internal::ArenaStringPtr pagekeyurl_;
  ::ru::mail::go::webbase::blobs::DomainStruct* domain_;
  ::ru::mail::go::webbase::blobs::ImageStruct* image_;
  ::ru::mail::go::webbase::blobs::PageStruct* page_;
  ::ru::mail::go::webbase::blobs::FullPage* fullpage_;
  ::ru::mail::go::webbase::blobs::BoundImage* boundimage_;
  ::ru::mail::go::webbase::blobs::LimitingInfo* limitinginfo_;
  ::ru::mail::go::webbase::sekitei::Sekitei_m* sekitei_;
  ::google::protobuf::uint64 cluster_id_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageMarkerUrlTrace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace) */ {
 public:
  ImageMarkerUrlTrace();
  virtual ~ImageMarkerUrlTrace();

  ImageMarkerUrlTrace(const ImageMarkerUrlTrace& from);

  inline ImageMarkerUrlTrace& operator=(const ImageMarkerUrlTrace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageMarkerUrlTrace(ImageMarkerUrlTrace&& from) noexcept
    : ImageMarkerUrlTrace() {
    *this = ::std::move(from);
  }

  inline ImageMarkerUrlTrace& operator=(ImageMarkerUrlTrace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageMarkerUrlTrace& default_instance();

  static inline const ImageMarkerUrlTrace* internal_default_instance() {
    return reinterpret_cast<const ImageMarkerUrlTrace*>(
               &_ImageMarkerUrlTrace_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(ImageMarkerUrlTrace* other);
  friend void swap(ImageMarkerUrlTrace& a, ImageMarkerUrlTrace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageMarkerUrlTrace* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageMarkerUrlTrace* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageMarkerUrlTrace& from);
  void MergeFrom(const ImageMarkerUrlTrace& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageMarkerUrlTrace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ImageMarkerUrlTrace_StageInfo StageInfo;
  static const StageInfo PassedImageDump =
    ImageMarkerUrlTrace_StageInfo_PassedImageDump;
  static const StageInfo PassedHtmlJoin =
    ImageMarkerUrlTrace_StageInfo_PassedHtmlJoin;
  static const StageInfo NotPassedHtmlJoin =
    ImageMarkerUrlTrace_StageInfo_NotPassedHtmlJoin;
  static const StageInfo PassedMaxHtmlJoin =
    ImageMarkerUrlTrace_StageInfo_PassedMaxHtmlJoin;
  static const StageInfo NotPassedMaxPageLimit =
    ImageMarkerUrlTrace_StageInfo_NotPassedMaxPageLimit;
  static const StageInfo PassedMaxPageLimit =
    ImageMarkerUrlTrace_StageInfo_PassedMaxPageLimit;
  static const StageInfo NotPassedManualSimhash =
    ImageMarkerUrlTrace_StageInfo_NotPassedManualSimhash;
  static const StageInfo PassedManualSimhash =
    ImageMarkerUrlTrace_StageInfo_PassedManualSimhash;
  static const StageInfo NotPassedCollectionClustering =
    ImageMarkerUrlTrace_StageInfo_NotPassedCollectionClustering;
  static const StageInfo PassedCollectionClustering =
    ImageMarkerUrlTrace_StageInfo_PassedCollectionClustering;
  static const StageInfo NotPassedSimhashDup =
    ImageMarkerUrlTrace_StageInfo_NotPassedSimhashDup;
  static const StageInfo PassedSimhashDup =
    ImageMarkerUrlTrace_StageInfo_PassedSimhashDup;
  static const StageInfo NotPassedSekiteiLimiter =
    ImageMarkerUrlTrace_StageInfo_NotPassedSekiteiLimiter;
  static const StageInfo PassedSekiteiLimiter =
    ImageMarkerUrlTrace_StageInfo_PassedSekiteiLimiter;
  static inline bool StageInfo_IsValid(int value) {
    return ImageMarkerUrlTrace_StageInfo_IsValid(value);
  }
  static const StageInfo StageInfo_MIN =
    ImageMarkerUrlTrace_StageInfo_StageInfo_MIN;
  static const StageInfo StageInfo_MAX =
    ImageMarkerUrlTrace_StageInfo_StageInfo_MAX;
  static const int StageInfo_ARRAYSIZE =
    ImageMarkerUrlTrace_StageInfo_StageInfo_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StageInfo_descriptor() {
    return ImageMarkerUrlTrace_StageInfo_descriptor();
  }
  static inline const ::std::string& StageInfo_Name(StageInfo value) {
    return ImageMarkerUrlTrace_StageInfo_Name(value);
  }
  static inline bool StageInfo_Parse(const ::std::string& name,
      StageInfo* value) {
    return ImageMarkerUrlTrace_StageInfo_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string mainDup = 3;
  bool has_maindup() const;
  void clear_maindup();
  static const int kMainDupFieldNumber = 3;
  const ::std::string& maindup() const;
  void set_maindup(const ::std::string& value);
  #if LANG_CXX11
  void set_maindup(::std::string&& value);
  #endif
  void set_maindup(const char* value);
  void set_maindup(const char* value, size_t size);
  ::std::string* mutable_maindup();
  ::std::string* release_maindup();
  void set_allocated_maindup(::std::string* maindup);

  // optional int64 limiterPos = 2;
  bool has_limiterpos() const;
  void clear_limiterpos();
  static const int kLimiterPosFieldNumber = 2;
  ::google::protobuf::int64 limiterpos() const;
  void set_limiterpos(::google::protobuf::int64 value);

  // required .ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.StageInfo stage = 1;
  bool has_stage() const;
  void clear_stage();
  static const int kStageFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::ImageMarkerUrlTrace_StageInfo stage() const;
  void set_stage(::ru::mail::go::webbase::blobs::ImageMarkerUrlTrace_StageInfo value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace)
 private:
  void set_has_stage();
  void clear_has_stage();
  void set_has_limiterpos();
  void clear_has_limiterpos();
  void set_has_maindup();
  void clear_has_maindup();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr maindup_;
  ::google::protobuf::int64 limiterpos_;
  int stage_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageTexts_PageTexts : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageTexts.PageTexts) */ {
 public:
  ImageTexts_PageTexts();
  virtual ~ImageTexts_PageTexts();

  ImageTexts_PageTexts(const ImageTexts_PageTexts& from);

  inline ImageTexts_PageTexts& operator=(const ImageTexts_PageTexts& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageTexts_PageTexts(ImageTexts_PageTexts&& from) noexcept
    : ImageTexts_PageTexts() {
    *this = ::std::move(from);
  }

  inline ImageTexts_PageTexts& operator=(ImageTexts_PageTexts&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageTexts_PageTexts& default_instance();

  static inline const ImageTexts_PageTexts* internal_default_instance() {
    return reinterpret_cast<const ImageTexts_PageTexts*>(
               &_ImageTexts_PageTexts_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(ImageTexts_PageTexts* other);
  friend void swap(ImageTexts_PageTexts& a, ImageTexts_PageTexts& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageTexts_PageTexts* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageTexts_PageTexts* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageTexts_PageTexts& from);
  void MergeFrom(const ImageTexts_PageTexts& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageTexts_PageTexts* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.TextBlock text = 1;
  int text_size() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::TextBlock& text(int index) const;
  ::ru::mail::go::webbase::blobs::TextBlock* mutable_text(int index);
  ::ru::mail::go::webbase::blobs::TextBlock* add_text();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TextBlock >*
      mutable_text();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TextBlock >&
      text() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageTexts.PageTexts)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TextBlock > text_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageTexts : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageTexts) */ {
 public:
  ImageTexts();
  virtual ~ImageTexts();

  ImageTexts(const ImageTexts& from);

  inline ImageTexts& operator=(const ImageTexts& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageTexts(ImageTexts&& from) noexcept
    : ImageTexts() {
    *this = ::std::move(from);
  }

  inline ImageTexts& operator=(ImageTexts&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageTexts& default_instance();

  static inline const ImageTexts* internal_default_instance() {
    return reinterpret_cast<const ImageTexts*>(
               &_ImageTexts_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(ImageTexts* other);
  friend void swap(ImageTexts& a, ImageTexts& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageTexts* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageTexts* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageTexts& from);
  void MergeFrom(const ImageTexts& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageTexts* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ImageTexts_PageTexts PageTexts;

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.ImageTexts.PageTexts texts = 1;
  int texts_size() const;
  void clear_texts();
  static const int kTextsFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::ImageTexts_PageTexts& texts(int index) const;
  ::ru::mail::go::webbase::blobs::ImageTexts_PageTexts* mutable_texts(int index);
  ::ru::mail::go::webbase::blobs::ImageTexts_PageTexts* add_texts();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageTexts_PageTexts >*
      mutable_texts();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageTexts_PageTexts >&
      texts() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageTexts)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageTexts_PageTexts > texts_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClusteringResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ClusteringResult) */ {
 public:
  ClusteringResult();
  virtual ~ClusteringResult();

  ClusteringResult(const ClusteringResult& from);

  inline ClusteringResult& operator=(const ClusteringResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClusteringResult(ClusteringResult&& from) noexcept
    : ClusteringResult() {
    *this = ::std::move(from);
  }

  inline ClusteringResult& operator=(ClusteringResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusteringResult& default_instance();

  static inline const ClusteringResult* internal_default_instance() {
    return reinterpret_cast<const ClusteringResult*>(
               &_ClusteringResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(ClusteringResult* other);
  friend void swap(ClusteringResult& a, ClusteringResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClusteringResult* New() const PROTOBUF_FINAL { return New(NULL); }

  ClusteringResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClusteringResult& from);
  void MergeFrom(const ClusteringResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClusteringResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float pagesWeights = 1;
  int pagesweights_size() const;
  void clear_pagesweights();
  static const int kPagesWeightsFieldNumber = 1;
  float pagesweights(int index) const;
  void set_pagesweights(int index, float value);
  void add_pagesweights(float value);
  const ::google::protobuf::RepeatedField< float >&
      pagesweights() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_pagesweights();

  // repeated string keywords = 2;
  int keywords_size() const;
  void clear_keywords();
  static const int kKeywordsFieldNumber = 2;
  const ::std::string& keywords(int index) const;
  ::std::string* mutable_keywords(int index);
  void set_keywords(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keywords(int index, ::std::string&& value);
  #endif
  void set_keywords(int index, const char* value);
  void set_keywords(int index, const char* value, size_t size);
  ::std::string* add_keywords();
  void add_keywords(const ::std::string& value);
  #if LANG_CXX11
  void add_keywords(::std::string&& value);
  #endif
  void add_keywords(const char* value);
  void add_keywords(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keywords() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keywords();

  // repeated float kWeights = 3;
  int kweights_size() const;
  void clear_kweights();
  static const int kKWeightsFieldNumber = 3;
  float kweights(int index) const;
  void set_kweights(int index, float value);
  void add_kweights(float value);
  const ::google::protobuf::RepeatedField< float >&
      kweights() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_kweights();

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ClusteringResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > pagesweights_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keywords_;
  ::google::protobuf::RepeatedField< float > kweights_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HostWithImgUrls : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.HostWithImgUrls) */ {
 public:
  HostWithImgUrls();
  virtual ~HostWithImgUrls();

  HostWithImgUrls(const HostWithImgUrls& from);

  inline HostWithImgUrls& operator=(const HostWithImgUrls& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HostWithImgUrls(HostWithImgUrls&& from) noexcept
    : HostWithImgUrls() {
    *this = ::std::move(from);
  }

  inline HostWithImgUrls& operator=(HostWithImgUrls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HostWithImgUrls& default_instance();

  static inline const HostWithImgUrls* internal_default_instance() {
    return reinterpret_cast<const HostWithImgUrls*>(
               &_HostWithImgUrls_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(HostWithImgUrls* other);
  friend void swap(HostWithImgUrls& a, HostWithImgUrls& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HostWithImgUrls* New() const PROTOBUF_FINAL { return New(NULL); }

  HostWithImgUrls* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HostWithImgUrls& from);
  void MergeFrom(const HostWithImgUrls& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HostWithImgUrls* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string url = 2;
  int url_size() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url(int index) const;
  ::std::string* mutable_url(int index);
  void set_url(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_url(int index, ::std::string&& value);
  #endif
  void set_url(int index, const char* value);
  void set_url(int index, const char* value, size_t size);
  ::std::string* add_url();
  void add_url(const ::std::string& value);
  #if LANG_CXX11
  void add_url(::std::string&& value);
  #endif
  void add_url(const char* value);
  void add_url(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& url() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_url();

  // optional string host = 1;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 1;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.HostWithImgUrls)
 private:
  void set_has_host();
  void clear_has_host();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> url_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThumbList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ThumbList) */ {
 public:
  ThumbList();
  virtual ~ThumbList();

  ThumbList(const ThumbList& from);

  inline ThumbList& operator=(const ThumbList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThumbList(ThumbList&& from) noexcept
    : ThumbList() {
    *this = ::std::move(from);
  }

  inline ThumbList& operator=(ThumbList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThumbList& default_instance();

  static inline const ThumbList* internal_default_instance() {
    return reinterpret_cast<const ThumbList*>(
               &_ThumbList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(ThumbList* other);
  friend void swap(ThumbList& a, ThumbList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThumbList* New() const PROTOBUF_FINAL { return New(NULL); }

  ThumbList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ThumbList& from);
  void MergeFrom(const ThumbList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ThumbList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.parsing.img.Thumb thumb = 1;
  int thumb_size() const;
  void clear_thumb();
  static const int kThumbFieldNumber = 1;
  const ::ru::mail::go::webbase::parsing::img::Thumb& thumb(int index) const;
  ::ru::mail::go::webbase::parsing::img::Thumb* mutable_thumb(int index);
  ::ru::mail::go::webbase::parsing::img::Thumb* add_thumb();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >*
      mutable_thumb();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >&
      thumb() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ThumbList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb > thumb_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThumbDoc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ThumbDoc) */ {
 public:
  ThumbDoc();
  virtual ~ThumbDoc();

  ThumbDoc(const ThumbDoc& from);

  inline ThumbDoc& operator=(const ThumbDoc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThumbDoc(ThumbDoc&& from) noexcept
    : ThumbDoc() {
    *this = ::std::move(from);
  }

  inline ThumbDoc& operator=(ThumbDoc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThumbDoc& default_instance();

  static inline const ThumbDoc* internal_default_instance() {
    return reinterpret_cast<const ThumbDoc*>(
               &_ThumbDoc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(ThumbDoc* other);
  friend void swap(ThumbDoc& a, ThumbDoc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThumbDoc* New() const PROTOBUF_FINAL { return New(NULL); }

  ThumbDoc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ThumbDoc& from);
  void MergeFrom(const ThumbDoc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ThumbDoc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required .ru.mail.go.webbase.blobs.ThumbList thumblist = 2;
  bool has_thumblist() const;
  void clear_thumblist();
  static const int kThumblistFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::ThumbList& thumblist() const;
  ::ru::mail::go::webbase::blobs::ThumbList* mutable_thumblist();
  ::ru::mail::go::webbase::blobs::ThumbList* release_thumblist();
  void set_allocated_thumblist(::ru::mail::go::webbase::blobs::ThumbList* thumblist);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ThumbDoc)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_thumblist();
  void clear_has_thumblist();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::ru::mail::go::webbase::blobs::ThumbList* thumblist_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RatioStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.RatioStats) */ {
 public:
  RatioStats();
  virtual ~RatioStats();

  RatioStats(const RatioStats& from);

  inline RatioStats& operator=(const RatioStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RatioStats(RatioStats&& from) noexcept
    : RatioStats() {
    *this = ::std::move(from);
  }

  inline RatioStats& operator=(RatioStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RatioStats& default_instance();

  static inline const RatioStats* internal_default_instance() {
    return reinterpret_cast<const RatioStats*>(
               &_RatioStats_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(RatioStats* other);
  friend void swap(RatioStats& a, RatioStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RatioStats* New() const PROTOBUF_FINAL { return New(NULL); }

  RatioStats* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RatioStats& from);
  void MergeFrom(const RatioStats& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RatioStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RatioStats_Kind Kind;
  static const Kind WEB_SHOW =
    RatioStats_Kind_WEB_SHOW;
  static const Kind IMG_SHOW =
    RatioStats_Kind_IMG_SHOW;
  static inline bool Kind_IsValid(int value) {
    return RatioStats_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    RatioStats_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    RatioStats_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    RatioStats_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return RatioStats_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return RatioStats_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return RatioStats_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string query = 1;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 1;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // required string mrcu = 4;
  bool has_mrcu() const;
  void clear_mrcu();
  static const int kMrcuFieldNumber = 4;
  const ::std::string& mrcu() const;
  void set_mrcu(const ::std::string& value);
  #if LANG_CXX11
  void set_mrcu(::std::string&& value);
  #endif
  void set_mrcu(const char* value);
  void set_mrcu(const char* value, size_t size);
  ::std::string* mutable_mrcu();
  ::std::string* release_mrcu();
  void set_allocated_mrcu(::std::string* mrcu);

  // required uint64 time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // required .ru.mail.go.webbase.blobs.RatioStats.Kind kind = 3;
  bool has_kind() const;
  void clear_kind();
  static const int kKindFieldNumber = 3;
  ::ru::mail::go::webbase::blobs::RatioStats_Kind kind() const;
  void set_kind(::ru::mail::go::webbase::blobs::RatioStats_Kind value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.RatioStats)
 private:
  void set_has_query();
  void clear_has_query();
  void set_has_time();
  void clear_has_time();
  void set_has_kind();
  void clear_has_kind();
  void set_has_mrcu();
  void clear_has_mrcu();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr query_;
  ::google::protobuf::internal::ArenaStringPtr mrcu_;
  ::google::protobuf::uint64 time_;
  int kind_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaviconObj : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.FaviconObj) */ {
 public:
  FaviconObj();
  virtual ~FaviconObj();

  FaviconObj(const FaviconObj& from);

  inline FaviconObj& operator=(const FaviconObj& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FaviconObj(FaviconObj&& from) noexcept
    : FaviconObj() {
    *this = ::std::move(from);
  }

  inline FaviconObj& operator=(FaviconObj&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaviconObj& default_instance();

  static inline const FaviconObj* internal_default_instance() {
    return reinterpret_cast<const FaviconObj*>(
               &_FaviconObj_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(FaviconObj* other);
  friend void swap(FaviconObj& a, FaviconObj& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FaviconObj* New() const PROTOBUF_FINAL { return New(NULL); }

  FaviconObj* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FaviconObj& from);
  void MergeFrom(const FaviconObj& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FaviconObj* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string siteURL = 1;
  bool has_siteurl() const;
  void clear_siteurl();
  static const int kSiteURLFieldNumber = 1;
  const ::std::string& siteurl() const;
  void set_siteurl(const ::std::string& value);
  #if LANG_CXX11
  void set_siteurl(::std::string&& value);
  #endif
  void set_siteurl(const char* value);
  void set_siteurl(const char* value, size_t size);
  ::std::string* mutable_siteurl();
  ::std::string* release_siteurl();
  void set_allocated_siteurl(::std::string* siteurl);

  // required string faviconURL = 2;
  bool has_faviconurl() const;
  void clear_faviconurl();
  static const int kFaviconURLFieldNumber = 2;
  const ::std::string& faviconurl() const;
  void set_faviconurl(const ::std::string& value);
  #if LANG_CXX11
  void set_faviconurl(::std::string&& value);
  #endif
  void set_faviconurl(const char* value);
  void set_faviconurl(const char* value, size_t size);
  ::std::string* mutable_faviconurl();
  ::std::string* release_faviconurl();
  void set_allocated_faviconurl(::std::string* faviconurl);

  // optional string faviconURL_high_res = 4;
  bool has_faviconurl_high_res() const;
  void clear_faviconurl_high_res();
  static const int kFaviconURLHighResFieldNumber = 4;
  const ::std::string& faviconurl_high_res() const;
  void set_faviconurl_high_res(const ::std::string& value);
  #if LANG_CXX11
  void set_faviconurl_high_res(::std::string&& value);
  #endif
  void set_faviconurl_high_res(const char* value);
  void set_faviconurl_high_res(const char* value, size_t size);
  ::std::string* mutable_faviconurl_high_res();
  ::std::string* release_faviconurl_high_res();
  void set_allocated_faviconurl_high_res(::std::string* faviconurl_high_res);

  // required .ru.mail.go.webbase.parsing.img.Thumb favicon = 3;
  bool has_favicon() const;
  void clear_favicon();
  static const int kFaviconFieldNumber = 3;
  const ::ru::mail::go::webbase::parsing::img::Thumb& favicon() const;
  ::ru::mail::go::webbase::parsing::img::Thumb* mutable_favicon();
  ::ru::mail::go::webbase::parsing::img::Thumb* release_favicon();
  void set_allocated_favicon(::ru::mail::go::webbase::parsing::img::Thumb* favicon);

  // optional .ru.mail.go.webbase.parsing.img.Thumb favicon_high_res = 5;
  bool has_favicon_high_res() const;
  void clear_favicon_high_res();
  static const int kFaviconHighResFieldNumber = 5;
  const ::ru::mail::go::webbase::parsing::img::Thumb& favicon_high_res() const;
  ::ru::mail::go::webbase::parsing::img::Thumb* mutable_favicon_high_res();
  ::ru::mail::go::webbase::parsing::img::Thumb* release_favicon_high_res();
  void set_allocated_favicon_high_res(::ru::mail::go::webbase::parsing::img::Thumb* favicon_high_res);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.FaviconObj)
 private:
  void set_has_siteurl();
  void clear_has_siteurl();
  void set_has_faviconurl();
  void clear_has_faviconurl();
  void set_has_favicon();
  void clear_has_favicon();
  void set_has_faviconurl_high_res();
  void clear_has_faviconurl_high_res();
  void set_has_favicon_high_res();
  void clear_has_favicon_high_res();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr siteurl_;
  ::google::protobuf::internal::ArenaStringPtr faviconurl_;
  ::google::protobuf::internal::ArenaStringPtr faviconurl_high_res_;
  ::ru::mail::go::webbase::parsing::img::Thumb* favicon_;
  ::ru::mail::go::webbase::parsing::img::Thumb* favicon_high_res_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageStructInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageStructInfo) */ {
 public:
  ImageStructInfo();
  virtual ~ImageStructInfo();

  ImageStructInfo(const ImageStructInfo& from);

  inline ImageStructInfo& operator=(const ImageStructInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageStructInfo(ImageStructInfo&& from) noexcept
    : ImageStructInfo() {
    *this = ::std::move(from);
  }

  inline ImageStructInfo& operator=(ImageStructInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageStructInfo& default_instance();

  static inline const ImageStructInfo* internal_default_instance() {
    return reinterpret_cast<const ImageStructInfo*>(
               &_ImageStructInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(ImageStructInfo* other);
  friend void swap(ImageStructInfo& a, ImageStructInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageStructInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageStructInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageStructInfo& from);
  void MergeFrom(const ImageStructInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageStructInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ImageStructInfo_ImageSource ImageSource;
  static const ImageSource NEWS =
    ImageStructInfo_ImageSource_NEWS;
  static const ImageSource TORG =
    ImageStructInfo_ImageSource_TORG;
  static const ImageSource AFISHA =
    ImageStructInfo_ImageSource_AFISHA;
  static const ImageSource APPS =
    ImageStructInfo_ImageSource_APPS;
  static const ImageSource GIFEST =
    ImageStructInfo_ImageSource_GIFEST;
  static const ImageSource RESERVED2 =
    ImageStructInfo_ImageSource_RESERVED2;
  static const ImageSource RESERVED3 =
    ImageStructInfo_ImageSource_RESERVED3;
  static const ImageSource RESERVED4 =
    ImageStructInfo_ImageSource_RESERVED4;
  static inline bool ImageSource_IsValid(int value) {
    return ImageStructInfo_ImageSource_IsValid(value);
  }
  static const ImageSource ImageSource_MIN =
    ImageStructInfo_ImageSource_ImageSource_MIN;
  static const ImageSource ImageSource_MAX =
    ImageStructInfo_ImageSource_ImageSource_MAX;
  static const int ImageSource_ARRAYSIZE =
    ImageStructInfo_ImageSource_ImageSource_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ImageSource_descriptor() {
    return ImageStructInfo_ImageSource_descriptor();
  }
  static inline const ::std::string& ImageSource_Name(ImageSource value) {
    return ImageStructInfo_ImageSource_Name(value);
  }
  static inline bool ImageSource_Parse(const ::std::string& name,
      ImageSource* value) {
    return ImageStructInfo_ImageSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string page_full_URL = 2;
  bool has_page_full_url() const;
  void clear_page_full_url();
  static const int kPageFullURLFieldNumber = 2;
  const ::std::string& page_full_url() const;
  void set_page_full_url(const ::std::string& value);
  #if LANG_CXX11
  void set_page_full_url(::std::string&& value);
  #endif
  void set_page_full_url(const char* value);
  void set_page_full_url(const char* value, size_t size);
  ::std::string* mutable_page_full_url();
  ::std::string* release_page_full_url();
  void set_allocated_page_full_url(::std::string* page_full_url);

  // optional string title = 3;
  bool has_title() const;
  void clear_title();
  static const int kTitleFieldNumber = 3;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // optional string text = 4;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 4;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional int64 image_time = 5;
  bool has_image_time() const;
  void clear_image_time();
  static const int kImageTimeFieldNumber = 5;
  ::google::protobuf::int64 image_time() const;
  void set_image_time(::google::protobuf::int64 value);

  // required .ru.mail.go.webbase.blobs.ImageStructInfo.ImageSource source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::ImageStructInfo_ImageSource source() const;
  void set_source(::ru::mail::go::webbase::blobs::ImageStructInfo_ImageSource value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageStructInfo)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_page_full_url();
  void clear_has_page_full_url();
  void set_has_title();
  void clear_has_title();
  void set_has_text();
  void clear_has_text();
  void set_has_image_time();
  void clear_has_image_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr page_full_url_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::int64 image_time_;
  int source_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewsImageInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.NewsImageInfo) */ {
 public:
  NewsImageInfo();
  virtual ~NewsImageInfo();

  NewsImageInfo(const NewsImageInfo& from);

  inline NewsImageInfo& operator=(const NewsImageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewsImageInfo(NewsImageInfo&& from) noexcept
    : NewsImageInfo() {
    *this = ::std::move(from);
  }

  inline NewsImageInfo& operator=(NewsImageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewsImageInfo& default_instance();

  static inline const NewsImageInfo* internal_default_instance() {
    return reinterpret_cast<const NewsImageInfo*>(
               &_NewsImageInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(NewsImageInfo* other);
  friend void swap(NewsImageInfo& a, NewsImageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewsImageInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  NewsImageInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewsImageInfo& from);
  void MergeFrom(const NewsImageInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewsImageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string news_img_hash = 2;
  bool has_news_img_hash() const;
  void clear_news_img_hash();
  static const int kNewsImgHashFieldNumber = 2;
  const ::std::string& news_img_hash() const;
  void set_news_img_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_news_img_hash(::std::string&& value);
  #endif
  void set_news_img_hash(const char* value);
  void set_news_img_hash(const char* value, size_t size);
  ::std::string* mutable_news_img_hash();
  ::std::string* release_news_img_hash();
  void set_allocated_news_img_hash(::std::string* news_img_hash);

  // required int64 news_id = 1;
  bool has_news_id() const;
  void clear_news_id();
  static const int kNewsIdFieldNumber = 1;
  ::google::protobuf::int64 news_id() const;
  void set_news_id(::google::protobuf::int64 value);

  // required int32 src_id = 3;
  bool has_src_id() const;
  void clear_src_id();
  static const int kSrcIdFieldNumber = 3;
  ::google::protobuf::int32 src_id() const;
  void set_src_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.NewsImageInfo)
 private:
  void set_has_news_id();
  void clear_has_news_id();
  void set_has_news_img_hash();
  void clear_has_news_img_hash();
  void set_has_src_id();
  void clear_has_src_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr news_img_hash_;
  ::google::protobuf::int64 news_id_;
  ::google::protobuf::int32 src_id_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageKeywords : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageKeywords) */ {
 public:
  ImageKeywords();
  virtual ~ImageKeywords();

  ImageKeywords(const ImageKeywords& from);

  inline ImageKeywords& operator=(const ImageKeywords& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageKeywords(ImageKeywords&& from) noexcept
    : ImageKeywords() {
    *this = ::std::move(from);
  }

  inline ImageKeywords& operator=(ImageKeywords&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageKeywords& default_instance();

  static inline const ImageKeywords* internal_default_instance() {
    return reinterpret_cast<const ImageKeywords*>(
               &_ImageKeywords_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(ImageKeywords* other);
  friend void swap(ImageKeywords& a, ImageKeywords& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageKeywords* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageKeywords* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageKeywords& from);
  void MergeFrom(const ImageKeywords& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageKeywords* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keywords = 1;
  int keywords_size() const;
  void clear_keywords();
  static const int kKeywordsFieldNumber = 1;
  const ::std::string& keywords(int index) const;
  ::std::string* mutable_keywords(int index);
  void set_keywords(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keywords(int index, ::std::string&& value);
  #endif
  void set_keywords(int index, const char* value);
  void set_keywords(int index, const char* value, size_t size);
  ::std::string* add_keywords();
  void add_keywords(const ::std::string& value);
  #if LANG_CXX11
  void add_keywords(::std::string&& value);
  #endif
  void add_keywords(const char* value);
  void add_keywords(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keywords() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keywords();

  // repeated float weights = 2;
  int weights_size() const;
  void clear_weights();
  static const int kWeightsFieldNumber = 2;
  float weights(int index) const;
  void set_weights(int index, float value);
  void add_weights(float value);
  const ::google::protobuf::RepeatedField< float >&
      weights() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_weights();

  // optional int32 cluster_size = 3;
  bool has_cluster_size() const;
  void clear_cluster_size();
  static const int kClusterSizeFieldNumber = 3;
  ::google::protobuf::int32 cluster_size() const;
  void set_cluster_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageKeywords)
 private:
  void set_has_cluster_size();
  void clear_has_cluster_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keywords_;
  ::google::protobuf::RepeatedField< float > weights_;
  ::google::protobuf::int32 cluster_size_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageObj : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageObj) */ {
 public:
  ImageObj();
  virtual ~ImageObj();

  ImageObj(const ImageObj& from);

  inline ImageObj& operator=(const ImageObj& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageObj(ImageObj&& from) noexcept
    : ImageObj() {
    *this = ::std::move(from);
  }

  inline ImageObj& operator=(ImageObj&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageObj& default_instance();

  static inline const ImageObj* internal_default_instance() {
    return reinterpret_cast<const ImageObj*>(
               &_ImageObj_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(ImageObj* other);
  friend void swap(ImageObj& a, ImageObj& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageObj* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageObj* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageObj& from);
  void MergeFrom(const ImageObj& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageObj* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string imageURL = 1;
  bool has_imageurl() const;
  void clear_imageurl();
  static const int kImageURLFieldNumber = 1;
  const ::std::string& imageurl() const;
  void set_imageurl(const ::std::string& value);
  #if LANG_CXX11
  void set_imageurl(::std::string&& value);
  #endif
  void set_imageurl(const char* value);
  void set_imageurl(const char* value, size_t size);
  ::std::string* mutable_imageurl();
  ::std::string* release_imageurl();
  void set_allocated_imageurl(::std::string* imageurl);

  // optional bytes image = 3;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 3;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const void* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // required int32 result_code = 2;
  bool has_result_code() const;
  void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  ::google::protobuf::int32 result_code() const;
  void set_result_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageObj)
 private:
  void set_has_imageurl();
  void clear_has_imageurl();
  void set_has_result_code();
  void clear_has_result_code();
  void set_has_image();
  void clear_has_image();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr imageurl_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::int32 result_code_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageIndexObj : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageIndexObj) */ {
 public:
  ImageIndexObj();
  virtual ~ImageIndexObj();

  ImageIndexObj(const ImageIndexObj& from);

  inline ImageIndexObj& operator=(const ImageIndexObj& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageIndexObj(ImageIndexObj&& from) noexcept
    : ImageIndexObj() {
    *this = ::std::move(from);
  }

  inline ImageIndexObj& operator=(ImageIndexObj&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageIndexObj& default_instance();

  static inline const ImageIndexObj* internal_default_instance() {
    return reinterpret_cast<const ImageIndexObj*>(
               &_ImageIndexObj_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(ImageIndexObj* other);
  friend void swap(ImageIndexObj& a, ImageIndexObj& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageIndexObj* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageIndexObj* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageIndexObj& from);
  void MergeFrom(const ImageIndexObj& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageIndexObj* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string xml_doc = 2;
  bool has_xml_doc() const;
  void clear_xml_doc();
  static const int kXmlDocFieldNumber = 2;
  const ::std::string& xml_doc() const;
  void set_xml_doc(const ::std::string& value);
  #if LANG_CXX11
  void set_xml_doc(::std::string&& value);
  #endif
  void set_xml_doc(const char* value);
  void set_xml_doc(const char* value, size_t size);
  ::std::string* mutable_xml_doc();
  ::std::string* release_xml_doc();
  void set_allocated_xml_doc(::std::string* xml_doc);

  // required .ru.mail.go.webbase.blobs.ThumbDoc thumb = 1;
  bool has_thumb() const;
  void clear_thumb();
  static const int kThumbFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::ThumbDoc& thumb() const;
  ::ru::mail::go::webbase::blobs::ThumbDoc* mutable_thumb();
  ::ru::mail::go::webbase::blobs::ThumbDoc* release_thumb();
  void set_allocated_thumb(::ru::mail::go::webbase::blobs::ThumbDoc* thumb);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageIndexObj)
 private:
  void set_has_thumb();
  void clear_has_thumb();
  void set_has_xml_doc();
  void clear_has_xml_doc();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr xml_doc_;
  ::ru::mail::go::webbase::blobs::ThumbDoc* thumb_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WOTInfo_WOTElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.WOTInfo.WOTElement) */ {
 public:
  WOTInfo_WOTElement();
  virtual ~WOTInfo_WOTElement();

  WOTInfo_WOTElement(const WOTInfo_WOTElement& from);

  inline WOTInfo_WOTElement& operator=(const WOTInfo_WOTElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WOTInfo_WOTElement(WOTInfo_WOTElement&& from) noexcept
    : WOTInfo_WOTElement() {
    *this = ::std::move(from);
  }

  inline WOTInfo_WOTElement& operator=(WOTInfo_WOTElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WOTInfo_WOTElement& default_instance();

  static inline const WOTInfo_WOTElement* internal_default_instance() {
    return reinterpret_cast<const WOTInfo_WOTElement*>(
               &_WOTInfo_WOTElement_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(WOTInfo_WOTElement* other);
  friend void swap(WOTInfo_WOTElement& a, WOTInfo_WOTElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WOTInfo_WOTElement* New() const PROTOBUF_FINAL { return New(NULL); }

  WOTInfo_WOTElement* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WOTInfo_WOTElement& from);
  void MergeFrom(const WOTInfo_WOTElement& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WOTInfo_WOTElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 confidence = 1;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 1;
  ::google::protobuf::int32 confidence() const;
  void set_confidence(::google::protobuf::int32 value);

  // required int32 reputation = 2;
  bool has_reputation() const;
  void clear_reputation();
  static const int kReputationFieldNumber = 2;
  ::google::protobuf::int32 reputation() const;
  void set_reputation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.WOTInfo.WOTElement)
 private:
  void set_has_confidence();
  void clear_has_confidence();
  void set_has_reputation();
  void clear_has_reputation();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 confidence_;
  ::google::protobuf::int32 reputation_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WOTInfo_WOTCategory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.WOTInfo.WOTCategory) */ {
 public:
  WOTInfo_WOTCategory();
  virtual ~WOTInfo_WOTCategory();

  WOTInfo_WOTCategory(const WOTInfo_WOTCategory& from);

  inline WOTInfo_WOTCategory& operator=(const WOTInfo_WOTCategory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WOTInfo_WOTCategory(WOTInfo_WOTCategory&& from) noexcept
    : WOTInfo_WOTCategory() {
    *this = ::std::move(from);
  }

  inline WOTInfo_WOTCategory& operator=(WOTInfo_WOTCategory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WOTInfo_WOTCategory& default_instance();

  static inline const WOTInfo_WOTCategory* internal_default_instance() {
    return reinterpret_cast<const WOTInfo_WOTCategory*>(
               &_WOTInfo_WOTCategory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(WOTInfo_WOTCategory* other);
  friend void swap(WOTInfo_WOTCategory& a, WOTInfo_WOTCategory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WOTInfo_WOTCategory* New() const PROTOBUF_FINAL { return New(NULL); }

  WOTInfo_WOTCategory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WOTInfo_WOTCategory& from);
  void MergeFrom(const WOTInfo_WOTCategory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WOTInfo_WOTCategory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 category = 1;
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 1;
  ::google::protobuf::int32 category() const;
  void set_category(::google::protobuf::int32 value);

  // required int32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.WOTInfo.WOTCategory)
 private:
  void set_has_category();
  void clear_has_category();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 category_;
  ::google::protobuf::int32 value_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WOTInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.WOTInfo) */ {
 public:
  WOTInfo();
  virtual ~WOTInfo();

  WOTInfo(const WOTInfo& from);

  inline WOTInfo& operator=(const WOTInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WOTInfo(WOTInfo&& from) noexcept
    : WOTInfo() {
    *this = ::std::move(from);
  }

  inline WOTInfo& operator=(WOTInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WOTInfo& default_instance();

  static inline const WOTInfo* internal_default_instance() {
    return reinterpret_cast<const WOTInfo*>(
               &_WOTInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(WOTInfo* other);
  friend void swap(WOTInfo& a, WOTInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WOTInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  WOTInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WOTInfo& from);
  void MergeFrom(const WOTInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WOTInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef WOTInfo_WOTElement WOTElement;
  typedef WOTInfo_WOTCategory WOTCategory;

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.WOTInfo.WOTCategory category = 5;
  int category_size() const;
  void clear_category();
  static const int kCategoryFieldNumber = 5;
  const ::ru::mail::go::webbase::blobs::WOTInfo_WOTCategory& category(int index) const;
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTCategory* mutable_category(int index);
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTCategory* add_category();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::WOTInfo_WOTCategory >*
      mutable_category();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::WOTInfo_WOTCategory >&
      category() const;

  // optional .ru.mail.go.webbase.blobs.WOTInfo.WOTElement trust_worthiness = 1;
  bool has_trust_worthiness() const;
  void clear_trust_worthiness();
  static const int kTrustWorthinessFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement& trust_worthiness() const;
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* mutable_trust_worthiness();
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* release_trust_worthiness();
  void set_allocated_trust_worthiness(::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* trust_worthiness);

  // optional .ru.mail.go.webbase.blobs.WOTInfo.WOTElement vendor_reliability = 2;
  bool has_vendor_reliability() const;
  void clear_vendor_reliability();
  static const int kVendorReliabilityFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement& vendor_reliability() const;
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* mutable_vendor_reliability();
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* release_vendor_reliability();
  void set_allocated_vendor_reliability(::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* vendor_reliability);

  // optional .ru.mail.go.webbase.blobs.WOTInfo.WOTElement privacy = 3;
  bool has_privacy() const;
  void clear_privacy();
  static const int kPrivacyFieldNumber = 3;
  const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement& privacy() const;
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* mutable_privacy();
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* release_privacy();
  void set_allocated_privacy(::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* privacy);

  // optional .ru.mail.go.webbase.blobs.WOTInfo.WOTElement child_safety = 4;
  bool has_child_safety() const;
  void clear_child_safety();
  static const int kChildSafetyFieldNumber = 4;
  const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement& child_safety() const;
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* mutable_child_safety();
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* release_child_safety();
  void set_allocated_child_safety(::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* child_safety);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.WOTInfo)
 private:
  void set_has_trust_worthiness();
  void clear_has_trust_worthiness();
  void set_has_vendor_reliability();
  void clear_has_vendor_reliability();
  void set_has_privacy();
  void clear_has_privacy();
  void set_has_child_safety();
  void clear_has_child_safety();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::WOTInfo_WOTCategory > category_;
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* trust_worthiness_;
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* vendor_reliability_;
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* privacy_;
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* child_safety_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WOTInfoObj : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.WOTInfoObj) */ {
 public:
  WOTInfoObj();
  virtual ~WOTInfoObj();

  WOTInfoObj(const WOTInfoObj& from);

  inline WOTInfoObj& operator=(const WOTInfoObj& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WOTInfoObj(WOTInfoObj&& from) noexcept
    : WOTInfoObj() {
    *this = ::std::move(from);
  }

  inline WOTInfoObj& operator=(WOTInfoObj&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WOTInfoObj& default_instance();

  static inline const WOTInfoObj* internal_default_instance() {
    return reinterpret_cast<const WOTInfoObj*>(
               &_WOTInfoObj_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(WOTInfoObj* other);
  friend void swap(WOTInfoObj& a, WOTInfoObj& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WOTInfoObj* New() const PROTOBUF_FINAL { return New(NULL); }

  WOTInfoObj* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WOTInfoObj& from);
  void MergeFrom(const WOTInfoObj& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WOTInfoObj* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string host = 1;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 1;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // required .ru.mail.go.webbase.blobs.WOTInfo wot_info = 2;
  bool has_wot_info() const;
  void clear_wot_info();
  static const int kWotInfoFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::WOTInfo& wot_info() const;
  ::ru::mail::go::webbase::blobs::WOTInfo* mutable_wot_info();
  ::ru::mail::go::webbase::blobs::WOTInfo* release_wot_info();
  void set_allocated_wot_info(::ru::mail::go::webbase::blobs::WOTInfo* wot_info);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.WOTInfoObj)
 private:
  void set_has_host();
  void clear_has_host();
  void set_has_wot_info();
  void clear_has_wot_info();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::ru::mail::go::webbase::blobs::WOTInfo* wot_info_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UrlRankInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.UrlRankInfo) */ {
 public:
  UrlRankInfo();
  virtual ~UrlRankInfo();

  UrlRankInfo(const UrlRankInfo& from);

  inline UrlRankInfo& operator=(const UrlRankInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UrlRankInfo(UrlRankInfo&& from) noexcept
    : UrlRankInfo() {
    *this = ::std::move(from);
  }

  inline UrlRankInfo& operator=(UrlRankInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UrlRankInfo& default_instance();

  static inline const UrlRankInfo* internal_default_instance() {
    return reinterpret_cast<const UrlRankInfo*>(
               &_UrlRankInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(UrlRankInfo* other);
  friend void swap(UrlRankInfo& a, UrlRankInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UrlRankInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  UrlRankInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UrlRankInfo& from);
  void MergeFrom(const UrlRankInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UrlRankInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.ComputedValues.Record kvRecords = 2;
  int kvrecords_size() const;
  void clear_kvrecords();
  static const int kKvRecordsFieldNumber = 2;
  const ::ru::mail::go::webbase::ComputedValues_Record& kvrecords(int index) const;
  ::ru::mail::go::webbase::ComputedValues_Record* mutable_kvrecords(int index);
  ::ru::mail::go::webbase::ComputedValues_Record* add_kvrecords();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::ComputedValues_Record >*
      mutable_kvrecords();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::ComputedValues_Record >&
      kvrecords() const;

  // required string rank_name = 1;
  bool has_rank_name() const;
  void clear_rank_name();
  static const int kRankNameFieldNumber = 1;
  const ::std::string& rank_name() const;
  void set_rank_name(const ::std::string& value);
  #if LANG_CXX11
  void set_rank_name(::std::string&& value);
  #endif
  void set_rank_name(const char* value);
  void set_rank_name(const char* value, size_t size);
  ::std::string* mutable_rank_name();
  ::std::string* release_rank_name();
  void set_allocated_rank_name(::std::string* rank_name);

  // optional .ru.mail.go.webbase.ComputedValues query_info = 3;
  bool has_query_info() const;
  void clear_query_info();
  static const int kQueryInfoFieldNumber = 3;
  const ::ru::mail::go::webbase::ComputedValues& query_info() const;
  ::ru::mail::go::webbase::ComputedValues* mutable_query_info();
  ::ru::mail::go::webbase::ComputedValues* release_query_info();
  void set_allocated_query_info(::ru::mail::go::webbase::ComputedValues* query_info);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.UrlRankInfo)
 private:
  void set_has_rank_name();
  void clear_has_rank_name();
  void set_has_query_info();
  void clear_has_query_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::ComputedValues_Record > kvrecords_;
  ::google::protobuf::internal::ArenaStringPtr rank_name_;
  ::ru::mail::go::webbase::ComputedValues* query_info_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UrlQueryInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.UrlQueryInfo) */ {
 public:
  UrlQueryInfo();
  virtual ~UrlQueryInfo();

  UrlQueryInfo(const UrlQueryInfo& from);

  inline UrlQueryInfo& operator=(const UrlQueryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UrlQueryInfo(UrlQueryInfo&& from) noexcept
    : UrlQueryInfo() {
    *this = ::std::move(from);
  }

  inline UrlQueryInfo& operator=(UrlQueryInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UrlQueryInfo& default_instance();

  static inline const UrlQueryInfo* internal_default_instance() {
    return reinterpret_cast<const UrlQueryInfo*>(
               &_UrlQueryInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(UrlQueryInfo* other);
  friend void swap(UrlQueryInfo& a, UrlQueryInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UrlQueryInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  UrlQueryInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UrlQueryInfo& from);
  void MergeFrom(const UrlQueryInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UrlQueryInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.UrlRankInfo ranks = 10;
  int ranks_size() const;
  void clear_ranks();
  static const int kRanksFieldNumber = 10;
  const ::ru::mail::go::webbase::blobs::UrlRankInfo& ranks(int index) const;
  ::ru::mail::go::webbase::blobs::UrlRankInfo* mutable_ranks(int index);
  ::ru::mail::go::webbase::blobs::UrlRankInfo* add_ranks();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::UrlRankInfo >*
      mutable_ranks();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::UrlRankInfo >&
      ranks() const;

  // optional string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional string query = 3;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 3;
  const ::std::string& query() const;
  void set_query(const ::std::string& value);
  #if LANG_CXX11
  void set_query(::std::string&& value);
  #endif
  void set_query(const char* value);
  void set_query(const char* value, size_t size);
  ::std::string* mutable_query();
  ::std::string* release_query();
  void set_allocated_query(::std::string* query);

  // optional string main_url = 6;
  bool has_main_url() const;
  void clear_main_url();
  static const int kMainUrlFieldNumber = 6;
  const ::std::string& main_url() const;
  void set_main_url(const ::std::string& value);
  #if LANG_CXX11
  void set_main_url(::std::string&& value);
  #endif
  void set_main_url(const char* value);
  void set_main_url(const char* value, size_t size);
  ::std::string* mutable_main_url();
  ::std::string* release_main_url();
  void set_allocated_main_url(::std::string* main_url);

  // optional string vk_music_hash = 11;
  bool has_vk_music_hash() const;
  void clear_vk_music_hash();
  static const int kVkMusicHashFieldNumber = 11;
  const ::std::string& vk_music_hash() const;
  void set_vk_music_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_vk_music_hash(::std::string&& value);
  #endif
  void set_vk_music_hash(const char* value);
  void set_vk_music_hash(const char* value, size_t size);
  ::std::string* mutable_vk_music_hash();
  ::std::string* release_vk_music_hash();
  void set_allocated_vk_music_hash(::std::string* vk_music_hash);

  // optional uint64 hash = 5;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 5;
  ::google::protobuf::uint64 hash() const;
  void set_hash(::google::protobuf::uint64 value);

  // optional uint64 cluster_id = 9;
  bool has_cluster_id() const;
  void clear_cluster_id();
  static const int kClusterIdFieldNumber = 9;
  ::google::protobuf::uint64 cluster_id() const;
  void set_cluster_id(::google::protobuf::uint64 value);

  // optional int32 mb_number = 2;
  bool has_mb_number() const;
  void clear_mb_number();
  static const int kMbNumberFieldNumber = 2;
  ::google::protobuf::int32 mb_number() const;
  void set_mb_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.UrlQueryInfo)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_mb_number();
  void clear_has_mb_number();
  void set_has_query();
  void clear_has_query();
  void set_has_hash();
  void clear_has_hash();
  void set_has_main_url();
  void clear_has_main_url();
  void set_has_cluster_id();
  void clear_has_cluster_id();
  void set_has_vk_music_hash();
  void clear_has_vk_music_hash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::UrlRankInfo > ranks_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr query_;
  ::google::protobuf::internal::ArenaStringPtr main_url_;
  ::google::protobuf::internal::ArenaStringPtr vk_music_hash_;
  ::google::protobuf::uint64 hash_;
  ::google::protobuf::uint64 cluster_id_;
  ::google::protobuf::int32 mb_number_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UrlQueryInfoKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.UrlQueryInfoKey) */ {
 public:
  UrlQueryInfoKey();
  virtual ~UrlQueryInfoKey();

  UrlQueryInfoKey(const UrlQueryInfoKey& from);

  inline UrlQueryInfoKey& operator=(const UrlQueryInfoKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UrlQueryInfoKey(UrlQueryInfoKey&& from) noexcept
    : UrlQueryInfoKey() {
    *this = ::std::move(from);
  }

  inline UrlQueryInfoKey& operator=(UrlQueryInfoKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UrlQueryInfoKey& default_instance();

  static inline const UrlQueryInfoKey* internal_default_instance() {
    return reinterpret_cast<const UrlQueryInfoKey*>(
               &_UrlQueryInfoKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(UrlQueryInfoKey* other);
  friend void swap(UrlQueryInfoKey& a, UrlQueryInfoKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UrlQueryInfoKey* New() const PROTOBUF_FINAL { return New(NULL); }

  UrlQueryInfoKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UrlQueryInfoKey& from);
  void MergeFrom(const UrlQueryInfoKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UrlQueryInfoKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string full_url = 1;
  bool has_full_url() const;
  void clear_full_url();
  static const int kFullUrlFieldNumber = 1;
  const ::std::string& full_url() const;
  void set_full_url(const ::std::string& value);
  #if LANG_CXX11
  void set_full_url(::std::string&& value);
  #endif
  void set_full_url(const char* value);
  void set_full_url(const char* value, size_t size);
  ::std::string* mutable_full_url();
  ::std::string* release_full_url();
  void set_allocated_full_url(::std::string* full_url);

  // required string rank_name = 2;
  bool has_rank_name() const;
  void clear_rank_name();
  static const int kRankNameFieldNumber = 2;
  const ::std::string& rank_name() const;
  void set_rank_name(const ::std::string& value);
  #if LANG_CXX11
  void set_rank_name(::std::string&& value);
  #endif
  void set_rank_name(const char* value);
  void set_rank_name(const char* value, size_t size);
  ::std::string* mutable_rank_name();
  ::std::string* release_rank_name();
  void set_allocated_rank_name(::std::string* rank_name);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.UrlQueryInfoKey)
 private:
  void set_has_full_url();
  void clear_has_full_url();
  void set_has_rank_name();
  void clear_has_rank_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr full_url_;
  ::google::protobuf::internal::ArenaStringPtr rank_name_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ThumbIndexKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ThumbIndexKey) */ {
 public:
  ThumbIndexKey();
  virtual ~ThumbIndexKey();

  ThumbIndexKey(const ThumbIndexKey& from);

  inline ThumbIndexKey& operator=(const ThumbIndexKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ThumbIndexKey(ThumbIndexKey&& from) noexcept
    : ThumbIndexKey() {
    *this = ::std::move(from);
  }

  inline ThumbIndexKey& operator=(ThumbIndexKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ThumbIndexKey& default_instance();

  static inline const ThumbIndexKey* internal_default_instance() {
    return reinterpret_cast<const ThumbIndexKey*>(
               &_ThumbIndexKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(ThumbIndexKey* other);
  friend void swap(ThumbIndexKey& a, ThumbIndexKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ThumbIndexKey* New() const PROTOBUF_FINAL { return New(NULL); }

  ThumbIndexKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ThumbIndexKey& from);
  void MergeFrom(const ThumbIndexKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ThumbIndexKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string full_url = 1;
  bool has_full_url() const;
  void clear_full_url();
  static const int kFullUrlFieldNumber = 1;
  const ::std::string& full_url() const;
  void set_full_url(const ::std::string& value);
  #if LANG_CXX11
  void set_full_url(::std::string&& value);
  #endif
  void set_full_url(const char* value);
  void set_full_url(const char* value, size_t size);
  ::std::string* mutable_full_url();
  ::std::string* release_full_url();
  void set_allocated_full_url(::std::string* full_url);

  // required uint32 priority = 2;
  bool has_priority() const;
  void clear_priority();
  static const int kPriorityFieldNumber = 2;
  ::google::protobuf::uint32 priority() const;
  void set_priority(::google::protobuf::uint32 value);

  // required uint32 partition = 3;
  bool has_partition() const;
  void clear_partition();
  static const int kPartitionFieldNumber = 3;
  ::google::protobuf::uint32 partition() const;
  void set_partition(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ThumbIndexKey)
 private:
  void set_has_full_url();
  void clear_has_full_url();
  void set_has_priority();
  void clear_has_priority();
  void set_has_partition();
  void clear_has_partition();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr full_url_;
  ::google::protobuf::uint32 priority_;
  ::google::protobuf::uint32 partition_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TextIndexKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.TextIndexKey) */ {
 public:
  TextIndexKey();
  virtual ~TextIndexKey();

  TextIndexKey(const TextIndexKey& from);

  inline TextIndexKey& operator=(const TextIndexKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextIndexKey(TextIndexKey&& from) noexcept
    : TextIndexKey() {
    *this = ::std::move(from);
  }

  inline TextIndexKey& operator=(TextIndexKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextIndexKey& default_instance();

  static inline const TextIndexKey* internal_default_instance() {
    return reinterpret_cast<const TextIndexKey*>(
               &_TextIndexKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(TextIndexKey* other);
  friend void swap(TextIndexKey& a, TextIndexKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextIndexKey* New() const PROTOBUF_FINAL { return New(NULL); }

  TextIndexKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TextIndexKey& from);
  void MergeFrom(const TextIndexKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TextIndexKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string keyDomain = 2;
  bool has_keydomain() const;
  void clear_keydomain();
  static const int kKeyDomainFieldNumber = 2;
  const ::std::string& keydomain() const;
  void set_keydomain(const ::std::string& value);
  #if LANG_CXX11
  void set_keydomain(::std::string&& value);
  #endif
  void set_keydomain(const char* value);
  void set_keydomain(const char* value, size_t size);
  ::std::string* mutable_keydomain();
  ::std::string* release_keydomain();
  void set_allocated_keydomain(::std::string* keydomain);

  // required uint32 partition = 1;
  bool has_partition() const;
  void clear_partition();
  static const int kPartitionFieldNumber = 1;
  ::google::protobuf::uint32 partition() const;
  void set_partition(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.TextIndexKey)
 private:
  void set_has_partition();
  void clear_has_partition();
  void set_has_keydomain();
  void clear_has_keydomain();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr keydomain_;
  ::google::protobuf::uint32 partition_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarkersInfo_PageInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo) */ {
 public:
  MarkersInfo_PageInfo();
  virtual ~MarkersInfo_PageInfo();

  MarkersInfo_PageInfo(const MarkersInfo_PageInfo& from);

  inline MarkersInfo_PageInfo& operator=(const MarkersInfo_PageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarkersInfo_PageInfo(MarkersInfo_PageInfo&& from) noexcept
    : MarkersInfo_PageInfo() {
    *this = ::std::move(from);
  }

  inline MarkersInfo_PageInfo& operator=(MarkersInfo_PageInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarkersInfo_PageInfo& default_instance();

  static inline const MarkersInfo_PageInfo* internal_default_instance() {
    return reinterpret_cast<const MarkersInfo_PageInfo*>(
               &_MarkersInfo_PageInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(MarkersInfo_PageInfo* other);
  friend void swap(MarkersInfo_PageInfo& a, MarkersInfo_PageInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarkersInfo_PageInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MarkersInfo_PageInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MarkersInfo_PageInfo& from);
  void MergeFrom(const MarkersInfo_PageInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MarkersInfo_PageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required uint32 webMarkersCnt = 2;
  bool has_webmarkerscnt() const;
  void clear_webmarkerscnt();
  static const int kWebMarkersCntFieldNumber = 2;
  ::google::protobuf::uint32 webmarkerscnt() const;
  void set_webmarkerscnt(::google::protobuf::uint32 value);

  // required uint32 ImgMarkersCnt = 3;
  bool has_imgmarkerscnt() const;
  void clear_imgmarkerscnt();
  static const int kImgMarkersCntFieldNumber = 3;
  ::google::protobuf::uint32 imgmarkerscnt() const;
  void set_imgmarkerscnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_webmarkerscnt();
  void clear_has_webmarkerscnt();
  void set_has_imgmarkerscnt();
  void clear_has_imgmarkerscnt();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::uint32 webmarkerscnt_;
  ::google::protobuf::uint32 imgmarkerscnt_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarkersInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.MarkersInfo) */ {
 public:
  MarkersInfo();
  virtual ~MarkersInfo();

  MarkersInfo(const MarkersInfo& from);

  inline MarkersInfo& operator=(const MarkersInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarkersInfo(MarkersInfo&& from) noexcept
    : MarkersInfo() {
    *this = ::std::move(from);
  }

  inline MarkersInfo& operator=(MarkersInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarkersInfo& default_instance();

  static inline const MarkersInfo* internal_default_instance() {
    return reinterpret_cast<const MarkersInfo*>(
               &_MarkersInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(MarkersInfo* other);
  friend void swap(MarkersInfo& a, MarkersInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarkersInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MarkersInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MarkersInfo& from);
  void MergeFrom(const MarkersInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MarkersInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MarkersInfo_PageInfo PageInfo;

  typedef MarkersInfo_Type Type;
  static const Type Domain =
    MarkersInfo_Type_Domain;
  static const Type Page =
    MarkersInfo_Type_Page;
  static inline bool Type_IsValid(int value) {
    return MarkersInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MarkersInfo_Type_Type_MIN;
  static const Type Type_MAX =
    MarkersInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MarkersInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MarkersInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MarkersInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MarkersInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ru.mail.go.webbase.blobs.MarkersInfo.PageInfo pageinfo = 2;
  bool has_pageinfo() const;
  void clear_pageinfo();
  static const int kPageinfoFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo& pageinfo() const;
  ::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo* mutable_pageinfo();
  ::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo* release_pageinfo();
  void set_allocated_pageinfo(::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo* pageinfo);

  // optional .ru.mail.go.webbase.sekitei.Sekitei_m sekitei = 3;
  bool has_sekitei() const;
  void clear_sekitei();
  static const int kSekiteiFieldNumber = 3;
  const ::ru::mail::go::webbase::sekitei::Sekitei_m& sekitei() const;
  ::ru::mail::go::webbase::sekitei::Sekitei_m* mutable_sekitei();
  ::ru::mail::go::webbase::sekitei::Sekitei_m* release_sekitei();
  void set_allocated_sekitei(::ru::mail::go::webbase::sekitei::Sekitei_m* sekitei);

  // required .ru.mail.go.webbase.blobs.MarkersInfo.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::MarkersInfo_Type type() const;
  void set_type(::ru::mail::go::webbase::blobs::MarkersInfo_Type value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.MarkersInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_pageinfo();
  void clear_has_pageinfo();
  void set_has_sekitei();
  void clear_has_sekitei();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo* pageinfo_;
  ::ru::mail::go::webbase::sekitei::Sekitei_m* sekitei_;
  int type_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResClustInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ResClustInfo) */ {
 public:
  ResClustInfo();
  virtual ~ResClustInfo();

  ResClustInfo(const ResClustInfo& from);

  inline ResClustInfo& operator=(const ResClustInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResClustInfo(ResClustInfo&& from) noexcept
    : ResClustInfo() {
    *this = ::std::move(from);
  }

  inline ResClustInfo& operator=(ResClustInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResClustInfo& default_instance();

  static inline const ResClustInfo* internal_default_instance() {
    return reinterpret_cast<const ResClustInfo*>(
               &_ResClustInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(ResClustInfo* other);
  friend void swap(ResClustInfo& a, ResClustInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResClustInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ResClustInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResClustInfo& from);
  void MergeFrom(const ResClustInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResClustInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string res_part1 = 2;
  bool has_res_part1() const;
  void clear_res_part1();
  static const int kResPart1FieldNumber = 2;
  const ::std::string& res_part1() const;
  void set_res_part1(const ::std::string& value);
  #if LANG_CXX11
  void set_res_part1(::std::string&& value);
  #endif
  void set_res_part1(const char* value);
  void set_res_part1(const char* value, size_t size);
  ::std::string* mutable_res_part1();
  ::std::string* release_res_part1();
  void set_allocated_res_part1(::std::string* res_part1);

  // optional string res_part2 = 3;
  bool has_res_part2() const;
  void clear_res_part2();
  static const int kResPart2FieldNumber = 3;
  const ::std::string& res_part2() const;
  void set_res_part2(const ::std::string& value);
  #if LANG_CXX11
  void set_res_part2(::std::string&& value);
  #endif
  void set_res_part2(const char* value);
  void set_res_part2(const char* value, size_t size);
  ::std::string* mutable_res_part2();
  ::std::string* release_res_part2();
  void set_allocated_res_part2(::std::string* res_part2);

  // required int64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ResClustInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_res_part1();
  void clear_has_res_part1();
  void set_has_res_part2();
  void clear_has_res_part2();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr res_part1_;
  ::google::protobuf::internal::ArenaStringPtr res_part2_;
  ::google::protobuf::int64 id_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DiscoveryVisitUrlInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo) */ {
 public:
  DiscoveryVisitUrlInfo();
  virtual ~DiscoveryVisitUrlInfo();

  DiscoveryVisitUrlInfo(const DiscoveryVisitUrlInfo& from);

  inline DiscoveryVisitUrlInfo& operator=(const DiscoveryVisitUrlInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscoveryVisitUrlInfo(DiscoveryVisitUrlInfo&& from) noexcept
    : DiscoveryVisitUrlInfo() {
    *this = ::std::move(from);
  }

  inline DiscoveryVisitUrlInfo& operator=(DiscoveryVisitUrlInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscoveryVisitUrlInfo& default_instance();

  static inline const DiscoveryVisitUrlInfo* internal_default_instance() {
    return reinterpret_cast<const DiscoveryVisitUrlInfo*>(
               &_DiscoveryVisitUrlInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(DiscoveryVisitUrlInfo* other);
  friend void swap(DiscoveryVisitUrlInfo& a, DiscoveryVisitUrlInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscoveryVisitUrlInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DiscoveryVisitUrlInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DiscoveryVisitUrlInfo& from);
  void MergeFrom(const DiscoveryVisitUrlInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DiscoveryVisitUrlInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DiscoveryVisitUrlInfo_Source Source;
  static const Source KVAKIN =
    DiscoveryVisitUrlInfo_Source_KVAKIN;
  static const Source TELEMETRY =
    DiscoveryVisitUrlInfo_Source_TELEMETRY;
  static const Source INTERLEAVING_DOC_A =
    DiscoveryVisitUrlInfo_Source_INTERLEAVING_DOC_A;
  static const Source INTERLEAVING_DOC_B =
    DiscoveryVisitUrlInfo_Source_INTERLEAVING_DOC_B;
  static const Source WPIIDUMP =
    DiscoveryVisitUrlInfo_Source_WPIIDUMP;
  static inline bool Source_IsValid(int value) {
    return DiscoveryVisitUrlInfo_Source_IsValid(value);
  }
  static const Source Source_MIN =
    DiscoveryVisitUrlInfo_Source_Source_MIN;
  static const Source Source_MAX =
    DiscoveryVisitUrlInfo_Source_Source_MAX;
  static const int Source_ARRAYSIZE =
    DiscoveryVisitUrlInfo_Source_Source_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Source_descriptor() {
    return DiscoveryVisitUrlInfo_Source_descriptor();
  }
  static inline const ::std::string& Source_Name(Source value) {
    return DiscoveryVisitUrlInfo_Source_Name(value);
  }
  static inline bool Source_Parse(const ::std::string& name,
      Source* value) {
    return DiscoveryVisitUrlInfo_Source_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string url = 3;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 3;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required uint64 ts = 2;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 2;
  ::google::protobuf::uint64 ts() const;
  void set_ts(::google::protobuf::uint64 value);

  // required .ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.Source source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::ru::mail::go::webbase::blobs::DiscoveryVisitUrlInfo_Source source() const;
  void set_source(::ru::mail::go::webbase::blobs::DiscoveryVisitUrlInfo_Source value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo)
 private:
  void set_has_source();
  void clear_has_source();
  void set_has_ts();
  void clear_has_ts();
  void set_has_url();
  void clear_has_url();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::uint64 ts_;
  int source_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DarkImageLinks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.DarkImageLinks) */ {
 public:
  DarkImageLinks();
  virtual ~DarkImageLinks();

  DarkImageLinks(const DarkImageLinks& from);

  inline DarkImageLinks& operator=(const DarkImageLinks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DarkImageLinks(DarkImageLinks&& from) noexcept
    : DarkImageLinks() {
    *this = ::std::move(from);
  }

  inline DarkImageLinks& operator=(DarkImageLinks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DarkImageLinks& default_instance();

  static inline const DarkImageLinks* internal_default_instance() {
    return reinterpret_cast<const DarkImageLinks*>(
               &_DarkImageLinks_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(DarkImageLinks* other);
  friend void swap(DarkImageLinks& a, DarkImageLinks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DarkImageLinks* New() const PROTOBUF_FINAL { return New(NULL); }

  DarkImageLinks* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DarkImageLinks& from);
  void MergeFrom(const DarkImageLinks& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DarkImageLinks* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.DarkImageLinksItem items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::DarkImageLinksItem& items(int index) const;
  ::ru::mail::go::webbase::blobs::DarkImageLinksItem* mutable_items(int index);
  ::ru::mail::go::webbase::blobs::DarkImageLinksItem* add_items();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::DarkImageLinksItem >*
      mutable_items();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::DarkImageLinksItem >&
      items() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.DarkImageLinks)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::DarkImageLinksItem > items_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DarkImageLinksItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.DarkImageLinksItem) */ {
 public:
  DarkImageLinksItem();
  virtual ~DarkImageLinksItem();

  DarkImageLinksItem(const DarkImageLinksItem& from);

  inline DarkImageLinksItem& operator=(const DarkImageLinksItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DarkImageLinksItem(DarkImageLinksItem&& from) noexcept
    : DarkImageLinksItem() {
    *this = ::std::move(from);
  }

  inline DarkImageLinksItem& operator=(DarkImageLinksItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DarkImageLinksItem& default_instance();

  static inline const DarkImageLinksItem* internal_default_instance() {
    return reinterpret_cast<const DarkImageLinksItem*>(
               &_DarkImageLinksItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(DarkImageLinksItem* other);
  friend void swap(DarkImageLinksItem& a, DarkImageLinksItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DarkImageLinksItem* New() const PROTOBUF_FINAL { return New(NULL); }

  DarkImageLinksItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DarkImageLinksItem& from);
  void MergeFrom(const DarkImageLinksItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DarkImageLinksItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional string meta = 8;
  bool has_meta() const;
  void clear_meta();
  static const int kMetaFieldNumber = 8;
  const ::std::string& meta() const;
  void set_meta(const ::std::string& value);
  #if LANG_CXX11
  void set_meta(::std::string&& value);
  #endif
  void set_meta(const char* value);
  void set_meta(const char* value, size_t size);
  ::std::string* mutable_meta();
  ::std::string* release_meta();
  void set_allocated_meta(::std::string* meta);

  // required uint32 httpStatus = 2;
  bool has_httpstatus() const;
  void clear_httpstatus();
  static const int kHttpStatusFieldNumber = 2;
  ::google::protobuf::uint32 httpstatus() const;
  void set_httpstatus(::google::protobuf::uint32 value);

  // optional uint32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // optional int32 left = 5;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 5;
  ::google::protobuf::int32 left() const;
  void set_left(::google::protobuf::int32 value);

  // optional int32 top = 6;
  bool has_top() const;
  void clear_top();
  static const int kTopFieldNumber = 6;
  ::google::protobuf::int32 top() const;
  void set_top(::google::protobuf::int32 value);

  // optional int32 zindex = 7;
  bool has_zindex() const;
  void clear_zindex();
  static const int kZindexFieldNumber = 7;
  ::google::protobuf::int32 zindex() const;
  void set_zindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.DarkImageLinksItem)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_httpstatus();
  void clear_has_httpstatus();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_left();
  void clear_has_left();
  void set_has_top();
  void clear_has_top();
  void set_has_zindex();
  void clear_has_zindex();
  void set_has_meta();
  void clear_has_meta();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr meta_;
  ::google::protobuf::uint32 httpstatus_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::int32 left_;
  ::google::protobuf::int32 top_;
  ::google::protobuf::int32 zindex_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmbeddingData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.EmbeddingData) */ {
 public:
  EmbeddingData();
  virtual ~EmbeddingData();

  EmbeddingData(const EmbeddingData& from);

  inline EmbeddingData& operator=(const EmbeddingData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EmbeddingData(EmbeddingData&& from) noexcept
    : EmbeddingData() {
    *this = ::std::move(from);
  }

  inline EmbeddingData& operator=(EmbeddingData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmbeddingData& default_instance();

  static inline const EmbeddingData* internal_default_instance() {
    return reinterpret_cast<const EmbeddingData*>(
               &_EmbeddingData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(EmbeddingData* other);
  friend void swap(EmbeddingData& a, EmbeddingData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EmbeddingData* New() const PROTOBUF_FINAL { return New(NULL); }

  EmbeddingData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmbeddingData& from);
  void MergeFrom(const EmbeddingData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmbeddingData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required .qembedder.pb.Embedding embedding = 2;
  bool has_embedding() const;
  void clear_embedding();
  static const int kEmbeddingFieldNumber = 2;
  const ::qembedder::pb::Embedding& embedding() const;
  ::qembedder::pb::Embedding* mutable_embedding();
  ::qembedder::pb::Embedding* release_embedding();
  void set_allocated_embedding(::qembedder::pb::Embedding* embedding);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.EmbeddingData)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_embedding();
  void clear_has_embedding();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::qembedder::pb::Embedding* embedding_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImageHashItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.ImageHashItem) */ {
 public:
  ImageHashItem();
  virtual ~ImageHashItem();

  ImageHashItem(const ImageHashItem& from);

  inline ImageHashItem& operator=(const ImageHashItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImageHashItem(ImageHashItem&& from) noexcept
    : ImageHashItem() {
    *this = ::std::move(from);
  }

  inline ImageHashItem& operator=(ImageHashItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageHashItem& default_instance();

  static inline const ImageHashItem* internal_default_instance() {
    return reinterpret_cast<const ImageHashItem*>(
               &_ImageHashItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(ImageHashItem* other);
  friend void swap(ImageHashItem& a, ImageHashItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImageHashItem* New() const PROTOBUF_FINAL { return New(NULL); }

  ImageHashItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImageHashItem& from);
  void MergeFrom(const ImageHashItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImageHashItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ImageHashItem_Source Source;
  static const Source PARSER =
    ImageHashItem_Source_PARSER;
  static const Source INTERLEAVING_DOC_A =
    ImageHashItem_Source_INTERLEAVING_DOC_A;
  static const Source INTERLEAVING_DOC_B =
    ImageHashItem_Source_INTERLEAVING_DOC_B;
  static const Source WPIIDUMP =
    ImageHashItem_Source_WPIIDUMP;
  static inline bool Source_IsValid(int value) {
    return ImageHashItem_Source_IsValid(value);
  }
  static const Source Source_MIN =
    ImageHashItem_Source_Source_MIN;
  static const Source Source_MAX =
    ImageHashItem_Source_Source_MAX;
  static const int Source_ARRAYSIZE =
    ImageHashItem_Source_Source_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Source_descriptor() {
    return ImageHashItem_Source_descriptor();
  }
  static inline const ::std::string& Source_Name(Source value) {
    return ImageHashItem_Source_Name(value);
  }
  static inline bool Source_Parse(const ::std::string& name,
      Source* value) {
    return ImageHashItem_Source_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required uint32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // required .ru.mail.go.webbase.blobs.ImageHashItem.Source souce = 2;
  bool has_souce() const;
  void clear_souce();
  static const int kSouceFieldNumber = 2;
  ::ru::mail::go::webbase::blobs::ImageHashItem_Source souce() const;
  void set_souce(::ru::mail::go::webbase::blobs::ImageHashItem_Source value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.ImageHashItem)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_souce();
  void clear_has_souce();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  int souce_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VideoFrames : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.VideoFrames) */ {
 public:
  VideoFrames();
  virtual ~VideoFrames();

  VideoFrames(const VideoFrames& from);

  inline VideoFrames& operator=(const VideoFrames& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VideoFrames(VideoFrames&& from) noexcept
    : VideoFrames() {
    *this = ::std::move(from);
  }

  inline VideoFrames& operator=(VideoFrames&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoFrames& default_instance();

  static inline const VideoFrames* internal_default_instance() {
    return reinterpret_cast<const VideoFrames*>(
               &_VideoFrames_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void Swap(VideoFrames* other);
  friend void swap(VideoFrames& a, VideoFrames& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VideoFrames* New() const PROTOBUF_FINAL { return New(NULL); }

  VideoFrames* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VideoFrames& from);
  void MergeFrom(const VideoFrames& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VideoFrames* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ru.mail.go.webbase.blobs.ThumbDoc frames = 1;
  bool has_frames() const;
  void clear_frames();
  static const int kFramesFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::ThumbDoc& frames() const;
  ::ru::mail::go::webbase::blobs::ThumbDoc* mutable_frames();
  ::ru::mail::go::webbase::blobs::ThumbDoc* release_frames();
  void set_allocated_frames(::ru::mail::go::webbase::blobs::ThumbDoc* frames);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.VideoFrames)
 private:
  void set_has_frames();
  void clear_has_frames();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ru::mail::go::webbase::blobs::ThumbDoc* frames_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OCRSentence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.OCRSentence) */ {
 public:
  OCRSentence();
  virtual ~OCRSentence();

  OCRSentence(const OCRSentence& from);

  inline OCRSentence& operator=(const OCRSentence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OCRSentence(OCRSentence&& from) noexcept
    : OCRSentence() {
    *this = ::std::move(from);
  }

  inline OCRSentence& operator=(OCRSentence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OCRSentence& default_instance();

  static inline const OCRSentence* internal_default_instance() {
    return reinterpret_cast<const OCRSentence*>(
               &_OCRSentence_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    63;

  void Swap(OCRSentence* other);
  friend void swap(OCRSentence& a, OCRSentence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OCRSentence* New() const PROTOBUF_FINAL { return New(NULL); }

  OCRSentence* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OCRSentence& from);
  void MergeFrom(const OCRSentence& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OCRSentence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // required float score = 2;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  float score() const;
  void set_score(float value);

  // required int32 x = 3;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 3;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 4;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 4;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // required int32 w = 5;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 5;
  ::google::protobuf::int32 w() const;
  void set_w(::google::protobuf::int32 value);

  // required int32 h = 6;
  bool has_h() const;
  void clear_h();
  static const int kHFieldNumber = 6;
  ::google::protobuf::int32 h() const;
  void set_h(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.OCRSentence)
 private:
  void set_has_text();
  void clear_has_text();
  void set_has_score();
  void clear_has_score();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_w();
  void clear_has_w();
  void set_has_h();
  void clear_has_h();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  float score_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 w_;
  ::google::protobuf::int32 h_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OCRResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.webbase.blobs.OCRResult) */ {
 public:
  OCRResult();
  virtual ~OCRResult();

  OCRResult(const OCRResult& from);

  inline OCRResult& operator=(const OCRResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OCRResult(OCRResult&& from) noexcept
    : OCRResult() {
    *this = ::std::move(from);
  }

  inline OCRResult& operator=(OCRResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OCRResult& default_instance();

  static inline const OCRResult* internal_default_instance() {
    return reinterpret_cast<const OCRResult*>(
               &_OCRResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    64;

  void Swap(OCRResult* other);
  friend void swap(OCRResult& a, OCRResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OCRResult* New() const PROTOBUF_FINAL { return New(NULL); }

  OCRResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OCRResult& from);
  void MergeFrom(const OCRResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OCRResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ru.mail.go.webbase.blobs.OCRSentence sentences = 1;
  int sentences_size() const;
  void clear_sentences();
  static const int kSentencesFieldNumber = 1;
  const ::ru::mail::go::webbase::blobs::OCRSentence& sentences(int index) const;
  ::ru::mail::go::webbase::blobs::OCRSentence* mutable_sentences(int index);
  ::ru::mail::go::webbase::blobs::OCRSentence* add_sentences();
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::OCRSentence >*
      mutable_sentences();
  const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::OCRSentence >&
      sentences() const;

  // @@protoc_insertion_point(class_scope:ru.mail.go.webbase.blobs.OCRResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::OCRSentence > sentences_;
  friend struct protobuf_image_5fblobs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TextItem

// required string text = 1;
inline bool TextItem::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextItem::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextItem::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextItem::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& TextItem::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextItem.text)
  return text_.GetNoArena();
}
inline void TextItem::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextItem.text)
}
#if LANG_CXX11
inline void TextItem::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TextItem.text)
}
#endif
inline void TextItem::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TextItem.text)
}
inline void TextItem::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TextItem.text)
}
inline ::std::string* TextItem::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TextItem.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextItem::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TextItem.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextItem::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TextItem.text)
}

// optional string url = 2;
inline bool TextItem::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextItem::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextItem::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextItem::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& TextItem::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextItem.url)
  return url_.GetNoArena();
}
inline void TextItem::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextItem.url)
}
#if LANG_CXX11
inline void TextItem::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TextItem.url)
}
#endif
inline void TextItem::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TextItem.url)
}
inline void TextItem::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TextItem.url)
}
inline ::std::string* TextItem::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TextItem.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextItem::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TextItem.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextItem::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TextItem.url)
}

// repeated .ru.mail.go.webbase.blobs.Tag tags = 3;
inline int TextItem::tags_size() const {
  return tags_.size();
}
inline void TextItem::clear_tags() {
  tags_.Clear();
}
inline ::ru::mail::go::webbase::blobs::Tag TextItem::tags(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextItem.tags)
  return static_cast< ::ru::mail::go::webbase::blobs::Tag >(tags_.Get(index));
}
inline void TextItem::set_tags(int index, ::ru::mail::go::webbase::blobs::Tag value) {
  assert(::ru::mail::go::webbase::blobs::Tag_IsValid(value));
  tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextItem.tags)
}
inline void TextItem::add_tags(::ru::mail::go::webbase::blobs::Tag value) {
  assert(::ru::mail::go::webbase::blobs::Tag_IsValid(value));
  tags_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.TextItem.tags)
}
inline const ::google::protobuf::RepeatedField<int>&
TextItem::tags() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.TextItem.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedField<int>*
TextItem::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.TextItem.tags)
  return &tags_;
}

// optional bool from_alt = 4 [default = false];
inline bool TextItem::has_from_alt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TextItem::set_has_from_alt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TextItem::clear_has_from_alt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TextItem::clear_from_alt() {
  from_alt_ = false;
  clear_has_from_alt();
}
inline bool TextItem::from_alt() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextItem.from_alt)
  return from_alt_;
}
inline void TextItem::set_from_alt(bool value) {
  set_has_from_alt();
  from_alt_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextItem.from_alt)
}

// optional string title = 5;
inline bool TextItem::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextItem::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextItem::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextItem::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_title();
}
inline const ::std::string& TextItem::title() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextItem.title)
  return title_.GetNoArena();
}
inline void TextItem::set_title(const ::std::string& value) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextItem.title)
}
#if LANG_CXX11
inline void TextItem::set_title(::std::string&& value) {
  set_has_title();
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TextItem.title)
}
#endif
inline void TextItem::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TextItem.title)
}
inline void TextItem::set_title(const char* value, size_t size) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TextItem.title)
}
inline ::std::string* TextItem::mutable_title() {
  set_has_title();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TextItem.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextItem::release_title() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TextItem.title)
  clear_has_title();
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextItem::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    set_has_title();
  } else {
    clear_has_title();
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TextItem.title)
}

// optional string urlkey = 6;
inline bool TextItem::has_urlkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TextItem::set_has_urlkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TextItem::clear_has_urlkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TextItem::clear_urlkey() {
  urlkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_urlkey();
}
inline const ::std::string& TextItem::urlkey() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextItem.urlkey)
  return urlkey_.GetNoArena();
}
inline void TextItem::set_urlkey(const ::std::string& value) {
  set_has_urlkey();
  urlkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextItem.urlkey)
}
#if LANG_CXX11
inline void TextItem::set_urlkey(::std::string&& value) {
  set_has_urlkey();
  urlkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TextItem.urlkey)
}
#endif
inline void TextItem::set_urlkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_urlkey();
  urlkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TextItem.urlkey)
}
inline void TextItem::set_urlkey(const char* value, size_t size) {
  set_has_urlkey();
  urlkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TextItem.urlkey)
}
inline ::std::string* TextItem::mutable_urlkey() {
  set_has_urlkey();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TextItem.urlkey)
  return urlkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextItem::release_urlkey() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TextItem.urlkey)
  clear_has_urlkey();
  return urlkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextItem::set_allocated_urlkey(::std::string* urlkey) {
  if (urlkey != NULL) {
    set_has_urlkey();
  } else {
    clear_has_urlkey();
  }
  urlkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), urlkey);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TextItem.urlkey)
}

// -------------------------------------------------------------------

// ExplicitDescription

// required .ru.mail.go.webbase.blobs.ParserID pid = 1;
inline bool ExplicitDescription::has_pid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExplicitDescription::set_has_pid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExplicitDescription::clear_has_pid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExplicitDescription::clear_pid() {
  pid_ = 0;
  clear_has_pid();
}
inline ::ru::mail::go::webbase::blobs::ParserID ExplicitDescription::pid() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ExplicitDescription.pid)
  return static_cast< ::ru::mail::go::webbase::blobs::ParserID >(pid_);
}
inline void ExplicitDescription::set_pid(::ru::mail::go::webbase::blobs::ParserID value) {
  assert(::ru::mail::go::webbase::blobs::ParserID_IsValid(value));
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ExplicitDescription.pid)
}

// optional string caption = 2;
inline bool ExplicitDescription::has_caption() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExplicitDescription::set_has_caption() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExplicitDescription::clear_has_caption() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExplicitDescription::clear_caption() {
  caption_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_caption();
}
inline const ::std::string& ExplicitDescription::caption() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ExplicitDescription.caption)
  return caption_.GetNoArena();
}
inline void ExplicitDescription::set_caption(const ::std::string& value) {
  set_has_caption();
  caption_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ExplicitDescription.caption)
}
#if LANG_CXX11
inline void ExplicitDescription::set_caption(::std::string&& value) {
  set_has_caption();
  caption_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ExplicitDescription.caption)
}
#endif
inline void ExplicitDescription::set_caption(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_caption();
  caption_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ExplicitDescription.caption)
}
inline void ExplicitDescription::set_caption(const char* value, size_t size) {
  set_has_caption();
  caption_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ExplicitDescription.caption)
}
inline ::std::string* ExplicitDescription::mutable_caption() {
  set_has_caption();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ExplicitDescription.caption)
  return caption_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExplicitDescription::release_caption() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ExplicitDescription.caption)
  clear_has_caption();
  return caption_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExplicitDescription::set_allocated_caption(::std::string* caption) {
  if (caption != NULL) {
    set_has_caption();
  } else {
    clear_has_caption();
  }
  caption_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), caption);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ExplicitDescription.caption)
}

// optional string author = 3;
inline bool ExplicitDescription::has_author() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExplicitDescription::set_has_author() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExplicitDescription::clear_has_author() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExplicitDescription::clear_author() {
  author_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_author();
}
inline const ::std::string& ExplicitDescription::author() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ExplicitDescription.author)
  return author_.GetNoArena();
}
inline void ExplicitDescription::set_author(const ::std::string& value) {
  set_has_author();
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ExplicitDescription.author)
}
#if LANG_CXX11
inline void ExplicitDescription::set_author(::std::string&& value) {
  set_has_author();
  author_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ExplicitDescription.author)
}
#endif
inline void ExplicitDescription::set_author(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_author();
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ExplicitDescription.author)
}
inline void ExplicitDescription::set_author(const char* value, size_t size) {
  set_has_author();
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ExplicitDescription.author)
}
inline ::std::string* ExplicitDescription::mutable_author() {
  set_has_author();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ExplicitDescription.author)
  return author_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExplicitDescription::release_author() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ExplicitDescription.author)
  clear_has_author();
  return author_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExplicitDescription::set_allocated_author(::std::string* author) {
  if (author != NULL) {
    set_has_author();
  } else {
    clear_has_author();
  }
  author_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ExplicitDescription.author)
}

// optional string path = 4;
inline bool ExplicitDescription::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExplicitDescription::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExplicitDescription::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExplicitDescription::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& ExplicitDescription::path() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ExplicitDescription.path)
  return path_.GetNoArena();
}
inline void ExplicitDescription::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ExplicitDescription.path)
}
#if LANG_CXX11
inline void ExplicitDescription::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ExplicitDescription.path)
}
#endif
inline void ExplicitDescription::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ExplicitDescription.path)
}
inline void ExplicitDescription::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ExplicitDescription.path)
}
inline ::std::string* ExplicitDescription::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ExplicitDescription.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExplicitDescription::release_path() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ExplicitDescription.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExplicitDescription::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ExplicitDescription.path)
}

// repeated string keywords = 5;
inline int ExplicitDescription::keywords_size() const {
  return keywords_.size();
}
inline void ExplicitDescription::clear_keywords() {
  keywords_.Clear();
}
inline const ::std::string& ExplicitDescription::keywords(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
  return keywords_.Get(index);
}
inline ::std::string* ExplicitDescription::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
  return keywords_.Mutable(index);
}
inline void ExplicitDescription::set_keywords(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
  keywords_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ExplicitDescription::set_keywords(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
  keywords_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ExplicitDescription::set_keywords(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
}
inline void ExplicitDescription::set_keywords(int index, const char* value, size_t size) {
  keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
}
inline ::std::string* ExplicitDescription::add_keywords() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
  return keywords_.Add();
}
inline void ExplicitDescription::add_keywords(const ::std::string& value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
}
#if LANG_CXX11
inline void ExplicitDescription::add_keywords(::std::string&& value) {
  keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
}
#endif
inline void ExplicitDescription::add_keywords(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
}
inline void ExplicitDescription::add_keywords(const char* value, size_t size) {
  keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExplicitDescription::keywords() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExplicitDescription::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ExplicitDescription.keywords)
  return &keywords_;
}

// optional string imgUrl = 6;
inline bool ExplicitDescription::has_imgurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExplicitDescription::set_has_imgurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExplicitDescription::clear_has_imgurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExplicitDescription::clear_imgurl() {
  imgurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imgurl();
}
inline const ::std::string& ExplicitDescription::imgurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ExplicitDescription.imgUrl)
  return imgurl_.GetNoArena();
}
inline void ExplicitDescription::set_imgurl(const ::std::string& value) {
  set_has_imgurl();
  imgurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ExplicitDescription.imgUrl)
}
#if LANG_CXX11
inline void ExplicitDescription::set_imgurl(::std::string&& value) {
  set_has_imgurl();
  imgurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ExplicitDescription.imgUrl)
}
#endif
inline void ExplicitDescription::set_imgurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imgurl();
  imgurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ExplicitDescription.imgUrl)
}
inline void ExplicitDescription::set_imgurl(const char* value, size_t size) {
  set_has_imgurl();
  imgurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ExplicitDescription.imgUrl)
}
inline ::std::string* ExplicitDescription::mutable_imgurl() {
  set_has_imgurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ExplicitDescription.imgUrl)
  return imgurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExplicitDescription::release_imgurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ExplicitDescription.imgUrl)
  clear_has_imgurl();
  return imgurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExplicitDescription::set_allocated_imgurl(::std::string* imgurl) {
  if (imgurl != NULL) {
    set_has_imgurl();
  } else {
    clear_has_imgurl();
  }
  imgurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imgurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ExplicitDescription.imgUrl)
}

// optional string htmlUrl = 7;
inline bool ExplicitDescription::has_htmlurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExplicitDescription::set_has_htmlurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExplicitDescription::clear_has_htmlurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExplicitDescription::clear_htmlurl() {
  htmlurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_htmlurl();
}
inline const ::std::string& ExplicitDescription::htmlurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ExplicitDescription.htmlUrl)
  return htmlurl_.GetNoArena();
}
inline void ExplicitDescription::set_htmlurl(const ::std::string& value) {
  set_has_htmlurl();
  htmlurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ExplicitDescription.htmlUrl)
}
#if LANG_CXX11
inline void ExplicitDescription::set_htmlurl(::std::string&& value) {
  set_has_htmlurl();
  htmlurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ExplicitDescription.htmlUrl)
}
#endif
inline void ExplicitDescription::set_htmlurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_htmlurl();
  htmlurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ExplicitDescription.htmlUrl)
}
inline void ExplicitDescription::set_htmlurl(const char* value, size_t size) {
  set_has_htmlurl();
  htmlurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ExplicitDescription.htmlUrl)
}
inline ::std::string* ExplicitDescription::mutable_htmlurl() {
  set_has_htmlurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ExplicitDescription.htmlUrl)
  return htmlurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExplicitDescription::release_htmlurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ExplicitDescription.htmlUrl)
  clear_has_htmlurl();
  return htmlurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExplicitDescription::set_allocated_htmlurl(::std::string* htmlurl) {
  if (htmlurl != NULL) {
    set_has_htmlurl();
  } else {
    clear_has_htmlurl();
  }
  htmlurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), htmlurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ExplicitDescription.htmlUrl)
}

// -------------------------------------------------------------------

// ImageLinks

// repeated .ru.mail.go.webbase.blobs.ImageLinksItem links = 1;
inline int ImageLinks::links_size() const {
  return links_.size();
}
inline void ImageLinks::clear_links() {
  links_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::ImageLinksItem& ImageLinks::links(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageLinks.links)
  return links_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::ImageLinksItem* ImageLinks::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageLinks.links)
  return links_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::ImageLinksItem* ImageLinks::add_links() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ImageLinks.links)
  return links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageLinksItem >*
ImageLinks::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ImageLinks.links)
  return &links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageLinksItem >&
ImageLinks::links() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ImageLinks.links)
  return links_;
}

// -------------------------------------------------------------------

// ImageLinksItem

// required string url = 1;
inline bool ImageLinksItem::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageLinksItem::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageLinksItem::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageLinksItem::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& ImageLinksItem::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageLinksItem.url)
  return url_.GetNoArena();
}
inline void ImageLinksItem::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageLinksItem.url)
}
#if LANG_CXX11
inline void ImageLinksItem::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageLinksItem.url)
}
#endif
inline void ImageLinksItem::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageLinksItem.url)
}
inline void ImageLinksItem::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageLinksItem.url)
}
inline ::std::string* ImageLinksItem::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageLinksItem.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageLinksItem::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageLinksItem.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageLinksItem::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageLinksItem.url)
}

// -------------------------------------------------------------------

// ImagePropsWithUrl

// required string url = 1;
inline bool ImagePropsWithUrl::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImagePropsWithUrl::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImagePropsWithUrl::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImagePropsWithUrl::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& ImagePropsWithUrl::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImagePropsWithUrl.url)
  return url_.GetNoArena();
}
inline void ImagePropsWithUrl::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImagePropsWithUrl.url)
}
#if LANG_CXX11
inline void ImagePropsWithUrl::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImagePropsWithUrl.url)
}
#endif
inline void ImagePropsWithUrl::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImagePropsWithUrl.url)
}
inline void ImagePropsWithUrl::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImagePropsWithUrl.url)
}
inline ::std::string* ImagePropsWithUrl::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImagePropsWithUrl.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImagePropsWithUrl::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImagePropsWithUrl.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImagePropsWithUrl::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImagePropsWithUrl.url)
}

// optional .ru.mail.go.webbase.blobs.ImageProps imageProps = 2;
inline bool ImagePropsWithUrl::has_imageprops() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImagePropsWithUrl::set_has_imageprops() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImagePropsWithUrl::clear_has_imageprops() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImagePropsWithUrl::clear_imageprops() {
  if (imageprops_ != NULL) imageprops_->::ru::mail::go::webbase::blobs::ImageProps::Clear();
  clear_has_imageprops();
}
inline const ::ru::mail::go::webbase::blobs::ImageProps& ImagePropsWithUrl::imageprops() const {
  const ::ru::mail::go::webbase::blobs::ImageProps* p = imageprops_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImagePropsWithUrl.imageProps)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ImageProps*>(
      &::ru::mail::go::webbase::blobs::_ImageProps_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ImageProps* ImagePropsWithUrl::mutable_imageprops() {
  set_has_imageprops();
  if (imageprops_ == NULL) {
    imageprops_ = new ::ru::mail::go::webbase::blobs::ImageProps;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImagePropsWithUrl.imageProps)
  return imageprops_;
}
inline ::ru::mail::go::webbase::blobs::ImageProps* ImagePropsWithUrl::release_imageprops() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImagePropsWithUrl.imageProps)
  clear_has_imageprops();
  ::ru::mail::go::webbase::blobs::ImageProps* temp = imageprops_;
  imageprops_ = NULL;
  return temp;
}
inline void ImagePropsWithUrl::set_allocated_imageprops(::ru::mail::go::webbase::blobs::ImageProps* imageprops) {
  delete imageprops_;
  imageprops_ = imageprops;
  if (imageprops) {
    set_has_imageprops();
  } else {
    clear_has_imageprops();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImagePropsWithUrl.imageProps)
}

// -------------------------------------------------------------------

// ImageItem

// required string url = 1;
inline bool ImageItem::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageItem::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageItem::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageItem::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& ImageItem::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageItem.url)
  return url_.GetNoArena();
}
inline void ImageItem::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageItem.url)
}
#if LANG_CXX11
inline void ImageItem::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageItem.url)
}
#endif
inline void ImageItem::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageItem.url)
}
inline void ImageItem::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageItem.url)
}
inline ::std::string* ImageItem::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageItem.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageItem::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageItem.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageItem::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageItem.url)
}

// optional string alt = 2;
inline bool ImageItem::has_alt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageItem::set_has_alt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageItem::clear_has_alt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageItem::clear_alt() {
  alt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alt();
}
inline const ::std::string& ImageItem::alt() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageItem.alt)
  return alt_.GetNoArena();
}
inline void ImageItem::set_alt(const ::std::string& value) {
  set_has_alt();
  alt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageItem.alt)
}
#if LANG_CXX11
inline void ImageItem::set_alt(::std::string&& value) {
  set_has_alt();
  alt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageItem.alt)
}
#endif
inline void ImageItem::set_alt(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_alt();
  alt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageItem.alt)
}
inline void ImageItem::set_alt(const char* value, size_t size) {
  set_has_alt();
  alt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageItem.alt)
}
inline ::std::string* ImageItem::mutable_alt() {
  set_has_alt();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageItem.alt)
  return alt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageItem::release_alt() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageItem.alt)
  clear_has_alt();
  return alt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageItem::set_allocated_alt(::std::string* alt) {
  if (alt != NULL) {
    set_has_alt();
  } else {
    clear_has_alt();
  }
  alt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alt);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageItem.alt)
}

// optional uint32 declaredWidth = 3;
inline bool ImageItem::has_declaredwidth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageItem::set_has_declaredwidth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageItem::clear_has_declaredwidth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageItem::clear_declaredwidth() {
  declaredwidth_ = 0u;
  clear_has_declaredwidth();
}
inline ::google::protobuf::uint32 ImageItem::declaredwidth() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageItem.declaredWidth)
  return declaredwidth_;
}
inline void ImageItem::set_declaredwidth(::google::protobuf::uint32 value) {
  set_has_declaredwidth();
  declaredwidth_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageItem.declaredWidth)
}

// optional uint32 declaredHeight = 4;
inline bool ImageItem::has_declaredheight() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageItem::set_has_declaredheight() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageItem::clear_has_declaredheight() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageItem::clear_declaredheight() {
  declaredheight_ = 0u;
  clear_has_declaredheight();
}
inline ::google::protobuf::uint32 ImageItem::declaredheight() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageItem.declaredHeight)
  return declaredheight_;
}
inline void ImageItem::set_declaredheight(::google::protobuf::uint32 value) {
  set_has_declaredheight();
  declaredheight_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageItem.declaredHeight)
}

// repeated .ru.mail.go.webbase.blobs.ExplicitDescription descrs = 5;
inline int ImageItem::descrs_size() const {
  return descrs_.size();
}
inline void ImageItem::clear_descrs() {
  descrs_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::ExplicitDescription& ImageItem::descrs(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageItem.descrs)
  return descrs_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::ExplicitDescription* ImageItem::mutable_descrs(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageItem.descrs)
  return descrs_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::ExplicitDescription* ImageItem::add_descrs() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ImageItem.descrs)
  return descrs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ExplicitDescription >*
ImageItem::mutable_descrs() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ImageItem.descrs)
  return &descrs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ExplicitDescription >&
ImageItem::descrs() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ImageItem.descrs)
  return descrs_;
}

// optional string title = 6;
inline bool ImageItem::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageItem::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageItem::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageItem::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_title();
}
inline const ::std::string& ImageItem::title() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageItem.title)
  return title_.GetNoArena();
}
inline void ImageItem::set_title(const ::std::string& value) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageItem.title)
}
#if LANG_CXX11
inline void ImageItem::set_title(::std::string&& value) {
  set_has_title();
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageItem.title)
}
#endif
inline void ImageItem::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageItem.title)
}
inline void ImageItem::set_title(const char* value, size_t size) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageItem.title)
}
inline ::std::string* ImageItem::mutable_title() {
  set_has_title();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageItem.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageItem::release_title() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageItem.title)
  clear_has_title();
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageItem::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    set_has_title();
  } else {
    clear_has_title();
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageItem.title)
}

// optional string urlkey = 7;
inline bool ImageItem::has_urlkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageItem::set_has_urlkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageItem::clear_has_urlkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageItem::clear_urlkey() {
  urlkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_urlkey();
}
inline const ::std::string& ImageItem::urlkey() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageItem.urlkey)
  return urlkey_.GetNoArena();
}
inline void ImageItem::set_urlkey(const ::std::string& value) {
  set_has_urlkey();
  urlkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageItem.urlkey)
}
#if LANG_CXX11
inline void ImageItem::set_urlkey(::std::string&& value) {
  set_has_urlkey();
  urlkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageItem.urlkey)
}
#endif
inline void ImageItem::set_urlkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_urlkey();
  urlkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageItem.urlkey)
}
inline void ImageItem::set_urlkey(const char* value, size_t size) {
  set_has_urlkey();
  urlkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageItem.urlkey)
}
inline ::std::string* ImageItem::mutable_urlkey() {
  set_has_urlkey();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageItem.urlkey)
  return urlkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageItem::release_urlkey() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageItem.urlkey)
  clear_has_urlkey();
  return urlkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageItem::set_allocated_urlkey(::std::string* urlkey) {
  if (urlkey != NULL) {
    set_has_urlkey();
  } else {
    clear_has_urlkey();
  }
  urlkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), urlkey);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageItem.urlkey)
}

// -------------------------------------------------------------------

// VarItem

// optional .ru.mail.go.webbase.blobs.ImageItem img = 1;
inline bool VarItem::has_img() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VarItem::set_has_img() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VarItem::clear_has_img() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VarItem::clear_img() {
  if (img_ != NULL) img_->::ru::mail::go::webbase::blobs::ImageItem::Clear();
  clear_has_img();
}
inline const ::ru::mail::go::webbase::blobs::ImageItem& VarItem::img() const {
  const ::ru::mail::go::webbase::blobs::ImageItem* p = img_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.VarItem.img)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ImageItem*>(
      &::ru::mail::go::webbase::blobs::_ImageItem_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ImageItem* VarItem::mutable_img() {
  set_has_img();
  if (img_ == NULL) {
    img_ = new ::ru::mail::go::webbase::blobs::ImageItem;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.VarItem.img)
  return img_;
}
inline ::ru::mail::go::webbase::blobs::ImageItem* VarItem::release_img() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.VarItem.img)
  clear_has_img();
  ::ru::mail::go::webbase::blobs::ImageItem* temp = img_;
  img_ = NULL;
  return temp;
}
inline void VarItem::set_allocated_img(::ru::mail::go::webbase::blobs::ImageItem* img) {
  delete img_;
  img_ = img;
  if (img) {
    set_has_img();
  } else {
    clear_has_img();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.VarItem.img)
}

// optional .ru.mail.go.webbase.blobs.TextItem txt = 2;
inline bool VarItem::has_txt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VarItem::set_has_txt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VarItem::clear_has_txt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VarItem::clear_txt() {
  if (txt_ != NULL) txt_->::ru::mail::go::webbase::blobs::TextItem::Clear();
  clear_has_txt();
}
inline const ::ru::mail::go::webbase::blobs::TextItem& VarItem::txt() const {
  const ::ru::mail::go::webbase::blobs::TextItem* p = txt_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.VarItem.txt)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::TextItem*>(
      &::ru::mail::go::webbase::blobs::_TextItem_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::TextItem* VarItem::mutable_txt() {
  set_has_txt();
  if (txt_ == NULL) {
    txt_ = new ::ru::mail::go::webbase::blobs::TextItem;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.VarItem.txt)
  return txt_;
}
inline ::ru::mail::go::webbase::blobs::TextItem* VarItem::release_txt() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.VarItem.txt)
  clear_has_txt();
  ::ru::mail::go::webbase::blobs::TextItem* temp = txt_;
  txt_ = NULL;
  return temp;
}
inline void VarItem::set_allocated_txt(::ru::mail::go::webbase::blobs::TextItem* txt) {
  delete txt_;
  txt_ = txt;
  if (txt) {
    set_has_txt();
  } else {
    clear_has_txt();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.VarItem.txt)
}

// repeated .ru.mail.go.webbase.blobs.VarItem children = 3;
inline int VarItem::children_size() const {
  return children_.size();
}
inline void VarItem::clear_children() {
  children_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::VarItem& VarItem::children(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.VarItem.children)
  return children_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::VarItem* VarItem::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.VarItem.children)
  return children_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::VarItem* VarItem::add_children() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.VarItem.children)
  return children_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::VarItem >*
VarItem::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.VarItem.children)
  return &children_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::VarItem >&
VarItem::children() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.VarItem.children)
  return children_;
}

// optional .ru.mail.go.webbase.blobs.Tag tag = 4;
inline bool VarItem::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VarItem::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VarItem::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VarItem::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::ru::mail::go::webbase::blobs::Tag VarItem::tag() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.VarItem.tag)
  return static_cast< ::ru::mail::go::webbase::blobs::Tag >(tag_);
}
inline void VarItem::set_tag(::ru::mail::go::webbase::blobs::Tag value) {
  assert(::ru::mail::go::webbase::blobs::Tag_IsValid(value));
  set_has_tag();
  tag_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.VarItem.tag)
}

// -------------------------------------------------------------------

// MetaAttr

// required string name = 1;
inline bool MetaAttr::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaAttr::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaAttr::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaAttr::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MetaAttr::name() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MetaAttr.name)
  return name_.GetNoArena();
}
inline void MetaAttr::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.MetaAttr.name)
}
#if LANG_CXX11
inline void MetaAttr::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.MetaAttr.name)
}
#endif
inline void MetaAttr::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.MetaAttr.name)
}
inline void MetaAttr::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.MetaAttr.name)
}
inline ::std::string* MetaAttr::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.MetaAttr.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetaAttr::release_name() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.MetaAttr.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetaAttr::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.MetaAttr.name)
}

// required string value = 2;
inline bool MetaAttr::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaAttr::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaAttr::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaAttr::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& MetaAttr::value() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MetaAttr.value)
  return value_.GetNoArena();
}
inline void MetaAttr::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.MetaAttr.value)
}
#if LANG_CXX11
inline void MetaAttr::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.MetaAttr.value)
}
#endif
inline void MetaAttr::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.MetaAttr.value)
}
inline void MetaAttr::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.MetaAttr.value)
}
inline ::std::string* MetaAttr::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.MetaAttr.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetaAttr::release_value() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.MetaAttr.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetaAttr::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.MetaAttr.value)
}

// -------------------------------------------------------------------

// MetaItem

// repeated .ru.mail.go.webbase.blobs.MetaAttr attrs = 1;
inline int MetaItem::attrs_size() const {
  return attrs_.size();
}
inline void MetaItem::clear_attrs() {
  attrs_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::MetaAttr& MetaItem::attrs(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MetaItem.attrs)
  return attrs_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::MetaAttr* MetaItem::mutable_attrs(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.MetaItem.attrs)
  return attrs_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::MetaAttr* MetaItem::add_attrs() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.MetaItem.attrs)
  return attrs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::MetaAttr >*
MetaItem::mutable_attrs() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.MetaItem.attrs)
  return &attrs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::MetaAttr >&
MetaItem::attrs() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.MetaItem.attrs)
  return attrs_;
}

// -------------------------------------------------------------------

// CustomItem

// required string url = 1;
inline bool CustomItem::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustomItem::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CustomItem::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CustomItem::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& CustomItem::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CustomItem.url)
  return url_.GetNoArena();
}
inline void CustomItem::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CustomItem.url)
}
#if LANG_CXX11
inline void CustomItem::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.CustomItem.url)
}
#endif
inline void CustomItem::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.CustomItem.url)
}
inline void CustomItem::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.CustomItem.url)
}
inline ::std::string* CustomItem::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CustomItem.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomItem::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.CustomItem.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomItem::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.CustomItem.url)
}

// repeated string texts = 2;
inline int CustomItem::texts_size() const {
  return texts_.size();
}
inline void CustomItem::clear_texts() {
  texts_.Clear();
}
inline const ::std::string& CustomItem::texts(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.CustomItem.texts)
  return texts_.Get(index);
}
inline ::std::string* CustomItem::mutable_texts(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.CustomItem.texts)
  return texts_.Mutable(index);
}
inline void CustomItem::set_texts(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CustomItem.texts)
  texts_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CustomItem::set_texts(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.CustomItem.texts)
  texts_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CustomItem::set_texts(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  texts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.CustomItem.texts)
}
inline void CustomItem::set_texts(int index, const char* value, size_t size) {
  texts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.CustomItem.texts)
}
inline ::std::string* CustomItem::add_texts() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.CustomItem.texts)
  return texts_.Add();
}
inline void CustomItem::add_texts(const ::std::string& value) {
  texts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.CustomItem.texts)
}
#if LANG_CXX11
inline void CustomItem::add_texts(::std::string&& value) {
  texts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.CustomItem.texts)
}
#endif
inline void CustomItem::add_texts(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  texts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.CustomItem.texts)
}
inline void CustomItem::add_texts(const char* value, size_t size) {
  texts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.CustomItem.texts)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CustomItem::texts() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.CustomItem.texts)
  return texts_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CustomItem::mutable_texts() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.CustomItem.texts)
  return &texts_;
}

// -------------------------------------------------------------------

// GifestData

// repeated .ru.mail.go.webbase.blobs.CustomItem items = 1;
inline int GifestData::items_size() const {
  return items_.size();
}
inline void GifestData::clear_items() {
  items_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::CustomItem& GifestData::items(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.GifestData.items)
  return items_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::CustomItem* GifestData::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.GifestData.items)
  return items_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::CustomItem* GifestData::add_items() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.GifestData.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::CustomItem >*
GifestData::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.GifestData.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::CustomItem >&
GifestData::items() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.GifestData.items)
  return items_;
}

// -------------------------------------------------------------------

// HtmlPage

// required uint32 porn = 1;
inline bool HtmlPage::has_porn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HtmlPage::set_has_porn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HtmlPage::clear_has_porn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HtmlPage::clear_porn() {
  porn_ = 0u;
  clear_has_porn();
}
inline ::google::protobuf::uint32 HtmlPage::porn() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.HtmlPage.porn)
  return porn_;
}
inline void HtmlPage::set_porn(::google::protobuf::uint32 value) {
  set_has_porn();
  porn_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.HtmlPage.porn)
}

// repeated .ru.mail.go.webbase.blobs.VarItem items = 3;
inline int HtmlPage::items_size() const {
  return items_.size();
}
inline void HtmlPage::clear_items() {
  items_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::VarItem& HtmlPage::items(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.HtmlPage.items)
  return items_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::VarItem* HtmlPage::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.HtmlPage.items)
  return items_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::VarItem* HtmlPage::add_items() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.HtmlPage.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::VarItem >*
HtmlPage::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.HtmlPage.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::VarItem >&
HtmlPage::items() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.HtmlPage.items)
  return items_;
}

// optional .ru.mail.go.webbase.blobs.FeatureList features_list = 4;
inline bool HtmlPage::has_features_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HtmlPage::set_has_features_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HtmlPage::clear_has_features_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HtmlPage::clear_features_list() {
  if (features_list_ != NULL) features_list_->::ru::mail::go::webbase::blobs::FeatureList::Clear();
  clear_has_features_list();
}
inline const ::ru::mail::go::webbase::blobs::FeatureList& HtmlPage::features_list() const {
  const ::ru::mail::go::webbase::blobs::FeatureList* p = features_list_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.HtmlPage.features_list)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::FeatureList*>(
      &::ru::mail::go::webbase::blobs::_FeatureList_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::FeatureList* HtmlPage::mutable_features_list() {
  set_has_features_list();
  if (features_list_ == NULL) {
    features_list_ = new ::ru::mail::go::webbase::blobs::FeatureList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.HtmlPage.features_list)
  return features_list_;
}
inline ::ru::mail::go::webbase::blobs::FeatureList* HtmlPage::release_features_list() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.HtmlPage.features_list)
  clear_has_features_list();
  ::ru::mail::go::webbase::blobs::FeatureList* temp = features_list_;
  features_list_ = NULL;
  return temp;
}
inline void HtmlPage::set_allocated_features_list(::ru::mail::go::webbase::blobs::FeatureList* features_list) {
  delete features_list_;
  features_list_ = features_list;
  if (features_list) {
    set_has_features_list();
  } else {
    clear_has_features_list();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.HtmlPage.features_list)
}

// repeated .ru.mail.go.webbase.blobs.MetaItem meta_items = 5;
inline int HtmlPage::meta_items_size() const {
  return meta_items_.size();
}
inline void HtmlPage::clear_meta_items() {
  meta_items_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::MetaItem& HtmlPage::meta_items(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.HtmlPage.meta_items)
  return meta_items_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::MetaItem* HtmlPage::mutable_meta_items(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.HtmlPage.meta_items)
  return meta_items_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::MetaItem* HtmlPage::add_meta_items() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.HtmlPage.meta_items)
  return meta_items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::MetaItem >*
HtmlPage::mutable_meta_items() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.HtmlPage.meta_items)
  return &meta_items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::MetaItem >&
HtmlPage::meta_items() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.HtmlPage.meta_items)
  return meta_items_;
}

// -------------------------------------------------------------------

// ParseHtmlInput

// required string url = 1;
inline bool ParseHtmlInput::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParseHtmlInput::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParseHtmlInput::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParseHtmlInput::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& ParseHtmlInput::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParseHtmlInput.url)
  return url_.GetNoArena();
}
inline void ParseHtmlInput::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParseHtmlInput.url)
}
#if LANG_CXX11
inline void ParseHtmlInput::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParseHtmlInput.url)
}
#endif
inline void ParseHtmlInput::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParseHtmlInput.url)
}
inline void ParseHtmlInput::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParseHtmlInput.url)
}
inline ::std::string* ParseHtmlInput::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParseHtmlInput.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParseHtmlInput::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParseHtmlInput.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParseHtmlInput::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParseHtmlInput.url)
}

// required bytes content = 2;
inline bool ParseHtmlInput::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParseHtmlInput::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParseHtmlInput::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParseHtmlInput::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_content();
}
inline const ::std::string& ParseHtmlInput::content() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParseHtmlInput.content)
  return content_.GetNoArena();
}
inline void ParseHtmlInput::set_content(const ::std::string& value) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParseHtmlInput.content)
}
#if LANG_CXX11
inline void ParseHtmlInput::set_content(::std::string&& value) {
  set_has_content();
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ParseHtmlInput.content)
}
#endif
inline void ParseHtmlInput::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ParseHtmlInput.content)
}
inline void ParseHtmlInput::set_content(const void* value, size_t size) {
  set_has_content();
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ParseHtmlInput.content)
}
inline ::std::string* ParseHtmlInput::mutable_content() {
  set_has_content();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ParseHtmlInput.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParseHtmlInput::release_content() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ParseHtmlInput.content)
  clear_has_content();
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParseHtmlInput::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    set_has_content();
  } else {
    clear_has_content();
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ParseHtmlInput.content)
}

// required .ru.mail.go.webbase.blobs.Encoding enc = 3;
inline bool ParseHtmlInput::has_enc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParseHtmlInput::set_has_enc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParseHtmlInput::clear_has_enc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParseHtmlInput::clear_enc() {
  enc_ = 0;
  clear_has_enc();
}
inline ::ru::mail::go::webbase::blobs::Encoding ParseHtmlInput::enc() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParseHtmlInput.enc)
  return static_cast< ::ru::mail::go::webbase::blobs::Encoding >(enc_);
}
inline void ParseHtmlInput::set_enc(::ru::mail::go::webbase::blobs::Encoding value) {
  assert(::ru::mail::go::webbase::blobs::Encoding_IsValid(value));
  set_has_enc();
  enc_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParseHtmlInput.enc)
}

// -------------------------------------------------------------------

// BOW

// repeated uint32 words = 1;
inline int BOW::words_size() const {
  return words_.size();
}
inline void BOW::clear_words() {
  words_.Clear();
}
inline ::google::protobuf::uint32 BOW::words(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BOW.words)
  return words_.Get(index);
}
inline void BOW::set_words(int index, ::google::protobuf::uint32 value) {
  words_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BOW.words)
}
inline void BOW::add_words(::google::protobuf::uint32 value) {
  words_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.BOW.words)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BOW::words() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.BOW.words)
  return words_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BOW::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.BOW.words)
  return &words_;
}

// -------------------------------------------------------------------

// DCT

// repeated float values = 1;
inline int DCT::values_size() const {
  return values_.size();
}
inline void DCT::clear_values() {
  values_.Clear();
}
inline float DCT::values(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DCT.values)
  return values_.Get(index);
}
inline void DCT::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DCT.values)
}
inline void DCT::add_values(float value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.DCT.values)
}
inline const ::google::protobuf::RepeatedField< float >&
DCT::values() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.DCT.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< float >*
DCT::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.DCT.values)
  return &values_;
}

// -------------------------------------------------------------------

// ImageProps

// required uint32 width = 1;
inline bool ImageProps::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageProps::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageProps::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageProps::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 ImageProps::width() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.width)
  return width_;
}
inline void ImageProps::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.width)
}

// required uint32 height = 2;
inline bool ImageProps::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageProps::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageProps::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageProps::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 ImageProps::height() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.height)
  return height_;
}
inline void ImageProps::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.height)
}

// required .ru.mail.go.webbase.parsing.img.ImageFormat format = 3;
inline bool ImageProps::has_format() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImageProps::set_has_format() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImageProps::clear_has_format() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImageProps::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::ru::mail::go::webbase::parsing::img::ImageFormat ImageProps::format() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.format)
  return static_cast< ::ru::mail::go::webbase::parsing::img::ImageFormat >(format_);
}
inline void ImageProps::set_format(::ru::mail::go::webbase::parsing::img::ImageFormat value) {
  assert(::ru::mail::go::webbase::parsing::img::ImageFormat_IsValid(value));
  set_has_format();
  format_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.format)
}

// required uint64 hash = 4;
inline bool ImageProps::has_hash() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageProps::set_has_hash() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageProps::clear_has_hash() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageProps::clear_hash() {
  hash_ = GOOGLE_ULONGLONG(0);
  clear_has_hash();
}
inline ::google::protobuf::uint64 ImageProps::hash() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.hash)
  return hash_;
}
inline void ImageProps::set_hash(::google::protobuf::uint64 value) {
  set_has_hash();
  hash_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.hash)
}

// required uint32 enthropy = 5;
inline bool ImageProps::has_enthropy() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImageProps::set_has_enthropy() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImageProps::clear_has_enthropy() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImageProps::clear_enthropy() {
  enthropy_ = 0u;
  clear_has_enthropy();
}
inline ::google::protobuf::uint32 ImageProps::enthropy() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.enthropy)
  return enthropy_;
}
inline void ImageProps::set_enthropy(::google::protobuf::uint32 value) {
  set_has_enthropy();
  enthropy_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.enthropy)
}

// optional .ru.mail.go.webbase.parsing.img.Exif exif = 6;
inline bool ImageProps::has_exif() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageProps::set_has_exif() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageProps::clear_has_exif() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageProps::clear_exif() {
  if (exif_ != NULL) exif_->::ru::mail::go::webbase::parsing::img::Exif::Clear();
  clear_has_exif();
}
inline const ::ru::mail::go::webbase::parsing::img::Exif& ImageProps::exif() const {
  const ::ru::mail::go::webbase::parsing::img::Exif* p = exif_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.exif)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::Exif*>(
      &::ru::mail::go::webbase::parsing::img::_Exif_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::Exif* ImageProps::mutable_exif() {
  set_has_exif();
  if (exif_ == NULL) {
    exif_ = new ::ru::mail::go::webbase::parsing::img::Exif;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageProps.exif)
  return exif_;
}
inline ::ru::mail::go::webbase::parsing::img::Exif* ImageProps::release_exif() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageProps.exif)
  clear_has_exif();
  ::ru::mail::go::webbase::parsing::img::Exif* temp = exif_;
  exif_ = NULL;
  return temp;
}
inline void ImageProps::set_allocated_exif(::ru::mail::go::webbase::parsing::img::Exif* exif) {
  delete exif_;
  exif_ = exif;
  if (exif) {
    set_has_exif();
  } else {
    clear_has_exif();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageProps.exif)
}

// required uint32 size = 7;
inline bool ImageProps::has_size() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ImageProps::set_has_size() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ImageProps::clear_has_size() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ImageProps::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 ImageProps::size() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.size)
  return size_;
}
inline void ImageProps::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.size)
}

// optional double sharpness = 8;
inline bool ImageProps::has_sharpness() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImageProps::set_has_sharpness() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImageProps::clear_has_sharpness() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImageProps::clear_sharpness() {
  sharpness_ = 0;
  clear_has_sharpness();
}
inline double ImageProps::sharpness() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.sharpness)
  return sharpness_;
}
inline void ImageProps::set_sharpness(double value) {
  set_has_sharpness();
  sharpness_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.sharpness)
}

// optional uint32 brightness = 9;
inline bool ImageProps::has_brightness() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ImageProps::set_has_brightness() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ImageProps::clear_has_brightness() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ImageProps::clear_brightness() {
  brightness_ = 0u;
  clear_has_brightness();
}
inline ::google::protobuf::uint32 ImageProps::brightness() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.brightness)
  return brightness_;
}
inline void ImageProps::set_brightness(::google::protobuf::uint32 value) {
  set_has_brightness();
  brightness_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.brightness)
}

// optional uint32 contrast = 10;
inline bool ImageProps::has_contrast() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ImageProps::set_has_contrast() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ImageProps::clear_has_contrast() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ImageProps::clear_contrast() {
  contrast_ = 0u;
  clear_has_contrast();
}
inline ::google::protobuf::uint32 ImageProps::contrast() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.contrast)
  return contrast_;
}
inline void ImageProps::set_contrast(::google::protobuf::uint32 value) {
  set_has_contrast();
  contrast_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.contrast)
}

// optional uint32 colors = 11;
inline bool ImageProps::has_colors() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ImageProps::set_has_colors() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ImageProps::clear_has_colors() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ImageProps::clear_colors() {
  colors_ = 0u;
  clear_has_colors();
}
inline ::google::protobuf::uint32 ImageProps::colors() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.colors)
  return colors_;
}
inline void ImageProps::set_colors(::google::protobuf::uint32 value) {
  set_has_colors();
  colors_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.colors)
}

// optional bool transparent = 12;
inline bool ImageProps::has_transparent() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ImageProps::set_has_transparent() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ImageProps::clear_has_transparent() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ImageProps::clear_transparent() {
  transparent_ = false;
  clear_has_transparent();
}
inline bool ImageProps::transparent() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.transparent)
  return transparent_;
}
inline void ImageProps::set_transparent(bool value) {
  set_has_transparent();
  transparent_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.transparent)
}

// optional .ru.mail.go.webbase.parsing.img.CvFeatures cv_features = 13;
inline bool ImageProps::has_cv_features() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageProps::set_has_cv_features() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageProps::clear_has_cv_features() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageProps::clear_cv_features() {
  if (cv_features_ != NULL) cv_features_->::ru::mail::go::webbase::parsing::img::CvFeatures::Clear();
  clear_has_cv_features();
}
inline const ::ru::mail::go::webbase::parsing::img::CvFeatures& ImageProps::cv_features() const {
  const ::ru::mail::go::webbase::parsing::img::CvFeatures* p = cv_features_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.cv_features)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::CvFeatures*>(
      &::ru::mail::go::webbase::parsing::img::_CvFeatures_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::CvFeatures* ImageProps::mutable_cv_features() {
  set_has_cv_features();
  if (cv_features_ == NULL) {
    cv_features_ = new ::ru::mail::go::webbase::parsing::img::CvFeatures;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageProps.cv_features)
  return cv_features_;
}
inline ::ru::mail::go::webbase::parsing::img::CvFeatures* ImageProps::release_cv_features() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageProps.cv_features)
  clear_has_cv_features();
  ::ru::mail::go::webbase::parsing::img::CvFeatures* temp = cv_features_;
  cv_features_ = NULL;
  return temp;
}
inline void ImageProps::set_allocated_cv_features(::ru::mail::go::webbase::parsing::img::CvFeatures* cv_features) {
  delete cv_features_;
  cv_features_ = cv_features;
  if (cv_features) {
    set_has_cv_features();
  } else {
    clear_has_cv_features();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageProps.cv_features)
}

// optional bool is_demotivator = 14;
inline bool ImageProps::has_is_demotivator() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ImageProps::set_has_is_demotivator() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ImageProps::clear_has_is_demotivator() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ImageProps::clear_is_demotivator() {
  is_demotivator_ = false;
  clear_has_is_demotivator();
}
inline bool ImageProps::is_demotivator() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.is_demotivator)
  return is_demotivator_;
}
inline void ImageProps::set_is_demotivator(bool value) {
  set_has_is_demotivator();
  is_demotivator_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.is_demotivator)
}

// optional uint32 short_hash = 15;
inline bool ImageProps::has_short_hash() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ImageProps::set_has_short_hash() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ImageProps::clear_has_short_hash() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ImageProps::clear_short_hash() {
  short_hash_ = 0u;
  clear_has_short_hash();
}
inline ::google::protobuf::uint32 ImageProps::short_hash() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.short_hash)
  return short_hash_;
}
inline void ImageProps::set_short_hash(::google::protobuf::uint32 value) {
  set_has_short_hash();
  short_hash_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.short_hash)
}

// repeated uint32 visual_words = 16;
inline int ImageProps::visual_words_size() const {
  return visual_words_.size();
}
inline void ImageProps::clear_visual_words() {
  visual_words_.Clear();
}
inline ::google::protobuf::uint32 ImageProps::visual_words(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.visual_words)
  return visual_words_.Get(index);
}
inline void ImageProps::set_visual_words(int index, ::google::protobuf::uint32 value) {
  visual_words_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.visual_words)
}
inline void ImageProps::add_visual_words(::google::protobuf::uint32 value) {
  visual_words_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ImageProps.visual_words)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ImageProps::visual_words() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ImageProps.visual_words)
  return visual_words_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ImageProps::mutable_visual_words() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ImageProps.visual_words)
  return &visual_words_;
}

// optional .ru.mail.go.webbase.blobs.BOW bow = 17;
inline bool ImageProps::has_bow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageProps::set_has_bow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageProps::clear_has_bow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageProps::clear_bow() {
  if (bow_ != NULL) bow_->::ru::mail::go::webbase::blobs::BOW::Clear();
  clear_has_bow();
}
inline const ::ru::mail::go::webbase::blobs::BOW& ImageProps::bow() const {
  const ::ru::mail::go::webbase::blobs::BOW* p = bow_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.bow)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::BOW*>(
      &::ru::mail::go::webbase::blobs::_BOW_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::BOW* ImageProps::mutable_bow() {
  set_has_bow();
  if (bow_ == NULL) {
    bow_ = new ::ru::mail::go::webbase::blobs::BOW;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageProps.bow)
  return bow_;
}
inline ::ru::mail::go::webbase::blobs::BOW* ImageProps::release_bow() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageProps.bow)
  clear_has_bow();
  ::ru::mail::go::webbase::blobs::BOW* temp = bow_;
  bow_ = NULL;
  return temp;
}
inline void ImageProps::set_allocated_bow(::ru::mail::go::webbase::blobs::BOW* bow) {
  delete bow_;
  bow_ = bow;
  if (bow) {
    set_has_bow();
  } else {
    clear_has_bow();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageProps.bow)
}

// optional .ru.mail.go.webbase.blobs.DCT dct = 18;
inline bool ImageProps::has_dct() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageProps::set_has_dct() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageProps::clear_has_dct() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageProps::clear_dct() {
  if (dct_ != NULL) dct_->::ru::mail::go::webbase::blobs::DCT::Clear();
  clear_has_dct();
}
inline const ::ru::mail::go::webbase::blobs::DCT& ImageProps::dct() const {
  const ::ru::mail::go::webbase::blobs::DCT* p = dct_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.dct)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::DCT*>(
      &::ru::mail::go::webbase::blobs::_DCT_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::DCT* ImageProps::mutable_dct() {
  set_has_dct();
  if (dct_ == NULL) {
    dct_ = new ::ru::mail::go::webbase::blobs::DCT;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageProps.dct)
  return dct_;
}
inline ::ru::mail::go::webbase::blobs::DCT* ImageProps::release_dct() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageProps.dct)
  clear_has_dct();
  ::ru::mail::go::webbase::blobs::DCT* temp = dct_;
  dct_ = NULL;
  return temp;
}
inline void ImageProps::set_allocated_dct(::ru::mail::go::webbase::blobs::DCT* dct) {
  delete dct_;
  dct_ = dct;
  if (dct) {
    set_has_dct();
  } else {
    clear_has_dct();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageProps.dct)
}

// optional .ru.mail.go.webbase.parsing.img.ImageClass category = 19;
inline bool ImageProps::has_category() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ImageProps::set_has_category() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ImageProps::clear_has_category() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ImageProps::clear_category() {
  category_ = 0;
  clear_has_category();
}
inline ::ru::mail::go::webbase::parsing::img::ImageClass ImageProps::category() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.category)
  return static_cast< ::ru::mail::go::webbase::parsing::img::ImageClass >(category_);
}
inline void ImageProps::set_category(::ru::mail::go::webbase::parsing::img::ImageClass value) {
  assert(::ru::mail::go::webbase::parsing::img::ImageClass_IsValid(value));
  set_has_category();
  category_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.category)
}

// optional bool animated = 20;
inline bool ImageProps::has_animated() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ImageProps::set_has_animated() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ImageProps::clear_has_animated() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ImageProps::clear_animated() {
  animated_ = false;
  clear_has_animated();
}
inline bool ImageProps::animated() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.animated)
  return animated_;
}
inline void ImageProps::set_animated(bool value) {
  set_has_animated();
  animated_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.animated)
}

// optional uint64 animation_length = 21;
inline bool ImageProps::has_animation_length() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ImageProps::set_has_animation_length() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ImageProps::clear_has_animation_length() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ImageProps::clear_animation_length() {
  animation_length_ = GOOGLE_ULONGLONG(0);
  clear_has_animation_length();
}
inline ::google::protobuf::uint64 ImageProps::animation_length() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageProps.animation_length)
  return animation_length_;
}
inline void ImageProps::set_animation_length(::google::protobuf::uint64 value) {
  set_has_animation_length();
  animation_length_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageProps.animation_length)
}

// -------------------------------------------------------------------

// ParserSignature

// required bool img = 1;
inline bool ParserSignature::has_img() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParserSignature::set_has_img() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParserSignature::clear_has_img() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParserSignature::clear_img() {
  img_ = false;
  clear_has_img();
}
inline bool ParserSignature::img() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParserSignature.img)
  return img_;
}
inline void ParserSignature::set_img(bool value) {
  set_has_img();
  img_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParserSignature.img)
}

// required bool ppl = 2;
inline bool ParserSignature::has_ppl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParserSignature::set_has_ppl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParserSignature::clear_has_ppl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParserSignature::clear_ppl() {
  ppl_ = false;
  clear_has_ppl();
}
inline bool ParserSignature::ppl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParserSignature.ppl)
  return ppl_;
}
inline void ParserSignature::set_ppl(bool value) {
  set_has_ppl();
  ppl_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParserSignature.ppl)
}

// required uint64 time = 3;
inline bool ParserSignature::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParserSignature::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParserSignature::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParserSignature::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 ParserSignature::time() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ParserSignature.time)
  return time_;
}
inline void ParserSignature::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ParserSignature.time)
}

// -------------------------------------------------------------------

// ImgParserBlob

// required bytes key = 1;
inline bool ImgParserBlob::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImgParserBlob::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImgParserBlob::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImgParserBlob::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& ImgParserBlob::key() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImgParserBlob.key)
  return key_.GetNoArena();
}
inline void ImgParserBlob::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImgParserBlob.key)
}
#if LANG_CXX11
inline void ImgParserBlob::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImgParserBlob.key)
}
#endif
inline void ImgParserBlob::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImgParserBlob.key)
}
inline void ImgParserBlob::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImgParserBlob.key)
}
inline ::std::string* ImgParserBlob::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImgParserBlob.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImgParserBlob::release_key() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImgParserBlob.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImgParserBlob::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImgParserBlob.key)
}

// required .ru.mail.go.webbase.blobs.ImageProps props = 2;
inline bool ImgParserBlob::has_props() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImgParserBlob::set_has_props() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImgParserBlob::clear_has_props() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImgParserBlob::clear_props() {
  if (props_ != NULL) props_->::ru::mail::go::webbase::blobs::ImageProps::Clear();
  clear_has_props();
}
inline const ::ru::mail::go::webbase::blobs::ImageProps& ImgParserBlob::props() const {
  const ::ru::mail::go::webbase::blobs::ImageProps* p = props_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImgParserBlob.props)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ImageProps*>(
      &::ru::mail::go::webbase::blobs::_ImageProps_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ImageProps* ImgParserBlob::mutable_props() {
  set_has_props();
  if (props_ == NULL) {
    props_ = new ::ru::mail::go::webbase::blobs::ImageProps;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImgParserBlob.props)
  return props_;
}
inline ::ru::mail::go::webbase::blobs::ImageProps* ImgParserBlob::release_props() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImgParserBlob.props)
  clear_has_props();
  ::ru::mail::go::webbase::blobs::ImageProps* temp = props_;
  props_ = NULL;
  return temp;
}
inline void ImgParserBlob::set_allocated_props(::ru::mail::go::webbase::blobs::ImageProps* props) {
  delete props_;
  props_ = props;
  if (props) {
    set_has_props();
  } else {
    clear_has_props();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImgParserBlob.props)
}

// required .ru.mail.go.webbase.parsing.img.Thumb thumb = 3;
inline bool ImgParserBlob::has_thumb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImgParserBlob::set_has_thumb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImgParserBlob::clear_has_thumb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImgParserBlob::clear_thumb() {
  if (thumb_ != NULL) thumb_->::ru::mail::go::webbase::parsing::img::Thumb::Clear();
  clear_has_thumb();
}
inline const ::ru::mail::go::webbase::parsing::img::Thumb& ImgParserBlob::thumb() const {
  const ::ru::mail::go::webbase::parsing::img::Thumb* p = thumb_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImgParserBlob.thumb)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::Thumb*>(
      &::ru::mail::go::webbase::parsing::img::_Thumb_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ImgParserBlob::mutable_thumb() {
  set_has_thumb();
  if (thumb_ == NULL) {
    thumb_ = new ::ru::mail::go::webbase::parsing::img::Thumb;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImgParserBlob.thumb)
  return thumb_;
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ImgParserBlob::release_thumb() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImgParserBlob.thumb)
  clear_has_thumb();
  ::ru::mail::go::webbase::parsing::img::Thumb* temp = thumb_;
  thumb_ = NULL;
  return temp;
}
inline void ImgParserBlob::set_allocated_thumb(::ru::mail::go::webbase::parsing::img::Thumb* thumb) {
  delete thumb_;
  thumb_ = thumb;
  if (thumb) {
    set_has_thumb();
  } else {
    clear_has_thumb();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImgParserBlob.thumb)
}

// optional .ru.mail.go.webbase.parsing.img.VideoClip video_thumb = 4;
inline bool ImgParserBlob::has_video_thumb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImgParserBlob::set_has_video_thumb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImgParserBlob::clear_has_video_thumb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImgParserBlob::clear_video_thumb() {
  if (video_thumb_ != NULL) video_thumb_->::ru::mail::go::webbase::parsing::img::VideoClip::Clear();
  clear_has_video_thumb();
}
inline const ::ru::mail::go::webbase::parsing::img::VideoClip& ImgParserBlob::video_thumb() const {
  const ::ru::mail::go::webbase::parsing::img::VideoClip* p = video_thumb_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImgParserBlob.video_thumb)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::VideoClip*>(
      &::ru::mail::go::webbase::parsing::img::_VideoClip_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::VideoClip* ImgParserBlob::mutable_video_thumb() {
  set_has_video_thumb();
  if (video_thumb_ == NULL) {
    video_thumb_ = new ::ru::mail::go::webbase::parsing::img::VideoClip;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImgParserBlob.video_thumb)
  return video_thumb_;
}
inline ::ru::mail::go::webbase::parsing::img::VideoClip* ImgParserBlob::release_video_thumb() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImgParserBlob.video_thumb)
  clear_has_video_thumb();
  ::ru::mail::go::webbase::parsing::img::VideoClip* temp = video_thumb_;
  video_thumb_ = NULL;
  return temp;
}
inline void ImgParserBlob::set_allocated_video_thumb(::ru::mail::go::webbase::parsing::img::VideoClip* video_thumb) {
  delete video_thumb_;
  video_thumb_ = video_thumb;
  if (video_thumb) {
    set_has_video_thumb();
  } else {
    clear_has_video_thumb();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImgParserBlob.video_thumb)
}

// repeated float sifts = 5;
inline int ImgParserBlob::sifts_size() const {
  return sifts_.size();
}
inline void ImgParserBlob::clear_sifts() {
  sifts_.Clear();
}
inline float ImgParserBlob::sifts(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImgParserBlob.sifts)
  return sifts_.Get(index);
}
inline void ImgParserBlob::set_sifts(int index, float value) {
  sifts_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImgParserBlob.sifts)
}
inline void ImgParserBlob::add_sifts(float value) {
  sifts_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ImgParserBlob.sifts)
}
inline const ::google::protobuf::RepeatedField< float >&
ImgParserBlob::sifts() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ImgParserBlob.sifts)
  return sifts_;
}
inline ::google::protobuf::RepeatedField< float >*
ImgParserBlob::mutable_sifts() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ImgParserBlob.sifts)
  return &sifts_;
}

// optional .ru.mail.go.webbase.parsing.img.Thumb thumb_hidpi = 6;
inline bool ImgParserBlob::has_thumb_hidpi() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImgParserBlob::set_has_thumb_hidpi() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImgParserBlob::clear_has_thumb_hidpi() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImgParserBlob::clear_thumb_hidpi() {
  if (thumb_hidpi_ != NULL) thumb_hidpi_->::ru::mail::go::webbase::parsing::img::Thumb::Clear();
  clear_has_thumb_hidpi();
}
inline const ::ru::mail::go::webbase::parsing::img::Thumb& ImgParserBlob::thumb_hidpi() const {
  const ::ru::mail::go::webbase::parsing::img::Thumb* p = thumb_hidpi_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImgParserBlob.thumb_hidpi)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::Thumb*>(
      &::ru::mail::go::webbase::parsing::img::_Thumb_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ImgParserBlob::mutable_thumb_hidpi() {
  set_has_thumb_hidpi();
  if (thumb_hidpi_ == NULL) {
    thumb_hidpi_ = new ::ru::mail::go::webbase::parsing::img::Thumb;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImgParserBlob.thumb_hidpi)
  return thumb_hidpi_;
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ImgParserBlob::release_thumb_hidpi() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImgParserBlob.thumb_hidpi)
  clear_has_thumb_hidpi();
  ::ru::mail::go::webbase::parsing::img::Thumb* temp = thumb_hidpi_;
  thumb_hidpi_ = NULL;
  return temp;
}
inline void ImgParserBlob::set_allocated_thumb_hidpi(::ru::mail::go::webbase::parsing::img::Thumb* thumb_hidpi) {
  delete thumb_hidpi_;
  thumb_hidpi_ = thumb_hidpi;
  if (thumb_hidpi) {
    set_has_thumb_hidpi();
  } else {
    clear_has_thumb_hidpi();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImgParserBlob.thumb_hidpi)
}

// optional .ru.mail.go.webbase.parsing.img.VideoClip video_thumb_hidpi = 7;
inline bool ImgParserBlob::has_video_thumb_hidpi() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImgParserBlob::set_has_video_thumb_hidpi() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImgParserBlob::clear_has_video_thumb_hidpi() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImgParserBlob::clear_video_thumb_hidpi() {
  if (video_thumb_hidpi_ != NULL) video_thumb_hidpi_->::ru::mail::go::webbase::parsing::img::VideoClip::Clear();
  clear_has_video_thumb_hidpi();
}
inline const ::ru::mail::go::webbase::parsing::img::VideoClip& ImgParserBlob::video_thumb_hidpi() const {
  const ::ru::mail::go::webbase::parsing::img::VideoClip* p = video_thumb_hidpi_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImgParserBlob.video_thumb_hidpi)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::VideoClip*>(
      &::ru::mail::go::webbase::parsing::img::_VideoClip_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::VideoClip* ImgParserBlob::mutable_video_thumb_hidpi() {
  set_has_video_thumb_hidpi();
  if (video_thumb_hidpi_ == NULL) {
    video_thumb_hidpi_ = new ::ru::mail::go::webbase::parsing::img::VideoClip;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImgParserBlob.video_thumb_hidpi)
  return video_thumb_hidpi_;
}
inline ::ru::mail::go::webbase::parsing::img::VideoClip* ImgParserBlob::release_video_thumb_hidpi() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImgParserBlob.video_thumb_hidpi)
  clear_has_video_thumb_hidpi();
  ::ru::mail::go::webbase::parsing::img::VideoClip* temp = video_thumb_hidpi_;
  video_thumb_hidpi_ = NULL;
  return temp;
}
inline void ImgParserBlob::set_allocated_video_thumb_hidpi(::ru::mail::go::webbase::parsing::img::VideoClip* video_thumb_hidpi) {
  delete video_thumb_hidpi_;
  video_thumb_hidpi_ = video_thumb_hidpi;
  if (video_thumb_hidpi) {
    set_has_video_thumb_hidpi();
  } else {
    clear_has_video_thumb_hidpi();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImgParserBlob.video_thumb_hidpi)
}

// -------------------------------------------------------------------

// ImgParserBlobList

// required uint32 num = 1;
inline bool ImgParserBlobList::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImgParserBlobList::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImgParserBlobList::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImgParserBlobList::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 ImgParserBlobList::num() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImgParserBlobList.num)
  return num_;
}
inline void ImgParserBlobList::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImgParserBlobList.num)
}

// repeated .ru.mail.go.webbase.blobs.ImgParserBlob images = 2;
inline int ImgParserBlobList::images_size() const {
  return images_.size();
}
inline void ImgParserBlobList::clear_images() {
  images_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::ImgParserBlob& ImgParserBlobList::images(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImgParserBlobList.images)
  return images_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::ImgParserBlob* ImgParserBlobList::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImgParserBlobList.images)
  return images_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::ImgParserBlob* ImgParserBlobList::add_images() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ImgParserBlobList.images)
  return images_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImgParserBlob >*
ImgParserBlobList::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ImgParserBlobList.images)
  return &images_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImgParserBlob >&
ImgParserBlobList::images() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ImgParserBlobList.images)
  return images_;
}

// -------------------------------------------------------------------

// DomainStruct

// required string keyDomain = 1;
inline bool DomainStruct::has_keydomain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DomainStruct::set_has_keydomain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DomainStruct::clear_has_keydomain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DomainStruct::clear_keydomain() {
  keydomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keydomain();
}
inline const ::std::string& DomainStruct::keydomain() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DomainStruct.keyDomain)
  return keydomain_.GetNoArena();
}
inline void DomainStruct::set_keydomain(const ::std::string& value) {
  set_has_keydomain();
  keydomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DomainStruct.keyDomain)
}
#if LANG_CXX11
inline void DomainStruct::set_keydomain(::std::string&& value) {
  set_has_keydomain();
  keydomain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.DomainStruct.keyDomain)
}
#endif
inline void DomainStruct::set_keydomain(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keydomain();
  keydomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.DomainStruct.keyDomain)
}
inline void DomainStruct::set_keydomain(const char* value, size_t size) {
  set_has_keydomain();
  keydomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.DomainStruct.keyDomain)
}
inline ::std::string* DomainStruct::mutable_keydomain() {
  set_has_keydomain();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.DomainStruct.keyDomain)
  return keydomain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DomainStruct::release_keydomain() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.DomainStruct.keyDomain)
  clear_has_keydomain();
  return keydomain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DomainStruct::set_allocated_keydomain(::std::string* keydomain) {
  if (keydomain != NULL) {
    set_has_keydomain();
  } else {
    clear_has_keydomain();
  }
  keydomain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keydomain);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.DomainStruct.keyDomain)
}

// required string fullDomain = 2;
inline bool DomainStruct::has_fulldomain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DomainStruct::set_has_fulldomain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DomainStruct::clear_has_fulldomain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DomainStruct::clear_fulldomain() {
  fulldomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fulldomain();
}
inline const ::std::string& DomainStruct::fulldomain() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DomainStruct.fullDomain)
  return fulldomain_.GetNoArena();
}
inline void DomainStruct::set_fulldomain(const ::std::string& value) {
  set_has_fulldomain();
  fulldomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DomainStruct.fullDomain)
}
#if LANG_CXX11
inline void DomainStruct::set_fulldomain(::std::string&& value) {
  set_has_fulldomain();
  fulldomain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.DomainStruct.fullDomain)
}
#endif
inline void DomainStruct::set_fulldomain(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fulldomain();
  fulldomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.DomainStruct.fullDomain)
}
inline void DomainStruct::set_fulldomain(const char* value, size_t size) {
  set_has_fulldomain();
  fulldomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.DomainStruct.fullDomain)
}
inline ::std::string* DomainStruct::mutable_fulldomain() {
  set_has_fulldomain();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.DomainStruct.fullDomain)
  return fulldomain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DomainStruct::release_fulldomain() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.DomainStruct.fullDomain)
  clear_has_fulldomain();
  return fulldomain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DomainStruct::set_allocated_fulldomain(::std::string* fulldomain) {
  if (fulldomain != NULL) {
    set_has_fulldomain();
  } else {
    clear_has_fulldomain();
  }
  fulldomain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fulldomain);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.DomainStruct.fullDomain)
}

// optional uint32 ic = 3;
inline bool DomainStruct::has_ic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DomainStruct::set_has_ic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DomainStruct::clear_has_ic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DomainStruct::clear_ic() {
  ic_ = 0u;
  clear_has_ic();
}
inline ::google::protobuf::uint32 DomainStruct::ic() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DomainStruct.ic)
  return ic_;
}
inline void DomainStruct::set_ic(::google::protobuf::uint32 value) {
  set_has_ic();
  ic_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DomainStruct.ic)
}

// optional uint32 trusted_ic = 4;
inline bool DomainStruct::has_trusted_ic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DomainStruct::set_has_trusted_ic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DomainStruct::clear_has_trusted_ic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DomainStruct::clear_trusted_ic() {
  trusted_ic_ = 0u;
  clear_has_trusted_ic();
}
inline ::google::protobuf::uint32 DomainStruct::trusted_ic() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DomainStruct.trusted_ic)
  return trusted_ic_;
}
inline void DomainStruct::set_trusted_ic(::google::protobuf::uint32 value) {
  set_has_trusted_ic();
  trusted_ic_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DomainStruct.trusted_ic)
}

// optional bool cloaking = 5;
inline bool DomainStruct::has_cloaking() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DomainStruct::set_has_cloaking() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DomainStruct::clear_has_cloaking() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DomainStruct::clear_cloaking() {
  cloaking_ = false;
  clear_has_cloaking();
}
inline bool DomainStruct::cloaking() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DomainStruct.cloaking)
  return cloaking_;
}
inline void DomainStruct::set_cloaking(bool value) {
  set_has_cloaking();
  cloaking_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DomainStruct.cloaking)
}

// optional uint32 nbrsq2 = 6;
inline bool DomainStruct::has_nbrsq2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DomainStruct::set_has_nbrsq2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DomainStruct::clear_has_nbrsq2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DomainStruct::clear_nbrsq2() {
  nbrsq2_ = 0u;
  clear_has_nbrsq2();
}
inline ::google::protobuf::uint32 DomainStruct::nbrsq2() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DomainStruct.nbrsq2)
  return nbrsq2_;
}
inline void DomainStruct::set_nbrsq2(::google::protobuf::uint32 value) {
  set_has_nbrsq2();
  nbrsq2_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DomainStruct.nbrsq2)
}

// optional .ru.mail.go.webbase.blobs.WOTInfo wot_info = 7;
inline bool DomainStruct::has_wot_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DomainStruct::set_has_wot_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DomainStruct::clear_has_wot_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DomainStruct::clear_wot_info() {
  if (wot_info_ != NULL) wot_info_->::ru::mail::go::webbase::blobs::WOTInfo::Clear();
  clear_has_wot_info();
}
inline const ::ru::mail::go::webbase::blobs::WOTInfo& DomainStruct::wot_info() const {
  const ::ru::mail::go::webbase::blobs::WOTInfo* p = wot_info_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DomainStruct.wot_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::WOTInfo*>(
      &::ru::mail::go::webbase::blobs::_WOTInfo_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::WOTInfo* DomainStruct::mutable_wot_info() {
  set_has_wot_info();
  if (wot_info_ == NULL) {
    wot_info_ = new ::ru::mail::go::webbase::blobs::WOTInfo;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.DomainStruct.wot_info)
  return wot_info_;
}
inline ::ru::mail::go::webbase::blobs::WOTInfo* DomainStruct::release_wot_info() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.DomainStruct.wot_info)
  clear_has_wot_info();
  ::ru::mail::go::webbase::blobs::WOTInfo* temp = wot_info_;
  wot_info_ = NULL;
  return temp;
}
inline void DomainStruct::set_allocated_wot_info(::ru::mail::go::webbase::blobs::WOTInfo* wot_info) {
  delete wot_info_;
  wot_info_ = wot_info;
  if (wot_info) {
    set_has_wot_info();
  } else {
    clear_has_wot_info();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.DomainStruct.wot_info)
}

// repeated .gogo.storage.extra_info domain_extra_info = 8;
inline int DomainStruct::domain_extra_info_size() const {
  return domain_extra_info_.size();
}
inline void DomainStruct::clear_domain_extra_info() {
  domain_extra_info_.Clear();
}
inline const ::gogo::storage::extra_info& DomainStruct::domain_extra_info(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DomainStruct.domain_extra_info)
  return domain_extra_info_.Get(index);
}
inline ::gogo::storage::extra_info* DomainStruct::mutable_domain_extra_info(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.DomainStruct.domain_extra_info)
  return domain_extra_info_.Mutable(index);
}
inline ::gogo::storage::extra_info* DomainStruct::add_domain_extra_info() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.DomainStruct.domain_extra_info)
  return domain_extra_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >*
DomainStruct::mutable_domain_extra_info() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.DomainStruct.domain_extra_info)
  return &domain_extra_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >&
DomainStruct::domain_extra_info() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.DomainStruct.domain_extra_info)
  return domain_extra_info_;
}

// optional uint32 spam = 9;
inline bool DomainStruct::has_spam() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DomainStruct::set_has_spam() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DomainStruct::clear_has_spam() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DomainStruct::clear_spam() {
  spam_ = 0u;
  clear_has_spam();
}
inline ::google::protobuf::uint32 DomainStruct::spam() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DomainStruct.spam)
  return spam_;
}
inline void DomainStruct::set_spam(::google::protobuf::uint32 value) {
  set_has_spam();
  spam_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DomainStruct.spam)
}

// -------------------------------------------------------------------

// ImageStruct_AdditionalProps

// optional float porn_prob = 22;
inline bool ImageStruct_AdditionalProps::has_porn_prob() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageStruct_AdditionalProps::set_has_porn_prob() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageStruct_AdditionalProps::clear_has_porn_prob() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageStruct_AdditionalProps::clear_porn_prob() {
  porn_prob_ = 0;
  clear_has_porn_prob();
}
inline float ImageStruct_AdditionalProps::porn_prob() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.AdditionalProps.porn_prob)
  return porn_prob_;
}
inline void ImageStruct_AdditionalProps::set_porn_prob(float value) {
  set_has_porn_prob();
  porn_prob_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStruct.AdditionalProps.porn_prob)
}

// optional float porn_prob_v2 = 23;
inline bool ImageStruct_AdditionalProps::has_porn_prob_v2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageStruct_AdditionalProps::set_has_porn_prob_v2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageStruct_AdditionalProps::clear_has_porn_prob_v2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageStruct_AdditionalProps::clear_porn_prob_v2() {
  porn_prob_v2_ = 0;
  clear_has_porn_prob_v2();
}
inline float ImageStruct_AdditionalProps::porn_prob_v2() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.AdditionalProps.porn_prob_v2)
  return porn_prob_v2_;
}
inline void ImageStruct_AdditionalProps::set_porn_prob_v2(float value) {
  set_has_porn_prob_v2();
  porn_prob_v2_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStruct.AdditionalProps.porn_prob_v2)
}

// -------------------------------------------------------------------

// ImageStruct

// required string keyUrl = 1;
inline bool ImageStruct::has_keyurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageStruct::set_has_keyurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageStruct::clear_has_keyurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageStruct::clear_keyurl() {
  keyurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keyurl();
}
inline const ::std::string& ImageStruct::keyurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.keyUrl)
  return keyurl_.GetNoArena();
}
inline void ImageStruct::set_keyurl(const ::std::string& value) {
  set_has_keyurl();
  keyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStruct.keyUrl)
}
#if LANG_CXX11
inline void ImageStruct::set_keyurl(::std::string&& value) {
  set_has_keyurl();
  keyurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageStruct.keyUrl)
}
#endif
inline void ImageStruct::set_keyurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keyurl();
  keyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageStruct.keyUrl)
}
inline void ImageStruct::set_keyurl(const char* value, size_t size) {
  set_has_keyurl();
  keyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageStruct.keyUrl)
}
inline ::std::string* ImageStruct::mutable_keyurl() {
  set_has_keyurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.keyUrl)
  return keyurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageStruct::release_keyurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.keyUrl)
  clear_has_keyurl();
  return keyurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageStruct::set_allocated_keyurl(::std::string* keyurl) {
  if (keyurl != NULL) {
    set_has_keyurl();
  } else {
    clear_has_keyurl();
  }
  keyurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keyurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.keyUrl)
}

// required string fullUrl = 2;
inline bool ImageStruct::has_fullurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageStruct::set_has_fullurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageStruct::clear_has_fullurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageStruct::clear_fullurl() {
  fullurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fullurl();
}
inline const ::std::string& ImageStruct::fullurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.fullUrl)
  return fullurl_.GetNoArena();
}
inline void ImageStruct::set_fullurl(const ::std::string& value) {
  set_has_fullurl();
  fullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStruct.fullUrl)
}
#if LANG_CXX11
inline void ImageStruct::set_fullurl(::std::string&& value) {
  set_has_fullurl();
  fullurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageStruct.fullUrl)
}
#endif
inline void ImageStruct::set_fullurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fullurl();
  fullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageStruct.fullUrl)
}
inline void ImageStruct::set_fullurl(const char* value, size_t size) {
  set_has_fullurl();
  fullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageStruct.fullUrl)
}
inline ::std::string* ImageStruct::mutable_fullurl() {
  set_has_fullurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.fullUrl)
  return fullurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageStruct::release_fullurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.fullUrl)
  clear_has_fullurl();
  return fullurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageStruct::set_allocated_fullurl(::std::string* fullurl) {
  if (fullurl != NULL) {
    set_has_fullurl();
  } else {
    clear_has_fullurl();
  }
  fullurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fullurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.fullUrl)
}

// optional .ru.mail.go.webbase.parsing.img.Thumb thumb = 3;
inline bool ImageStruct::has_thumb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageStruct::set_has_thumb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageStruct::clear_has_thumb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageStruct::clear_thumb() {
  if (thumb_ != NULL) thumb_->::ru::mail::go::webbase::parsing::img::Thumb::Clear();
  clear_has_thumb();
}
inline const ::ru::mail::go::webbase::parsing::img::Thumb& ImageStruct::thumb() const {
  const ::ru::mail::go::webbase::parsing::img::Thumb* p = thumb_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.thumb)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::Thumb*>(
      &::ru::mail::go::webbase::parsing::img::_Thumb_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ImageStruct::mutable_thumb() {
  set_has_thumb();
  if (thumb_ == NULL) {
    thumb_ = new ::ru::mail::go::webbase::parsing::img::Thumb;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.thumb)
  return thumb_;
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ImageStruct::release_thumb() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.thumb)
  clear_has_thumb();
  ::ru::mail::go::webbase::parsing::img::Thumb* temp = thumb_;
  thumb_ = NULL;
  return temp;
}
inline void ImageStruct::set_allocated_thumb(::ru::mail::go::webbase::parsing::img::Thumb* thumb) {
  delete thumb_;
  thumb_ = thumb;
  if (thumb) {
    set_has_thumb();
  } else {
    clear_has_thumb();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.thumb)
}

// required .ru.mail.go.webbase.blobs.ImageProps props = 4;
inline bool ImageStruct::has_props() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageStruct::set_has_props() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageStruct::clear_has_props() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageStruct::clear_props() {
  if (props_ != NULL) props_->::ru::mail::go::webbase::blobs::ImageProps::Clear();
  clear_has_props();
}
inline const ::ru::mail::go::webbase::blobs::ImageProps& ImageStruct::props() const {
  const ::ru::mail::go::webbase::blobs::ImageProps* p = props_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.props)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ImageProps*>(
      &::ru::mail::go::webbase::blobs::_ImageProps_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ImageProps* ImageStruct::mutable_props() {
  set_has_props();
  if (props_ == NULL) {
    props_ = new ::ru::mail::go::webbase::blobs::ImageProps;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.props)
  return props_;
}
inline ::ru::mail::go::webbase::blobs::ImageProps* ImageStruct::release_props() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.props)
  clear_has_props();
  ::ru::mail::go::webbase::blobs::ImageProps* temp = props_;
  props_ = NULL;
  return temp;
}
inline void ImageStruct::set_allocated_props(::ru::mail::go::webbase::blobs::ImageProps* props) {
  delete props_;
  props_ = props;
  if (props) {
    set_has_props();
  } else {
    clear_has_props();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.props)
}

// optional uint32 broken = 5;
inline bool ImageStruct::has_broken() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ImageStruct::set_has_broken() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ImageStruct::clear_has_broken() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ImageStruct::clear_broken() {
  broken_ = 0u;
  clear_has_broken();
}
inline ::google::protobuf::uint32 ImageStruct::broken() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.broken)
  return broken_;
}
inline void ImageStruct::set_broken(::google::protobuf::uint32 value) {
  set_has_broken();
  broken_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStruct.broken)
}

// optional .ru.mail.go.webbase.blobs.ExtraTextArray imageExtraTexts = 6;
inline bool ImageStruct::has_imageextratexts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageStruct::set_has_imageextratexts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageStruct::clear_has_imageextratexts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageStruct::clear_imageextratexts() {
  if (imageextratexts_ != NULL) imageextratexts_->::ru::mail::go::webbase::blobs::ExtraTextArray::Clear();
  clear_has_imageextratexts();
}
inline const ::ru::mail::go::webbase::blobs::ExtraTextArray& ImageStruct::imageextratexts() const {
  const ::ru::mail::go::webbase::blobs::ExtraTextArray* p = imageextratexts_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.imageExtraTexts)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ExtraTextArray*>(
      &::ru::mail::go::webbase::blobs::_ExtraTextArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ExtraTextArray* ImageStruct::mutable_imageextratexts() {
  set_has_imageextratexts();
  if (imageextratexts_ == NULL) {
    imageextratexts_ = new ::ru::mail::go::webbase::blobs::ExtraTextArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.imageExtraTexts)
  return imageextratexts_;
}
inline ::ru::mail::go::webbase::blobs::ExtraTextArray* ImageStruct::release_imageextratexts() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.imageExtraTexts)
  clear_has_imageextratexts();
  ::ru::mail::go::webbase::blobs::ExtraTextArray* temp = imageextratexts_;
  imageextratexts_ = NULL;
  return temp;
}
inline void ImageStruct::set_allocated_imageextratexts(::ru::mail::go::webbase::blobs::ExtraTextArray* imageextratexts) {
  delete imageextratexts_;
  imageextratexts_ = imageextratexts;
  if (imageextratexts) {
    set_has_imageextratexts();
  } else {
    clear_has_imageextratexts();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.imageExtraTexts)
}

// optional uint32 preview_db = 7;
inline bool ImageStruct::has_preview_db() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ImageStruct::set_has_preview_db() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ImageStruct::clear_has_preview_db() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ImageStruct::clear_preview_db() {
  preview_db_ = 0u;
  clear_has_preview_db();
}
inline ::google::protobuf::uint32 ImageStruct::preview_db() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.preview_db)
  return preview_db_;
}
inline void ImageStruct::set_preview_db(::google::protobuf::uint32 value) {
  set_has_preview_db();
  preview_db_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStruct.preview_db)
}

// optional .ru.mail.go.webbase.parsing.img.VideoClip video_thumb = 8;
inline bool ImageStruct::has_video_thumb() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageStruct::set_has_video_thumb() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageStruct::clear_has_video_thumb() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageStruct::clear_video_thumb() {
  if (video_thumb_ != NULL) video_thumb_->::ru::mail::go::webbase::parsing::img::VideoClip::Clear();
  clear_has_video_thumb();
}
inline const ::ru::mail::go::webbase::parsing::img::VideoClip& ImageStruct::video_thumb() const {
  const ::ru::mail::go::webbase::parsing::img::VideoClip* p = video_thumb_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.video_thumb)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::VideoClip*>(
      &::ru::mail::go::webbase::parsing::img::_VideoClip_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::VideoClip* ImageStruct::mutable_video_thumb() {
  set_has_video_thumb();
  if (video_thumb_ == NULL) {
    video_thumb_ = new ::ru::mail::go::webbase::parsing::img::VideoClip;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.video_thumb)
  return video_thumb_;
}
inline ::ru::mail::go::webbase::parsing::img::VideoClip* ImageStruct::release_video_thumb() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.video_thumb)
  clear_has_video_thumb();
  ::ru::mail::go::webbase::parsing::img::VideoClip* temp = video_thumb_;
  video_thumb_ = NULL;
  return temp;
}
inline void ImageStruct::set_allocated_video_thumb(::ru::mail::go::webbase::parsing::img::VideoClip* video_thumb) {
  delete video_thumb_;
  video_thumb_ = video_thumb;
  if (video_thumb) {
    set_has_video_thumb();
  } else {
    clear_has_video_thumb();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.video_thumb)
}

// optional .ru.mail.go.webbase.blobs.VisitInfo YGVisitInfo = 9;
inline bool ImageStruct::has_ygvisitinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageStruct::set_has_ygvisitinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageStruct::clear_has_ygvisitinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageStruct::clear_ygvisitinfo() {
  if (ygvisitinfo_ != NULL) ygvisitinfo_->::ru::mail::go::webbase::blobs::VisitInfo::Clear();
  clear_has_ygvisitinfo();
}
inline const ::ru::mail::go::webbase::blobs::VisitInfo& ImageStruct::ygvisitinfo() const {
  const ::ru::mail::go::webbase::blobs::VisitInfo* p = ygvisitinfo_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.YGVisitInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::VisitInfo*>(
      &::ru::mail::go::webbase::blobs::_VisitInfo_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::VisitInfo* ImageStruct::mutable_ygvisitinfo() {
  set_has_ygvisitinfo();
  if (ygvisitinfo_ == NULL) {
    ygvisitinfo_ = new ::ru::mail::go::webbase::blobs::VisitInfo;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.YGVisitInfo)
  return ygvisitinfo_;
}
inline ::ru::mail::go::webbase::blobs::VisitInfo* ImageStruct::release_ygvisitinfo() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.YGVisitInfo)
  clear_has_ygvisitinfo();
  ::ru::mail::go::webbase::blobs::VisitInfo* temp = ygvisitinfo_;
  ygvisitinfo_ = NULL;
  return temp;
}
inline void ImageStruct::set_allocated_ygvisitinfo(::ru::mail::go::webbase::blobs::VisitInfo* ygvisitinfo) {
  delete ygvisitinfo_;
  ygvisitinfo_ = ygvisitinfo;
  if (ygvisitinfo) {
    set_has_ygvisitinfo();
  } else {
    clear_has_ygvisitinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.YGVisitInfo)
}

// optional .ru.mail.go.webbase.blobs.ImageStruct.AdditionalProps additional_props = 10;
inline bool ImageStruct::has_additional_props() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImageStruct::set_has_additional_props() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImageStruct::clear_has_additional_props() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImageStruct::clear_additional_props() {
  if (additional_props_ != NULL) additional_props_->::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps::Clear();
  clear_has_additional_props();
}
inline const ::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps& ImageStruct::additional_props() const {
  const ::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps* p = additional_props_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.additional_props)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps*>(
      &::ru::mail::go::webbase::blobs::_ImageStruct_AdditionalProps_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps* ImageStruct::mutable_additional_props() {
  set_has_additional_props();
  if (additional_props_ == NULL) {
    additional_props_ = new ::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.additional_props)
  return additional_props_;
}
inline ::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps* ImageStruct::release_additional_props() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.additional_props)
  clear_has_additional_props();
  ::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps* temp = additional_props_;
  additional_props_ = NULL;
  return temp;
}
inline void ImageStruct::set_allocated_additional_props(::ru::mail::go::webbase::blobs::ImageStruct_AdditionalProps* additional_props) {
  delete additional_props_;
  additional_props_ = additional_props;
  if (additional_props) {
    set_has_additional_props();
  } else {
    clear_has_additional_props();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.additional_props)
}

// optional .qembedder.pb.Embedding cnn_embedding = 11;
inline bool ImageStruct::has_cnn_embedding() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImageStruct::set_has_cnn_embedding() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImageStruct::clear_has_cnn_embedding() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImageStruct::clear_cnn_embedding() {
  if (cnn_embedding_ != NULL) cnn_embedding_->::qembedder::pb::Embedding::Clear();
  clear_has_cnn_embedding();
}
inline const ::qembedder::pb::Embedding& ImageStruct::cnn_embedding() const {
  const ::qembedder::pb::Embedding* p = cnn_embedding_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.cnn_embedding)
  return p != NULL ? *p : *reinterpret_cast<const ::qembedder::pb::Embedding*>(
      &::qembedder::pb::_Embedding_default_instance_);
}
inline ::qembedder::pb::Embedding* ImageStruct::mutable_cnn_embedding() {
  set_has_cnn_embedding();
  if (cnn_embedding_ == NULL) {
    cnn_embedding_ = new ::qembedder::pb::Embedding;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.cnn_embedding)
  return cnn_embedding_;
}
inline ::qembedder::pb::Embedding* ImageStruct::release_cnn_embedding() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.cnn_embedding)
  clear_has_cnn_embedding();
  ::qembedder::pb::Embedding* temp = cnn_embedding_;
  cnn_embedding_ = NULL;
  return temp;
}
inline void ImageStruct::set_allocated_cnn_embedding(::qembedder::pb::Embedding* cnn_embedding) {
  delete cnn_embedding_;
  cnn_embedding_ = cnn_embedding;
  if (cnn_embedding) {
    set_has_cnn_embedding();
  } else {
    clear_has_cnn_embedding();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.cnn_embedding)
}

// optional .qembedder.pb.Embedding cnn_serp_embedding = 12;
inline bool ImageStruct::has_cnn_serp_embedding() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImageStruct::set_has_cnn_serp_embedding() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImageStruct::clear_has_cnn_serp_embedding() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImageStruct::clear_cnn_serp_embedding() {
  if (cnn_serp_embedding_ != NULL) cnn_serp_embedding_->::qembedder::pb::Embedding::Clear();
  clear_has_cnn_serp_embedding();
}
inline const ::qembedder::pb::Embedding& ImageStruct::cnn_serp_embedding() const {
  const ::qembedder::pb::Embedding* p = cnn_serp_embedding_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.cnn_serp_embedding)
  return p != NULL ? *p : *reinterpret_cast<const ::qembedder::pb::Embedding*>(
      &::qembedder::pb::_Embedding_default_instance_);
}
inline ::qembedder::pb::Embedding* ImageStruct::mutable_cnn_serp_embedding() {
  set_has_cnn_serp_embedding();
  if (cnn_serp_embedding_ == NULL) {
    cnn_serp_embedding_ = new ::qembedder::pb::Embedding;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.cnn_serp_embedding)
  return cnn_serp_embedding_;
}
inline ::qembedder::pb::Embedding* ImageStruct::release_cnn_serp_embedding() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.cnn_serp_embedding)
  clear_has_cnn_serp_embedding();
  ::qembedder::pb::Embedding* temp = cnn_serp_embedding_;
  cnn_serp_embedding_ = NULL;
  return temp;
}
inline void ImageStruct::set_allocated_cnn_serp_embedding(::qembedder::pb::Embedding* cnn_serp_embedding) {
  delete cnn_serp_embedding_;
  cnn_serp_embedding_ = cnn_serp_embedding;
  if (cnn_serp_embedding) {
    set_has_cnn_serp_embedding();
  } else {
    clear_has_cnn_serp_embedding();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.cnn_serp_embedding)
}

// optional .qembedder.pb.Embedding vit_serp_embedding = 14;
inline bool ImageStruct::has_vit_serp_embedding() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ImageStruct::set_has_vit_serp_embedding() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ImageStruct::clear_has_vit_serp_embedding() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ImageStruct::clear_vit_serp_embedding() {
  if (vit_serp_embedding_ != NULL) vit_serp_embedding_->::qembedder::pb::Embedding::Clear();
  clear_has_vit_serp_embedding();
}
inline const ::qembedder::pb::Embedding& ImageStruct::vit_serp_embedding() const {
  const ::qembedder::pb::Embedding* p = vit_serp_embedding_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.vit_serp_embedding)
  return p != NULL ? *p : *reinterpret_cast<const ::qembedder::pb::Embedding*>(
      &::qembedder::pb::_Embedding_default_instance_);
}
inline ::qembedder::pb::Embedding* ImageStruct::mutable_vit_serp_embedding() {
  set_has_vit_serp_embedding();
  if (vit_serp_embedding_ == NULL) {
    vit_serp_embedding_ = new ::qembedder::pb::Embedding;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.vit_serp_embedding)
  return vit_serp_embedding_;
}
inline ::qembedder::pb::Embedding* ImageStruct::release_vit_serp_embedding() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.vit_serp_embedding)
  clear_has_vit_serp_embedding();
  ::qembedder::pb::Embedding* temp = vit_serp_embedding_;
  vit_serp_embedding_ = NULL;
  return temp;
}
inline void ImageStruct::set_allocated_vit_serp_embedding(::qembedder::pb::Embedding* vit_serp_embedding) {
  delete vit_serp_embedding_;
  vit_serp_embedding_ = vit_serp_embedding;
  if (vit_serp_embedding) {
    set_has_vit_serp_embedding();
  } else {
    clear_has_vit_serp_embedding();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.vit_serp_embedding)
}

// optional bool required_for_assessor = 13;
inline bool ImageStruct::has_required_for_assessor() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ImageStruct::set_has_required_for_assessor() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ImageStruct::clear_has_required_for_assessor() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ImageStruct::clear_required_for_assessor() {
  required_for_assessor_ = false;
  clear_has_required_for_assessor();
}
inline bool ImageStruct::required_for_assessor() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.required_for_assessor)
  return required_for_assessor_;
}
inline void ImageStruct::set_required_for_assessor(bool value) {
  set_has_required_for_assessor();
  required_for_assessor_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStruct.required_for_assessor)
}

// optional float aws_probability = 15;
inline bool ImageStruct::has_aws_probability() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ImageStruct::set_has_aws_probability() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ImageStruct::clear_has_aws_probability() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ImageStruct::clear_aws_probability() {
  aws_probability_ = 0;
  clear_has_aws_probability();
}
inline float ImageStruct::aws_probability() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.aws_probability)
  return aws_probability_;
}
inline void ImageStruct::set_aws_probability(float value) {
  set_has_aws_probability();
  aws_probability_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStruct.aws_probability)
}

// optional .qembedder.pb.Embedding img_match_embedding = 16;
inline bool ImageStruct::has_img_match_embedding() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ImageStruct::set_has_img_match_embedding() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ImageStruct::clear_has_img_match_embedding() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ImageStruct::clear_img_match_embedding() {
  if (img_match_embedding_ != NULL) img_match_embedding_->::qembedder::pb::Embedding::Clear();
  clear_has_img_match_embedding();
}
inline const ::qembedder::pb::Embedding& ImageStruct::img_match_embedding() const {
  const ::qembedder::pb::Embedding* p = img_match_embedding_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.img_match_embedding)
  return p != NULL ? *p : *reinterpret_cast<const ::qembedder::pb::Embedding*>(
      &::qembedder::pb::_Embedding_default_instance_);
}
inline ::qembedder::pb::Embedding* ImageStruct::mutable_img_match_embedding() {
  set_has_img_match_embedding();
  if (img_match_embedding_ == NULL) {
    img_match_embedding_ = new ::qembedder::pb::Embedding;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStruct.img_match_embedding)
  return img_match_embedding_;
}
inline ::qembedder::pb::Embedding* ImageStruct::release_img_match_embedding() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStruct.img_match_embedding)
  clear_has_img_match_embedding();
  ::qembedder::pb::Embedding* temp = img_match_embedding_;
  img_match_embedding_ = NULL;
  return temp;
}
inline void ImageStruct::set_allocated_img_match_embedding(::qembedder::pb::Embedding* img_match_embedding) {
  delete img_match_embedding_;
  img_match_embedding_ = img_match_embedding;
  if (img_match_embedding) {
    set_has_img_match_embedding();
  } else {
    clear_has_img_match_embedding();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStruct.img_match_embedding)
}

// optional bool previous = 17;
inline bool ImageStruct::has_previous() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ImageStruct::set_has_previous() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ImageStruct::clear_has_previous() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ImageStruct::clear_previous() {
  previous_ = false;
  clear_has_previous();
}
inline bool ImageStruct::previous() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStruct.previous)
  return previous_;
}
inline void ImageStruct::set_previous(bool value) {
  set_has_previous();
  previous_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStruct.previous)
}

// -------------------------------------------------------------------

// PageStruct

// required string keyUrl = 1;
inline bool PageStruct::has_keyurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PageStruct::set_has_keyurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PageStruct::clear_has_keyurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PageStruct::clear_keyurl() {
  keyurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keyurl();
}
inline const ::std::string& PageStruct::keyurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PageStruct.keyUrl)
  return keyurl_.GetNoArena();
}
inline void PageStruct::set_keyurl(const ::std::string& value) {
  set_has_keyurl();
  keyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.PageStruct.keyUrl)
}
#if LANG_CXX11
inline void PageStruct::set_keyurl(::std::string&& value) {
  set_has_keyurl();
  keyurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.PageStruct.keyUrl)
}
#endif
inline void PageStruct::set_keyurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keyurl();
  keyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.PageStruct.keyUrl)
}
inline void PageStruct::set_keyurl(const char* value, size_t size) {
  set_has_keyurl();
  keyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.PageStruct.keyUrl)
}
inline ::std::string* PageStruct::mutable_keyurl() {
  set_has_keyurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.PageStruct.keyUrl)
  return keyurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PageStruct::release_keyurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.PageStruct.keyUrl)
  clear_has_keyurl();
  return keyurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PageStruct::set_allocated_keyurl(::std::string* keyurl) {
  if (keyurl != NULL) {
    set_has_keyurl();
  } else {
    clear_has_keyurl();
  }
  keyurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keyurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.PageStruct.keyUrl)
}

// required string fullUrl = 2;
inline bool PageStruct::has_fullurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PageStruct::set_has_fullurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PageStruct::clear_has_fullurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PageStruct::clear_fullurl() {
  fullurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fullurl();
}
inline const ::std::string& PageStruct::fullurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PageStruct.fullUrl)
  return fullurl_.GetNoArena();
}
inline void PageStruct::set_fullurl(const ::std::string& value) {
  set_has_fullurl();
  fullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.PageStruct.fullUrl)
}
#if LANG_CXX11
inline void PageStruct::set_fullurl(::std::string&& value) {
  set_has_fullurl();
  fullurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.PageStruct.fullUrl)
}
#endif
inline void PageStruct::set_fullurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fullurl();
  fullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.PageStruct.fullUrl)
}
inline void PageStruct::set_fullurl(const char* value, size_t size) {
  set_has_fullurl();
  fullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.PageStruct.fullUrl)
}
inline ::std::string* PageStruct::mutable_fullurl() {
  set_has_fullurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.PageStruct.fullUrl)
  return fullurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PageStruct::release_fullurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.PageStruct.fullUrl)
  clear_has_fullurl();
  return fullurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PageStruct::set_allocated_fullurl(::std::string* fullurl) {
  if (fullurl != NULL) {
    set_has_fullurl();
  } else {
    clear_has_fullurl();
  }
  fullurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fullurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.PageStruct.fullUrl)
}

// required .ru.mail.go.webbase.blobs.HtmlPage page = 3;
inline bool PageStruct::has_page() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PageStruct::set_has_page() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PageStruct::clear_has_page() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PageStruct::clear_page() {
  if (page_ != NULL) page_->::ru::mail::go::webbase::blobs::HtmlPage::Clear();
  clear_has_page();
}
inline const ::ru::mail::go::webbase::blobs::HtmlPage& PageStruct::page() const {
  const ::ru::mail::go::webbase::blobs::HtmlPage* p = page_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PageStruct.page)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::HtmlPage*>(
      &::ru::mail::go::webbase::blobs::_HtmlPage_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::HtmlPage* PageStruct::mutable_page() {
  set_has_page();
  if (page_ == NULL) {
    page_ = new ::ru::mail::go::webbase::blobs::HtmlPage;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.PageStruct.page)
  return page_;
}
inline ::ru::mail::go::webbase::blobs::HtmlPage* PageStruct::release_page() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.PageStruct.page)
  clear_has_page();
  ::ru::mail::go::webbase::blobs::HtmlPage* temp = page_;
  page_ = NULL;
  return temp;
}
inline void PageStruct::set_allocated_page(::ru::mail::go::webbase::blobs::HtmlPage* page) {
  delete page_;
  page_ = page;
  if (page) {
    set_has_page();
  } else {
    clear_has_page();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.PageStruct.page)
}

// optional .ru.mail.go.webbase.blobs.ExtraTextArray extraTexts = 4;
inline bool PageStruct::has_extratexts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PageStruct::set_has_extratexts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PageStruct::clear_has_extratexts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PageStruct::clear_extratexts() {
  if (extratexts_ != NULL) extratexts_->::ru::mail::go::webbase::blobs::ExtraTextArray::Clear();
  clear_has_extratexts();
}
inline const ::ru::mail::go::webbase::blobs::ExtraTextArray& PageStruct::extratexts() const {
  const ::ru::mail::go::webbase::blobs::ExtraTextArray* p = extratexts_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PageStruct.extraTexts)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ExtraTextArray*>(
      &::ru::mail::go::webbase::blobs::_ExtraTextArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ExtraTextArray* PageStruct::mutable_extratexts() {
  set_has_extratexts();
  if (extratexts_ == NULL) {
    extratexts_ = new ::ru::mail::go::webbase::blobs::ExtraTextArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.PageStruct.extraTexts)
  return extratexts_;
}
inline ::ru::mail::go::webbase::blobs::ExtraTextArray* PageStruct::release_extratexts() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.PageStruct.extraTexts)
  clear_has_extratexts();
  ::ru::mail::go::webbase::blobs::ExtraTextArray* temp = extratexts_;
  extratexts_ = NULL;
  return temp;
}
inline void PageStruct::set_allocated_extratexts(::ru::mail::go::webbase::blobs::ExtraTextArray* extratexts) {
  delete extratexts_;
  extratexts_ = extratexts;
  if (extratexts) {
    set_has_extratexts();
  } else {
    clear_has_extratexts();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.PageStruct.extraTexts)
}

// optional .ru.mail.go.webbase.blobs.ExtraTextArray imageExtraTexts = 5;
inline bool PageStruct::has_imageextratexts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PageStruct::set_has_imageextratexts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PageStruct::clear_has_imageextratexts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PageStruct::clear_imageextratexts() {
  if (imageextratexts_ != NULL) imageextratexts_->::ru::mail::go::webbase::blobs::ExtraTextArray::Clear();
  clear_has_imageextratexts();
}
inline const ::ru::mail::go::webbase::blobs::ExtraTextArray& PageStruct::imageextratexts() const {
  const ::ru::mail::go::webbase::blobs::ExtraTextArray* p = imageextratexts_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PageStruct.imageExtraTexts)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ExtraTextArray*>(
      &::ru::mail::go::webbase::blobs::_ExtraTextArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ExtraTextArray* PageStruct::mutable_imageextratexts() {
  set_has_imageextratexts();
  if (imageextratexts_ == NULL) {
    imageextratexts_ = new ::ru::mail::go::webbase::blobs::ExtraTextArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.PageStruct.imageExtraTexts)
  return imageextratexts_;
}
inline ::ru::mail::go::webbase::blobs::ExtraTextArray* PageStruct::release_imageextratexts() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.PageStruct.imageExtraTexts)
  clear_has_imageextratexts();
  ::ru::mail::go::webbase::blobs::ExtraTextArray* temp = imageextratexts_;
  imageextratexts_ = NULL;
  return temp;
}
inline void PageStruct::set_allocated_imageextratexts(::ru::mail::go::webbase::blobs::ExtraTextArray* imageextratexts) {
  delete imageextratexts_;
  imageextratexts_ = imageextratexts;
  if (imageextratexts) {
    set_has_imageextratexts();
  } else {
    clear_has_imageextratexts();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.PageStruct.imageExtraTexts)
}

// repeated .gogo.storage.extra_info page_extra_info = 6;
inline int PageStruct::page_extra_info_size() const {
  return page_extra_info_.size();
}
inline void PageStruct::clear_page_extra_info() {
  page_extra_info_.Clear();
}
inline const ::gogo::storage::extra_info& PageStruct::page_extra_info(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PageStruct.page_extra_info)
  return page_extra_info_.Get(index);
}
inline ::gogo::storage::extra_info* PageStruct::mutable_page_extra_info(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.PageStruct.page_extra_info)
  return page_extra_info_.Mutable(index);
}
inline ::gogo::storage::extra_info* PageStruct::add_page_extra_info() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.PageStruct.page_extra_info)
  return page_extra_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >*
PageStruct::mutable_page_extra_info() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.PageStruct.page_extra_info)
  return &page_extra_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >&
PageStruct::page_extra_info() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.PageStruct.page_extra_info)
  return page_extra_info_;
}

// optional uint32 spam = 7;
inline bool PageStruct::has_spam() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PageStruct::set_has_spam() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PageStruct::clear_has_spam() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PageStruct::clear_spam() {
  spam_ = 0u;
  clear_has_spam();
}
inline ::google::protobuf::uint32 PageStruct::spam() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PageStruct.spam)
  return spam_;
}
inline void PageStruct::set_spam(::google::protobuf::uint32 value) {
  set_has_spam();
  spam_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.PageStruct.spam)
}

// required float limiterRank = 8;
inline bool PageStruct::has_limiterrank() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PageStruct::set_has_limiterrank() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PageStruct::clear_has_limiterrank() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PageStruct::clear_limiterrank() {
  limiterrank_ = 0;
  clear_has_limiterrank();
}
inline float PageStruct::limiterrank() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.PageStruct.limiterRank)
  return limiterrank_;
}
inline void PageStruct::set_limiterrank(float value) {
  set_has_limiterrank();
  limiterrank_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.PageStruct.limiterRank)
}

// -------------------------------------------------------------------

// QueryStruct

// required string query = 1;
inline bool QueryStruct::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryStruct::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryStruct::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryStruct::clear_query() {
  query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_query();
}
inline const ::std::string& QueryStruct::query() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.QueryStruct.query)
  return query_.GetNoArena();
}
inline void QueryStruct::set_query(const ::std::string& value) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.QueryStruct.query)
}
#if LANG_CXX11
inline void QueryStruct::set_query(::std::string&& value) {
  set_has_query();
  query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.QueryStruct.query)
}
#endif
inline void QueryStruct::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.QueryStruct.query)
}
inline void QueryStruct::set_query(const char* value, size_t size) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.QueryStruct.query)
}
inline ::std::string* QueryStruct::mutable_query() {
  set_has_query();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.QueryStruct.query)
  return query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryStruct::release_query() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.QueryStruct.query)
  clear_has_query();
  return query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryStruct::set_allocated_query(::std::string* query) {
  if (query != NULL) {
    set_has_query();
  } else {
    clear_has_query();
  }
  query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.QueryStruct.query)
}

// required string keyUrl = 2;
inline bool QueryStruct::has_keyurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryStruct::set_has_keyurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryStruct::clear_has_keyurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryStruct::clear_keyurl() {
  keyurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keyurl();
}
inline const ::std::string& QueryStruct::keyurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.QueryStruct.keyUrl)
  return keyurl_.GetNoArena();
}
inline void QueryStruct::set_keyurl(const ::std::string& value) {
  set_has_keyurl();
  keyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.QueryStruct.keyUrl)
}
#if LANG_CXX11
inline void QueryStruct::set_keyurl(::std::string&& value) {
  set_has_keyurl();
  keyurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.QueryStruct.keyUrl)
}
#endif
inline void QueryStruct::set_keyurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keyurl();
  keyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.QueryStruct.keyUrl)
}
inline void QueryStruct::set_keyurl(const char* value, size_t size) {
  set_has_keyurl();
  keyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.QueryStruct.keyUrl)
}
inline ::std::string* QueryStruct::mutable_keyurl() {
  set_has_keyurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.QueryStruct.keyUrl)
  return keyurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryStruct::release_keyurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.QueryStruct.keyUrl)
  clear_has_keyurl();
  return keyurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryStruct::set_allocated_keyurl(::std::string* keyurl) {
  if (keyurl != NULL) {
    set_has_keyurl();
  } else {
    clear_has_keyurl();
  }
  keyurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keyurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.QueryStruct.keyUrl)
}

// required double ctr = 3;
inline bool QueryStruct::has_ctr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryStruct::set_has_ctr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryStruct::clear_has_ctr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryStruct::clear_ctr() {
  ctr_ = 0;
  clear_has_ctr();
}
inline double QueryStruct::ctr() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.QueryStruct.ctr)
  return ctr_;
}
inline void QueryStruct::set_ctr(double value) {
  set_has_ctr();
  ctr_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.QueryStruct.ctr)
}

// required uint32 imps = 4;
inline bool QueryStruct::has_imps() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryStruct::set_has_imps() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryStruct::clear_has_imps() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryStruct::clear_imps() {
  imps_ = 0u;
  clear_has_imps();
}
inline ::google::protobuf::uint32 QueryStruct::imps() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.QueryStruct.imps)
  return imps_;
}
inline void QueryStruct::set_imps(::google::protobuf::uint32 value) {
  set_has_imps();
  imps_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.QueryStruct.imps)
}

// required uint32 gyimps = 5;
inline bool QueryStruct::has_gyimps() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QueryStruct::set_has_gyimps() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QueryStruct::clear_has_gyimps() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QueryStruct::clear_gyimps() {
  gyimps_ = 0u;
  clear_has_gyimps();
}
inline ::google::protobuf::uint32 QueryStruct::gyimps() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.QueryStruct.gyimps)
  return gyimps_;
}
inline void QueryStruct::set_gyimps(::google::protobuf::uint32 value) {
  set_has_gyimps();
  gyimps_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.QueryStruct.gyimps)
}

// -------------------------------------------------------------------

// FullPage

// required .ru.mail.go.webbase.blobs.PageStruct page = 2;
inline bool FullPage::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FullPage::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FullPage::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FullPage::clear_page() {
  if (page_ != NULL) page_->::ru::mail::go::webbase::blobs::PageStruct::Clear();
  clear_has_page();
}
inline const ::ru::mail::go::webbase::blobs::PageStruct& FullPage::page() const {
  const ::ru::mail::go::webbase::blobs::PageStruct* p = page_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FullPage.page)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::PageStruct*>(
      &::ru::mail::go::webbase::blobs::_PageStruct_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::PageStruct* FullPage::mutable_page() {
  set_has_page();
  if (page_ == NULL) {
    page_ = new ::ru::mail::go::webbase::blobs::PageStruct;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FullPage.page)
  return page_;
}
inline ::ru::mail::go::webbase::blobs::PageStruct* FullPage::release_page() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FullPage.page)
  clear_has_page();
  ::ru::mail::go::webbase::blobs::PageStruct* temp = page_;
  page_ = NULL;
  return temp;
}
inline void FullPage::set_allocated_page(::ru::mail::go::webbase::blobs::PageStruct* page) {
  delete page_;
  page_ = page;
  if (page) {
    set_has_page();
  } else {
    clear_has_page();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FullPage.page)
}

// repeated .ru.mail.go.webbase.blobs.ImageStruct image = 3;
inline int FullPage::image_size() const {
  return image_.size();
}
inline void FullPage::clear_image() {
  image_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::ImageStruct& FullPage::image(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FullPage.image)
  return image_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::ImageStruct* FullPage::mutable_image(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FullPage.image)
  return image_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::ImageStruct* FullPage::add_image() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.FullPage.image)
  return image_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageStruct >*
FullPage::mutable_image() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.FullPage.image)
  return &image_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageStruct >&
FullPage::image() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.FullPage.image)
  return image_;
}

// -------------------------------------------------------------------

// LimitingInfo

// required string imageKeyUrl = 1;
inline bool LimitingInfo::has_imagekeyurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LimitingInfo::set_has_imagekeyurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LimitingInfo::clear_has_imagekeyurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LimitingInfo::clear_imagekeyurl() {
  imagekeyurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imagekeyurl();
}
inline const ::std::string& LimitingInfo::imagekeyurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.LimitingInfo.imageKeyUrl)
  return imagekeyurl_.GetNoArena();
}
inline void LimitingInfo::set_imagekeyurl(const ::std::string& value) {
  set_has_imagekeyurl();
  imagekeyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.LimitingInfo.imageKeyUrl)
}
#if LANG_CXX11
inline void LimitingInfo::set_imagekeyurl(::std::string&& value) {
  set_has_imagekeyurl();
  imagekeyurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.LimitingInfo.imageKeyUrl)
}
#endif
inline void LimitingInfo::set_imagekeyurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imagekeyurl();
  imagekeyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.LimitingInfo.imageKeyUrl)
}
inline void LimitingInfo::set_imagekeyurl(const char* value, size_t size) {
  set_has_imagekeyurl();
  imagekeyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.LimitingInfo.imageKeyUrl)
}
inline ::std::string* LimitingInfo::mutable_imagekeyurl() {
  set_has_imagekeyurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.LimitingInfo.imageKeyUrl)
  return imagekeyurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LimitingInfo::release_imagekeyurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.LimitingInfo.imageKeyUrl)
  clear_has_imagekeyurl();
  return imagekeyurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LimitingInfo::set_allocated_imagekeyurl(::std::string* imagekeyurl) {
  if (imagekeyurl != NULL) {
    set_has_imagekeyurl();
  } else {
    clear_has_imagekeyurl();
  }
  imagekeyurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imagekeyurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.LimitingInfo.imageKeyUrl)
}

// required string pageUrl = 2;
inline bool LimitingInfo::has_pageurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LimitingInfo::set_has_pageurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LimitingInfo::clear_has_pageurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LimitingInfo::clear_pageurl() {
  pageurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pageurl();
}
inline const ::std::string& LimitingInfo::pageurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.LimitingInfo.pageUrl)
  return pageurl_.GetNoArena();
}
inline void LimitingInfo::set_pageurl(const ::std::string& value) {
  set_has_pageurl();
  pageurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.LimitingInfo.pageUrl)
}
#if LANG_CXX11
inline void LimitingInfo::set_pageurl(::std::string&& value) {
  set_has_pageurl();
  pageurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.LimitingInfo.pageUrl)
}
#endif
inline void LimitingInfo::set_pageurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pageurl();
  pageurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.LimitingInfo.pageUrl)
}
inline void LimitingInfo::set_pageurl(const char* value, size_t size) {
  set_has_pageurl();
  pageurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.LimitingInfo.pageUrl)
}
inline ::std::string* LimitingInfo::mutable_pageurl() {
  set_has_pageurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.LimitingInfo.pageUrl)
  return pageurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LimitingInfo::release_pageurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.LimitingInfo.pageUrl)
  clear_has_pageurl();
  return pageurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LimitingInfo::set_allocated_pageurl(::std::string* pageurl) {
  if (pageurl != NULL) {
    set_has_pageurl();
  } else {
    clear_has_pageurl();
  }
  pageurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pageurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.LimitingInfo.pageUrl)
}

// required float limiterRank = 3;
inline bool LimitingInfo::has_limiterrank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LimitingInfo::set_has_limiterrank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LimitingInfo::clear_has_limiterrank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LimitingInfo::clear_limiterrank() {
  limiterrank_ = 0;
  clear_has_limiterrank();
}
inline float LimitingInfo::limiterrank() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.LimitingInfo.limiterRank)
  return limiterrank_;
}
inline void LimitingInfo::set_limiterrank(float value) {
  set_has_limiterrank();
  limiterrank_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.LimitingInfo.limiterRank)
}

// -------------------------------------------------------------------

// BoundImage

// required .ru.mail.go.webbase.blobs.ImageStruct image = 1;
inline bool BoundImage::has_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoundImage::set_has_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoundImage::clear_has_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoundImage::clear_image() {
  if (image_ != NULL) image_->::ru::mail::go::webbase::blobs::ImageStruct::Clear();
  clear_has_image();
}
inline const ::ru::mail::go::webbase::blobs::ImageStruct& BoundImage::image() const {
  const ::ru::mail::go::webbase::blobs::ImageStruct* p = image_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.image)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ImageStruct*>(
      &::ru::mail::go::webbase::blobs::_ImageStruct_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ImageStruct* BoundImage::mutable_image() {
  set_has_image();
  if (image_ == NULL) {
    image_ = new ::ru::mail::go::webbase::blobs::ImageStruct;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.BoundImage.image)
  return image_;
}
inline ::ru::mail::go::webbase::blobs::ImageStruct* BoundImage::release_image() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.BoundImage.image)
  clear_has_image();
  ::ru::mail::go::webbase::blobs::ImageStruct* temp = image_;
  image_ = NULL;
  return temp;
}
inline void BoundImage::set_allocated_image(::ru::mail::go::webbase::blobs::ImageStruct* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.BoundImage.image)
}

// optional .ru.mail.go.webbase.blobs.DomainStruct pageDomain = 3;
inline bool BoundImage::has_pagedomain() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoundImage::set_has_pagedomain() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BoundImage::clear_has_pagedomain() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BoundImage::clear_pagedomain() {
  if (pagedomain_ != NULL) pagedomain_->::ru::mail::go::webbase::blobs::DomainStruct::Clear();
  clear_has_pagedomain();
}
inline const ::ru::mail::go::webbase::blobs::DomainStruct& BoundImage::pagedomain() const {
  const ::ru::mail::go::webbase::blobs::DomainStruct* p = pagedomain_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.pageDomain)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::DomainStruct*>(
      &::ru::mail::go::webbase::blobs::_DomainStruct_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::DomainStruct* BoundImage::mutable_pagedomain() {
  set_has_pagedomain();
  if (pagedomain_ == NULL) {
    pagedomain_ = new ::ru::mail::go::webbase::blobs::DomainStruct;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.BoundImage.pageDomain)
  return pagedomain_;
}
inline ::ru::mail::go::webbase::blobs::DomainStruct* BoundImage::release_pagedomain() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.BoundImage.pageDomain)
  clear_has_pagedomain();
  ::ru::mail::go::webbase::blobs::DomainStruct* temp = pagedomain_;
  pagedomain_ = NULL;
  return temp;
}
inline void BoundImage::set_allocated_pagedomain(::ru::mail::go::webbase::blobs::DomainStruct* pagedomain) {
  delete pagedomain_;
  pagedomain_ = pagedomain;
  if (pagedomain) {
    set_has_pagedomain();
  } else {
    clear_has_pagedomain();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.BoundImage.pageDomain)
}

// required string pageKeyUrl = 4;
inline bool BoundImage::has_pagekeyurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundImage::set_has_pagekeyurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoundImage::clear_has_pagekeyurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoundImage::clear_pagekeyurl() {
  pagekeyurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pagekeyurl();
}
inline const ::std::string& BoundImage::pagekeyurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.pageKeyUrl)
  return pagekeyurl_.GetNoArena();
}
inline void BoundImage::set_pagekeyurl(const ::std::string& value) {
  set_has_pagekeyurl();
  pagekeyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.pageKeyUrl)
}
#if LANG_CXX11
inline void BoundImage::set_pagekeyurl(::std::string&& value) {
  set_has_pagekeyurl();
  pagekeyurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.BoundImage.pageKeyUrl)
}
#endif
inline void BoundImage::set_pagekeyurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pagekeyurl();
  pagekeyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.BoundImage.pageKeyUrl)
}
inline void BoundImage::set_pagekeyurl(const char* value, size_t size) {
  set_has_pagekeyurl();
  pagekeyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.BoundImage.pageKeyUrl)
}
inline ::std::string* BoundImage::mutable_pagekeyurl() {
  set_has_pagekeyurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.BoundImage.pageKeyUrl)
  return pagekeyurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BoundImage::release_pagekeyurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.BoundImage.pageKeyUrl)
  clear_has_pagekeyurl();
  return pagekeyurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BoundImage::set_allocated_pagekeyurl(::std::string* pagekeyurl) {
  if (pagekeyurl != NULL) {
    set_has_pagekeyurl();
  } else {
    clear_has_pagekeyurl();
  }
  pagekeyurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pagekeyurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.BoundImage.pageKeyUrl)
}

// required string pageFullUrl = 5;
inline bool BoundImage::has_pagefullurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundImage::set_has_pagefullurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundImage::clear_has_pagefullurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundImage::clear_pagefullurl() {
  pagefullurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pagefullurl();
}
inline const ::std::string& BoundImage::pagefullurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.pageFullUrl)
  return pagefullurl_.GetNoArena();
}
inline void BoundImage::set_pagefullurl(const ::std::string& value) {
  set_has_pagefullurl();
  pagefullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.pageFullUrl)
}
#if LANG_CXX11
inline void BoundImage::set_pagefullurl(::std::string&& value) {
  set_has_pagefullurl();
  pagefullurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.BoundImage.pageFullUrl)
}
#endif
inline void BoundImage::set_pagefullurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pagefullurl();
  pagefullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.BoundImage.pageFullUrl)
}
inline void BoundImage::set_pagefullurl(const char* value, size_t size) {
  set_has_pagefullurl();
  pagefullurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.BoundImage.pageFullUrl)
}
inline ::std::string* BoundImage::mutable_pagefullurl() {
  set_has_pagefullurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.BoundImage.pageFullUrl)
  return pagefullurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BoundImage::release_pagefullurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.BoundImage.pageFullUrl)
  clear_has_pagefullurl();
  return pagefullurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BoundImage::set_allocated_pagefullurl(::std::string* pagefullurl) {
  if (pagefullurl != NULL) {
    set_has_pagefullurl();
  } else {
    clear_has_pagefullurl();
  }
  pagefullurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pagefullurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.BoundImage.pageFullUrl)
}

// repeated .ru.mail.go.webbase.blobs.TextBlock block = 6;
inline int BoundImage::block_size() const {
  return block_.size();
}
inline void BoundImage::clear_block() {
  block_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::TextBlock& BoundImage::block(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.block)
  return block_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::TextBlock* BoundImage::mutable_block(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.BoundImage.block)
  return block_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::TextBlock* BoundImage::add_block() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.BoundImage.block)
  return block_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TextBlock >*
BoundImage::mutable_block() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.BoundImage.block)
  return &block_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TextBlock >&
BoundImage::block() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.BoundImage.block)
  return block_;
}

// optional .ru.mail.go.webbase.blobs.ExtraTextArray extraTexts = 7;
inline bool BoundImage::has_extratexts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BoundImage::set_has_extratexts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BoundImage::clear_has_extratexts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BoundImage::clear_extratexts() {
  if (extratexts_ != NULL) extratexts_->::ru::mail::go::webbase::blobs::ExtraTextArray::Clear();
  clear_has_extratexts();
}
inline const ::ru::mail::go::webbase::blobs::ExtraTextArray& BoundImage::extratexts() const {
  const ::ru::mail::go::webbase::blobs::ExtraTextArray* p = extratexts_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.extraTexts)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ExtraTextArray*>(
      &::ru::mail::go::webbase::blobs::_ExtraTextArray_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ExtraTextArray* BoundImage::mutable_extratexts() {
  set_has_extratexts();
  if (extratexts_ == NULL) {
    extratexts_ = new ::ru::mail::go::webbase::blobs::ExtraTextArray;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.BoundImage.extraTexts)
  return extratexts_;
}
inline ::ru::mail::go::webbase::blobs::ExtraTextArray* BoundImage::release_extratexts() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.BoundImage.extraTexts)
  clear_has_extratexts();
  ::ru::mail::go::webbase::blobs::ExtraTextArray* temp = extratexts_;
  extratexts_ = NULL;
  return temp;
}
inline void BoundImage::set_allocated_extratexts(::ru::mail::go::webbase::blobs::ExtraTextArray* extratexts) {
  delete extratexts_;
  extratexts_ = extratexts;
  if (extratexts) {
    set_has_extratexts();
  } else {
    clear_has_extratexts();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.BoundImage.extraTexts)
}

// repeated .ru.mail.go.webbase.blobs.QueryStruct query = 8;
inline int BoundImage::query_size() const {
  return query_.size();
}
inline void BoundImage::clear_query() {
  query_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::QueryStruct& BoundImage::query(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.query)
  return query_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::QueryStruct* BoundImage::mutable_query(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.BoundImage.query)
  return query_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::QueryStruct* BoundImage::add_query() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.BoundImage.query)
  return query_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::QueryStruct >*
BoundImage::mutable_query() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.BoundImage.query)
  return &query_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::QueryStruct >&
BoundImage::query() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.BoundImage.query)
  return query_;
}

// required uint32 imagesMedium = 10;
inline bool BoundImage::has_imagesmedium() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BoundImage::set_has_imagesmedium() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BoundImage::clear_has_imagesmedium() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BoundImage::clear_imagesmedium() {
  imagesmedium_ = 0u;
  clear_has_imagesmedium();
}
inline ::google::protobuf::uint32 BoundImage::imagesmedium() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.imagesMedium)
  return imagesmedium_;
}
inline void BoundImage::set_imagesmedium(::google::protobuf::uint32 value) {
  set_has_imagesmedium();
  imagesmedium_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.imagesMedium)
}

// required uint32 imagesLarge = 11;
inline bool BoundImage::has_imageslarge() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BoundImage::set_has_imageslarge() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BoundImage::clear_has_imageslarge() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BoundImage::clear_imageslarge() {
  imageslarge_ = 0u;
  clear_has_imageslarge();
}
inline ::google::protobuf::uint32 BoundImage::imageslarge() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.imagesLarge)
  return imageslarge_;
}
inline void BoundImage::set_imageslarge(::google::protobuf::uint32 value) {
  set_has_imageslarge();
  imageslarge_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.imagesLarge)
}

// optional uint32 imagesDups = 12;
inline bool BoundImage::has_imagesdups() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BoundImage::set_has_imagesdups() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BoundImage::clear_has_imagesdups() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BoundImage::clear_imagesdups() {
  imagesdups_ = 0u;
  clear_has_imagesdups();
}
inline ::google::protobuf::uint32 BoundImage::imagesdups() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.imagesDups)
  return imagesdups_;
}
inline void BoundImage::set_imagesdups(::google::protobuf::uint32 value) {
  set_has_imagesdups();
  imagesdups_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.imagesDups)
}

// required uint32 porn = 13;
inline bool BoundImage::has_porn() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BoundImage::set_has_porn() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BoundImage::clear_has_porn() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BoundImage::clear_porn() {
  porn_ = 0u;
  clear_has_porn();
}
inline ::google::protobuf::uint32 BoundImage::porn() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.porn)
  return porn_;
}
inline void BoundImage::set_porn(::google::protobuf::uint32 value) {
  set_has_porn();
  porn_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.porn)
}

// optional uint32 preview_db = 14;
inline bool BoundImage::has_preview_db() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BoundImage::set_has_preview_db() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BoundImage::clear_has_preview_db() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BoundImage::clear_preview_db() {
  preview_db_ = 0u;
  clear_has_preview_db();
}
inline ::google::protobuf::uint32 BoundImage::preview_db() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.preview_db)
  return preview_db_;
}
inline void BoundImage::set_preview_db(::google::protobuf::uint32 value) {
  set_has_preview_db();
  preview_db_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.preview_db)
}

// optional uint32 time = 15 [default = 0];
inline bool BoundImage::has_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BoundImage::set_has_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BoundImage::clear_has_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BoundImage::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 BoundImage::time() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.time)
  return time_;
}
inline void BoundImage::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.time)
}

// optional uint32 maxPorn = 16;
inline bool BoundImage::has_maxporn() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BoundImage::set_has_maxporn() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BoundImage::clear_has_maxporn() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BoundImage::clear_maxporn() {
  maxporn_ = 0u;
  clear_has_maxporn();
}
inline ::google::protobuf::uint32 BoundImage::maxporn() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.maxPorn)
  return maxporn_;
}
inline void BoundImage::set_maxporn(::google::protobuf::uint32 value) {
  set_has_maxporn();
  maxporn_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.maxPorn)
}

// optional .ru.mail.go.webbase.blobs.FeatureList featuresList = 17;
inline bool BoundImage::has_featureslist() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BoundImage::set_has_featureslist() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BoundImage::clear_has_featureslist() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BoundImage::clear_featureslist() {
  if (featureslist_ != NULL) featureslist_->::ru::mail::go::webbase::blobs::FeatureList::Clear();
  clear_has_featureslist();
}
inline const ::ru::mail::go::webbase::blobs::FeatureList& BoundImage::featureslist() const {
  const ::ru::mail::go::webbase::blobs::FeatureList* p = featureslist_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.featuresList)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::FeatureList*>(
      &::ru::mail::go::webbase::blobs::_FeatureList_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::FeatureList* BoundImage::mutable_featureslist() {
  set_has_featureslist();
  if (featureslist_ == NULL) {
    featureslist_ = new ::ru::mail::go::webbase::blobs::FeatureList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.BoundImage.featuresList)
  return featureslist_;
}
inline ::ru::mail::go::webbase::blobs::FeatureList* BoundImage::release_featureslist() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.BoundImage.featuresList)
  clear_has_featureslist();
  ::ru::mail::go::webbase::blobs::FeatureList* temp = featureslist_;
  featureslist_ = NULL;
  return temp;
}
inline void BoundImage::set_allocated_featureslist(::ru::mail::go::webbase::blobs::FeatureList* featureslist) {
  delete featureslist_;
  featureslist_ = featureslist;
  if (featureslist) {
    set_has_featureslist();
  } else {
    clear_has_featureslist();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.BoundImage.featuresList)
}

// optional .ru.mail.go.webbase.blobs.ClusteringResult clusteringResult = 18;
inline bool BoundImage::has_clusteringresult() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BoundImage::set_has_clusteringresult() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BoundImage::clear_has_clusteringresult() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BoundImage::clear_clusteringresult() {
  if (clusteringresult_ != NULL) clusteringresult_->::ru::mail::go::webbase::blobs::ClusteringResult::Clear();
  clear_has_clusteringresult();
}
inline const ::ru::mail::go::webbase::blobs::ClusteringResult& BoundImage::clusteringresult() const {
  const ::ru::mail::go::webbase::blobs::ClusteringResult* p = clusteringresult_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.clusteringResult)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ClusteringResult*>(
      &::ru::mail::go::webbase::blobs::_ClusteringResult_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ClusteringResult* BoundImage::mutable_clusteringresult() {
  set_has_clusteringresult();
  if (clusteringresult_ == NULL) {
    clusteringresult_ = new ::ru::mail::go::webbase::blobs::ClusteringResult;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.BoundImage.clusteringResult)
  return clusteringresult_;
}
inline ::ru::mail::go::webbase::blobs::ClusteringResult* BoundImage::release_clusteringresult() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.BoundImage.clusteringResult)
  clear_has_clusteringresult();
  ::ru::mail::go::webbase::blobs::ClusteringResult* temp = clusteringresult_;
  clusteringresult_ = NULL;
  return temp;
}
inline void BoundImage::set_allocated_clusteringresult(::ru::mail::go::webbase::blobs::ClusteringResult* clusteringresult) {
  delete clusteringresult_;
  clusteringresult_ = clusteringresult;
  if (clusteringresult) {
    set_has_clusteringresult();
  } else {
    clear_has_clusteringresult();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.BoundImage.clusteringResult)
}

// repeated .gogo.storage.extra_info page_extra_info = 21;
inline int BoundImage::page_extra_info_size() const {
  return page_extra_info_.size();
}
inline void BoundImage::clear_page_extra_info() {
  page_extra_info_.Clear();
}
inline const ::gogo::storage::extra_info& BoundImage::page_extra_info(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.page_extra_info)
  return page_extra_info_.Get(index);
}
inline ::gogo::storage::extra_info* BoundImage::mutable_page_extra_info(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.BoundImage.page_extra_info)
  return page_extra_info_.Mutable(index);
}
inline ::gogo::storage::extra_info* BoundImage::add_page_extra_info() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.BoundImage.page_extra_info)
  return page_extra_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >*
BoundImage::mutable_page_extra_info() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.BoundImage.page_extra_info)
  return &page_extra_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::gogo::storage::extra_info >&
BoundImage::page_extra_info() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.BoundImage.page_extra_info)
  return page_extra_info_;
}

// optional uint32 imageCopies = 22;
inline bool BoundImage::has_imagecopies() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BoundImage::set_has_imagecopies() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BoundImage::clear_has_imagecopies() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BoundImage::clear_imagecopies() {
  imagecopies_ = 0u;
  clear_has_imagecopies();
}
inline ::google::protobuf::uint32 BoundImage::imagecopies() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.imageCopies)
  return imagecopies_;
}
inline void BoundImage::set_imagecopies(::google::protobuf::uint32 value) {
  set_has_imagecopies();
  imagecopies_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.imageCopies)
}

// optional uint32 numPages = 23;
inline bool BoundImage::has_numpages() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BoundImage::set_has_numpages() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BoundImage::clear_has_numpages() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BoundImage::clear_numpages() {
  numpages_ = 0u;
  clear_has_numpages();
}
inline ::google::protobuf::uint32 BoundImage::numpages() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.numPages)
  return numpages_;
}
inline void BoundImage::set_numpages(::google::protobuf::uint32 value) {
  set_has_numpages();
  numpages_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.numPages)
}

// repeated uint32 pornStat = 24;
inline int BoundImage::pornstat_size() const {
  return pornstat_.size();
}
inline void BoundImage::clear_pornstat() {
  pornstat_.Clear();
}
inline ::google::protobuf::uint32 BoundImage::pornstat(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.pornStat)
  return pornstat_.Get(index);
}
inline void BoundImage::set_pornstat(int index, ::google::protobuf::uint32 value) {
  pornstat_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.pornStat)
}
inline void BoundImage::add_pornstat(::google::protobuf::uint32 value) {
  pornstat_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.BoundImage.pornStat)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
BoundImage::pornstat() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.BoundImage.pornStat)
  return pornstat_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
BoundImage::mutable_pornstat() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.BoundImage.pornStat)
  return &pornstat_;
}

// optional uint32 spam = 25;
inline bool BoundImage::has_spam() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BoundImage::set_has_spam() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BoundImage::clear_has_spam() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BoundImage::clear_spam() {
  spam_ = 0u;
  clear_has_spam();
}
inline ::google::protobuf::uint32 BoundImage::spam() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.spam)
  return spam_;
}
inline void BoundImage::set_spam(::google::protobuf::uint32 value) {
  set_has_spam();
  spam_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.spam)
}

// optional uint32 altlen = 26;
inline bool BoundImage::has_altlen() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BoundImage::set_has_altlen() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BoundImage::clear_has_altlen() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BoundImage::clear_altlen() {
  altlen_ = 0u;
  clear_has_altlen();
}
inline ::google::protobuf::uint32 BoundImage::altlen() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.altlen)
  return altlen_;
}
inline void BoundImage::set_altlen(::google::protobuf::uint32 value) {
  set_has_altlen();
  altlen_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.altlen)
}

// optional uint64 cluster_id = 27;
inline bool BoundImage::has_cluster_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BoundImage::set_has_cluster_id() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BoundImage::clear_has_cluster_id() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BoundImage::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cluster_id();
}
inline ::google::protobuf::uint64 BoundImage::cluster_id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.cluster_id)
  return cluster_id_;
}
inline void BoundImage::set_cluster_id(::google::protobuf::uint64 value) {
  set_has_cluster_id();
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.cluster_id)
}

// optional uint32 numTextBlocks = 28;
inline bool BoundImage::has_numtextblocks() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BoundImage::set_has_numtextblocks() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BoundImage::clear_has_numtextblocks() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BoundImage::clear_numtextblocks() {
  numtextblocks_ = 0u;
  clear_has_numtextblocks();
}
inline ::google::protobuf::uint32 BoundImage::numtextblocks() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.numTextBlocks)
  return numtextblocks_;
}
inline void BoundImage::set_numtextblocks(::google::protobuf::uint32 value) {
  set_has_numtextblocks();
  numtextblocks_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.numTextBlocks)
}

// optional float limiterRank = 29;
inline bool BoundImage::has_limiterrank() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BoundImage::set_has_limiterrank() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BoundImage::clear_has_limiterrank() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BoundImage::clear_limiterrank() {
  limiterrank_ = 0;
  clear_has_limiterrank();
}
inline float BoundImage::limiterrank() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.BoundImage.limiterRank)
  return limiterrank_;
}
inline void BoundImage::set_limiterrank(float value) {
  set_has_limiterrank();
  limiterrank_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.BoundImage.limiterRank)
}

// -------------------------------------------------------------------

// TextBlock

// required string text = 1;
inline bool TextBlock::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextBlock::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextBlock::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextBlock::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& TextBlock::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextBlock.text)
  return text_.GetNoArena();
}
inline void TextBlock::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextBlock.text)
}
#if LANG_CXX11
inline void TextBlock::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TextBlock.text)
}
#endif
inline void TextBlock::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TextBlock.text)
}
inline void TextBlock::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TextBlock.text)
}
inline ::std::string* TextBlock::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TextBlock.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextBlock::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TextBlock.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextBlock::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TextBlock.text)
}

// required .ru.mail.go.webbase.blobs.ZoneName zname = 2;
inline bool TextBlock::has_zname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextBlock::set_has_zname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextBlock::clear_has_zname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextBlock::clear_zname() {
  zname_ = 1;
  clear_has_zname();
}
inline ::ru::mail::go::webbase::blobs::ZoneName TextBlock::zname() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextBlock.zname)
  return static_cast< ::ru::mail::go::webbase::blobs::ZoneName >(zname_);
}
inline void TextBlock::set_zname(::ru::mail::go::webbase::blobs::ZoneName value) {
  assert(::ru::mail::go::webbase::blobs::ZoneName_IsValid(value));
  set_has_zname();
  zname_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextBlock.zname)
}

// optional uint32 dist = 3;
inline bool TextBlock::has_dist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextBlock::set_has_dist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextBlock::clear_has_dist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextBlock::clear_dist() {
  dist_ = 0u;
  clear_has_dist();
}
inline ::google::protobuf::uint32 TextBlock::dist() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextBlock.dist)
  return dist_;
}
inline void TextBlock::set_dist(::google::protobuf::uint32 value) {
  set_has_dist();
  dist_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextBlock.dist)
}

// repeated .ru.mail.go.webbase.blobs.Tag tags = 4;
inline int TextBlock::tags_size() const {
  return tags_.size();
}
inline void TextBlock::clear_tags() {
  tags_.Clear();
}
inline ::ru::mail::go::webbase::blobs::Tag TextBlock::tags(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextBlock.tags)
  return static_cast< ::ru::mail::go::webbase::blobs::Tag >(tags_.Get(index));
}
inline void TextBlock::set_tags(int index, ::ru::mail::go::webbase::blobs::Tag value) {
  assert(::ru::mail::go::webbase::blobs::Tag_IsValid(value));
  tags_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextBlock.tags)
}
inline void TextBlock::add_tags(::ru::mail::go::webbase::blobs::Tag value) {
  assert(::ru::mail::go::webbase::blobs::Tag_IsValid(value));
  tags_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.TextBlock.tags)
}
inline const ::google::protobuf::RepeatedField<int>&
TextBlock::tags() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.TextBlock.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedField<int>*
TextBlock::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.TextBlock.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// VisitInfo

// required int64 lastYVisit = 1;
inline bool VisitInfo::has_lastyvisit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisitInfo::set_has_lastyvisit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VisitInfo::clear_has_lastyvisit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VisitInfo::clear_lastyvisit() {
  lastyvisit_ = GOOGLE_LONGLONG(0);
  clear_has_lastyvisit();
}
inline ::google::protobuf::int64 VisitInfo::lastyvisit() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.VisitInfo.lastYVisit)
  return lastyvisit_;
}
inline void VisitInfo::set_lastyvisit(::google::protobuf::int64 value) {
  set_has_lastyvisit();
  lastyvisit_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.VisitInfo.lastYVisit)
}

// required int64 lastGVisit = 2;
inline bool VisitInfo::has_lastgvisit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VisitInfo::set_has_lastgvisit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VisitInfo::clear_has_lastgvisit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VisitInfo::clear_lastgvisit() {
  lastgvisit_ = GOOGLE_LONGLONG(0);
  clear_has_lastgvisit();
}
inline ::google::protobuf::int64 VisitInfo::lastgvisit() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.VisitInfo.lastGVisit)
  return lastgvisit_;
}
inline void VisitInfo::set_lastgvisit(::google::protobuf::int64 value) {
  set_has_lastgvisit();
  lastgvisit_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.VisitInfo.lastGVisit)
}

// -------------------------------------------------------------------

// UrlPair

// required string image = 1;
inline bool UrlPair::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UrlPair::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UrlPair::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UrlPair::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image();
}
inline const ::std::string& UrlPair::image() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlPair.image)
  return image_.GetNoArena();
}
inline void UrlPair::set_image(const ::std::string& value) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlPair.image)
}
#if LANG_CXX11
inline void UrlPair::set_image(::std::string&& value) {
  set_has_image();
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.UrlPair.image)
}
#endif
inline void UrlPair::set_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.UrlPair.image)
}
inline void UrlPair::set_image(const char* value, size_t size) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.UrlPair.image)
}
inline ::std::string* UrlPair::mutable_image() {
  set_has_image();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlPair.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UrlPair::release_image() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.UrlPair.image)
  clear_has_image();
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UrlPair::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    set_has_image();
  } else {
    clear_has_image();
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.UrlPair.image)
}

// required string page = 2;
inline bool UrlPair::has_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UrlPair::set_has_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UrlPair::clear_has_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UrlPair::clear_page() {
  page_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_page();
}
inline const ::std::string& UrlPair::page() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlPair.page)
  return page_.GetNoArena();
}
inline void UrlPair::set_page(const ::std::string& value) {
  set_has_page();
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlPair.page)
}
#if LANG_CXX11
inline void UrlPair::set_page(::std::string&& value) {
  set_has_page();
  page_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.UrlPair.page)
}
#endif
inline void UrlPair::set_page(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_page();
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.UrlPair.page)
}
inline void UrlPair::set_page(const char* value, size_t size) {
  set_has_page();
  page_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.UrlPair.page)
}
inline ::std::string* UrlPair::mutable_page() {
  set_has_page();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlPair.page)
  return page_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UrlPair::release_page() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.UrlPair.page)
  clear_has_page();
  return page_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UrlPair::set_allocated_page(::std::string* page) {
  if (page != NULL) {
    set_has_page();
  } else {
    clear_has_page();
  }
  page_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), page);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.UrlPair.page)
}

// -------------------------------------------------------------------

// Any

// optional .ru.mail.go.webbase.blobs.DomainStruct domain = 1;
inline bool Any::has_domain() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Any::set_has_domain() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Any::clear_has_domain() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Any::clear_domain() {
  if (domain_ != NULL) domain_->::ru::mail::go::webbase::blobs::DomainStruct::Clear();
  clear_has_domain();
}
inline const ::ru::mail::go::webbase::blobs::DomainStruct& Any::domain() const {
  const ::ru::mail::go::webbase::blobs::DomainStruct* p = domain_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Any.domain)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::DomainStruct*>(
      &::ru::mail::go::webbase::blobs::_DomainStruct_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::DomainStruct* Any::mutable_domain() {
  set_has_domain();
  if (domain_ == NULL) {
    domain_ = new ::ru::mail::go::webbase::blobs::DomainStruct;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Any.domain)
  return domain_;
}
inline ::ru::mail::go::webbase::blobs::DomainStruct* Any::release_domain() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Any.domain)
  clear_has_domain();
  ::ru::mail::go::webbase::blobs::DomainStruct* temp = domain_;
  domain_ = NULL;
  return temp;
}
inline void Any::set_allocated_domain(::ru::mail::go::webbase::blobs::DomainStruct* domain) {
  delete domain_;
  domain_ = domain;
  if (domain) {
    set_has_domain();
  } else {
    clear_has_domain();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Any.domain)
}

// optional .ru.mail.go.webbase.blobs.ImageStruct image = 2;
inline bool Any::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Any::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Any::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Any::clear_image() {
  if (image_ != NULL) image_->::ru::mail::go::webbase::blobs::ImageStruct::Clear();
  clear_has_image();
}
inline const ::ru::mail::go::webbase::blobs::ImageStruct& Any::image() const {
  const ::ru::mail::go::webbase::blobs::ImageStruct* p = image_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Any.image)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ImageStruct*>(
      &::ru::mail::go::webbase::blobs::_ImageStruct_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ImageStruct* Any::mutable_image() {
  set_has_image();
  if (image_ == NULL) {
    image_ = new ::ru::mail::go::webbase::blobs::ImageStruct;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Any.image)
  return image_;
}
inline ::ru::mail::go::webbase::blobs::ImageStruct* Any::release_image() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Any.image)
  clear_has_image();
  ::ru::mail::go::webbase::blobs::ImageStruct* temp = image_;
  image_ = NULL;
  return temp;
}
inline void Any::set_allocated_image(::ru::mail::go::webbase::blobs::ImageStruct* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Any.image)
}

// optional .ru.mail.go.webbase.blobs.PageStruct page = 3;
inline bool Any::has_page() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Any::set_has_page() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Any::clear_has_page() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Any::clear_page() {
  if (page_ != NULL) page_->::ru::mail::go::webbase::blobs::PageStruct::Clear();
  clear_has_page();
}
inline const ::ru::mail::go::webbase::blobs::PageStruct& Any::page() const {
  const ::ru::mail::go::webbase::blobs::PageStruct* p = page_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Any.page)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::PageStruct*>(
      &::ru::mail::go::webbase::blobs::_PageStruct_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::PageStruct* Any::mutable_page() {
  set_has_page();
  if (page_ == NULL) {
    page_ = new ::ru::mail::go::webbase::blobs::PageStruct;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Any.page)
  return page_;
}
inline ::ru::mail::go::webbase::blobs::PageStruct* Any::release_page() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Any.page)
  clear_has_page();
  ::ru::mail::go::webbase::blobs::PageStruct* temp = page_;
  page_ = NULL;
  return temp;
}
inline void Any::set_allocated_page(::ru::mail::go::webbase::blobs::PageStruct* page) {
  delete page_;
  page_ = page;
  if (page) {
    set_has_page();
  } else {
    clear_has_page();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Any.page)
}

// optional string keyDomain = 4;
inline bool Any::has_keydomain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Any::set_has_keydomain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Any::clear_has_keydomain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Any::clear_keydomain() {
  keydomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keydomain();
}
inline const ::std::string& Any::keydomain() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Any.keyDomain)
  return keydomain_.GetNoArena();
}
inline void Any::set_keydomain(const ::std::string& value) {
  set_has_keydomain();
  keydomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Any.keyDomain)
}
#if LANG_CXX11
inline void Any::set_keydomain(::std::string&& value) {
  set_has_keydomain();
  keydomain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Any.keyDomain)
}
#endif
inline void Any::set_keydomain(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keydomain();
  keydomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Any.keyDomain)
}
inline void Any::set_keydomain(const char* value, size_t size) {
  set_has_keydomain();
  keydomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Any.keyDomain)
}
inline ::std::string* Any::mutable_keydomain() {
  set_has_keydomain();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Any.keyDomain)
  return keydomain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Any::release_keydomain() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Any.keyDomain)
  clear_has_keydomain();
  return keydomain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Any::set_allocated_keydomain(::std::string* keydomain) {
  if (keydomain != NULL) {
    set_has_keydomain();
  } else {
    clear_has_keydomain();
  }
  keydomain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keydomain);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Any.keyDomain)
}

// optional string pageKeyUrl = 5;
inline bool Any::has_pagekeyurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Any::set_has_pagekeyurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Any::clear_has_pagekeyurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Any::clear_pagekeyurl() {
  pagekeyurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pagekeyurl();
}
inline const ::std::string& Any::pagekeyurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Any.pageKeyUrl)
  return pagekeyurl_.GetNoArena();
}
inline void Any::set_pagekeyurl(const ::std::string& value) {
  set_has_pagekeyurl();
  pagekeyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Any.pageKeyUrl)
}
#if LANG_CXX11
inline void Any::set_pagekeyurl(::std::string&& value) {
  set_has_pagekeyurl();
  pagekeyurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.Any.pageKeyUrl)
}
#endif
inline void Any::set_pagekeyurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pagekeyurl();
  pagekeyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.Any.pageKeyUrl)
}
inline void Any::set_pagekeyurl(const char* value, size_t size) {
  set_has_pagekeyurl();
  pagekeyurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.Any.pageKeyUrl)
}
inline ::std::string* Any::mutable_pagekeyurl() {
  set_has_pagekeyurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Any.pageKeyUrl)
  return pagekeyurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Any::release_pagekeyurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Any.pageKeyUrl)
  clear_has_pagekeyurl();
  return pagekeyurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Any::set_allocated_pagekeyurl(::std::string* pagekeyurl) {
  if (pagekeyurl != NULL) {
    set_has_pagekeyurl();
  } else {
    clear_has_pagekeyurl();
  }
  pagekeyurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pagekeyurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Any.pageKeyUrl)
}

// optional .ru.mail.go.webbase.blobs.FullPage fullPage = 6;
inline bool Any::has_fullpage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Any::set_has_fullpage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Any::clear_has_fullpage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Any::clear_fullpage() {
  if (fullpage_ != NULL) fullpage_->::ru::mail::go::webbase::blobs::FullPage::Clear();
  clear_has_fullpage();
}
inline const ::ru::mail::go::webbase::blobs::FullPage& Any::fullpage() const {
  const ::ru::mail::go::webbase::blobs::FullPage* p = fullpage_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Any.fullPage)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::FullPage*>(
      &::ru::mail::go::webbase::blobs::_FullPage_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::FullPage* Any::mutable_fullpage() {
  set_has_fullpage();
  if (fullpage_ == NULL) {
    fullpage_ = new ::ru::mail::go::webbase::blobs::FullPage;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Any.fullPage)
  return fullpage_;
}
inline ::ru::mail::go::webbase::blobs::FullPage* Any::release_fullpage() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Any.fullPage)
  clear_has_fullpage();
  ::ru::mail::go::webbase::blobs::FullPage* temp = fullpage_;
  fullpage_ = NULL;
  return temp;
}
inline void Any::set_allocated_fullpage(::ru::mail::go::webbase::blobs::FullPage* fullpage) {
  delete fullpage_;
  fullpage_ = fullpage;
  if (fullpage) {
    set_has_fullpage();
  } else {
    clear_has_fullpage();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Any.fullPage)
}

// optional .ru.mail.go.webbase.blobs.BoundImage boundImage = 7;
inline bool Any::has_boundimage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Any::set_has_boundimage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Any::clear_has_boundimage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Any::clear_boundimage() {
  if (boundimage_ != NULL) boundimage_->::ru::mail::go::webbase::blobs::BoundImage::Clear();
  clear_has_boundimage();
}
inline const ::ru::mail::go::webbase::blobs::BoundImage& Any::boundimage() const {
  const ::ru::mail::go::webbase::blobs::BoundImage* p = boundimage_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Any.boundImage)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::BoundImage*>(
      &::ru::mail::go::webbase::blobs::_BoundImage_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::BoundImage* Any::mutable_boundimage() {
  set_has_boundimage();
  if (boundimage_ == NULL) {
    boundimage_ = new ::ru::mail::go::webbase::blobs::BoundImage;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Any.boundImage)
  return boundimage_;
}
inline ::ru::mail::go::webbase::blobs::BoundImage* Any::release_boundimage() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Any.boundImage)
  clear_has_boundimage();
  ::ru::mail::go::webbase::blobs::BoundImage* temp = boundimage_;
  boundimage_ = NULL;
  return temp;
}
inline void Any::set_allocated_boundimage(::ru::mail::go::webbase::blobs::BoundImage* boundimage) {
  delete boundimage_;
  boundimage_ = boundimage;
  if (boundimage) {
    set_has_boundimage();
  } else {
    clear_has_boundimage();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Any.boundImage)
}

// optional .ru.mail.go.webbase.blobs.LimitingInfo limitingInfo = 8;
inline bool Any::has_limitinginfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Any::set_has_limitinginfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Any::clear_has_limitinginfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Any::clear_limitinginfo() {
  if (limitinginfo_ != NULL) limitinginfo_->::ru::mail::go::webbase::blobs::LimitingInfo::Clear();
  clear_has_limitinginfo();
}
inline const ::ru::mail::go::webbase::blobs::LimitingInfo& Any::limitinginfo() const {
  const ::ru::mail::go::webbase::blobs::LimitingInfo* p = limitinginfo_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Any.limitingInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::LimitingInfo*>(
      &::ru::mail::go::webbase::blobs::_LimitingInfo_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::LimitingInfo* Any::mutable_limitinginfo() {
  set_has_limitinginfo();
  if (limitinginfo_ == NULL) {
    limitinginfo_ = new ::ru::mail::go::webbase::blobs::LimitingInfo;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Any.limitingInfo)
  return limitinginfo_;
}
inline ::ru::mail::go::webbase::blobs::LimitingInfo* Any::release_limitinginfo() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Any.limitingInfo)
  clear_has_limitinginfo();
  ::ru::mail::go::webbase::blobs::LimitingInfo* temp = limitinginfo_;
  limitinginfo_ = NULL;
  return temp;
}
inline void Any::set_allocated_limitinginfo(::ru::mail::go::webbase::blobs::LimitingInfo* limitinginfo) {
  delete limitinginfo_;
  limitinginfo_ = limitinginfo;
  if (limitinginfo) {
    set_has_limitinginfo();
  } else {
    clear_has_limitinginfo();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Any.limitingInfo)
}

// optional uint64 cluster_id = 9;
inline bool Any::has_cluster_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Any::set_has_cluster_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Any::clear_has_cluster_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Any::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cluster_id();
}
inline ::google::protobuf::uint64 Any::cluster_id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Any.cluster_id)
  return cluster_id_;
}
inline void Any::set_cluster_id(::google::protobuf::uint64 value) {
  set_has_cluster_id();
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.Any.cluster_id)
}

// optional .ru.mail.go.webbase.sekitei.Sekitei_m sekitei = 10;
inline bool Any::has_sekitei() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Any::set_has_sekitei() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Any::clear_has_sekitei() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Any::clear_sekitei() {
  if (sekitei_ != NULL) sekitei_->::ru::mail::go::webbase::sekitei::Sekitei_m::Clear();
  clear_has_sekitei();
}
inline const ::ru::mail::go::webbase::sekitei::Sekitei_m& Any::sekitei() const {
  const ::ru::mail::go::webbase::sekitei::Sekitei_m* p = sekitei_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Any.sekitei)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::sekitei::Sekitei_m*>(
      &::ru::mail::go::webbase::sekitei::_Sekitei_m_default_instance_);
}
inline ::ru::mail::go::webbase::sekitei::Sekitei_m* Any::mutable_sekitei() {
  set_has_sekitei();
  if (sekitei_ == NULL) {
    sekitei_ = new ::ru::mail::go::webbase::sekitei::Sekitei_m;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Any.sekitei)
  return sekitei_;
}
inline ::ru::mail::go::webbase::sekitei::Sekitei_m* Any::release_sekitei() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.Any.sekitei)
  clear_has_sekitei();
  ::ru::mail::go::webbase::sekitei::Sekitei_m* temp = sekitei_;
  sekitei_ = NULL;
  return temp;
}
inline void Any::set_allocated_sekitei(::ru::mail::go::webbase::sekitei::Sekitei_m* sekitei) {
  delete sekitei_;
  sekitei_ = sekitei;
  if (sekitei) {
    set_has_sekitei();
  } else {
    clear_has_sekitei();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.Any.sekitei)
}

// repeated .ru.mail.go.webbase.blobs.UrlPair duplicates = 11;
inline int Any::duplicates_size() const {
  return duplicates_.size();
}
inline void Any::clear_duplicates() {
  duplicates_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::UrlPair& Any::duplicates(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.Any.duplicates)
  return duplicates_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::UrlPair* Any::mutable_duplicates(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.Any.duplicates)
  return duplicates_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::UrlPair* Any::add_duplicates() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.Any.duplicates)
  return duplicates_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::UrlPair >*
Any::mutable_duplicates() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.Any.duplicates)
  return &duplicates_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::UrlPair >&
Any::duplicates() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.Any.duplicates)
  return duplicates_;
}

// -------------------------------------------------------------------

// ImageMarkerUrlTrace

// required .ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.StageInfo stage = 1;
inline bool ImageMarkerUrlTrace::has_stage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageMarkerUrlTrace::set_has_stage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageMarkerUrlTrace::clear_has_stage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageMarkerUrlTrace::clear_stage() {
  stage_ = 0;
  clear_has_stage();
}
inline ::ru::mail::go::webbase::blobs::ImageMarkerUrlTrace_StageInfo ImageMarkerUrlTrace::stage() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.stage)
  return static_cast< ::ru::mail::go::webbase::blobs::ImageMarkerUrlTrace_StageInfo >(stage_);
}
inline void ImageMarkerUrlTrace::set_stage(::ru::mail::go::webbase::blobs::ImageMarkerUrlTrace_StageInfo value) {
  assert(::ru::mail::go::webbase::blobs::ImageMarkerUrlTrace_StageInfo_IsValid(value));
  set_has_stage();
  stage_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.stage)
}

// optional int64 limiterPos = 2;
inline bool ImageMarkerUrlTrace::has_limiterpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageMarkerUrlTrace::set_has_limiterpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageMarkerUrlTrace::clear_has_limiterpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageMarkerUrlTrace::clear_limiterpos() {
  limiterpos_ = GOOGLE_LONGLONG(0);
  clear_has_limiterpos();
}
inline ::google::protobuf::int64 ImageMarkerUrlTrace::limiterpos() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.limiterPos)
  return limiterpos_;
}
inline void ImageMarkerUrlTrace::set_limiterpos(::google::protobuf::int64 value) {
  set_has_limiterpos();
  limiterpos_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.limiterPos)
}

// optional string mainDup = 3;
inline bool ImageMarkerUrlTrace::has_maindup() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageMarkerUrlTrace::set_has_maindup() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageMarkerUrlTrace::clear_has_maindup() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageMarkerUrlTrace::clear_maindup() {
  maindup_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_maindup();
}
inline const ::std::string& ImageMarkerUrlTrace::maindup() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.mainDup)
  return maindup_.GetNoArena();
}
inline void ImageMarkerUrlTrace::set_maindup(const ::std::string& value) {
  set_has_maindup();
  maindup_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.mainDup)
}
#if LANG_CXX11
inline void ImageMarkerUrlTrace::set_maindup(::std::string&& value) {
  set_has_maindup();
  maindup_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.mainDup)
}
#endif
inline void ImageMarkerUrlTrace::set_maindup(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_maindup();
  maindup_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.mainDup)
}
inline void ImageMarkerUrlTrace::set_maindup(const char* value, size_t size) {
  set_has_maindup();
  maindup_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.mainDup)
}
inline ::std::string* ImageMarkerUrlTrace::mutable_maindup() {
  set_has_maindup();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.mainDup)
  return maindup_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageMarkerUrlTrace::release_maindup() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.mainDup)
  clear_has_maindup();
  return maindup_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageMarkerUrlTrace::set_allocated_maindup(::std::string* maindup) {
  if (maindup != NULL) {
    set_has_maindup();
  } else {
    clear_has_maindup();
  }
  maindup_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), maindup);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageMarkerUrlTrace.mainDup)
}

// -------------------------------------------------------------------

// ImageTexts_PageTexts

// repeated .ru.mail.go.webbase.blobs.TextBlock text = 1;
inline int ImageTexts_PageTexts::text_size() const {
  return text_.size();
}
inline void ImageTexts_PageTexts::clear_text() {
  text_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::TextBlock& ImageTexts_PageTexts::text(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageTexts.PageTexts.text)
  return text_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::TextBlock* ImageTexts_PageTexts::mutable_text(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageTexts.PageTexts.text)
  return text_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::TextBlock* ImageTexts_PageTexts::add_text() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ImageTexts.PageTexts.text)
  return text_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TextBlock >*
ImageTexts_PageTexts::mutable_text() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ImageTexts.PageTexts.text)
  return &text_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::TextBlock >&
ImageTexts_PageTexts::text() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ImageTexts.PageTexts.text)
  return text_;
}

// -------------------------------------------------------------------

// ImageTexts

// repeated .ru.mail.go.webbase.blobs.ImageTexts.PageTexts texts = 1;
inline int ImageTexts::texts_size() const {
  return texts_.size();
}
inline void ImageTexts::clear_texts() {
  texts_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::ImageTexts_PageTexts& ImageTexts::texts(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageTexts.texts)
  return texts_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::ImageTexts_PageTexts* ImageTexts::mutable_texts(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageTexts.texts)
  return texts_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::ImageTexts_PageTexts* ImageTexts::add_texts() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ImageTexts.texts)
  return texts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageTexts_PageTexts >*
ImageTexts::mutable_texts() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ImageTexts.texts)
  return &texts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::ImageTexts_PageTexts >&
ImageTexts::texts() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ImageTexts.texts)
  return texts_;
}

// -------------------------------------------------------------------

// ClusteringResult

// repeated float pagesWeights = 1;
inline int ClusteringResult::pagesweights_size() const {
  return pagesweights_.size();
}
inline void ClusteringResult::clear_pagesweights() {
  pagesweights_.Clear();
}
inline float ClusteringResult::pagesweights(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ClusteringResult.pagesWeights)
  return pagesweights_.Get(index);
}
inline void ClusteringResult::set_pagesweights(int index, float value) {
  pagesweights_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ClusteringResult.pagesWeights)
}
inline void ClusteringResult::add_pagesweights(float value) {
  pagesweights_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ClusteringResult.pagesWeights)
}
inline const ::google::protobuf::RepeatedField< float >&
ClusteringResult::pagesweights() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ClusteringResult.pagesWeights)
  return pagesweights_;
}
inline ::google::protobuf::RepeatedField< float >*
ClusteringResult::mutable_pagesweights() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ClusteringResult.pagesWeights)
  return &pagesweights_;
}

// repeated string keywords = 2;
inline int ClusteringResult::keywords_size() const {
  return keywords_.size();
}
inline void ClusteringResult::clear_keywords() {
  keywords_.Clear();
}
inline const ::std::string& ClusteringResult::keywords(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
  return keywords_.Get(index);
}
inline ::std::string* ClusteringResult::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
  return keywords_.Mutable(index);
}
inline void ClusteringResult::set_keywords(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
  keywords_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ClusteringResult::set_keywords(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
  keywords_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ClusteringResult::set_keywords(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
}
inline void ClusteringResult::set_keywords(int index, const char* value, size_t size) {
  keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
}
inline ::std::string* ClusteringResult::add_keywords() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
  return keywords_.Add();
}
inline void ClusteringResult::add_keywords(const ::std::string& value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
}
#if LANG_CXX11
inline void ClusteringResult::add_keywords(::std::string&& value) {
  keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
}
#endif
inline void ClusteringResult::add_keywords(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
}
inline void ClusteringResult::add_keywords(const char* value, size_t size) {
  keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClusteringResult::keywords() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClusteringResult::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ClusteringResult.keywords)
  return &keywords_;
}

// repeated float kWeights = 3;
inline int ClusteringResult::kweights_size() const {
  return kweights_.size();
}
inline void ClusteringResult::clear_kweights() {
  kweights_.Clear();
}
inline float ClusteringResult::kweights(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ClusteringResult.kWeights)
  return kweights_.Get(index);
}
inline void ClusteringResult::set_kweights(int index, float value) {
  kweights_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ClusteringResult.kWeights)
}
inline void ClusteringResult::add_kweights(float value) {
  kweights_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ClusteringResult.kWeights)
}
inline const ::google::protobuf::RepeatedField< float >&
ClusteringResult::kweights() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ClusteringResult.kWeights)
  return kweights_;
}
inline ::google::protobuf::RepeatedField< float >*
ClusteringResult::mutable_kweights() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ClusteringResult.kWeights)
  return &kweights_;
}

// -------------------------------------------------------------------

// HostWithImgUrls

// optional string host = 1;
inline bool HostWithImgUrls::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HostWithImgUrls::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HostWithImgUrls::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HostWithImgUrls::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& HostWithImgUrls::host() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.HostWithImgUrls.host)
  return host_.GetNoArena();
}
inline void HostWithImgUrls::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.HostWithImgUrls.host)
}
#if LANG_CXX11
inline void HostWithImgUrls::set_host(::std::string&& value) {
  set_has_host();
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.HostWithImgUrls.host)
}
#endif
inline void HostWithImgUrls::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.HostWithImgUrls.host)
}
inline void HostWithImgUrls::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.HostWithImgUrls.host)
}
inline ::std::string* HostWithImgUrls::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.HostWithImgUrls.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostWithImgUrls::release_host() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.HostWithImgUrls.host)
  clear_has_host();
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostWithImgUrls::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.HostWithImgUrls.host)
}

// repeated string url = 2;
inline int HostWithImgUrls::url_size() const {
  return url_.size();
}
inline void HostWithImgUrls::clear_url() {
  url_.Clear();
}
inline const ::std::string& HostWithImgUrls::url(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
  return url_.Get(index);
}
inline ::std::string* HostWithImgUrls::mutable_url(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
  return url_.Mutable(index);
}
inline void HostWithImgUrls::set_url(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
  url_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void HostWithImgUrls::set_url(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
  url_.Mutable(index)->assign(std::move(value));
}
#endif
inline void HostWithImgUrls::set_url(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  url_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
}
inline void HostWithImgUrls::set_url(int index, const char* value, size_t size) {
  url_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
}
inline ::std::string* HostWithImgUrls::add_url() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
  return url_.Add();
}
inline void HostWithImgUrls::add_url(const ::std::string& value) {
  url_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
}
#if LANG_CXX11
inline void HostWithImgUrls::add_url(::std::string&& value) {
  url_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
}
#endif
inline void HostWithImgUrls::add_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  url_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
}
inline void HostWithImgUrls::add_url(const char* value, size_t size) {
  url_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HostWithImgUrls::url() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
  return url_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HostWithImgUrls::mutable_url() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.HostWithImgUrls.url)
  return &url_;
}

// -------------------------------------------------------------------

// ThumbList

// repeated .ru.mail.go.webbase.parsing.img.Thumb thumb = 1;
inline int ThumbList::thumb_size() const {
  return thumb_.size();
}
inline void ThumbList::clear_thumb() {
  thumb_.Clear();
}
inline const ::ru::mail::go::webbase::parsing::img::Thumb& ThumbList::thumb(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ThumbList.thumb)
  return thumb_.Get(index);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ThumbList::mutable_thumb(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ThumbList.thumb)
  return thumb_.Mutable(index);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* ThumbList::add_thumb() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ThumbList.thumb)
  return thumb_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >*
ThumbList::mutable_thumb() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ThumbList.thumb)
  return &thumb_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::parsing::img::Thumb >&
ThumbList::thumb() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ThumbList.thumb)
  return thumb_;
}

// -------------------------------------------------------------------

// ThumbDoc

// required string url = 1;
inline bool ThumbDoc::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThumbDoc::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThumbDoc::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThumbDoc::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& ThumbDoc::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ThumbDoc.url)
  return url_.GetNoArena();
}
inline void ThumbDoc::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ThumbDoc.url)
}
#if LANG_CXX11
inline void ThumbDoc::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ThumbDoc.url)
}
#endif
inline void ThumbDoc::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ThumbDoc.url)
}
inline void ThumbDoc::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ThumbDoc.url)
}
inline ::std::string* ThumbDoc::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ThumbDoc.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThumbDoc::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ThumbDoc.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThumbDoc::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ThumbDoc.url)
}

// required .ru.mail.go.webbase.blobs.ThumbList thumblist = 2;
inline bool ThumbDoc::has_thumblist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThumbDoc::set_has_thumblist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThumbDoc::clear_has_thumblist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThumbDoc::clear_thumblist() {
  if (thumblist_ != NULL) thumblist_->::ru::mail::go::webbase::blobs::ThumbList::Clear();
  clear_has_thumblist();
}
inline const ::ru::mail::go::webbase::blobs::ThumbList& ThumbDoc::thumblist() const {
  const ::ru::mail::go::webbase::blobs::ThumbList* p = thumblist_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ThumbDoc.thumblist)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ThumbList*>(
      &::ru::mail::go::webbase::blobs::_ThumbList_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ThumbList* ThumbDoc::mutable_thumblist() {
  set_has_thumblist();
  if (thumblist_ == NULL) {
    thumblist_ = new ::ru::mail::go::webbase::blobs::ThumbList;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ThumbDoc.thumblist)
  return thumblist_;
}
inline ::ru::mail::go::webbase::blobs::ThumbList* ThumbDoc::release_thumblist() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ThumbDoc.thumblist)
  clear_has_thumblist();
  ::ru::mail::go::webbase::blobs::ThumbList* temp = thumblist_;
  thumblist_ = NULL;
  return temp;
}
inline void ThumbDoc::set_allocated_thumblist(::ru::mail::go::webbase::blobs::ThumbList* thumblist) {
  delete thumblist_;
  thumblist_ = thumblist;
  if (thumblist) {
    set_has_thumblist();
  } else {
    clear_has_thumblist();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ThumbDoc.thumblist)
}

// -------------------------------------------------------------------

// RatioStats

// required string query = 1;
inline bool RatioStats::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RatioStats::set_has_query() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RatioStats::clear_has_query() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RatioStats::clear_query() {
  query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_query();
}
inline const ::std::string& RatioStats::query() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.RatioStats.query)
  return query_.GetNoArena();
}
inline void RatioStats::set_query(const ::std::string& value) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.RatioStats.query)
}
#if LANG_CXX11
inline void RatioStats::set_query(::std::string&& value) {
  set_has_query();
  query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.RatioStats.query)
}
#endif
inline void RatioStats::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.RatioStats.query)
}
inline void RatioStats::set_query(const char* value, size_t size) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.RatioStats.query)
}
inline ::std::string* RatioStats::mutable_query() {
  set_has_query();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.RatioStats.query)
  return query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RatioStats::release_query() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.RatioStats.query)
  clear_has_query();
  return query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RatioStats::set_allocated_query(::std::string* query) {
  if (query != NULL) {
    set_has_query();
  } else {
    clear_has_query();
  }
  query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.RatioStats.query)
}

// required uint64 time = 2;
inline bool RatioStats::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RatioStats::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RatioStats::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RatioStats::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 RatioStats::time() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.RatioStats.time)
  return time_;
}
inline void RatioStats::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.RatioStats.time)
}

// required .ru.mail.go.webbase.blobs.RatioStats.Kind kind = 3;
inline bool RatioStats::has_kind() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RatioStats::set_has_kind() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RatioStats::clear_has_kind() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RatioStats::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::ru::mail::go::webbase::blobs::RatioStats_Kind RatioStats::kind() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.RatioStats.kind)
  return static_cast< ::ru::mail::go::webbase::blobs::RatioStats_Kind >(kind_);
}
inline void RatioStats::set_kind(::ru::mail::go::webbase::blobs::RatioStats_Kind value) {
  assert(::ru::mail::go::webbase::blobs::RatioStats_Kind_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.RatioStats.kind)
}

// required string mrcu = 4;
inline bool RatioStats::has_mrcu() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RatioStats::set_has_mrcu() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RatioStats::clear_has_mrcu() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RatioStats::clear_mrcu() {
  mrcu_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mrcu();
}
inline const ::std::string& RatioStats::mrcu() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.RatioStats.mrcu)
  return mrcu_.GetNoArena();
}
inline void RatioStats::set_mrcu(const ::std::string& value) {
  set_has_mrcu();
  mrcu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.RatioStats.mrcu)
}
#if LANG_CXX11
inline void RatioStats::set_mrcu(::std::string&& value) {
  set_has_mrcu();
  mrcu_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.RatioStats.mrcu)
}
#endif
inline void RatioStats::set_mrcu(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mrcu();
  mrcu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.RatioStats.mrcu)
}
inline void RatioStats::set_mrcu(const char* value, size_t size) {
  set_has_mrcu();
  mrcu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.RatioStats.mrcu)
}
inline ::std::string* RatioStats::mutable_mrcu() {
  set_has_mrcu();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.RatioStats.mrcu)
  return mrcu_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RatioStats::release_mrcu() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.RatioStats.mrcu)
  clear_has_mrcu();
  return mrcu_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RatioStats::set_allocated_mrcu(::std::string* mrcu) {
  if (mrcu != NULL) {
    set_has_mrcu();
  } else {
    clear_has_mrcu();
  }
  mrcu_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mrcu);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.RatioStats.mrcu)
}

// -------------------------------------------------------------------

// FaviconObj

// required string siteURL = 1;
inline bool FaviconObj::has_siteurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaviconObj::set_has_siteurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaviconObj::clear_has_siteurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaviconObj::clear_siteurl() {
  siteurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_siteurl();
}
inline const ::std::string& FaviconObj::siteurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FaviconObj.siteURL)
  return siteurl_.GetNoArena();
}
inline void FaviconObj::set_siteurl(const ::std::string& value) {
  set_has_siteurl();
  siteurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FaviconObj.siteURL)
}
#if LANG_CXX11
inline void FaviconObj::set_siteurl(::std::string&& value) {
  set_has_siteurl();
  siteurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.FaviconObj.siteURL)
}
#endif
inline void FaviconObj::set_siteurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_siteurl();
  siteurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FaviconObj.siteURL)
}
inline void FaviconObj::set_siteurl(const char* value, size_t size) {
  set_has_siteurl();
  siteurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FaviconObj.siteURL)
}
inline ::std::string* FaviconObj::mutable_siteurl() {
  set_has_siteurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FaviconObj.siteURL)
  return siteurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaviconObj::release_siteurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FaviconObj.siteURL)
  clear_has_siteurl();
  return siteurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaviconObj::set_allocated_siteurl(::std::string* siteurl) {
  if (siteurl != NULL) {
    set_has_siteurl();
  } else {
    clear_has_siteurl();
  }
  siteurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), siteurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FaviconObj.siteURL)
}

// required string faviconURL = 2;
inline bool FaviconObj::has_faviconurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaviconObj::set_has_faviconurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaviconObj::clear_has_faviconurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaviconObj::clear_faviconurl() {
  faviconurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_faviconurl();
}
inline const ::std::string& FaviconObj::faviconurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FaviconObj.faviconURL)
  return faviconurl_.GetNoArena();
}
inline void FaviconObj::set_faviconurl(const ::std::string& value) {
  set_has_faviconurl();
  faviconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FaviconObj.faviconURL)
}
#if LANG_CXX11
inline void FaviconObj::set_faviconurl(::std::string&& value) {
  set_has_faviconurl();
  faviconurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.FaviconObj.faviconURL)
}
#endif
inline void FaviconObj::set_faviconurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_faviconurl();
  faviconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FaviconObj.faviconURL)
}
inline void FaviconObj::set_faviconurl(const char* value, size_t size) {
  set_has_faviconurl();
  faviconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FaviconObj.faviconURL)
}
inline ::std::string* FaviconObj::mutable_faviconurl() {
  set_has_faviconurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FaviconObj.faviconURL)
  return faviconurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaviconObj::release_faviconurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FaviconObj.faviconURL)
  clear_has_faviconurl();
  return faviconurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaviconObj::set_allocated_faviconurl(::std::string* faviconurl) {
  if (faviconurl != NULL) {
    set_has_faviconurl();
  } else {
    clear_has_faviconurl();
  }
  faviconurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), faviconurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FaviconObj.faviconURL)
}

// required .ru.mail.go.webbase.parsing.img.Thumb favicon = 3;
inline bool FaviconObj::has_favicon() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FaviconObj::set_has_favicon() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FaviconObj::clear_has_favicon() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FaviconObj::clear_favicon() {
  if (favicon_ != NULL) favicon_->::ru::mail::go::webbase::parsing::img::Thumb::Clear();
  clear_has_favicon();
}
inline const ::ru::mail::go::webbase::parsing::img::Thumb& FaviconObj::favicon() const {
  const ::ru::mail::go::webbase::parsing::img::Thumb* p = favicon_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FaviconObj.favicon)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::Thumb*>(
      &::ru::mail::go::webbase::parsing::img::_Thumb_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* FaviconObj::mutable_favicon() {
  set_has_favicon();
  if (favicon_ == NULL) {
    favicon_ = new ::ru::mail::go::webbase::parsing::img::Thumb;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FaviconObj.favicon)
  return favicon_;
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* FaviconObj::release_favicon() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FaviconObj.favicon)
  clear_has_favicon();
  ::ru::mail::go::webbase::parsing::img::Thumb* temp = favicon_;
  favicon_ = NULL;
  return temp;
}
inline void FaviconObj::set_allocated_favicon(::ru::mail::go::webbase::parsing::img::Thumb* favicon) {
  delete favicon_;
  favicon_ = favicon;
  if (favicon) {
    set_has_favicon();
  } else {
    clear_has_favicon();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FaviconObj.favicon)
}

// optional string faviconURL_high_res = 4;
inline bool FaviconObj::has_faviconurl_high_res() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FaviconObj::set_has_faviconurl_high_res() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FaviconObj::clear_has_faviconurl_high_res() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FaviconObj::clear_faviconurl_high_res() {
  faviconurl_high_res_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_faviconurl_high_res();
}
inline const ::std::string& FaviconObj::faviconurl_high_res() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FaviconObj.faviconURL_high_res)
  return faviconurl_high_res_.GetNoArena();
}
inline void FaviconObj::set_faviconurl_high_res(const ::std::string& value) {
  set_has_faviconurl_high_res();
  faviconurl_high_res_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.FaviconObj.faviconURL_high_res)
}
#if LANG_CXX11
inline void FaviconObj::set_faviconurl_high_res(::std::string&& value) {
  set_has_faviconurl_high_res();
  faviconurl_high_res_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.FaviconObj.faviconURL_high_res)
}
#endif
inline void FaviconObj::set_faviconurl_high_res(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_faviconurl_high_res();
  faviconurl_high_res_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.FaviconObj.faviconURL_high_res)
}
inline void FaviconObj::set_faviconurl_high_res(const char* value, size_t size) {
  set_has_faviconurl_high_res();
  faviconurl_high_res_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.FaviconObj.faviconURL_high_res)
}
inline ::std::string* FaviconObj::mutable_faviconurl_high_res() {
  set_has_faviconurl_high_res();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FaviconObj.faviconURL_high_res)
  return faviconurl_high_res_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaviconObj::release_faviconurl_high_res() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FaviconObj.faviconURL_high_res)
  clear_has_faviconurl_high_res();
  return faviconurl_high_res_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaviconObj::set_allocated_faviconurl_high_res(::std::string* faviconurl_high_res) {
  if (faviconurl_high_res != NULL) {
    set_has_faviconurl_high_res();
  } else {
    clear_has_faviconurl_high_res();
  }
  faviconurl_high_res_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), faviconurl_high_res);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FaviconObj.faviconURL_high_res)
}

// optional .ru.mail.go.webbase.parsing.img.Thumb favicon_high_res = 5;
inline bool FaviconObj::has_favicon_high_res() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FaviconObj::set_has_favicon_high_res() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FaviconObj::clear_has_favicon_high_res() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FaviconObj::clear_favicon_high_res() {
  if (favicon_high_res_ != NULL) favicon_high_res_->::ru::mail::go::webbase::parsing::img::Thumb::Clear();
  clear_has_favicon_high_res();
}
inline const ::ru::mail::go::webbase::parsing::img::Thumb& FaviconObj::favicon_high_res() const {
  const ::ru::mail::go::webbase::parsing::img::Thumb* p = favicon_high_res_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.FaviconObj.favicon_high_res)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::parsing::img::Thumb*>(
      &::ru::mail::go::webbase::parsing::img::_Thumb_default_instance_);
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* FaviconObj::mutable_favicon_high_res() {
  set_has_favicon_high_res();
  if (favicon_high_res_ == NULL) {
    favicon_high_res_ = new ::ru::mail::go::webbase::parsing::img::Thumb;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.FaviconObj.favicon_high_res)
  return favicon_high_res_;
}
inline ::ru::mail::go::webbase::parsing::img::Thumb* FaviconObj::release_favicon_high_res() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.FaviconObj.favicon_high_res)
  clear_has_favicon_high_res();
  ::ru::mail::go::webbase::parsing::img::Thumb* temp = favicon_high_res_;
  favicon_high_res_ = NULL;
  return temp;
}
inline void FaviconObj::set_allocated_favicon_high_res(::ru::mail::go::webbase::parsing::img::Thumb* favicon_high_res) {
  delete favicon_high_res_;
  favicon_high_res_ = favicon_high_res;
  if (favicon_high_res) {
    set_has_favicon_high_res();
  } else {
    clear_has_favicon_high_res();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.FaviconObj.favicon_high_res)
}

// -------------------------------------------------------------------

// ImageStructInfo

// required .ru.mail.go.webbase.blobs.ImageStructInfo.ImageSource source = 1;
inline bool ImageStructInfo::has_source() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageStructInfo::set_has_source() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageStructInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageStructInfo::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::ru::mail::go::webbase::blobs::ImageStructInfo_ImageSource ImageStructInfo::source() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStructInfo.source)
  return static_cast< ::ru::mail::go::webbase::blobs::ImageStructInfo_ImageSource >(source_);
}
inline void ImageStructInfo::set_source(::ru::mail::go::webbase::blobs::ImageStructInfo_ImageSource value) {
  assert(::ru::mail::go::webbase::blobs::ImageStructInfo_ImageSource_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStructInfo.source)
}

// required string page_full_URL = 2;
inline bool ImageStructInfo::has_page_full_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageStructInfo::set_has_page_full_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageStructInfo::clear_has_page_full_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageStructInfo::clear_page_full_url() {
  page_full_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_page_full_url();
}
inline const ::std::string& ImageStructInfo::page_full_url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStructInfo.page_full_URL)
  return page_full_url_.GetNoArena();
}
inline void ImageStructInfo::set_page_full_url(const ::std::string& value) {
  set_has_page_full_url();
  page_full_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStructInfo.page_full_URL)
}
#if LANG_CXX11
inline void ImageStructInfo::set_page_full_url(::std::string&& value) {
  set_has_page_full_url();
  page_full_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageStructInfo.page_full_URL)
}
#endif
inline void ImageStructInfo::set_page_full_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_page_full_url();
  page_full_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageStructInfo.page_full_URL)
}
inline void ImageStructInfo::set_page_full_url(const char* value, size_t size) {
  set_has_page_full_url();
  page_full_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageStructInfo.page_full_URL)
}
inline ::std::string* ImageStructInfo::mutable_page_full_url() {
  set_has_page_full_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStructInfo.page_full_URL)
  return page_full_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageStructInfo::release_page_full_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStructInfo.page_full_URL)
  clear_has_page_full_url();
  return page_full_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageStructInfo::set_allocated_page_full_url(::std::string* page_full_url) {
  if (page_full_url != NULL) {
    set_has_page_full_url();
  } else {
    clear_has_page_full_url();
  }
  page_full_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), page_full_url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStructInfo.page_full_URL)
}

// optional string title = 3;
inline bool ImageStructInfo::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageStructInfo::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageStructInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageStructInfo::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_title();
}
inline const ::std::string& ImageStructInfo::title() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStructInfo.title)
  return title_.GetNoArena();
}
inline void ImageStructInfo::set_title(const ::std::string& value) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStructInfo.title)
}
#if LANG_CXX11
inline void ImageStructInfo::set_title(::std::string&& value) {
  set_has_title();
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageStructInfo.title)
}
#endif
inline void ImageStructInfo::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageStructInfo.title)
}
inline void ImageStructInfo::set_title(const char* value, size_t size) {
  set_has_title();
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageStructInfo.title)
}
inline ::std::string* ImageStructInfo::mutable_title() {
  set_has_title();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStructInfo.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageStructInfo::release_title() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStructInfo.title)
  clear_has_title();
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageStructInfo::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    set_has_title();
  } else {
    clear_has_title();
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStructInfo.title)
}

// optional string text = 4;
inline bool ImageStructInfo::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageStructInfo::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageStructInfo::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageStructInfo::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& ImageStructInfo::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStructInfo.text)
  return text_.GetNoArena();
}
inline void ImageStructInfo::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStructInfo.text)
}
#if LANG_CXX11
inline void ImageStructInfo::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageStructInfo.text)
}
#endif
inline void ImageStructInfo::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageStructInfo.text)
}
inline void ImageStructInfo::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageStructInfo.text)
}
inline ::std::string* ImageStructInfo::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageStructInfo.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageStructInfo::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageStructInfo.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageStructInfo::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageStructInfo.text)
}

// optional int64 image_time = 5;
inline bool ImageStructInfo::has_image_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageStructInfo::set_has_image_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageStructInfo::clear_has_image_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageStructInfo::clear_image_time() {
  image_time_ = GOOGLE_LONGLONG(0);
  clear_has_image_time();
}
inline ::google::protobuf::int64 ImageStructInfo::image_time() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageStructInfo.image_time)
  return image_time_;
}
inline void ImageStructInfo::set_image_time(::google::protobuf::int64 value) {
  set_has_image_time();
  image_time_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageStructInfo.image_time)
}

// -------------------------------------------------------------------

// NewsImageInfo

// required int64 news_id = 1;
inline bool NewsImageInfo::has_news_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewsImageInfo::set_has_news_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewsImageInfo::clear_has_news_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewsImageInfo::clear_news_id() {
  news_id_ = GOOGLE_LONGLONG(0);
  clear_has_news_id();
}
inline ::google::protobuf::int64 NewsImageInfo::news_id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.NewsImageInfo.news_id)
  return news_id_;
}
inline void NewsImageInfo::set_news_id(::google::protobuf::int64 value) {
  set_has_news_id();
  news_id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.NewsImageInfo.news_id)
}

// required string news_img_hash = 2;
inline bool NewsImageInfo::has_news_img_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewsImageInfo::set_has_news_img_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewsImageInfo::clear_has_news_img_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewsImageInfo::clear_news_img_hash() {
  news_img_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_news_img_hash();
}
inline const ::std::string& NewsImageInfo::news_img_hash() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.NewsImageInfo.news_img_hash)
  return news_img_hash_.GetNoArena();
}
inline void NewsImageInfo::set_news_img_hash(const ::std::string& value) {
  set_has_news_img_hash();
  news_img_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.NewsImageInfo.news_img_hash)
}
#if LANG_CXX11
inline void NewsImageInfo::set_news_img_hash(::std::string&& value) {
  set_has_news_img_hash();
  news_img_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.NewsImageInfo.news_img_hash)
}
#endif
inline void NewsImageInfo::set_news_img_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_news_img_hash();
  news_img_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.NewsImageInfo.news_img_hash)
}
inline void NewsImageInfo::set_news_img_hash(const char* value, size_t size) {
  set_has_news_img_hash();
  news_img_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.NewsImageInfo.news_img_hash)
}
inline ::std::string* NewsImageInfo::mutable_news_img_hash() {
  set_has_news_img_hash();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.NewsImageInfo.news_img_hash)
  return news_img_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewsImageInfo::release_news_img_hash() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.NewsImageInfo.news_img_hash)
  clear_has_news_img_hash();
  return news_img_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewsImageInfo::set_allocated_news_img_hash(::std::string* news_img_hash) {
  if (news_img_hash != NULL) {
    set_has_news_img_hash();
  } else {
    clear_has_news_img_hash();
  }
  news_img_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), news_img_hash);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.NewsImageInfo.news_img_hash)
}

// required int32 src_id = 3;
inline bool NewsImageInfo::has_src_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewsImageInfo::set_has_src_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewsImageInfo::clear_has_src_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewsImageInfo::clear_src_id() {
  src_id_ = 0;
  clear_has_src_id();
}
inline ::google::protobuf::int32 NewsImageInfo::src_id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.NewsImageInfo.src_id)
  return src_id_;
}
inline void NewsImageInfo::set_src_id(::google::protobuf::int32 value) {
  set_has_src_id();
  src_id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.NewsImageInfo.src_id)
}

// -------------------------------------------------------------------

// ImageKeywords

// repeated string keywords = 1;
inline int ImageKeywords::keywords_size() const {
  return keywords_.size();
}
inline void ImageKeywords::clear_keywords() {
  keywords_.Clear();
}
inline const ::std::string& ImageKeywords::keywords(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
  return keywords_.Get(index);
}
inline ::std::string* ImageKeywords::mutable_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
  return keywords_.Mutable(index);
}
inline void ImageKeywords::set_keywords(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
  keywords_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ImageKeywords::set_keywords(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
  keywords_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ImageKeywords::set_keywords(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
}
inline void ImageKeywords::set_keywords(int index, const char* value, size_t size) {
  keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
}
inline ::std::string* ImageKeywords::add_keywords() {
  // @@protoc_insertion_point(field_add_mutable:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
  return keywords_.Add();
}
inline void ImageKeywords::add_keywords(const ::std::string& value) {
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
}
#if LANG_CXX11
inline void ImageKeywords::add_keywords(::std::string&& value) {
  keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
}
#endif
inline void ImageKeywords::add_keywords(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
}
inline void ImageKeywords::add_keywords(const char* value, size_t size) {
  keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImageKeywords::keywords() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImageKeywords::mutable_keywords() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ImageKeywords.keywords)
  return &keywords_;
}

// repeated float weights = 2;
inline int ImageKeywords::weights_size() const {
  return weights_.size();
}
inline void ImageKeywords::clear_weights() {
  weights_.Clear();
}
inline float ImageKeywords::weights(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageKeywords.weights)
  return weights_.Get(index);
}
inline void ImageKeywords::set_weights(int index, float value) {
  weights_.Set(index, value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageKeywords.weights)
}
inline void ImageKeywords::add_weights(float value) {
  weights_.Add(value);
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.ImageKeywords.weights)
}
inline const ::google::protobuf::RepeatedField< float >&
ImageKeywords::weights() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.ImageKeywords.weights)
  return weights_;
}
inline ::google::protobuf::RepeatedField< float >*
ImageKeywords::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.ImageKeywords.weights)
  return &weights_;
}

// optional int32 cluster_size = 3;
inline bool ImageKeywords::has_cluster_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageKeywords::set_has_cluster_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageKeywords::clear_has_cluster_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageKeywords::clear_cluster_size() {
  cluster_size_ = 0;
  clear_has_cluster_size();
}
inline ::google::protobuf::int32 ImageKeywords::cluster_size() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageKeywords.cluster_size)
  return cluster_size_;
}
inline void ImageKeywords::set_cluster_size(::google::protobuf::int32 value) {
  set_has_cluster_size();
  cluster_size_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageKeywords.cluster_size)
}

// -------------------------------------------------------------------

// ImageObj

// required string imageURL = 1;
inline bool ImageObj::has_imageurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageObj::set_has_imageurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageObj::clear_has_imageurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageObj::clear_imageurl() {
  imageurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imageurl();
}
inline const ::std::string& ImageObj::imageurl() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageObj.imageURL)
  return imageurl_.GetNoArena();
}
inline void ImageObj::set_imageurl(const ::std::string& value) {
  set_has_imageurl();
  imageurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageObj.imageURL)
}
#if LANG_CXX11
inline void ImageObj::set_imageurl(::std::string&& value) {
  set_has_imageurl();
  imageurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageObj.imageURL)
}
#endif
inline void ImageObj::set_imageurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imageurl();
  imageurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageObj.imageURL)
}
inline void ImageObj::set_imageurl(const char* value, size_t size) {
  set_has_imageurl();
  imageurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageObj.imageURL)
}
inline ::std::string* ImageObj::mutable_imageurl() {
  set_has_imageurl();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageObj.imageURL)
  return imageurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageObj::release_imageurl() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageObj.imageURL)
  clear_has_imageurl();
  return imageurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageObj::set_allocated_imageurl(::std::string* imageurl) {
  if (imageurl != NULL) {
    set_has_imageurl();
  } else {
    clear_has_imageurl();
  }
  imageurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imageurl);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageObj.imageURL)
}

// required int32 result_code = 2;
inline bool ImageObj::has_result_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageObj::set_has_result_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageObj::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageObj::clear_result_code() {
  result_code_ = 0;
  clear_has_result_code();
}
inline ::google::protobuf::int32 ImageObj::result_code() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageObj.result_code)
  return result_code_;
}
inline void ImageObj::set_result_code(::google::protobuf::int32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageObj.result_code)
}

// optional bytes image = 3;
inline bool ImageObj::has_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageObj::set_has_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageObj::clear_has_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageObj::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image();
}
inline const ::std::string& ImageObj::image() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageObj.image)
  return image_.GetNoArena();
}
inline void ImageObj::set_image(const ::std::string& value) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageObj.image)
}
#if LANG_CXX11
inline void ImageObj::set_image(::std::string&& value) {
  set_has_image();
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageObj.image)
}
#endif
inline void ImageObj::set_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageObj.image)
}
inline void ImageObj::set_image(const void* value, size_t size) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageObj.image)
}
inline ::std::string* ImageObj::mutable_image() {
  set_has_image();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageObj.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageObj::release_image() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageObj.image)
  clear_has_image();
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageObj::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    set_has_image();
  } else {
    clear_has_image();
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageObj.image)
}

// -------------------------------------------------------------------

// ImageIndexObj

// required .ru.mail.go.webbase.blobs.ThumbDoc thumb = 1;
inline bool ImageIndexObj::has_thumb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageIndexObj::set_has_thumb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageIndexObj::clear_has_thumb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageIndexObj::clear_thumb() {
  if (thumb_ != NULL) thumb_->::ru::mail::go::webbase::blobs::ThumbDoc::Clear();
  clear_has_thumb();
}
inline const ::ru::mail::go::webbase::blobs::ThumbDoc& ImageIndexObj::thumb() const {
  const ::ru::mail::go::webbase::blobs::ThumbDoc* p = thumb_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageIndexObj.thumb)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ThumbDoc*>(
      &::ru::mail::go::webbase::blobs::_ThumbDoc_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ThumbDoc* ImageIndexObj::mutable_thumb() {
  set_has_thumb();
  if (thumb_ == NULL) {
    thumb_ = new ::ru::mail::go::webbase::blobs::ThumbDoc;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageIndexObj.thumb)
  return thumb_;
}
inline ::ru::mail::go::webbase::blobs::ThumbDoc* ImageIndexObj::release_thumb() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageIndexObj.thumb)
  clear_has_thumb();
  ::ru::mail::go::webbase::blobs::ThumbDoc* temp = thumb_;
  thumb_ = NULL;
  return temp;
}
inline void ImageIndexObj::set_allocated_thumb(::ru::mail::go::webbase::blobs::ThumbDoc* thumb) {
  delete thumb_;
  thumb_ = thumb;
  if (thumb) {
    set_has_thumb();
  } else {
    clear_has_thumb();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageIndexObj.thumb)
}

// required string xml_doc = 2;
inline bool ImageIndexObj::has_xml_doc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageIndexObj::set_has_xml_doc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageIndexObj::clear_has_xml_doc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageIndexObj::clear_xml_doc() {
  xml_doc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xml_doc();
}
inline const ::std::string& ImageIndexObj::xml_doc() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageIndexObj.xml_doc)
  return xml_doc_.GetNoArena();
}
inline void ImageIndexObj::set_xml_doc(const ::std::string& value) {
  set_has_xml_doc();
  xml_doc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageIndexObj.xml_doc)
}
#if LANG_CXX11
inline void ImageIndexObj::set_xml_doc(::std::string&& value) {
  set_has_xml_doc();
  xml_doc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageIndexObj.xml_doc)
}
#endif
inline void ImageIndexObj::set_xml_doc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xml_doc();
  xml_doc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageIndexObj.xml_doc)
}
inline void ImageIndexObj::set_xml_doc(const char* value, size_t size) {
  set_has_xml_doc();
  xml_doc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageIndexObj.xml_doc)
}
inline ::std::string* ImageIndexObj::mutable_xml_doc() {
  set_has_xml_doc();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageIndexObj.xml_doc)
  return xml_doc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageIndexObj::release_xml_doc() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageIndexObj.xml_doc)
  clear_has_xml_doc();
  return xml_doc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageIndexObj::set_allocated_xml_doc(::std::string* xml_doc) {
  if (xml_doc != NULL) {
    set_has_xml_doc();
  } else {
    clear_has_xml_doc();
  }
  xml_doc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xml_doc);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageIndexObj.xml_doc)
}

// -------------------------------------------------------------------

// WOTInfo_WOTElement

// required int32 confidence = 1;
inline bool WOTInfo_WOTElement::has_confidence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WOTInfo_WOTElement::set_has_confidence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WOTInfo_WOTElement::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WOTInfo_WOTElement::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline ::google::protobuf::int32 WOTInfo_WOTElement::confidence() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.WOTInfo.WOTElement.confidence)
  return confidence_;
}
inline void WOTInfo_WOTElement::set_confidence(::google::protobuf::int32 value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.WOTInfo.WOTElement.confidence)
}

// required int32 reputation = 2;
inline bool WOTInfo_WOTElement::has_reputation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WOTInfo_WOTElement::set_has_reputation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WOTInfo_WOTElement::clear_has_reputation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WOTInfo_WOTElement::clear_reputation() {
  reputation_ = 0;
  clear_has_reputation();
}
inline ::google::protobuf::int32 WOTInfo_WOTElement::reputation() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.WOTInfo.WOTElement.reputation)
  return reputation_;
}
inline void WOTInfo_WOTElement::set_reputation(::google::protobuf::int32 value) {
  set_has_reputation();
  reputation_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.WOTInfo.WOTElement.reputation)
}

// -------------------------------------------------------------------

// WOTInfo_WOTCategory

// required int32 category = 1;
inline bool WOTInfo_WOTCategory::has_category() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WOTInfo_WOTCategory::set_has_category() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WOTInfo_WOTCategory::clear_has_category() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WOTInfo_WOTCategory::clear_category() {
  category_ = 0;
  clear_has_category();
}
inline ::google::protobuf::int32 WOTInfo_WOTCategory::category() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.WOTInfo.WOTCategory.category)
  return category_;
}
inline void WOTInfo_WOTCategory::set_category(::google::protobuf::int32 value) {
  set_has_category();
  category_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.WOTInfo.WOTCategory.category)
}

// required int32 value = 2;
inline bool WOTInfo_WOTCategory::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WOTInfo_WOTCategory::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WOTInfo_WOTCategory::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WOTInfo_WOTCategory::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 WOTInfo_WOTCategory::value() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.WOTInfo.WOTCategory.value)
  return value_;
}
inline void WOTInfo_WOTCategory::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.WOTInfo.WOTCategory.value)
}

// -------------------------------------------------------------------

// WOTInfo

// optional .ru.mail.go.webbase.blobs.WOTInfo.WOTElement trust_worthiness = 1;
inline bool WOTInfo::has_trust_worthiness() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WOTInfo::set_has_trust_worthiness() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WOTInfo::clear_has_trust_worthiness() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WOTInfo::clear_trust_worthiness() {
  if (trust_worthiness_ != NULL) trust_worthiness_->::ru::mail::go::webbase::blobs::WOTInfo_WOTElement::Clear();
  clear_has_trust_worthiness();
}
inline const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement& WOTInfo::trust_worthiness() const {
  const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* p = trust_worthiness_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.WOTInfo.trust_worthiness)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement*>(
      &::ru::mail::go::webbase::blobs::_WOTInfo_WOTElement_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* WOTInfo::mutable_trust_worthiness() {
  set_has_trust_worthiness();
  if (trust_worthiness_ == NULL) {
    trust_worthiness_ = new ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.WOTInfo.trust_worthiness)
  return trust_worthiness_;
}
inline ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* WOTInfo::release_trust_worthiness() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.WOTInfo.trust_worthiness)
  clear_has_trust_worthiness();
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* temp = trust_worthiness_;
  trust_worthiness_ = NULL;
  return temp;
}
inline void WOTInfo::set_allocated_trust_worthiness(::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* trust_worthiness) {
  delete trust_worthiness_;
  trust_worthiness_ = trust_worthiness;
  if (trust_worthiness) {
    set_has_trust_worthiness();
  } else {
    clear_has_trust_worthiness();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.WOTInfo.trust_worthiness)
}

// optional .ru.mail.go.webbase.blobs.WOTInfo.WOTElement vendor_reliability = 2;
inline bool WOTInfo::has_vendor_reliability() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WOTInfo::set_has_vendor_reliability() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WOTInfo::clear_has_vendor_reliability() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WOTInfo::clear_vendor_reliability() {
  if (vendor_reliability_ != NULL) vendor_reliability_->::ru::mail::go::webbase::blobs::WOTInfo_WOTElement::Clear();
  clear_has_vendor_reliability();
}
inline const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement& WOTInfo::vendor_reliability() const {
  const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* p = vendor_reliability_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.WOTInfo.vendor_reliability)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement*>(
      &::ru::mail::go::webbase::blobs::_WOTInfo_WOTElement_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* WOTInfo::mutable_vendor_reliability() {
  set_has_vendor_reliability();
  if (vendor_reliability_ == NULL) {
    vendor_reliability_ = new ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.WOTInfo.vendor_reliability)
  return vendor_reliability_;
}
inline ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* WOTInfo::release_vendor_reliability() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.WOTInfo.vendor_reliability)
  clear_has_vendor_reliability();
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* temp = vendor_reliability_;
  vendor_reliability_ = NULL;
  return temp;
}
inline void WOTInfo::set_allocated_vendor_reliability(::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* vendor_reliability) {
  delete vendor_reliability_;
  vendor_reliability_ = vendor_reliability;
  if (vendor_reliability) {
    set_has_vendor_reliability();
  } else {
    clear_has_vendor_reliability();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.WOTInfo.vendor_reliability)
}

// optional .ru.mail.go.webbase.blobs.WOTInfo.WOTElement privacy = 3;
inline bool WOTInfo::has_privacy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WOTInfo::set_has_privacy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WOTInfo::clear_has_privacy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WOTInfo::clear_privacy() {
  if (privacy_ != NULL) privacy_->::ru::mail::go::webbase::blobs::WOTInfo_WOTElement::Clear();
  clear_has_privacy();
}
inline const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement& WOTInfo::privacy() const {
  const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* p = privacy_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.WOTInfo.privacy)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement*>(
      &::ru::mail::go::webbase::blobs::_WOTInfo_WOTElement_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* WOTInfo::mutable_privacy() {
  set_has_privacy();
  if (privacy_ == NULL) {
    privacy_ = new ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.WOTInfo.privacy)
  return privacy_;
}
inline ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* WOTInfo::release_privacy() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.WOTInfo.privacy)
  clear_has_privacy();
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* temp = privacy_;
  privacy_ = NULL;
  return temp;
}
inline void WOTInfo::set_allocated_privacy(::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* privacy) {
  delete privacy_;
  privacy_ = privacy;
  if (privacy) {
    set_has_privacy();
  } else {
    clear_has_privacy();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.WOTInfo.privacy)
}

// optional .ru.mail.go.webbase.blobs.WOTInfo.WOTElement child_safety = 4;
inline bool WOTInfo::has_child_safety() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WOTInfo::set_has_child_safety() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WOTInfo::clear_has_child_safety() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WOTInfo::clear_child_safety() {
  if (child_safety_ != NULL) child_safety_->::ru::mail::go::webbase::blobs::WOTInfo_WOTElement::Clear();
  clear_has_child_safety();
}
inline const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement& WOTInfo::child_safety() const {
  const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* p = child_safety_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.WOTInfo.child_safety)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement*>(
      &::ru::mail::go::webbase::blobs::_WOTInfo_WOTElement_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* WOTInfo::mutable_child_safety() {
  set_has_child_safety();
  if (child_safety_ == NULL) {
    child_safety_ = new ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.WOTInfo.child_safety)
  return child_safety_;
}
inline ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* WOTInfo::release_child_safety() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.WOTInfo.child_safety)
  clear_has_child_safety();
  ::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* temp = child_safety_;
  child_safety_ = NULL;
  return temp;
}
inline void WOTInfo::set_allocated_child_safety(::ru::mail::go::webbase::blobs::WOTInfo_WOTElement* child_safety) {
  delete child_safety_;
  child_safety_ = child_safety;
  if (child_safety) {
    set_has_child_safety();
  } else {
    clear_has_child_safety();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.WOTInfo.child_safety)
}

// repeated .ru.mail.go.webbase.blobs.WOTInfo.WOTCategory category = 5;
inline int WOTInfo::category_size() const {
  return category_.size();
}
inline void WOTInfo::clear_category() {
  category_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::WOTInfo_WOTCategory& WOTInfo::category(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.WOTInfo.category)
  return category_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::WOTInfo_WOTCategory* WOTInfo::mutable_category(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.WOTInfo.category)
  return category_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::WOTInfo_WOTCategory* WOTInfo::add_category() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.WOTInfo.category)
  return category_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::WOTInfo_WOTCategory >*
WOTInfo::mutable_category() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.WOTInfo.category)
  return &category_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::WOTInfo_WOTCategory >&
WOTInfo::category() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.WOTInfo.category)
  return category_;
}

// -------------------------------------------------------------------

// WOTInfoObj

// required string host = 1;
inline bool WOTInfoObj::has_host() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WOTInfoObj::set_has_host() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WOTInfoObj::clear_has_host() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WOTInfoObj::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& WOTInfoObj::host() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.WOTInfoObj.host)
  return host_.GetNoArena();
}
inline void WOTInfoObj::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.WOTInfoObj.host)
}
#if LANG_CXX11
inline void WOTInfoObj::set_host(::std::string&& value) {
  set_has_host();
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.WOTInfoObj.host)
}
#endif
inline void WOTInfoObj::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.WOTInfoObj.host)
}
inline void WOTInfoObj::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.WOTInfoObj.host)
}
inline ::std::string* WOTInfoObj::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.WOTInfoObj.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WOTInfoObj::release_host() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.WOTInfoObj.host)
  clear_has_host();
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WOTInfoObj::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.WOTInfoObj.host)
}

// required .ru.mail.go.webbase.blobs.WOTInfo wot_info = 2;
inline bool WOTInfoObj::has_wot_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WOTInfoObj::set_has_wot_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WOTInfoObj::clear_has_wot_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WOTInfoObj::clear_wot_info() {
  if (wot_info_ != NULL) wot_info_->::ru::mail::go::webbase::blobs::WOTInfo::Clear();
  clear_has_wot_info();
}
inline const ::ru::mail::go::webbase::blobs::WOTInfo& WOTInfoObj::wot_info() const {
  const ::ru::mail::go::webbase::blobs::WOTInfo* p = wot_info_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.WOTInfoObj.wot_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::WOTInfo*>(
      &::ru::mail::go::webbase::blobs::_WOTInfo_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::WOTInfo* WOTInfoObj::mutable_wot_info() {
  set_has_wot_info();
  if (wot_info_ == NULL) {
    wot_info_ = new ::ru::mail::go::webbase::blobs::WOTInfo;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.WOTInfoObj.wot_info)
  return wot_info_;
}
inline ::ru::mail::go::webbase::blobs::WOTInfo* WOTInfoObj::release_wot_info() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.WOTInfoObj.wot_info)
  clear_has_wot_info();
  ::ru::mail::go::webbase::blobs::WOTInfo* temp = wot_info_;
  wot_info_ = NULL;
  return temp;
}
inline void WOTInfoObj::set_allocated_wot_info(::ru::mail::go::webbase::blobs::WOTInfo* wot_info) {
  delete wot_info_;
  wot_info_ = wot_info;
  if (wot_info) {
    set_has_wot_info();
  } else {
    clear_has_wot_info();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.WOTInfoObj.wot_info)
}

// -------------------------------------------------------------------

// UrlRankInfo

// required string rank_name = 1;
inline bool UrlRankInfo::has_rank_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UrlRankInfo::set_has_rank_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UrlRankInfo::clear_has_rank_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UrlRankInfo::clear_rank_name() {
  rank_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rank_name();
}
inline const ::std::string& UrlRankInfo::rank_name() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlRankInfo.rank_name)
  return rank_name_.GetNoArena();
}
inline void UrlRankInfo::set_rank_name(const ::std::string& value) {
  set_has_rank_name();
  rank_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlRankInfo.rank_name)
}
#if LANG_CXX11
inline void UrlRankInfo::set_rank_name(::std::string&& value) {
  set_has_rank_name();
  rank_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.UrlRankInfo.rank_name)
}
#endif
inline void UrlRankInfo::set_rank_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rank_name();
  rank_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.UrlRankInfo.rank_name)
}
inline void UrlRankInfo::set_rank_name(const char* value, size_t size) {
  set_has_rank_name();
  rank_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.UrlRankInfo.rank_name)
}
inline ::std::string* UrlRankInfo::mutable_rank_name() {
  set_has_rank_name();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlRankInfo.rank_name)
  return rank_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UrlRankInfo::release_rank_name() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.UrlRankInfo.rank_name)
  clear_has_rank_name();
  return rank_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UrlRankInfo::set_allocated_rank_name(::std::string* rank_name) {
  if (rank_name != NULL) {
    set_has_rank_name();
  } else {
    clear_has_rank_name();
  }
  rank_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rank_name);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.UrlRankInfo.rank_name)
}

// repeated .ru.mail.go.webbase.ComputedValues.Record kvRecords = 2;
inline int UrlRankInfo::kvrecords_size() const {
  return kvrecords_.size();
}
inline void UrlRankInfo::clear_kvrecords() {
  kvrecords_.Clear();
}
inline const ::ru::mail::go::webbase::ComputedValues_Record& UrlRankInfo::kvrecords(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlRankInfo.kvRecords)
  return kvrecords_.Get(index);
}
inline ::ru::mail::go::webbase::ComputedValues_Record* UrlRankInfo::mutable_kvrecords(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlRankInfo.kvRecords)
  return kvrecords_.Mutable(index);
}
inline ::ru::mail::go::webbase::ComputedValues_Record* UrlRankInfo::add_kvrecords() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.UrlRankInfo.kvRecords)
  return kvrecords_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::ComputedValues_Record >*
UrlRankInfo::mutable_kvrecords() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.UrlRankInfo.kvRecords)
  return &kvrecords_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::ComputedValues_Record >&
UrlRankInfo::kvrecords() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.UrlRankInfo.kvRecords)
  return kvrecords_;
}

// optional .ru.mail.go.webbase.ComputedValues query_info = 3;
inline bool UrlRankInfo::has_query_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UrlRankInfo::set_has_query_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UrlRankInfo::clear_has_query_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UrlRankInfo::clear_query_info() {
  if (query_info_ != NULL) query_info_->::ru::mail::go::webbase::ComputedValues::Clear();
  clear_has_query_info();
}
inline const ::ru::mail::go::webbase::ComputedValues& UrlRankInfo::query_info() const {
  const ::ru::mail::go::webbase::ComputedValues* p = query_info_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlRankInfo.query_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::ComputedValues*>(
      &::ru::mail::go::webbase::_ComputedValues_default_instance_);
}
inline ::ru::mail::go::webbase::ComputedValues* UrlRankInfo::mutable_query_info() {
  set_has_query_info();
  if (query_info_ == NULL) {
    query_info_ = new ::ru::mail::go::webbase::ComputedValues;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlRankInfo.query_info)
  return query_info_;
}
inline ::ru::mail::go::webbase::ComputedValues* UrlRankInfo::release_query_info() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.UrlRankInfo.query_info)
  clear_has_query_info();
  ::ru::mail::go::webbase::ComputedValues* temp = query_info_;
  query_info_ = NULL;
  return temp;
}
inline void UrlRankInfo::set_allocated_query_info(::ru::mail::go::webbase::ComputedValues* query_info) {
  delete query_info_;
  query_info_ = query_info;
  if (query_info) {
    set_has_query_info();
  } else {
    clear_has_query_info();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.UrlRankInfo.query_info)
}

// -------------------------------------------------------------------

// UrlQueryInfo

// optional string url = 1;
inline bool UrlQueryInfo::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UrlQueryInfo::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UrlQueryInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UrlQueryInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& UrlQueryInfo::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlQueryInfo.url)
  return url_.GetNoArena();
}
inline void UrlQueryInfo::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlQueryInfo.url)
}
#if LANG_CXX11
inline void UrlQueryInfo::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.UrlQueryInfo.url)
}
#endif
inline void UrlQueryInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.UrlQueryInfo.url)
}
inline void UrlQueryInfo::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.UrlQueryInfo.url)
}
inline ::std::string* UrlQueryInfo::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlQueryInfo.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UrlQueryInfo::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.UrlQueryInfo.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UrlQueryInfo::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.UrlQueryInfo.url)
}

// optional int32 mb_number = 2;
inline bool UrlQueryInfo::has_mb_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UrlQueryInfo::set_has_mb_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UrlQueryInfo::clear_has_mb_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UrlQueryInfo::clear_mb_number() {
  mb_number_ = 0;
  clear_has_mb_number();
}
inline ::google::protobuf::int32 UrlQueryInfo::mb_number() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlQueryInfo.mb_number)
  return mb_number_;
}
inline void UrlQueryInfo::set_mb_number(::google::protobuf::int32 value) {
  set_has_mb_number();
  mb_number_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlQueryInfo.mb_number)
}

// optional string query = 3;
inline bool UrlQueryInfo::has_query() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UrlQueryInfo::set_has_query() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UrlQueryInfo::clear_has_query() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UrlQueryInfo::clear_query() {
  query_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_query();
}
inline const ::std::string& UrlQueryInfo::query() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlQueryInfo.query)
  return query_.GetNoArena();
}
inline void UrlQueryInfo::set_query(const ::std::string& value) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlQueryInfo.query)
}
#if LANG_CXX11
inline void UrlQueryInfo::set_query(::std::string&& value) {
  set_has_query();
  query_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.UrlQueryInfo.query)
}
#endif
inline void UrlQueryInfo::set_query(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.UrlQueryInfo.query)
}
inline void UrlQueryInfo::set_query(const char* value, size_t size) {
  set_has_query();
  query_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.UrlQueryInfo.query)
}
inline ::std::string* UrlQueryInfo::mutable_query() {
  set_has_query();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlQueryInfo.query)
  return query_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UrlQueryInfo::release_query() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.UrlQueryInfo.query)
  clear_has_query();
  return query_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UrlQueryInfo::set_allocated_query(::std::string* query) {
  if (query != NULL) {
    set_has_query();
  } else {
    clear_has_query();
  }
  query_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), query);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.UrlQueryInfo.query)
}

// optional uint64 hash = 5;
inline bool UrlQueryInfo::has_hash() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UrlQueryInfo::set_has_hash() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UrlQueryInfo::clear_has_hash() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UrlQueryInfo::clear_hash() {
  hash_ = GOOGLE_ULONGLONG(0);
  clear_has_hash();
}
inline ::google::protobuf::uint64 UrlQueryInfo::hash() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlQueryInfo.hash)
  return hash_;
}
inline void UrlQueryInfo::set_hash(::google::protobuf::uint64 value) {
  set_has_hash();
  hash_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlQueryInfo.hash)
}

// optional string main_url = 6;
inline bool UrlQueryInfo::has_main_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UrlQueryInfo::set_has_main_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UrlQueryInfo::clear_has_main_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UrlQueryInfo::clear_main_url() {
  main_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_main_url();
}
inline const ::std::string& UrlQueryInfo::main_url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlQueryInfo.main_url)
  return main_url_.GetNoArena();
}
inline void UrlQueryInfo::set_main_url(const ::std::string& value) {
  set_has_main_url();
  main_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlQueryInfo.main_url)
}
#if LANG_CXX11
inline void UrlQueryInfo::set_main_url(::std::string&& value) {
  set_has_main_url();
  main_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.UrlQueryInfo.main_url)
}
#endif
inline void UrlQueryInfo::set_main_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_main_url();
  main_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.UrlQueryInfo.main_url)
}
inline void UrlQueryInfo::set_main_url(const char* value, size_t size) {
  set_has_main_url();
  main_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.UrlQueryInfo.main_url)
}
inline ::std::string* UrlQueryInfo::mutable_main_url() {
  set_has_main_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlQueryInfo.main_url)
  return main_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UrlQueryInfo::release_main_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.UrlQueryInfo.main_url)
  clear_has_main_url();
  return main_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UrlQueryInfo::set_allocated_main_url(::std::string* main_url) {
  if (main_url != NULL) {
    set_has_main_url();
  } else {
    clear_has_main_url();
  }
  main_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), main_url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.UrlQueryInfo.main_url)
}

// optional uint64 cluster_id = 9;
inline bool UrlQueryInfo::has_cluster_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UrlQueryInfo::set_has_cluster_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UrlQueryInfo::clear_has_cluster_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UrlQueryInfo::clear_cluster_id() {
  cluster_id_ = GOOGLE_ULONGLONG(0);
  clear_has_cluster_id();
}
inline ::google::protobuf::uint64 UrlQueryInfo::cluster_id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlQueryInfo.cluster_id)
  return cluster_id_;
}
inline void UrlQueryInfo::set_cluster_id(::google::protobuf::uint64 value) {
  set_has_cluster_id();
  cluster_id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlQueryInfo.cluster_id)
}

// repeated .ru.mail.go.webbase.blobs.UrlRankInfo ranks = 10;
inline int UrlQueryInfo::ranks_size() const {
  return ranks_.size();
}
inline void UrlQueryInfo::clear_ranks() {
  ranks_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::UrlRankInfo& UrlQueryInfo::ranks(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlQueryInfo.ranks)
  return ranks_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::UrlRankInfo* UrlQueryInfo::mutable_ranks(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlQueryInfo.ranks)
  return ranks_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::UrlRankInfo* UrlQueryInfo::add_ranks() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.UrlQueryInfo.ranks)
  return ranks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::UrlRankInfo >*
UrlQueryInfo::mutable_ranks() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.UrlQueryInfo.ranks)
  return &ranks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::UrlRankInfo >&
UrlQueryInfo::ranks() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.UrlQueryInfo.ranks)
  return ranks_;
}

// optional string vk_music_hash = 11;
inline bool UrlQueryInfo::has_vk_music_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UrlQueryInfo::set_has_vk_music_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UrlQueryInfo::clear_has_vk_music_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UrlQueryInfo::clear_vk_music_hash() {
  vk_music_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vk_music_hash();
}
inline const ::std::string& UrlQueryInfo::vk_music_hash() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlQueryInfo.vk_music_hash)
  return vk_music_hash_.GetNoArena();
}
inline void UrlQueryInfo::set_vk_music_hash(const ::std::string& value) {
  set_has_vk_music_hash();
  vk_music_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlQueryInfo.vk_music_hash)
}
#if LANG_CXX11
inline void UrlQueryInfo::set_vk_music_hash(::std::string&& value) {
  set_has_vk_music_hash();
  vk_music_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.UrlQueryInfo.vk_music_hash)
}
#endif
inline void UrlQueryInfo::set_vk_music_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vk_music_hash();
  vk_music_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.UrlQueryInfo.vk_music_hash)
}
inline void UrlQueryInfo::set_vk_music_hash(const char* value, size_t size) {
  set_has_vk_music_hash();
  vk_music_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.UrlQueryInfo.vk_music_hash)
}
inline ::std::string* UrlQueryInfo::mutable_vk_music_hash() {
  set_has_vk_music_hash();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlQueryInfo.vk_music_hash)
  return vk_music_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UrlQueryInfo::release_vk_music_hash() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.UrlQueryInfo.vk_music_hash)
  clear_has_vk_music_hash();
  return vk_music_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UrlQueryInfo::set_allocated_vk_music_hash(::std::string* vk_music_hash) {
  if (vk_music_hash != NULL) {
    set_has_vk_music_hash();
  } else {
    clear_has_vk_music_hash();
  }
  vk_music_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vk_music_hash);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.UrlQueryInfo.vk_music_hash)
}

// -------------------------------------------------------------------

// UrlQueryInfoKey

// required string full_url = 1;
inline bool UrlQueryInfoKey::has_full_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UrlQueryInfoKey::set_has_full_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UrlQueryInfoKey::clear_has_full_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UrlQueryInfoKey::clear_full_url() {
  full_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_full_url();
}
inline const ::std::string& UrlQueryInfoKey::full_url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlQueryInfoKey.full_url)
  return full_url_.GetNoArena();
}
inline void UrlQueryInfoKey::set_full_url(const ::std::string& value) {
  set_has_full_url();
  full_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlQueryInfoKey.full_url)
}
#if LANG_CXX11
inline void UrlQueryInfoKey::set_full_url(::std::string&& value) {
  set_has_full_url();
  full_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.UrlQueryInfoKey.full_url)
}
#endif
inline void UrlQueryInfoKey::set_full_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_full_url();
  full_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.UrlQueryInfoKey.full_url)
}
inline void UrlQueryInfoKey::set_full_url(const char* value, size_t size) {
  set_has_full_url();
  full_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.UrlQueryInfoKey.full_url)
}
inline ::std::string* UrlQueryInfoKey::mutable_full_url() {
  set_has_full_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlQueryInfoKey.full_url)
  return full_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UrlQueryInfoKey::release_full_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.UrlQueryInfoKey.full_url)
  clear_has_full_url();
  return full_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UrlQueryInfoKey::set_allocated_full_url(::std::string* full_url) {
  if (full_url != NULL) {
    set_has_full_url();
  } else {
    clear_has_full_url();
  }
  full_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), full_url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.UrlQueryInfoKey.full_url)
}

// required string rank_name = 2;
inline bool UrlQueryInfoKey::has_rank_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UrlQueryInfoKey::set_has_rank_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UrlQueryInfoKey::clear_has_rank_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UrlQueryInfoKey::clear_rank_name() {
  rank_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rank_name();
}
inline const ::std::string& UrlQueryInfoKey::rank_name() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.UrlQueryInfoKey.rank_name)
  return rank_name_.GetNoArena();
}
inline void UrlQueryInfoKey::set_rank_name(const ::std::string& value) {
  set_has_rank_name();
  rank_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.UrlQueryInfoKey.rank_name)
}
#if LANG_CXX11
inline void UrlQueryInfoKey::set_rank_name(::std::string&& value) {
  set_has_rank_name();
  rank_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.UrlQueryInfoKey.rank_name)
}
#endif
inline void UrlQueryInfoKey::set_rank_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rank_name();
  rank_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.UrlQueryInfoKey.rank_name)
}
inline void UrlQueryInfoKey::set_rank_name(const char* value, size_t size) {
  set_has_rank_name();
  rank_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.UrlQueryInfoKey.rank_name)
}
inline ::std::string* UrlQueryInfoKey::mutable_rank_name() {
  set_has_rank_name();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.UrlQueryInfoKey.rank_name)
  return rank_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UrlQueryInfoKey::release_rank_name() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.UrlQueryInfoKey.rank_name)
  clear_has_rank_name();
  return rank_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UrlQueryInfoKey::set_allocated_rank_name(::std::string* rank_name) {
  if (rank_name != NULL) {
    set_has_rank_name();
  } else {
    clear_has_rank_name();
  }
  rank_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rank_name);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.UrlQueryInfoKey.rank_name)
}

// -------------------------------------------------------------------

// ThumbIndexKey

// required string full_url = 1;
inline bool ThumbIndexKey::has_full_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThumbIndexKey::set_has_full_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThumbIndexKey::clear_has_full_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThumbIndexKey::clear_full_url() {
  full_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_full_url();
}
inline const ::std::string& ThumbIndexKey::full_url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ThumbIndexKey.full_url)
  return full_url_.GetNoArena();
}
inline void ThumbIndexKey::set_full_url(const ::std::string& value) {
  set_has_full_url();
  full_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ThumbIndexKey.full_url)
}
#if LANG_CXX11
inline void ThumbIndexKey::set_full_url(::std::string&& value) {
  set_has_full_url();
  full_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ThumbIndexKey.full_url)
}
#endif
inline void ThumbIndexKey::set_full_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_full_url();
  full_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ThumbIndexKey.full_url)
}
inline void ThumbIndexKey::set_full_url(const char* value, size_t size) {
  set_has_full_url();
  full_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ThumbIndexKey.full_url)
}
inline ::std::string* ThumbIndexKey::mutable_full_url() {
  set_has_full_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ThumbIndexKey.full_url)
  return full_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ThumbIndexKey::release_full_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ThumbIndexKey.full_url)
  clear_has_full_url();
  return full_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ThumbIndexKey::set_allocated_full_url(::std::string* full_url) {
  if (full_url != NULL) {
    set_has_full_url();
  } else {
    clear_has_full_url();
  }
  full_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), full_url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ThumbIndexKey.full_url)
}

// required uint32 priority = 2;
inline bool ThumbIndexKey::has_priority() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThumbIndexKey::set_has_priority() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThumbIndexKey::clear_has_priority() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThumbIndexKey::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 ThumbIndexKey::priority() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ThumbIndexKey.priority)
  return priority_;
}
inline void ThumbIndexKey::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ThumbIndexKey.priority)
}

// required uint32 partition = 3;
inline bool ThumbIndexKey::has_partition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThumbIndexKey::set_has_partition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThumbIndexKey::clear_has_partition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThumbIndexKey::clear_partition() {
  partition_ = 0u;
  clear_has_partition();
}
inline ::google::protobuf::uint32 ThumbIndexKey::partition() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ThumbIndexKey.partition)
  return partition_;
}
inline void ThumbIndexKey::set_partition(::google::protobuf::uint32 value) {
  set_has_partition();
  partition_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ThumbIndexKey.partition)
}

// -------------------------------------------------------------------

// TextIndexKey

// required uint32 partition = 1;
inline bool TextIndexKey::has_partition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextIndexKey::set_has_partition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextIndexKey::clear_has_partition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextIndexKey::clear_partition() {
  partition_ = 0u;
  clear_has_partition();
}
inline ::google::protobuf::uint32 TextIndexKey::partition() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextIndexKey.partition)
  return partition_;
}
inline void TextIndexKey::set_partition(::google::protobuf::uint32 value) {
  set_has_partition();
  partition_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextIndexKey.partition)
}

// required string keyDomain = 2;
inline bool TextIndexKey::has_keydomain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextIndexKey::set_has_keydomain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextIndexKey::clear_has_keydomain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextIndexKey::clear_keydomain() {
  keydomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keydomain();
}
inline const ::std::string& TextIndexKey::keydomain() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.TextIndexKey.keyDomain)
  return keydomain_.GetNoArena();
}
inline void TextIndexKey::set_keydomain(const ::std::string& value) {
  set_has_keydomain();
  keydomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.TextIndexKey.keyDomain)
}
#if LANG_CXX11
inline void TextIndexKey::set_keydomain(::std::string&& value) {
  set_has_keydomain();
  keydomain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.TextIndexKey.keyDomain)
}
#endif
inline void TextIndexKey::set_keydomain(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keydomain();
  keydomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.TextIndexKey.keyDomain)
}
inline void TextIndexKey::set_keydomain(const char* value, size_t size) {
  set_has_keydomain();
  keydomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.TextIndexKey.keyDomain)
}
inline ::std::string* TextIndexKey::mutable_keydomain() {
  set_has_keydomain();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.TextIndexKey.keyDomain)
  return keydomain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextIndexKey::release_keydomain() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.TextIndexKey.keyDomain)
  clear_has_keydomain();
  return keydomain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextIndexKey::set_allocated_keydomain(::std::string* keydomain) {
  if (keydomain != NULL) {
    set_has_keydomain();
  } else {
    clear_has_keydomain();
  }
  keydomain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keydomain);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.TextIndexKey.keyDomain)
}

// -------------------------------------------------------------------

// MarkersInfo_PageInfo

// required string url = 1;
inline bool MarkersInfo_PageInfo::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarkersInfo_PageInfo::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarkersInfo_PageInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarkersInfo_PageInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& MarkersInfo_PageInfo::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.url)
  return url_.GetNoArena();
}
inline void MarkersInfo_PageInfo::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.url)
}
#if LANG_CXX11
inline void MarkersInfo_PageInfo::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.url)
}
#endif
inline void MarkersInfo_PageInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.url)
}
inline void MarkersInfo_PageInfo::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.url)
}
inline ::std::string* MarkersInfo_PageInfo::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarkersInfo_PageInfo::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarkersInfo_PageInfo::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.url)
}

// required uint32 webMarkersCnt = 2;
inline bool MarkersInfo_PageInfo::has_webmarkerscnt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarkersInfo_PageInfo::set_has_webmarkerscnt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarkersInfo_PageInfo::clear_has_webmarkerscnt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarkersInfo_PageInfo::clear_webmarkerscnt() {
  webmarkerscnt_ = 0u;
  clear_has_webmarkerscnt();
}
inline ::google::protobuf::uint32 MarkersInfo_PageInfo::webmarkerscnt() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.webMarkersCnt)
  return webmarkerscnt_;
}
inline void MarkersInfo_PageInfo::set_webmarkerscnt(::google::protobuf::uint32 value) {
  set_has_webmarkerscnt();
  webmarkerscnt_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.webMarkersCnt)
}

// required uint32 ImgMarkersCnt = 3;
inline bool MarkersInfo_PageInfo::has_imgmarkerscnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarkersInfo_PageInfo::set_has_imgmarkerscnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarkersInfo_PageInfo::clear_has_imgmarkerscnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarkersInfo_PageInfo::clear_imgmarkerscnt() {
  imgmarkerscnt_ = 0u;
  clear_has_imgmarkerscnt();
}
inline ::google::protobuf::uint32 MarkersInfo_PageInfo::imgmarkerscnt() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.ImgMarkersCnt)
  return imgmarkerscnt_;
}
inline void MarkersInfo_PageInfo::set_imgmarkerscnt(::google::protobuf::uint32 value) {
  set_has_imgmarkerscnt();
  imgmarkerscnt_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.MarkersInfo.PageInfo.ImgMarkersCnt)
}

// -------------------------------------------------------------------

// MarkersInfo

// required .ru.mail.go.webbase.blobs.MarkersInfo.Type type = 1;
inline bool MarkersInfo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarkersInfo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarkersInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarkersInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ru::mail::go::webbase::blobs::MarkersInfo_Type MarkersInfo::type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MarkersInfo.type)
  return static_cast< ::ru::mail::go::webbase::blobs::MarkersInfo_Type >(type_);
}
inline void MarkersInfo::set_type(::ru::mail::go::webbase::blobs::MarkersInfo_Type value) {
  assert(::ru::mail::go::webbase::blobs::MarkersInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.MarkersInfo.type)
}

// optional .ru.mail.go.webbase.blobs.MarkersInfo.PageInfo pageinfo = 2;
inline bool MarkersInfo::has_pageinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarkersInfo::set_has_pageinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarkersInfo::clear_has_pageinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarkersInfo::clear_pageinfo() {
  if (pageinfo_ != NULL) pageinfo_->::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo::Clear();
  clear_has_pageinfo();
}
inline const ::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo& MarkersInfo::pageinfo() const {
  const ::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo* p = pageinfo_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MarkersInfo.pageinfo)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo*>(
      &::ru::mail::go::webbase::blobs::_MarkersInfo_PageInfo_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo* MarkersInfo::mutable_pageinfo() {
  set_has_pageinfo();
  if (pageinfo_ == NULL) {
    pageinfo_ = new ::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.MarkersInfo.pageinfo)
  return pageinfo_;
}
inline ::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo* MarkersInfo::release_pageinfo() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.MarkersInfo.pageinfo)
  clear_has_pageinfo();
  ::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo* temp = pageinfo_;
  pageinfo_ = NULL;
  return temp;
}
inline void MarkersInfo::set_allocated_pageinfo(::ru::mail::go::webbase::blobs::MarkersInfo_PageInfo* pageinfo) {
  delete pageinfo_;
  pageinfo_ = pageinfo;
  if (pageinfo) {
    set_has_pageinfo();
  } else {
    clear_has_pageinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.MarkersInfo.pageinfo)
}

// optional .ru.mail.go.webbase.sekitei.Sekitei_m sekitei = 3;
inline bool MarkersInfo::has_sekitei() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarkersInfo::set_has_sekitei() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarkersInfo::clear_has_sekitei() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarkersInfo::clear_sekitei() {
  if (sekitei_ != NULL) sekitei_->::ru::mail::go::webbase::sekitei::Sekitei_m::Clear();
  clear_has_sekitei();
}
inline const ::ru::mail::go::webbase::sekitei::Sekitei_m& MarkersInfo::sekitei() const {
  const ::ru::mail::go::webbase::sekitei::Sekitei_m* p = sekitei_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.MarkersInfo.sekitei)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::sekitei::Sekitei_m*>(
      &::ru::mail::go::webbase::sekitei::_Sekitei_m_default_instance_);
}
inline ::ru::mail::go::webbase::sekitei::Sekitei_m* MarkersInfo::mutable_sekitei() {
  set_has_sekitei();
  if (sekitei_ == NULL) {
    sekitei_ = new ::ru::mail::go::webbase::sekitei::Sekitei_m;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.MarkersInfo.sekitei)
  return sekitei_;
}
inline ::ru::mail::go::webbase::sekitei::Sekitei_m* MarkersInfo::release_sekitei() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.MarkersInfo.sekitei)
  clear_has_sekitei();
  ::ru::mail::go::webbase::sekitei::Sekitei_m* temp = sekitei_;
  sekitei_ = NULL;
  return temp;
}
inline void MarkersInfo::set_allocated_sekitei(::ru::mail::go::webbase::sekitei::Sekitei_m* sekitei) {
  delete sekitei_;
  sekitei_ = sekitei;
  if (sekitei) {
    set_has_sekitei();
  } else {
    clear_has_sekitei();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.MarkersInfo.sekitei)
}

// -------------------------------------------------------------------

// ResClustInfo

// required int64 id = 1;
inline bool ResClustInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResClustInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResClustInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResClustInfo::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 ResClustInfo::id() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ResClustInfo.id)
  return id_;
}
inline void ResClustInfo::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ResClustInfo.id)
}

// optional string res_part1 = 2;
inline bool ResClustInfo::has_res_part1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResClustInfo::set_has_res_part1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResClustInfo::clear_has_res_part1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResClustInfo::clear_res_part1() {
  res_part1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_res_part1();
}
inline const ::std::string& ResClustInfo::res_part1() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ResClustInfo.res_part1)
  return res_part1_.GetNoArena();
}
inline void ResClustInfo::set_res_part1(const ::std::string& value) {
  set_has_res_part1();
  res_part1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ResClustInfo.res_part1)
}
#if LANG_CXX11
inline void ResClustInfo::set_res_part1(::std::string&& value) {
  set_has_res_part1();
  res_part1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ResClustInfo.res_part1)
}
#endif
inline void ResClustInfo::set_res_part1(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_res_part1();
  res_part1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ResClustInfo.res_part1)
}
inline void ResClustInfo::set_res_part1(const char* value, size_t size) {
  set_has_res_part1();
  res_part1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ResClustInfo.res_part1)
}
inline ::std::string* ResClustInfo::mutable_res_part1() {
  set_has_res_part1();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ResClustInfo.res_part1)
  return res_part1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResClustInfo::release_res_part1() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ResClustInfo.res_part1)
  clear_has_res_part1();
  return res_part1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResClustInfo::set_allocated_res_part1(::std::string* res_part1) {
  if (res_part1 != NULL) {
    set_has_res_part1();
  } else {
    clear_has_res_part1();
  }
  res_part1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), res_part1);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ResClustInfo.res_part1)
}

// optional string res_part2 = 3;
inline bool ResClustInfo::has_res_part2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResClustInfo::set_has_res_part2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResClustInfo::clear_has_res_part2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResClustInfo::clear_res_part2() {
  res_part2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_res_part2();
}
inline const ::std::string& ResClustInfo::res_part2() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ResClustInfo.res_part2)
  return res_part2_.GetNoArena();
}
inline void ResClustInfo::set_res_part2(const ::std::string& value) {
  set_has_res_part2();
  res_part2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ResClustInfo.res_part2)
}
#if LANG_CXX11
inline void ResClustInfo::set_res_part2(::std::string&& value) {
  set_has_res_part2();
  res_part2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ResClustInfo.res_part2)
}
#endif
inline void ResClustInfo::set_res_part2(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_res_part2();
  res_part2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ResClustInfo.res_part2)
}
inline void ResClustInfo::set_res_part2(const char* value, size_t size) {
  set_has_res_part2();
  res_part2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ResClustInfo.res_part2)
}
inline ::std::string* ResClustInfo::mutable_res_part2() {
  set_has_res_part2();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ResClustInfo.res_part2)
  return res_part2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResClustInfo::release_res_part2() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ResClustInfo.res_part2)
  clear_has_res_part2();
  return res_part2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResClustInfo::set_allocated_res_part2(::std::string* res_part2) {
  if (res_part2 != NULL) {
    set_has_res_part2();
  } else {
    clear_has_res_part2();
  }
  res_part2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), res_part2);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ResClustInfo.res_part2)
}

// -------------------------------------------------------------------

// DiscoveryVisitUrlInfo

// required .ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.Source source = 1;
inline bool DiscoveryVisitUrlInfo::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiscoveryVisitUrlInfo::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiscoveryVisitUrlInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiscoveryVisitUrlInfo::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::ru::mail::go::webbase::blobs::DiscoveryVisitUrlInfo_Source DiscoveryVisitUrlInfo::source() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.source)
  return static_cast< ::ru::mail::go::webbase::blobs::DiscoveryVisitUrlInfo_Source >(source_);
}
inline void DiscoveryVisitUrlInfo::set_source(::ru::mail::go::webbase::blobs::DiscoveryVisitUrlInfo_Source value) {
  assert(::ru::mail::go::webbase::blobs::DiscoveryVisitUrlInfo_Source_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.source)
}

// required uint64 ts = 2;
inline bool DiscoveryVisitUrlInfo::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiscoveryVisitUrlInfo::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiscoveryVisitUrlInfo::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiscoveryVisitUrlInfo::clear_ts() {
  ts_ = GOOGLE_ULONGLONG(0);
  clear_has_ts();
}
inline ::google::protobuf::uint64 DiscoveryVisitUrlInfo::ts() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.ts)
  return ts_;
}
inline void DiscoveryVisitUrlInfo::set_ts(::google::protobuf::uint64 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.ts)
}

// required string url = 3;
inline bool DiscoveryVisitUrlInfo::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscoveryVisitUrlInfo::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiscoveryVisitUrlInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiscoveryVisitUrlInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& DiscoveryVisitUrlInfo::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.url)
  return url_.GetNoArena();
}
inline void DiscoveryVisitUrlInfo::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.url)
}
#if LANG_CXX11
inline void DiscoveryVisitUrlInfo::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.url)
}
#endif
inline void DiscoveryVisitUrlInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.url)
}
inline void DiscoveryVisitUrlInfo::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.url)
}
inline ::std::string* DiscoveryVisitUrlInfo::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DiscoveryVisitUrlInfo::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DiscoveryVisitUrlInfo::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.DiscoveryVisitUrlInfo.url)
}

// -------------------------------------------------------------------

// DarkImageLinks

// repeated .ru.mail.go.webbase.blobs.DarkImageLinksItem items = 1;
inline int DarkImageLinks::items_size() const {
  return items_.size();
}
inline void DarkImageLinks::clear_items() {
  items_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::DarkImageLinksItem& DarkImageLinks::items(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DarkImageLinks.items)
  return items_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::DarkImageLinksItem* DarkImageLinks::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.DarkImageLinks.items)
  return items_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::DarkImageLinksItem* DarkImageLinks::add_items() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.DarkImageLinks.items)
  return items_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::DarkImageLinksItem >*
DarkImageLinks::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.DarkImageLinks.items)
  return &items_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::DarkImageLinksItem >&
DarkImageLinks::items() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.DarkImageLinks.items)
  return items_;
}

// -------------------------------------------------------------------

// DarkImageLinksItem

// required string url = 1;
inline bool DarkImageLinksItem::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DarkImageLinksItem::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DarkImageLinksItem::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DarkImageLinksItem::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& DarkImageLinksItem::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DarkImageLinksItem.url)
  return url_.GetNoArena();
}
inline void DarkImageLinksItem::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DarkImageLinksItem.url)
}
#if LANG_CXX11
inline void DarkImageLinksItem::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.DarkImageLinksItem.url)
}
#endif
inline void DarkImageLinksItem::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.DarkImageLinksItem.url)
}
inline void DarkImageLinksItem::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.DarkImageLinksItem.url)
}
inline ::std::string* DarkImageLinksItem::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.DarkImageLinksItem.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DarkImageLinksItem::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.DarkImageLinksItem.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DarkImageLinksItem::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.DarkImageLinksItem.url)
}

// required uint32 httpStatus = 2;
inline bool DarkImageLinksItem::has_httpstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DarkImageLinksItem::set_has_httpstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DarkImageLinksItem::clear_has_httpstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DarkImageLinksItem::clear_httpstatus() {
  httpstatus_ = 0u;
  clear_has_httpstatus();
}
inline ::google::protobuf::uint32 DarkImageLinksItem::httpstatus() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DarkImageLinksItem.httpStatus)
  return httpstatus_;
}
inline void DarkImageLinksItem::set_httpstatus(::google::protobuf::uint32 value) {
  set_has_httpstatus();
  httpstatus_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DarkImageLinksItem.httpStatus)
}

// optional uint32 width = 3;
inline bool DarkImageLinksItem::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DarkImageLinksItem::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DarkImageLinksItem::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DarkImageLinksItem::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 DarkImageLinksItem::width() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DarkImageLinksItem.width)
  return width_;
}
inline void DarkImageLinksItem::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DarkImageLinksItem.width)
}

// optional uint32 height = 4;
inline bool DarkImageLinksItem::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DarkImageLinksItem::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DarkImageLinksItem::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DarkImageLinksItem::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 DarkImageLinksItem::height() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DarkImageLinksItem.height)
  return height_;
}
inline void DarkImageLinksItem::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DarkImageLinksItem.height)
}

// optional int32 left = 5;
inline bool DarkImageLinksItem::has_left() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DarkImageLinksItem::set_has_left() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DarkImageLinksItem::clear_has_left() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DarkImageLinksItem::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline ::google::protobuf::int32 DarkImageLinksItem::left() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DarkImageLinksItem.left)
  return left_;
}
inline void DarkImageLinksItem::set_left(::google::protobuf::int32 value) {
  set_has_left();
  left_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DarkImageLinksItem.left)
}

// optional int32 top = 6;
inline bool DarkImageLinksItem::has_top() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DarkImageLinksItem::set_has_top() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DarkImageLinksItem::clear_has_top() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DarkImageLinksItem::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline ::google::protobuf::int32 DarkImageLinksItem::top() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DarkImageLinksItem.top)
  return top_;
}
inline void DarkImageLinksItem::set_top(::google::protobuf::int32 value) {
  set_has_top();
  top_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DarkImageLinksItem.top)
}

// optional int32 zindex = 7;
inline bool DarkImageLinksItem::has_zindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DarkImageLinksItem::set_has_zindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DarkImageLinksItem::clear_has_zindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DarkImageLinksItem::clear_zindex() {
  zindex_ = 0;
  clear_has_zindex();
}
inline ::google::protobuf::int32 DarkImageLinksItem::zindex() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DarkImageLinksItem.zindex)
  return zindex_;
}
inline void DarkImageLinksItem::set_zindex(::google::protobuf::int32 value) {
  set_has_zindex();
  zindex_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DarkImageLinksItem.zindex)
}

// optional string meta = 8;
inline bool DarkImageLinksItem::has_meta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DarkImageLinksItem::set_has_meta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DarkImageLinksItem::clear_has_meta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DarkImageLinksItem::clear_meta() {
  meta_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_meta();
}
inline const ::std::string& DarkImageLinksItem::meta() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.DarkImageLinksItem.meta)
  return meta_.GetNoArena();
}
inline void DarkImageLinksItem::set_meta(const ::std::string& value) {
  set_has_meta();
  meta_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.DarkImageLinksItem.meta)
}
#if LANG_CXX11
inline void DarkImageLinksItem::set_meta(::std::string&& value) {
  set_has_meta();
  meta_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.DarkImageLinksItem.meta)
}
#endif
inline void DarkImageLinksItem::set_meta(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_meta();
  meta_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.DarkImageLinksItem.meta)
}
inline void DarkImageLinksItem::set_meta(const char* value, size_t size) {
  set_has_meta();
  meta_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.DarkImageLinksItem.meta)
}
inline ::std::string* DarkImageLinksItem::mutable_meta() {
  set_has_meta();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.DarkImageLinksItem.meta)
  return meta_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DarkImageLinksItem::release_meta() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.DarkImageLinksItem.meta)
  clear_has_meta();
  return meta_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DarkImageLinksItem::set_allocated_meta(::std::string* meta) {
  if (meta != NULL) {
    set_has_meta();
  } else {
    clear_has_meta();
  }
  meta_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meta);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.DarkImageLinksItem.meta)
}

// -------------------------------------------------------------------

// EmbeddingData

// required string url = 1;
inline bool EmbeddingData::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmbeddingData::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmbeddingData::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmbeddingData::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& EmbeddingData::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.EmbeddingData.url)
  return url_.GetNoArena();
}
inline void EmbeddingData::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.EmbeddingData.url)
}
#if LANG_CXX11
inline void EmbeddingData::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.EmbeddingData.url)
}
#endif
inline void EmbeddingData::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.EmbeddingData.url)
}
inline void EmbeddingData::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.EmbeddingData.url)
}
inline ::std::string* EmbeddingData::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.EmbeddingData.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmbeddingData::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.EmbeddingData.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmbeddingData::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.EmbeddingData.url)
}

// required .qembedder.pb.Embedding embedding = 2;
inline bool EmbeddingData::has_embedding() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmbeddingData::set_has_embedding() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmbeddingData::clear_has_embedding() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmbeddingData::clear_embedding() {
  if (embedding_ != NULL) embedding_->::qembedder::pb::Embedding::Clear();
  clear_has_embedding();
}
inline const ::qembedder::pb::Embedding& EmbeddingData::embedding() const {
  const ::qembedder::pb::Embedding* p = embedding_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.EmbeddingData.embedding)
  return p != NULL ? *p : *reinterpret_cast<const ::qembedder::pb::Embedding*>(
      &::qembedder::pb::_Embedding_default_instance_);
}
inline ::qembedder::pb::Embedding* EmbeddingData::mutable_embedding() {
  set_has_embedding();
  if (embedding_ == NULL) {
    embedding_ = new ::qembedder::pb::Embedding;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.EmbeddingData.embedding)
  return embedding_;
}
inline ::qembedder::pb::Embedding* EmbeddingData::release_embedding() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.EmbeddingData.embedding)
  clear_has_embedding();
  ::qembedder::pb::Embedding* temp = embedding_;
  embedding_ = NULL;
  return temp;
}
inline void EmbeddingData::set_allocated_embedding(::qembedder::pb::Embedding* embedding) {
  delete embedding_;
  embedding_ = embedding;
  if (embedding) {
    set_has_embedding();
  } else {
    clear_has_embedding();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.EmbeddingData.embedding)
}

// -------------------------------------------------------------------

// ImageHashItem

// required string url = 1;
inline bool ImageHashItem::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageHashItem::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageHashItem::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageHashItem::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& ImageHashItem::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageHashItem.url)
  return url_.GetNoArena();
}
inline void ImageHashItem::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageHashItem.url)
}
#if LANG_CXX11
inline void ImageHashItem::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.ImageHashItem.url)
}
#endif
inline void ImageHashItem::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.ImageHashItem.url)
}
inline void ImageHashItem::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.ImageHashItem.url)
}
inline ::std::string* ImageHashItem::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.ImageHashItem.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageHashItem::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.ImageHashItem.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageHashItem::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.ImageHashItem.url)
}

// required .ru.mail.go.webbase.blobs.ImageHashItem.Source souce = 2;
inline bool ImageHashItem::has_souce() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageHashItem::set_has_souce() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageHashItem::clear_has_souce() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageHashItem::clear_souce() {
  souce_ = 1;
  clear_has_souce();
}
inline ::ru::mail::go::webbase::blobs::ImageHashItem_Source ImageHashItem::souce() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageHashItem.souce)
  return static_cast< ::ru::mail::go::webbase::blobs::ImageHashItem_Source >(souce_);
}
inline void ImageHashItem::set_souce(::ru::mail::go::webbase::blobs::ImageHashItem_Source value) {
  assert(::ru::mail::go::webbase::blobs::ImageHashItem_Source_IsValid(value));
  set_has_souce();
  souce_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageHashItem.souce)
}

// required uint32 width = 3;
inline bool ImageHashItem::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageHashItem::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageHashItem::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageHashItem::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 ImageHashItem::width() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageHashItem.width)
  return width_;
}
inline void ImageHashItem::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageHashItem.width)
}

// required uint32 height = 4;
inline bool ImageHashItem::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageHashItem::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageHashItem::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageHashItem::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 ImageHashItem::height() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.ImageHashItem.height)
  return height_;
}
inline void ImageHashItem::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.ImageHashItem.height)
}

// -------------------------------------------------------------------

// VideoFrames

// required .ru.mail.go.webbase.blobs.ThumbDoc frames = 1;
inline bool VideoFrames::has_frames() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoFrames::set_has_frames() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoFrames::clear_has_frames() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoFrames::clear_frames() {
  if (frames_ != NULL) frames_->::ru::mail::go::webbase::blobs::ThumbDoc::Clear();
  clear_has_frames();
}
inline const ::ru::mail::go::webbase::blobs::ThumbDoc& VideoFrames::frames() const {
  const ::ru::mail::go::webbase::blobs::ThumbDoc* p = frames_;
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.VideoFrames.frames)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::ThumbDoc*>(
      &::ru::mail::go::webbase::blobs::_ThumbDoc_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::ThumbDoc* VideoFrames::mutable_frames() {
  set_has_frames();
  if (frames_ == NULL) {
    frames_ = new ::ru::mail::go::webbase::blobs::ThumbDoc;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.VideoFrames.frames)
  return frames_;
}
inline ::ru::mail::go::webbase::blobs::ThumbDoc* VideoFrames::release_frames() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.VideoFrames.frames)
  clear_has_frames();
  ::ru::mail::go::webbase::blobs::ThumbDoc* temp = frames_;
  frames_ = NULL;
  return temp;
}
inline void VideoFrames::set_allocated_frames(::ru::mail::go::webbase::blobs::ThumbDoc* frames) {
  delete frames_;
  frames_ = frames;
  if (frames) {
    set_has_frames();
  } else {
    clear_has_frames();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.VideoFrames.frames)
}

// -------------------------------------------------------------------

// OCRSentence

// required string text = 1;
inline bool OCRSentence::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OCRSentence::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OCRSentence::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OCRSentence::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& OCRSentence::text() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OCRSentence.text)
  return text_.GetNoArena();
}
inline void OCRSentence::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OCRSentence.text)
}
#if LANG_CXX11
inline void OCRSentence::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.webbase.blobs.OCRSentence.text)
}
#endif
inline void OCRSentence::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.webbase.blobs.OCRSentence.text)
}
inline void OCRSentence::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.webbase.blobs.OCRSentence.text)
}
inline ::std::string* OCRSentence::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.OCRSentence.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OCRSentence::release_text() {
  // @@protoc_insertion_point(field_release:ru.mail.go.webbase.blobs.OCRSentence.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OCRSentence::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.webbase.blobs.OCRSentence.text)
}

// required float score = 2;
inline bool OCRSentence::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OCRSentence::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OCRSentence::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OCRSentence::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float OCRSentence::score() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OCRSentence.score)
  return score_;
}
inline void OCRSentence::set_score(float value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OCRSentence.score)
}

// required int32 x = 3;
inline bool OCRSentence::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OCRSentence::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OCRSentence::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OCRSentence::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 OCRSentence::x() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OCRSentence.x)
  return x_;
}
inline void OCRSentence::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OCRSentence.x)
}

// required int32 y = 4;
inline bool OCRSentence::has_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OCRSentence::set_has_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OCRSentence::clear_has_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OCRSentence::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 OCRSentence::y() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OCRSentence.y)
  return y_;
}
inline void OCRSentence::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OCRSentence.y)
}

// required int32 w = 5;
inline bool OCRSentence::has_w() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OCRSentence::set_has_w() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OCRSentence::clear_has_w() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OCRSentence::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 OCRSentence::w() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OCRSentence.w)
  return w_;
}
inline void OCRSentence::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OCRSentence.w)
}

// required int32 h = 6;
inline bool OCRSentence::has_h() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OCRSentence::set_has_h() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OCRSentence::clear_has_h() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OCRSentence::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline ::google::protobuf::int32 OCRSentence::h() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OCRSentence.h)
  return h_;
}
inline void OCRSentence::set_h(::google::protobuf::int32 value) {
  set_has_h();
  h_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.webbase.blobs.OCRSentence.h)
}

// -------------------------------------------------------------------

// OCRResult

// repeated .ru.mail.go.webbase.blobs.OCRSentence sentences = 1;
inline int OCRResult::sentences_size() const {
  return sentences_.size();
}
inline void OCRResult::clear_sentences() {
  sentences_.Clear();
}
inline const ::ru::mail::go::webbase::blobs::OCRSentence& OCRResult::sentences(int index) const {
  // @@protoc_insertion_point(field_get:ru.mail.go.webbase.blobs.OCRResult.sentences)
  return sentences_.Get(index);
}
inline ::ru::mail::go::webbase::blobs::OCRSentence* OCRResult::mutable_sentences(int index) {
  // @@protoc_insertion_point(field_mutable:ru.mail.go.webbase.blobs.OCRResult.sentences)
  return sentences_.Mutable(index);
}
inline ::ru::mail::go::webbase::blobs::OCRSentence* OCRResult::add_sentences() {
  // @@protoc_insertion_point(field_add:ru.mail.go.webbase.blobs.OCRResult.sentences)
  return sentences_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::OCRSentence >*
OCRResult::mutable_sentences() {
  // @@protoc_insertion_point(field_mutable_list:ru.mail.go.webbase.blobs.OCRResult.sentences)
  return &sentences_;
}
inline const ::google::protobuf::RepeatedPtrField< ::ru::mail::go::webbase::blobs::OCRSentence >&
OCRResult::sentences() const {
  // @@protoc_insertion_point(field_list:ru.mail.go.webbase.blobs.OCRResult.sentences)
  return sentences_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace blobs
}  // namespace webbase
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::ImageMarkerUrlTrace_StageInfo> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::ImageMarkerUrlTrace_StageInfo>() {
  return ::ru::mail::go::webbase::blobs::ImageMarkerUrlTrace_StageInfo_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::RatioStats_Kind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::RatioStats_Kind>() {
  return ::ru::mail::go::webbase::blobs::RatioStats_Kind_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::ImageStructInfo_ImageSource> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::ImageStructInfo_ImageSource>() {
  return ::ru::mail::go::webbase::blobs::ImageStructInfo_ImageSource_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::MarkersInfo_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::MarkersInfo_Type>() {
  return ::ru::mail::go::webbase::blobs::MarkersInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::DiscoveryVisitUrlInfo_Source> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::DiscoveryVisitUrlInfo_Source>() {
  return ::ru::mail::go::webbase::blobs::DiscoveryVisitUrlInfo_Source_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::ImageHashItem_Source> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::ImageHashItem_Source>() {
  return ::ru::mail::go::webbase::blobs::ImageHashItem_Source_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::Tag> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::Tag>() {
  return ::ru::mail::go::webbase::blobs::Tag_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::ParserID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::ParserID>() {
  return ::ru::mail::go::webbase::blobs::ParserID_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::webbase::blobs::ZoneName> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::webbase::blobs::ZoneName>() {
  return ::ru::mail::go::webbase::blobs::ZoneName_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_image_5fblobs_2eproto__INCLUDED
