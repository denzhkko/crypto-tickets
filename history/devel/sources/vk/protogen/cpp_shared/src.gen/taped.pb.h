// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: taped.proto

#ifndef PROTOBUF_taped_2eproto__INCLUDED
#define PROTOBUF_taped_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
class TagRecommendation;
class TagRecommendationDefaultTypeInternal;
extern TagRecommendationDefaultTypeInternal _TagRecommendation_default_instance_;
class TagRecommendations;
class TagRecommendationsDefaultTypeInternal;
extern TagRecommendationsDefaultTypeInternal _TagRecommendations_default_instance_;
class TapeDocument;
class TapeDocumentDefaultTypeInternal;
extern TapeDocumentDefaultTypeInternal _TapeDocument_default_instance_;
class TapeDocument_Tag;
class TapeDocument_TagDefaultTypeInternal;
extern TapeDocument_TagDefaultTypeInternal _TapeDocument_Tag_default_instance_;
class UserRecommendation;
class UserRecommendationDefaultTypeInternal;
extern UserRecommendationDefaultTypeInternal _UserRecommendation_default_instance_;

namespace protobuf_taped_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_taped_2eproto

enum TapeDocument_Type {
  TapeDocument_Type_IMG = 0,
  TapeDocument_Type_WEB = 1,
  TapeDocument_Type_NEWS = 2,
  TapeDocument_Type_CAT = 3,
  TapeDocument_Type_MYATA = 4
};
bool TapeDocument_Type_IsValid(int value);
const TapeDocument_Type TapeDocument_Type_Type_MIN = TapeDocument_Type_IMG;
const TapeDocument_Type TapeDocument_Type_Type_MAX = TapeDocument_Type_MYATA;
const int TapeDocument_Type_Type_ARRAYSIZE = TapeDocument_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TapeDocument_Type_descriptor();
inline const ::std::string& TapeDocument_Type_Name(TapeDocument_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TapeDocument_Type_descriptor(), value);
}
inline bool TapeDocument_Type_Parse(
    const ::std::string& name, TapeDocument_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TapeDocument_Type>(
    TapeDocument_Type_descriptor(), name, value);
}
// ===================================================================

class TapeDocument_Tag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TapeDocument.Tag) */ {
 public:
  TapeDocument_Tag();
  virtual ~TapeDocument_Tag();

  TapeDocument_Tag(const TapeDocument_Tag& from);

  inline TapeDocument_Tag& operator=(const TapeDocument_Tag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TapeDocument_Tag(TapeDocument_Tag&& from) noexcept
    : TapeDocument_Tag() {
    *this = ::std::move(from);
  }

  inline TapeDocument_Tag& operator=(TapeDocument_Tag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TapeDocument_Tag& default_instance();

  static inline const TapeDocument_Tag* internal_default_instance() {
    return reinterpret_cast<const TapeDocument_Tag*>(
               &_TapeDocument_Tag_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TapeDocument_Tag* other);
  friend void swap(TapeDocument_Tag& a, TapeDocument_Tag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TapeDocument_Tag* New() const PROTOBUF_FINAL { return New(NULL); }

  TapeDocument_Tag* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TapeDocument_Tag& from);
  void MergeFrom(const TapeDocument_Tag& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TapeDocument_Tag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional int32 freq = 2;
  bool has_freq() const;
  void clear_freq();
  static const int kFreqFieldNumber = 2;
  ::google::protobuf::int32 freq() const;
  void set_freq(::google::protobuf::int32 value);

  // optional int32 pos = 3;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 3;
  ::google::protobuf::int32 pos() const;
  void set_pos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TapeDocument.Tag)
 private:
  void set_has_text();
  void clear_has_text();
  void set_has_freq();
  void clear_has_freq();
  void set_has_pos();
  void clear_has_pos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::int32 freq_;
  ::google::protobuf::int32 pos_;
  friend struct protobuf_taped_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TapeDocument : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TapeDocument) */ {
 public:
  TapeDocument();
  virtual ~TapeDocument();

  TapeDocument(const TapeDocument& from);

  inline TapeDocument& operator=(const TapeDocument& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TapeDocument(TapeDocument&& from) noexcept
    : TapeDocument() {
    *this = ::std::move(from);
  }

  inline TapeDocument& operator=(TapeDocument&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TapeDocument& default_instance();

  static inline const TapeDocument* internal_default_instance() {
    return reinterpret_cast<const TapeDocument*>(
               &_TapeDocument_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TapeDocument* other);
  friend void swap(TapeDocument& a, TapeDocument& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TapeDocument* New() const PROTOBUF_FINAL { return New(NULL); }

  TapeDocument* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TapeDocument& from);
  void MergeFrom(const TapeDocument& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TapeDocument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TapeDocument_Tag Tag;

  typedef TapeDocument_Type Type;
  static const Type IMG =
    TapeDocument_Type_IMG;
  static const Type WEB =
    TapeDocument_Type_WEB;
  static const Type NEWS =
    TapeDocument_Type_NEWS;
  static const Type CAT =
    TapeDocument_Type_CAT;
  static const Type MYATA =
    TapeDocument_Type_MYATA;
  static inline bool Type_IsValid(int value) {
    return TapeDocument_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TapeDocument_Type_Type_MIN;
  static const Type Type_MAX =
    TapeDocument_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TapeDocument_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TapeDocument_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TapeDocument_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TapeDocument_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .TapeDocument.Tag tags = 16;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 16;
  const ::TapeDocument_Tag& tags(int index) const;
  ::TapeDocument_Tag* mutable_tags(int index);
  ::TapeDocument_Tag* add_tags();
  ::google::protobuf::RepeatedPtrField< ::TapeDocument_Tag >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::TapeDocument_Tag >&
      tags() const;

  // optional string anchor = 3;
  bool has_anchor() const;
  void clear_anchor();
  static const int kAnchorFieldNumber = 3;
  const ::std::string& anchor() const;
  void set_anchor(const ::std::string& value);
  #if LANG_CXX11
  void set_anchor(::std::string&& value);
  #endif
  void set_anchor(const char* value);
  void set_anchor(const char* value, size_t size);
  ::std::string* mutable_anchor();
  ::std::string* release_anchor();
  void set_allocated_anchor(::std::string* anchor);

  // optional string text1 = 4;
  bool has_text1() const;
  void clear_text1();
  static const int kText1FieldNumber = 4;
  const ::std::string& text1() const;
  void set_text1(const ::std::string& value);
  #if LANG_CXX11
  void set_text1(::std::string&& value);
  #endif
  void set_text1(const char* value);
  void set_text1(const char* value, size_t size);
  ::std::string* mutable_text1();
  ::std::string* release_text1();
  void set_allocated_text1(::std::string* text1);

  // optional string text2 = 5;
  bool has_text2() const;
  void clear_text2();
  static const int kText2FieldNumber = 5;
  const ::std::string& text2() const;
  void set_text2(const ::std::string& value);
  #if LANG_CXX11
  void set_text2(::std::string&& value);
  #endif
  void set_text2(const char* value);
  void set_text2(const char* value, size_t size);
  ::std::string* mutable_text2();
  ::std::string* release_text2();
  void set_allocated_text2(::std::string* text2);

  // optional string keywords = 6;
  bool has_keywords() const;
  void clear_keywords();
  static const int kKeywordsFieldNumber = 6;
  const ::std::string& keywords() const;
  void set_keywords(const ::std::string& value);
  #if LANG_CXX11
  void set_keywords(::std::string&& value);
  #endif
  void set_keywords(const char* value);
  void set_keywords(const char* value, size_t size);
  ::std::string* mutable_keywords();
  ::std::string* release_keywords();
  void set_allocated_keywords(::std::string* keywords);

  // optional string page_title = 7;
  bool has_page_title() const;
  void clear_page_title();
  static const int kPageTitleFieldNumber = 7;
  const ::std::string& page_title() const;
  void set_page_title(const ::std::string& value);
  #if LANG_CXX11
  void set_page_title(::std::string&& value);
  #endif
  void set_page_title(const char* value);
  void set_page_title(const char* value, size_t size);
  ::std::string* mutable_page_title();
  ::std::string* release_page_title();
  void set_allocated_page_title(::std::string* page_title);

  // optional string h_text = 8;
  bool has_h_text() const;
  void clear_h_text();
  static const int kHTextFieldNumber = 8;
  const ::std::string& h_text() const;
  void set_h_text(const ::std::string& value);
  #if LANG_CXX11
  void set_h_text(::std::string&& value);
  #endif
  void set_h_text(const char* value);
  void set_h_text(const char* value, size_t size);
  ::std::string* mutable_h_text();
  ::std::string* release_h_text();
  void set_allocated_h_text(::std::string* h_text);

  // optional string dest_url = 9;
  bool has_dest_url() const;
  void clear_dest_url();
  static const int kDestUrlFieldNumber = 9;
  const ::std::string& dest_url() const;
  void set_dest_url(const ::std::string& value);
  #if LANG_CXX11
  void set_dest_url(::std::string&& value);
  #endif
  void set_dest_url(const char* value);
  void set_dest_url(const char* value, size_t size);
  ::std::string* mutable_dest_url();
  ::std::string* release_dest_url();
  void set_allocated_dest_url(::std::string* dest_url);

  // optional string img_url = 10;
  bool has_img_url() const;
  void clear_img_url();
  static const int kImgUrlFieldNumber = 10;
  const ::std::string& img_url() const;
  void set_img_url(const ::std::string& value);
  #if LANG_CXX11
  void set_img_url(::std::string&& value);
  #endif
  void set_img_url(const char* value);
  void set_img_url(const char* value, size_t size);
  ::std::string* mutable_img_url();
  ::std::string* release_img_url();
  void set_allocated_img_url(::std::string* img_url);

  // optional string img_preview_url = 11;
  bool has_img_preview_url() const;
  void clear_img_preview_url();
  static const int kImgPreviewUrlFieldNumber = 11;
  const ::std::string& img_preview_url() const;
  void set_img_preview_url(const ::std::string& value);
  #if LANG_CXX11
  void set_img_preview_url(::std::string&& value);
  #endif
  void set_img_preview_url(const char* value);
  void set_img_preview_url(const char* value, size_t size);
  ::std::string* mutable_img_preview_url();
  ::std::string* release_img_preview_url();
  void set_allocated_img_preview_url(::std::string* img_preview_url);

  // optional string anchor_tag = 15;
  bool has_anchor_tag() const;
  void clear_anchor_tag();
  static const int kAnchorTagFieldNumber = 15;
  const ::std::string& anchor_tag() const;
  void set_anchor_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_anchor_tag(::std::string&& value);
  #endif
  void set_anchor_tag(const char* value);
  void set_anchor_tag(const char* value, size_t size);
  ::std::string* mutable_anchor_tag();
  ::std::string* release_anchor_tag();
  void set_allocated_anchor_tag(::std::string* anchor_tag);

  // optional uint64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // optional .TapeDocument.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::TapeDocument_Type type() const;
  void set_type(::TapeDocument_Type value);

  // optional int32 img_width = 12;
  bool has_img_width() const;
  void clear_img_width();
  static const int kImgWidthFieldNumber = 12;
  ::google::protobuf::int32 img_width() const;
  void set_img_width(::google::protobuf::int32 value);

  // optional int32 img_height = 13;
  bool has_img_height() const;
  void clear_img_height();
  static const int kImgHeightFieldNumber = 13;
  ::google::protobuf::int32 img_height() const;
  void set_img_height(::google::protobuf::int32 value);

  // optional float rank = 14;
  bool has_rank() const;
  void clear_rank();
  static const int kRankFieldNumber = 14;
  float rank() const;
  void set_rank(float value);

  // @@protoc_insertion_point(class_scope:TapeDocument)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_type();
  void clear_has_type();
  void set_has_anchor();
  void clear_has_anchor();
  void set_has_text1();
  void clear_has_text1();
  void set_has_text2();
  void clear_has_text2();
  void set_has_keywords();
  void clear_has_keywords();
  void set_has_page_title();
  void clear_has_page_title();
  void set_has_h_text();
  void clear_has_h_text();
  void set_has_dest_url();
  void clear_has_dest_url();
  void set_has_img_url();
  void clear_has_img_url();
  void set_has_img_preview_url();
  void clear_has_img_preview_url();
  void set_has_img_width();
  void clear_has_img_width();
  void set_has_img_height();
  void clear_has_img_height();
  void set_has_rank();
  void clear_has_rank();
  void set_has_anchor_tag();
  void clear_has_anchor_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TapeDocument_Tag > tags_;
  ::google::protobuf::internal::ArenaStringPtr anchor_;
  ::google::protobuf::internal::ArenaStringPtr text1_;
  ::google::protobuf::internal::ArenaStringPtr text2_;
  ::google::protobuf::internal::ArenaStringPtr keywords_;
  ::google::protobuf::internal::ArenaStringPtr page_title_;
  ::google::protobuf::internal::ArenaStringPtr h_text_;
  ::google::protobuf::internal::ArenaStringPtr dest_url_;
  ::google::protobuf::internal::ArenaStringPtr img_url_;
  ::google::protobuf::internal::ArenaStringPtr img_preview_url_;
  ::google::protobuf::internal::ArenaStringPtr anchor_tag_;
  ::google::protobuf::uint64 id_;
  int type_;
  ::google::protobuf::int32 img_width_;
  ::google::protobuf::int32 img_height_;
  float rank_;
  friend struct protobuf_taped_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TagRecommendation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TagRecommendation) */ {
 public:
  TagRecommendation();
  virtual ~TagRecommendation();

  TagRecommendation(const TagRecommendation& from);

  inline TagRecommendation& operator=(const TagRecommendation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TagRecommendation(TagRecommendation&& from) noexcept
    : TagRecommendation() {
    *this = ::std::move(from);
  }

  inline TagRecommendation& operator=(TagRecommendation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TagRecommendation& default_instance();

  static inline const TagRecommendation* internal_default_instance() {
    return reinterpret_cast<const TagRecommendation*>(
               &_TagRecommendation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(TagRecommendation* other);
  friend void swap(TagRecommendation& a, TagRecommendation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TagRecommendation* New() const PROTOBUF_FINAL { return New(NULL); }

  TagRecommendation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TagRecommendation& from);
  void MergeFrom(const TagRecommendation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TagRecommendation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint64 tag_hash = 1;
  bool has_tag_hash() const;
  void clear_tag_hash();
  static const int kTagHashFieldNumber = 1;
  ::google::protobuf::uint64 tag_hash() const;
  void set_tag_hash(::google::protobuf::uint64 value);

  // optional float rank = 2;
  bool has_rank() const;
  void clear_rank();
  static const int kRankFieldNumber = 2;
  float rank() const;
  void set_rank(float value);

  // @@protoc_insertion_point(class_scope:TagRecommendation)
 private:
  void set_has_tag_hash();
  void clear_has_tag_hash();
  void set_has_rank();
  void clear_has_rank();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 tag_hash_;
  float rank_;
  friend struct protobuf_taped_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TagRecommendations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TagRecommendations) */ {
 public:
  TagRecommendations();
  virtual ~TagRecommendations();

  TagRecommendations(const TagRecommendations& from);

  inline TagRecommendations& operator=(const TagRecommendations& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TagRecommendations(TagRecommendations&& from) noexcept
    : TagRecommendations() {
    *this = ::std::move(from);
  }

  inline TagRecommendations& operator=(TagRecommendations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TagRecommendations& default_instance();

  static inline const TagRecommendations* internal_default_instance() {
    return reinterpret_cast<const TagRecommendations*>(
               &_TagRecommendations_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TagRecommendations* other);
  friend void swap(TagRecommendations& a, TagRecommendations& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TagRecommendations* New() const PROTOBUF_FINAL { return New(NULL); }

  TagRecommendations* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TagRecommendations& from);
  void MergeFrom(const TagRecommendations& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TagRecommendations* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TagRecommendation recos = 1;
  int recos_size() const;
  void clear_recos();
  static const int kRecosFieldNumber = 1;
  const ::TagRecommendation& recos(int index) const;
  ::TagRecommendation* mutable_recos(int index);
  ::TagRecommendation* add_recos();
  ::google::protobuf::RepeatedPtrField< ::TagRecommendation >*
      mutable_recos();
  const ::google::protobuf::RepeatedPtrField< ::TagRecommendation >&
      recos() const;

  // @@protoc_insertion_point(class_scope:TagRecommendations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TagRecommendation > recos_;
  friend struct protobuf_taped_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserRecommendation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UserRecommendation) */ {
 public:
  UserRecommendation();
  virtual ~UserRecommendation();

  UserRecommendation(const UserRecommendation& from);

  inline UserRecommendation& operator=(const UserRecommendation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRecommendation(UserRecommendation&& from) noexcept
    : UserRecommendation() {
    *this = ::std::move(from);
  }

  inline UserRecommendation& operator=(UserRecommendation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRecommendation& default_instance();

  static inline const UserRecommendation* internal_default_instance() {
    return reinterpret_cast<const UserRecommendation*>(
               &_UserRecommendation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(UserRecommendation* other);
  friend void swap(UserRecommendation& a, UserRecommendation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRecommendation* New() const PROTOBUF_FINAL { return New(NULL); }

  UserRecommendation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserRecommendation& from);
  void MergeFrom(const UserRecommendation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserRecommendation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional .TagRecommendations anchor_reco = 2;
  bool has_anchor_reco() const;
  void clear_anchor_reco();
  static const int kAnchorRecoFieldNumber = 2;
  const ::TagRecommendations& anchor_reco() const;
  ::TagRecommendations* mutable_anchor_reco();
  ::TagRecommendations* release_anchor_reco();
  void set_allocated_anchor_reco(::TagRecommendations* anchor_reco);

  // optional .TagRecommendations connected_reco = 3;
  bool has_connected_reco() const;
  void clear_connected_reco();
  static const int kConnectedRecoFieldNumber = 3;
  const ::TagRecommendations& connected_reco() const;
  ::TagRecommendations* mutable_connected_reco();
  ::TagRecommendations* release_connected_reco();
  void set_allocated_connected_reco(::TagRecommendations* connected_reco);

  // optional .TagRecommendations connected_weighted_reco = 4;
  bool has_connected_weighted_reco() const;
  void clear_connected_weighted_reco();
  static const int kConnectedWeightedRecoFieldNumber = 4;
  const ::TagRecommendations& connected_weighted_reco() const;
  ::TagRecommendations* mutable_connected_weighted_reco();
  ::TagRecommendations* release_connected_weighted_reco();
  void set_allocated_connected_weighted_reco(::TagRecommendations* connected_weighted_reco);

  // @@protoc_insertion_point(class_scope:UserRecommendation)
 private:
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_anchor_reco();
  void clear_has_anchor_reco();
  void set_has_connected_reco();
  void clear_has_connected_reco();
  void set_has_connected_weighted_reco();
  void clear_has_connected_weighted_reco();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::TagRecommendations* anchor_reco_;
  ::TagRecommendations* connected_reco_;
  ::TagRecommendations* connected_weighted_reco_;
  friend struct protobuf_taped_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TapeDocument_Tag

// optional string text = 1;
inline bool TapeDocument_Tag::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TapeDocument_Tag::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TapeDocument_Tag::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TapeDocument_Tag::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& TapeDocument_Tag::text() const {
  // @@protoc_insertion_point(field_get:TapeDocument.Tag.text)
  return text_.GetNoArena();
}
inline void TapeDocument_Tag::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TapeDocument.Tag.text)
}
#if LANG_CXX11
inline void TapeDocument_Tag::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TapeDocument.Tag.text)
}
#endif
inline void TapeDocument_Tag::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TapeDocument.Tag.text)
}
inline void TapeDocument_Tag::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TapeDocument.Tag.text)
}
inline ::std::string* TapeDocument_Tag::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:TapeDocument.Tag.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TapeDocument_Tag::release_text() {
  // @@protoc_insertion_point(field_release:TapeDocument.Tag.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TapeDocument_Tag::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:TapeDocument.Tag.text)
}

// optional int32 freq = 2;
inline bool TapeDocument_Tag::has_freq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TapeDocument_Tag::set_has_freq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TapeDocument_Tag::clear_has_freq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TapeDocument_Tag::clear_freq() {
  freq_ = 0;
  clear_has_freq();
}
inline ::google::protobuf::int32 TapeDocument_Tag::freq() const {
  // @@protoc_insertion_point(field_get:TapeDocument.Tag.freq)
  return freq_;
}
inline void TapeDocument_Tag::set_freq(::google::protobuf::int32 value) {
  set_has_freq();
  freq_ = value;
  // @@protoc_insertion_point(field_set:TapeDocument.Tag.freq)
}

// optional int32 pos = 3;
inline bool TapeDocument_Tag::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TapeDocument_Tag::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TapeDocument_Tag::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TapeDocument_Tag::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 TapeDocument_Tag::pos() const {
  // @@protoc_insertion_point(field_get:TapeDocument.Tag.pos)
  return pos_;
}
inline void TapeDocument_Tag::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
  // @@protoc_insertion_point(field_set:TapeDocument.Tag.pos)
}

// -------------------------------------------------------------------

// TapeDocument

// optional uint64 id = 1;
inline bool TapeDocument::has_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TapeDocument::set_has_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TapeDocument::clear_has_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TapeDocument::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 TapeDocument::id() const {
  // @@protoc_insertion_point(field_get:TapeDocument.id)
  return id_;
}
inline void TapeDocument::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:TapeDocument.id)
}

// optional .TapeDocument.Type type = 2;
inline bool TapeDocument::has_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TapeDocument::set_has_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TapeDocument::clear_has_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TapeDocument::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TapeDocument_Type TapeDocument::type() const {
  // @@protoc_insertion_point(field_get:TapeDocument.type)
  return static_cast< ::TapeDocument_Type >(type_);
}
inline void TapeDocument::set_type(::TapeDocument_Type value) {
  assert(::TapeDocument_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TapeDocument.type)
}

// optional string anchor = 3;
inline bool TapeDocument::has_anchor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TapeDocument::set_has_anchor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TapeDocument::clear_has_anchor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TapeDocument::clear_anchor() {
  anchor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_anchor();
}
inline const ::std::string& TapeDocument::anchor() const {
  // @@protoc_insertion_point(field_get:TapeDocument.anchor)
  return anchor_.GetNoArena();
}
inline void TapeDocument::set_anchor(const ::std::string& value) {
  set_has_anchor();
  anchor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TapeDocument.anchor)
}
#if LANG_CXX11
inline void TapeDocument::set_anchor(::std::string&& value) {
  set_has_anchor();
  anchor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TapeDocument.anchor)
}
#endif
inline void TapeDocument::set_anchor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_anchor();
  anchor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TapeDocument.anchor)
}
inline void TapeDocument::set_anchor(const char* value, size_t size) {
  set_has_anchor();
  anchor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TapeDocument.anchor)
}
inline ::std::string* TapeDocument::mutable_anchor() {
  set_has_anchor();
  // @@protoc_insertion_point(field_mutable:TapeDocument.anchor)
  return anchor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TapeDocument::release_anchor() {
  // @@protoc_insertion_point(field_release:TapeDocument.anchor)
  clear_has_anchor();
  return anchor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TapeDocument::set_allocated_anchor(::std::string* anchor) {
  if (anchor != NULL) {
    set_has_anchor();
  } else {
    clear_has_anchor();
  }
  anchor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), anchor);
  // @@protoc_insertion_point(field_set_allocated:TapeDocument.anchor)
}

// optional string text1 = 4;
inline bool TapeDocument::has_text1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TapeDocument::set_has_text1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TapeDocument::clear_has_text1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TapeDocument::clear_text1() {
  text1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text1();
}
inline const ::std::string& TapeDocument::text1() const {
  // @@protoc_insertion_point(field_get:TapeDocument.text1)
  return text1_.GetNoArena();
}
inline void TapeDocument::set_text1(const ::std::string& value) {
  set_has_text1();
  text1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TapeDocument.text1)
}
#if LANG_CXX11
inline void TapeDocument::set_text1(::std::string&& value) {
  set_has_text1();
  text1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TapeDocument.text1)
}
#endif
inline void TapeDocument::set_text1(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text1();
  text1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TapeDocument.text1)
}
inline void TapeDocument::set_text1(const char* value, size_t size) {
  set_has_text1();
  text1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TapeDocument.text1)
}
inline ::std::string* TapeDocument::mutable_text1() {
  set_has_text1();
  // @@protoc_insertion_point(field_mutable:TapeDocument.text1)
  return text1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TapeDocument::release_text1() {
  // @@protoc_insertion_point(field_release:TapeDocument.text1)
  clear_has_text1();
  return text1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TapeDocument::set_allocated_text1(::std::string* text1) {
  if (text1 != NULL) {
    set_has_text1();
  } else {
    clear_has_text1();
  }
  text1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text1);
  // @@protoc_insertion_point(field_set_allocated:TapeDocument.text1)
}

// optional string text2 = 5;
inline bool TapeDocument::has_text2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TapeDocument::set_has_text2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TapeDocument::clear_has_text2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TapeDocument::clear_text2() {
  text2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text2();
}
inline const ::std::string& TapeDocument::text2() const {
  // @@protoc_insertion_point(field_get:TapeDocument.text2)
  return text2_.GetNoArena();
}
inline void TapeDocument::set_text2(const ::std::string& value) {
  set_has_text2();
  text2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TapeDocument.text2)
}
#if LANG_CXX11
inline void TapeDocument::set_text2(::std::string&& value) {
  set_has_text2();
  text2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TapeDocument.text2)
}
#endif
inline void TapeDocument::set_text2(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text2();
  text2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TapeDocument.text2)
}
inline void TapeDocument::set_text2(const char* value, size_t size) {
  set_has_text2();
  text2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TapeDocument.text2)
}
inline ::std::string* TapeDocument::mutable_text2() {
  set_has_text2();
  // @@protoc_insertion_point(field_mutable:TapeDocument.text2)
  return text2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TapeDocument::release_text2() {
  // @@protoc_insertion_point(field_release:TapeDocument.text2)
  clear_has_text2();
  return text2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TapeDocument::set_allocated_text2(::std::string* text2) {
  if (text2 != NULL) {
    set_has_text2();
  } else {
    clear_has_text2();
  }
  text2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text2);
  // @@protoc_insertion_point(field_set_allocated:TapeDocument.text2)
}

// optional string keywords = 6;
inline bool TapeDocument::has_keywords() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TapeDocument::set_has_keywords() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TapeDocument::clear_has_keywords() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TapeDocument::clear_keywords() {
  keywords_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keywords();
}
inline const ::std::string& TapeDocument::keywords() const {
  // @@protoc_insertion_point(field_get:TapeDocument.keywords)
  return keywords_.GetNoArena();
}
inline void TapeDocument::set_keywords(const ::std::string& value) {
  set_has_keywords();
  keywords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TapeDocument.keywords)
}
#if LANG_CXX11
inline void TapeDocument::set_keywords(::std::string&& value) {
  set_has_keywords();
  keywords_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TapeDocument.keywords)
}
#endif
inline void TapeDocument::set_keywords(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keywords();
  keywords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TapeDocument.keywords)
}
inline void TapeDocument::set_keywords(const char* value, size_t size) {
  set_has_keywords();
  keywords_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TapeDocument.keywords)
}
inline ::std::string* TapeDocument::mutable_keywords() {
  set_has_keywords();
  // @@protoc_insertion_point(field_mutable:TapeDocument.keywords)
  return keywords_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TapeDocument::release_keywords() {
  // @@protoc_insertion_point(field_release:TapeDocument.keywords)
  clear_has_keywords();
  return keywords_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TapeDocument::set_allocated_keywords(::std::string* keywords) {
  if (keywords != NULL) {
    set_has_keywords();
  } else {
    clear_has_keywords();
  }
  keywords_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keywords);
  // @@protoc_insertion_point(field_set_allocated:TapeDocument.keywords)
}

// optional string page_title = 7;
inline bool TapeDocument::has_page_title() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TapeDocument::set_has_page_title() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TapeDocument::clear_has_page_title() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TapeDocument::clear_page_title() {
  page_title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_page_title();
}
inline const ::std::string& TapeDocument::page_title() const {
  // @@protoc_insertion_point(field_get:TapeDocument.page_title)
  return page_title_.GetNoArena();
}
inline void TapeDocument::set_page_title(const ::std::string& value) {
  set_has_page_title();
  page_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TapeDocument.page_title)
}
#if LANG_CXX11
inline void TapeDocument::set_page_title(::std::string&& value) {
  set_has_page_title();
  page_title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TapeDocument.page_title)
}
#endif
inline void TapeDocument::set_page_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_page_title();
  page_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TapeDocument.page_title)
}
inline void TapeDocument::set_page_title(const char* value, size_t size) {
  set_has_page_title();
  page_title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TapeDocument.page_title)
}
inline ::std::string* TapeDocument::mutable_page_title() {
  set_has_page_title();
  // @@protoc_insertion_point(field_mutable:TapeDocument.page_title)
  return page_title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TapeDocument::release_page_title() {
  // @@protoc_insertion_point(field_release:TapeDocument.page_title)
  clear_has_page_title();
  return page_title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TapeDocument::set_allocated_page_title(::std::string* page_title) {
  if (page_title != NULL) {
    set_has_page_title();
  } else {
    clear_has_page_title();
  }
  page_title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), page_title);
  // @@protoc_insertion_point(field_set_allocated:TapeDocument.page_title)
}

// optional string h_text = 8;
inline bool TapeDocument::has_h_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TapeDocument::set_has_h_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TapeDocument::clear_has_h_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TapeDocument::clear_h_text() {
  h_text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_h_text();
}
inline const ::std::string& TapeDocument::h_text() const {
  // @@protoc_insertion_point(field_get:TapeDocument.h_text)
  return h_text_.GetNoArena();
}
inline void TapeDocument::set_h_text(const ::std::string& value) {
  set_has_h_text();
  h_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TapeDocument.h_text)
}
#if LANG_CXX11
inline void TapeDocument::set_h_text(::std::string&& value) {
  set_has_h_text();
  h_text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TapeDocument.h_text)
}
#endif
inline void TapeDocument::set_h_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_h_text();
  h_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TapeDocument.h_text)
}
inline void TapeDocument::set_h_text(const char* value, size_t size) {
  set_has_h_text();
  h_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TapeDocument.h_text)
}
inline ::std::string* TapeDocument::mutable_h_text() {
  set_has_h_text();
  // @@protoc_insertion_point(field_mutable:TapeDocument.h_text)
  return h_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TapeDocument::release_h_text() {
  // @@protoc_insertion_point(field_release:TapeDocument.h_text)
  clear_has_h_text();
  return h_text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TapeDocument::set_allocated_h_text(::std::string* h_text) {
  if (h_text != NULL) {
    set_has_h_text();
  } else {
    clear_has_h_text();
  }
  h_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), h_text);
  // @@protoc_insertion_point(field_set_allocated:TapeDocument.h_text)
}

// optional string dest_url = 9;
inline bool TapeDocument::has_dest_url() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TapeDocument::set_has_dest_url() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TapeDocument::clear_has_dest_url() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TapeDocument::clear_dest_url() {
  dest_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dest_url();
}
inline const ::std::string& TapeDocument::dest_url() const {
  // @@protoc_insertion_point(field_get:TapeDocument.dest_url)
  return dest_url_.GetNoArena();
}
inline void TapeDocument::set_dest_url(const ::std::string& value) {
  set_has_dest_url();
  dest_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TapeDocument.dest_url)
}
#if LANG_CXX11
inline void TapeDocument::set_dest_url(::std::string&& value) {
  set_has_dest_url();
  dest_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TapeDocument.dest_url)
}
#endif
inline void TapeDocument::set_dest_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dest_url();
  dest_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TapeDocument.dest_url)
}
inline void TapeDocument::set_dest_url(const char* value, size_t size) {
  set_has_dest_url();
  dest_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TapeDocument.dest_url)
}
inline ::std::string* TapeDocument::mutable_dest_url() {
  set_has_dest_url();
  // @@protoc_insertion_point(field_mutable:TapeDocument.dest_url)
  return dest_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TapeDocument::release_dest_url() {
  // @@protoc_insertion_point(field_release:TapeDocument.dest_url)
  clear_has_dest_url();
  return dest_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TapeDocument::set_allocated_dest_url(::std::string* dest_url) {
  if (dest_url != NULL) {
    set_has_dest_url();
  } else {
    clear_has_dest_url();
  }
  dest_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_url);
  // @@protoc_insertion_point(field_set_allocated:TapeDocument.dest_url)
}

// optional string img_url = 10;
inline bool TapeDocument::has_img_url() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TapeDocument::set_has_img_url() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TapeDocument::clear_has_img_url() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TapeDocument::clear_img_url() {
  img_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_img_url();
}
inline const ::std::string& TapeDocument::img_url() const {
  // @@protoc_insertion_point(field_get:TapeDocument.img_url)
  return img_url_.GetNoArena();
}
inline void TapeDocument::set_img_url(const ::std::string& value) {
  set_has_img_url();
  img_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TapeDocument.img_url)
}
#if LANG_CXX11
inline void TapeDocument::set_img_url(::std::string&& value) {
  set_has_img_url();
  img_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TapeDocument.img_url)
}
#endif
inline void TapeDocument::set_img_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_img_url();
  img_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TapeDocument.img_url)
}
inline void TapeDocument::set_img_url(const char* value, size_t size) {
  set_has_img_url();
  img_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TapeDocument.img_url)
}
inline ::std::string* TapeDocument::mutable_img_url() {
  set_has_img_url();
  // @@protoc_insertion_point(field_mutable:TapeDocument.img_url)
  return img_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TapeDocument::release_img_url() {
  // @@protoc_insertion_point(field_release:TapeDocument.img_url)
  clear_has_img_url();
  return img_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TapeDocument::set_allocated_img_url(::std::string* img_url) {
  if (img_url != NULL) {
    set_has_img_url();
  } else {
    clear_has_img_url();
  }
  img_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), img_url);
  // @@protoc_insertion_point(field_set_allocated:TapeDocument.img_url)
}

// optional string img_preview_url = 11;
inline bool TapeDocument::has_img_preview_url() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TapeDocument::set_has_img_preview_url() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TapeDocument::clear_has_img_preview_url() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TapeDocument::clear_img_preview_url() {
  img_preview_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_img_preview_url();
}
inline const ::std::string& TapeDocument::img_preview_url() const {
  // @@protoc_insertion_point(field_get:TapeDocument.img_preview_url)
  return img_preview_url_.GetNoArena();
}
inline void TapeDocument::set_img_preview_url(const ::std::string& value) {
  set_has_img_preview_url();
  img_preview_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TapeDocument.img_preview_url)
}
#if LANG_CXX11
inline void TapeDocument::set_img_preview_url(::std::string&& value) {
  set_has_img_preview_url();
  img_preview_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TapeDocument.img_preview_url)
}
#endif
inline void TapeDocument::set_img_preview_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_img_preview_url();
  img_preview_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TapeDocument.img_preview_url)
}
inline void TapeDocument::set_img_preview_url(const char* value, size_t size) {
  set_has_img_preview_url();
  img_preview_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TapeDocument.img_preview_url)
}
inline ::std::string* TapeDocument::mutable_img_preview_url() {
  set_has_img_preview_url();
  // @@protoc_insertion_point(field_mutable:TapeDocument.img_preview_url)
  return img_preview_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TapeDocument::release_img_preview_url() {
  // @@protoc_insertion_point(field_release:TapeDocument.img_preview_url)
  clear_has_img_preview_url();
  return img_preview_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TapeDocument::set_allocated_img_preview_url(::std::string* img_preview_url) {
  if (img_preview_url != NULL) {
    set_has_img_preview_url();
  } else {
    clear_has_img_preview_url();
  }
  img_preview_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), img_preview_url);
  // @@protoc_insertion_point(field_set_allocated:TapeDocument.img_preview_url)
}

// optional int32 img_width = 12;
inline bool TapeDocument::has_img_width() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TapeDocument::set_has_img_width() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TapeDocument::clear_has_img_width() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TapeDocument::clear_img_width() {
  img_width_ = 0;
  clear_has_img_width();
}
inline ::google::protobuf::int32 TapeDocument::img_width() const {
  // @@protoc_insertion_point(field_get:TapeDocument.img_width)
  return img_width_;
}
inline void TapeDocument::set_img_width(::google::protobuf::int32 value) {
  set_has_img_width();
  img_width_ = value;
  // @@protoc_insertion_point(field_set:TapeDocument.img_width)
}

// optional int32 img_height = 13;
inline bool TapeDocument::has_img_height() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TapeDocument::set_has_img_height() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TapeDocument::clear_has_img_height() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TapeDocument::clear_img_height() {
  img_height_ = 0;
  clear_has_img_height();
}
inline ::google::protobuf::int32 TapeDocument::img_height() const {
  // @@protoc_insertion_point(field_get:TapeDocument.img_height)
  return img_height_;
}
inline void TapeDocument::set_img_height(::google::protobuf::int32 value) {
  set_has_img_height();
  img_height_ = value;
  // @@protoc_insertion_point(field_set:TapeDocument.img_height)
}

// optional float rank = 14;
inline bool TapeDocument::has_rank() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TapeDocument::set_has_rank() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TapeDocument::clear_has_rank() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TapeDocument::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline float TapeDocument::rank() const {
  // @@protoc_insertion_point(field_get:TapeDocument.rank)
  return rank_;
}
inline void TapeDocument::set_rank(float value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:TapeDocument.rank)
}

// optional string anchor_tag = 15;
inline bool TapeDocument::has_anchor_tag() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TapeDocument::set_has_anchor_tag() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TapeDocument::clear_has_anchor_tag() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TapeDocument::clear_anchor_tag() {
  anchor_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_anchor_tag();
}
inline const ::std::string& TapeDocument::anchor_tag() const {
  // @@protoc_insertion_point(field_get:TapeDocument.anchor_tag)
  return anchor_tag_.GetNoArena();
}
inline void TapeDocument::set_anchor_tag(const ::std::string& value) {
  set_has_anchor_tag();
  anchor_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TapeDocument.anchor_tag)
}
#if LANG_CXX11
inline void TapeDocument::set_anchor_tag(::std::string&& value) {
  set_has_anchor_tag();
  anchor_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TapeDocument.anchor_tag)
}
#endif
inline void TapeDocument::set_anchor_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_anchor_tag();
  anchor_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TapeDocument.anchor_tag)
}
inline void TapeDocument::set_anchor_tag(const char* value, size_t size) {
  set_has_anchor_tag();
  anchor_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TapeDocument.anchor_tag)
}
inline ::std::string* TapeDocument::mutable_anchor_tag() {
  set_has_anchor_tag();
  // @@protoc_insertion_point(field_mutable:TapeDocument.anchor_tag)
  return anchor_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TapeDocument::release_anchor_tag() {
  // @@protoc_insertion_point(field_release:TapeDocument.anchor_tag)
  clear_has_anchor_tag();
  return anchor_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TapeDocument::set_allocated_anchor_tag(::std::string* anchor_tag) {
  if (anchor_tag != NULL) {
    set_has_anchor_tag();
  } else {
    clear_has_anchor_tag();
  }
  anchor_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), anchor_tag);
  // @@protoc_insertion_point(field_set_allocated:TapeDocument.anchor_tag)
}

// repeated .TapeDocument.Tag tags = 16;
inline int TapeDocument::tags_size() const {
  return tags_.size();
}
inline void TapeDocument::clear_tags() {
  tags_.Clear();
}
inline const ::TapeDocument_Tag& TapeDocument::tags(int index) const {
  // @@protoc_insertion_point(field_get:TapeDocument.tags)
  return tags_.Get(index);
}
inline ::TapeDocument_Tag* TapeDocument::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:TapeDocument.tags)
  return tags_.Mutable(index);
}
inline ::TapeDocument_Tag* TapeDocument::add_tags() {
  // @@protoc_insertion_point(field_add:TapeDocument.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TapeDocument_Tag >*
TapeDocument::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:TapeDocument.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TapeDocument_Tag >&
TapeDocument::tags() const {
  // @@protoc_insertion_point(field_list:TapeDocument.tags)
  return tags_;
}

// -------------------------------------------------------------------

// TagRecommendation

// optional uint64 tag_hash = 1;
inline bool TagRecommendation::has_tag_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TagRecommendation::set_has_tag_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TagRecommendation::clear_has_tag_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TagRecommendation::clear_tag_hash() {
  tag_hash_ = GOOGLE_ULONGLONG(0);
  clear_has_tag_hash();
}
inline ::google::protobuf::uint64 TagRecommendation::tag_hash() const {
  // @@protoc_insertion_point(field_get:TagRecommendation.tag_hash)
  return tag_hash_;
}
inline void TagRecommendation::set_tag_hash(::google::protobuf::uint64 value) {
  set_has_tag_hash();
  tag_hash_ = value;
  // @@protoc_insertion_point(field_set:TagRecommendation.tag_hash)
}

// optional float rank = 2;
inline bool TagRecommendation::has_rank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TagRecommendation::set_has_rank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TagRecommendation::clear_has_rank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TagRecommendation::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline float TagRecommendation::rank() const {
  // @@protoc_insertion_point(field_get:TagRecommendation.rank)
  return rank_;
}
inline void TagRecommendation::set_rank(float value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:TagRecommendation.rank)
}

// optional string name = 3;
inline bool TagRecommendation::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TagRecommendation::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TagRecommendation::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TagRecommendation::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TagRecommendation::name() const {
  // @@protoc_insertion_point(field_get:TagRecommendation.name)
  return name_.GetNoArena();
}
inline void TagRecommendation::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TagRecommendation.name)
}
#if LANG_CXX11
inline void TagRecommendation::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TagRecommendation.name)
}
#endif
inline void TagRecommendation::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TagRecommendation.name)
}
inline void TagRecommendation::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TagRecommendation.name)
}
inline ::std::string* TagRecommendation::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:TagRecommendation.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TagRecommendation::release_name() {
  // @@protoc_insertion_point(field_release:TagRecommendation.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TagRecommendation::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:TagRecommendation.name)
}

// -------------------------------------------------------------------

// TagRecommendations

// repeated .TagRecommendation recos = 1;
inline int TagRecommendations::recos_size() const {
  return recos_.size();
}
inline void TagRecommendations::clear_recos() {
  recos_.Clear();
}
inline const ::TagRecommendation& TagRecommendations::recos(int index) const {
  // @@protoc_insertion_point(field_get:TagRecommendations.recos)
  return recos_.Get(index);
}
inline ::TagRecommendation* TagRecommendations::mutable_recos(int index) {
  // @@protoc_insertion_point(field_mutable:TagRecommendations.recos)
  return recos_.Mutable(index);
}
inline ::TagRecommendation* TagRecommendations::add_recos() {
  // @@protoc_insertion_point(field_add:TagRecommendations.recos)
  return recos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TagRecommendation >*
TagRecommendations::mutable_recos() {
  // @@protoc_insertion_point(field_mutable_list:TagRecommendations.recos)
  return &recos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TagRecommendation >&
TagRecommendations::recos() const {
  // @@protoc_insertion_point(field_list:TagRecommendations.recos)
  return recos_;
}

// -------------------------------------------------------------------

// UserRecommendation

// optional string user_id = 1;
inline bool UserRecommendation::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRecommendation::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRecommendation::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRecommendation::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& UserRecommendation::user_id() const {
  // @@protoc_insertion_point(field_get:UserRecommendation.user_id)
  return user_id_.GetNoArena();
}
inline void UserRecommendation::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:UserRecommendation.user_id)
}
#if LANG_CXX11
inline void UserRecommendation::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:UserRecommendation.user_id)
}
#endif
inline void UserRecommendation::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:UserRecommendation.user_id)
}
inline void UserRecommendation::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:UserRecommendation.user_id)
}
inline ::std::string* UserRecommendation::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:UserRecommendation.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRecommendation::release_user_id() {
  // @@protoc_insertion_point(field_release:UserRecommendation.user_id)
  clear_has_user_id();
  return user_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRecommendation::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:UserRecommendation.user_id)
}

// optional .TagRecommendations anchor_reco = 2;
inline bool UserRecommendation::has_anchor_reco() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRecommendation::set_has_anchor_reco() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRecommendation::clear_has_anchor_reco() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRecommendation::clear_anchor_reco() {
  if (anchor_reco_ != NULL) anchor_reco_->::TagRecommendations::Clear();
  clear_has_anchor_reco();
}
inline const ::TagRecommendations& UserRecommendation::anchor_reco() const {
  const ::TagRecommendations* p = anchor_reco_;
  // @@protoc_insertion_point(field_get:UserRecommendation.anchor_reco)
  return p != NULL ? *p : *reinterpret_cast<const ::TagRecommendations*>(
      &::_TagRecommendations_default_instance_);
}
inline ::TagRecommendations* UserRecommendation::mutable_anchor_reco() {
  set_has_anchor_reco();
  if (anchor_reco_ == NULL) {
    anchor_reco_ = new ::TagRecommendations;
  }
  // @@protoc_insertion_point(field_mutable:UserRecommendation.anchor_reco)
  return anchor_reco_;
}
inline ::TagRecommendations* UserRecommendation::release_anchor_reco() {
  // @@protoc_insertion_point(field_release:UserRecommendation.anchor_reco)
  clear_has_anchor_reco();
  ::TagRecommendations* temp = anchor_reco_;
  anchor_reco_ = NULL;
  return temp;
}
inline void UserRecommendation::set_allocated_anchor_reco(::TagRecommendations* anchor_reco) {
  delete anchor_reco_;
  anchor_reco_ = anchor_reco;
  if (anchor_reco) {
    set_has_anchor_reco();
  } else {
    clear_has_anchor_reco();
  }
  // @@protoc_insertion_point(field_set_allocated:UserRecommendation.anchor_reco)
}

// optional .TagRecommendations connected_reco = 3;
inline bool UserRecommendation::has_connected_reco() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserRecommendation::set_has_connected_reco() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserRecommendation::clear_has_connected_reco() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserRecommendation::clear_connected_reco() {
  if (connected_reco_ != NULL) connected_reco_->::TagRecommendations::Clear();
  clear_has_connected_reco();
}
inline const ::TagRecommendations& UserRecommendation::connected_reco() const {
  const ::TagRecommendations* p = connected_reco_;
  // @@protoc_insertion_point(field_get:UserRecommendation.connected_reco)
  return p != NULL ? *p : *reinterpret_cast<const ::TagRecommendations*>(
      &::_TagRecommendations_default_instance_);
}
inline ::TagRecommendations* UserRecommendation::mutable_connected_reco() {
  set_has_connected_reco();
  if (connected_reco_ == NULL) {
    connected_reco_ = new ::TagRecommendations;
  }
  // @@protoc_insertion_point(field_mutable:UserRecommendation.connected_reco)
  return connected_reco_;
}
inline ::TagRecommendations* UserRecommendation::release_connected_reco() {
  // @@protoc_insertion_point(field_release:UserRecommendation.connected_reco)
  clear_has_connected_reco();
  ::TagRecommendations* temp = connected_reco_;
  connected_reco_ = NULL;
  return temp;
}
inline void UserRecommendation::set_allocated_connected_reco(::TagRecommendations* connected_reco) {
  delete connected_reco_;
  connected_reco_ = connected_reco;
  if (connected_reco) {
    set_has_connected_reco();
  } else {
    clear_has_connected_reco();
  }
  // @@protoc_insertion_point(field_set_allocated:UserRecommendation.connected_reco)
}

// optional .TagRecommendations connected_weighted_reco = 4;
inline bool UserRecommendation::has_connected_weighted_reco() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserRecommendation::set_has_connected_weighted_reco() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserRecommendation::clear_has_connected_weighted_reco() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserRecommendation::clear_connected_weighted_reco() {
  if (connected_weighted_reco_ != NULL) connected_weighted_reco_->::TagRecommendations::Clear();
  clear_has_connected_weighted_reco();
}
inline const ::TagRecommendations& UserRecommendation::connected_weighted_reco() const {
  const ::TagRecommendations* p = connected_weighted_reco_;
  // @@protoc_insertion_point(field_get:UserRecommendation.connected_weighted_reco)
  return p != NULL ? *p : *reinterpret_cast<const ::TagRecommendations*>(
      &::_TagRecommendations_default_instance_);
}
inline ::TagRecommendations* UserRecommendation::mutable_connected_weighted_reco() {
  set_has_connected_weighted_reco();
  if (connected_weighted_reco_ == NULL) {
    connected_weighted_reco_ = new ::TagRecommendations;
  }
  // @@protoc_insertion_point(field_mutable:UserRecommendation.connected_weighted_reco)
  return connected_weighted_reco_;
}
inline ::TagRecommendations* UserRecommendation::release_connected_weighted_reco() {
  // @@protoc_insertion_point(field_release:UserRecommendation.connected_weighted_reco)
  clear_has_connected_weighted_reco();
  ::TagRecommendations* temp = connected_weighted_reco_;
  connected_weighted_reco_ = NULL;
  return temp;
}
inline void UserRecommendation::set_allocated_connected_weighted_reco(::TagRecommendations* connected_weighted_reco) {
  delete connected_weighted_reco_;
  connected_weighted_reco_ = connected_weighted_reco;
  if (connected_weighted_reco) {
    set_has_connected_weighted_reco();
  } else {
    clear_has_connected_weighted_reco();
  }
  // @@protoc_insertion_point(field_set_allocated:UserRecommendation.connected_weighted_reco)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::TapeDocument_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TapeDocument_Type>() {
  return ::TapeDocument_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_taped_2eproto__INCLUDED
