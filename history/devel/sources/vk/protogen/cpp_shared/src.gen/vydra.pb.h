// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vydra.proto

#ifndef PROTOBUF_vydra_2eproto__INCLUDED
#define PROTOBUF_vydra_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "silicon_data.pb.h"
// @@protoc_insertion_point(includes)
namespace ru {
namespace mail {
namespace go {
namespace vydra {
namespace data {
class VydraResultDoc;
class VydraResultDocDefaultTypeInternal;
extern VydraResultDocDefaultTypeInternal _VydraResultDoc_default_instance_;
class VydraResultInfo;
class VydraResultInfoDefaultTypeInternal;
extern VydraResultInfoDefaultTypeInternal _VydraResultInfo_default_instance_;
class VydraSourceDoc;
class VydraSourceDocDefaultTypeInternal;
extern VydraSourceDocDefaultTypeInternal _VydraSourceDoc_default_instance_;
}  // namespace data
}  // namespace vydra
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace ru {
namespace mail {
namespace go {
namespace vydra {
namespace data {

namespace protobuf_vydra_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_vydra_2eproto

enum VydraSourceDoc_Type {
  VydraSourceDoc_Type_HTML = 0,
  VydraSourceDoc_Type_AMP_HTML = 1
};
bool VydraSourceDoc_Type_IsValid(int value);
const VydraSourceDoc_Type VydraSourceDoc_Type_Type_MIN = VydraSourceDoc_Type_HTML;
const VydraSourceDoc_Type VydraSourceDoc_Type_Type_MAX = VydraSourceDoc_Type_AMP_HTML;
const int VydraSourceDoc_Type_Type_ARRAYSIZE = VydraSourceDoc_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* VydraSourceDoc_Type_descriptor();
inline const ::std::string& VydraSourceDoc_Type_Name(VydraSourceDoc_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    VydraSourceDoc_Type_descriptor(), value);
}
inline bool VydraSourceDoc_Type_Parse(
    const ::std::string& name, VydraSourceDoc_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VydraSourceDoc_Type>(
    VydraSourceDoc_Type_descriptor(), name, value);
}
enum VydraResultStatus {
  OK = 0,
  FAIL = 1,
  NO_PARSER = 2,
  INVALID_INPUT = 3,
  INPUT_TOO_LONG = 4,
  INVALID_SOURCE_URL = 5,
  BANNED_URL = 6,
  BAD_DOC_TYPE = 7
};
bool VydraResultStatus_IsValid(int value);
const VydraResultStatus VydraResultStatus_MIN = OK;
const VydraResultStatus VydraResultStatus_MAX = BAD_DOC_TYPE;
const int VydraResultStatus_ARRAYSIZE = VydraResultStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* VydraResultStatus_descriptor();
inline const ::std::string& VydraResultStatus_Name(VydraResultStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    VydraResultStatus_descriptor(), value);
}
inline bool VydraResultStatus_Parse(
    const ::std::string& name, VydraResultStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VydraResultStatus>(
    VydraResultStatus_descriptor(), name, value);
}
// ===================================================================

class VydraSourceDoc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.vydra.data.VydraSourceDoc) */ {
 public:
  VydraSourceDoc();
  virtual ~VydraSourceDoc();

  VydraSourceDoc(const VydraSourceDoc& from);

  inline VydraSourceDoc& operator=(const VydraSourceDoc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VydraSourceDoc(VydraSourceDoc&& from) noexcept
    : VydraSourceDoc() {
    *this = ::std::move(from);
  }

  inline VydraSourceDoc& operator=(VydraSourceDoc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VydraSourceDoc& default_instance();

  static inline const VydraSourceDoc* internal_default_instance() {
    return reinterpret_cast<const VydraSourceDoc*>(
               &_VydraSourceDoc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(VydraSourceDoc* other);
  friend void swap(VydraSourceDoc& a, VydraSourceDoc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VydraSourceDoc* New() const PROTOBUF_FINAL { return New(NULL); }

  VydraSourceDoc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VydraSourceDoc& from);
  void MergeFrom(const VydraSourceDoc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VydraSourceDoc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VydraSourceDoc_Type Type;
  static const Type HTML =
    VydraSourceDoc_Type_HTML;
  static const Type AMP_HTML =
    VydraSourceDoc_Type_AMP_HTML;
  static inline bool Type_IsValid(int value) {
    return VydraSourceDoc_Type_IsValid(value);
  }
  static const Type Type_MIN =
    VydraSourceDoc_Type_Type_MIN;
  static const Type Type_MAX =
    VydraSourceDoc_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    VydraSourceDoc_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return VydraSourceDoc_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return VydraSourceDoc_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return VydraSourceDoc_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required string html = 2;
  bool has_html() const;
  void clear_html();
  static const int kHtmlFieldNumber = 2;
  const ::std::string& html() const;
  void set_html(const ::std::string& value);
  #if LANG_CXX11
  void set_html(::std::string&& value);
  #endif
  void set_html(const char* value);
  void set_html(const char* value, size_t size);
  ::std::string* mutable_html();
  ::std::string* release_html();
  void set_allocated_html(::std::string* html);

  // optional .ru.mail.go.vydra.data.VydraSourceDoc.Type type = 3 [default = HTML];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::ru::mail::go::vydra::data::VydraSourceDoc_Type type() const;
  void set_type(::ru::mail::go::vydra::data::VydraSourceDoc_Type value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.vydra.data.VydraSourceDoc)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_html();
  void clear_has_html();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr html_;
  int type_;
  friend struct protobuf_vydra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VydraResultInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.vydra.data.VydraResultInfo) */ {
 public:
  VydraResultInfo();
  virtual ~VydraResultInfo();

  VydraResultInfo(const VydraResultInfo& from);

  inline VydraResultInfo& operator=(const VydraResultInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VydraResultInfo(VydraResultInfo&& from) noexcept
    : VydraResultInfo() {
    *this = ::std::move(from);
  }

  inline VydraResultInfo& operator=(VydraResultInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VydraResultInfo& default_instance();

  static inline const VydraResultInfo* internal_default_instance() {
    return reinterpret_cast<const VydraResultInfo*>(
               &_VydraResultInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(VydraResultInfo* other);
  friend void swap(VydraResultInfo& a, VydraResultInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VydraResultInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  VydraResultInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VydraResultInfo& from);
  void MergeFrom(const VydraResultInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VydraResultInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 layer_words_count = 1;
  bool has_layer_words_count() const;
  void clear_layer_words_count();
  static const int kLayerWordsCountFieldNumber = 1;
  ::google::protobuf::int32 layer_words_count() const;
  void set_layer_words_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.vydra.data.VydraResultInfo)
 private:
  void set_has_layer_words_count();
  void clear_has_layer_words_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 layer_words_count_;
  friend struct protobuf_vydra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VydraResultDoc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ru.mail.go.vydra.data.VydraResultDoc) */ {
 public:
  VydraResultDoc();
  virtual ~VydraResultDoc();

  VydraResultDoc(const VydraResultDoc& from);

  inline VydraResultDoc& operator=(const VydraResultDoc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VydraResultDoc(VydraResultDoc&& from) noexcept
    : VydraResultDoc() {
    *this = ::std::move(from);
  }

  inline VydraResultDoc& operator=(VydraResultDoc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VydraResultDoc& default_instance();

  static inline const VydraResultDoc* internal_default_instance() {
    return reinterpret_cast<const VydraResultDoc*>(
               &_VydraResultDoc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(VydraResultDoc* other);
  friend void swap(VydraResultDoc& a, VydraResultDoc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VydraResultDoc* New() const PROTOBUF_FINAL { return New(NULL); }

  VydraResultDoc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VydraResultDoc& from);
  void MergeFrom(const VydraResultDoc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VydraResultDoc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ru.mail.go.webbase.blobs.SiliconDocParserInfo siliconData = 2;
  bool has_silicondata() const;
  void clear_silicondata();
  static const int kSiliconDataFieldNumber = 2;
  const ::ru::mail::go::webbase::blobs::SiliconDocParserInfo& silicondata() const;
  ::ru::mail::go::webbase::blobs::SiliconDocParserInfo* mutable_silicondata();
  ::ru::mail::go::webbase::blobs::SiliconDocParserInfo* release_silicondata();
  void set_allocated_silicondata(::ru::mail::go::webbase::blobs::SiliconDocParserInfo* silicondata);

  // optional .ru.mail.go.vydra.data.VydraResultInfo info = 3;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 3;
  const ::ru::mail::go::vydra::data::VydraResultInfo& info() const;
  ::ru::mail::go::vydra::data::VydraResultInfo* mutable_info();
  ::ru::mail::go::vydra::data::VydraResultInfo* release_info();
  void set_allocated_info(::ru::mail::go::vydra::data::VydraResultInfo* info);

  // required .ru.mail.go.vydra.data.VydraResultStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::ru::mail::go::vydra::data::VydraResultStatus status() const;
  void set_status(::ru::mail::go::vydra::data::VydraResultStatus value);

  // @@protoc_insertion_point(class_scope:ru.mail.go.vydra.data.VydraResultDoc)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_silicondata();
  void clear_has_silicondata();
  void set_has_info();
  void clear_has_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::ru::mail::go::webbase::blobs::SiliconDocParserInfo* silicondata_;
  ::ru::mail::go::vydra::data::VydraResultInfo* info_;
  int status_;
  friend struct protobuf_vydra_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VydraSourceDoc

// required string url = 1;
inline bool VydraSourceDoc::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VydraSourceDoc::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VydraSourceDoc::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VydraSourceDoc::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& VydraSourceDoc::url() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.vydra.data.VydraSourceDoc.url)
  return url_.GetNoArena();
}
inline void VydraSourceDoc::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.vydra.data.VydraSourceDoc.url)
}
#if LANG_CXX11
inline void VydraSourceDoc::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.vydra.data.VydraSourceDoc.url)
}
#endif
inline void VydraSourceDoc::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.vydra.data.VydraSourceDoc.url)
}
inline void VydraSourceDoc::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.vydra.data.VydraSourceDoc.url)
}
inline ::std::string* VydraSourceDoc::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.vydra.data.VydraSourceDoc.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VydraSourceDoc::release_url() {
  // @@protoc_insertion_point(field_release:ru.mail.go.vydra.data.VydraSourceDoc.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VydraSourceDoc::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.vydra.data.VydraSourceDoc.url)
}

// required string html = 2;
inline bool VydraSourceDoc::has_html() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VydraSourceDoc::set_has_html() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VydraSourceDoc::clear_has_html() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VydraSourceDoc::clear_html() {
  html_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_html();
}
inline const ::std::string& VydraSourceDoc::html() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.vydra.data.VydraSourceDoc.html)
  return html_.GetNoArena();
}
inline void VydraSourceDoc::set_html(const ::std::string& value) {
  set_has_html();
  html_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ru.mail.go.vydra.data.VydraSourceDoc.html)
}
#if LANG_CXX11
inline void VydraSourceDoc::set_html(::std::string&& value) {
  set_has_html();
  html_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ru.mail.go.vydra.data.VydraSourceDoc.html)
}
#endif
inline void VydraSourceDoc::set_html(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_html();
  html_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ru.mail.go.vydra.data.VydraSourceDoc.html)
}
inline void VydraSourceDoc::set_html(const char* value, size_t size) {
  set_has_html();
  html_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ru.mail.go.vydra.data.VydraSourceDoc.html)
}
inline ::std::string* VydraSourceDoc::mutable_html() {
  set_has_html();
  // @@protoc_insertion_point(field_mutable:ru.mail.go.vydra.data.VydraSourceDoc.html)
  return html_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VydraSourceDoc::release_html() {
  // @@protoc_insertion_point(field_release:ru.mail.go.vydra.data.VydraSourceDoc.html)
  clear_has_html();
  return html_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VydraSourceDoc::set_allocated_html(::std::string* html) {
  if (html != NULL) {
    set_has_html();
  } else {
    clear_has_html();
  }
  html_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), html);
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.vydra.data.VydraSourceDoc.html)
}

// optional .ru.mail.go.vydra.data.VydraSourceDoc.Type type = 3 [default = HTML];
inline bool VydraSourceDoc::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VydraSourceDoc::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VydraSourceDoc::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VydraSourceDoc::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ru::mail::go::vydra::data::VydraSourceDoc_Type VydraSourceDoc::type() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.vydra.data.VydraSourceDoc.type)
  return static_cast< ::ru::mail::go::vydra::data::VydraSourceDoc_Type >(type_);
}
inline void VydraSourceDoc::set_type(::ru::mail::go::vydra::data::VydraSourceDoc_Type value) {
  assert(::ru::mail::go::vydra::data::VydraSourceDoc_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.vydra.data.VydraSourceDoc.type)
}

// -------------------------------------------------------------------

// VydraResultInfo

// optional int32 layer_words_count = 1;
inline bool VydraResultInfo::has_layer_words_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VydraResultInfo::set_has_layer_words_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VydraResultInfo::clear_has_layer_words_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VydraResultInfo::clear_layer_words_count() {
  layer_words_count_ = 0;
  clear_has_layer_words_count();
}
inline ::google::protobuf::int32 VydraResultInfo::layer_words_count() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.vydra.data.VydraResultInfo.layer_words_count)
  return layer_words_count_;
}
inline void VydraResultInfo::set_layer_words_count(::google::protobuf::int32 value) {
  set_has_layer_words_count();
  layer_words_count_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.vydra.data.VydraResultInfo.layer_words_count)
}

// -------------------------------------------------------------------

// VydraResultDoc

// required .ru.mail.go.vydra.data.VydraResultStatus status = 1;
inline bool VydraResultDoc::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VydraResultDoc::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VydraResultDoc::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VydraResultDoc::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::ru::mail::go::vydra::data::VydraResultStatus VydraResultDoc::status() const {
  // @@protoc_insertion_point(field_get:ru.mail.go.vydra.data.VydraResultDoc.status)
  return static_cast< ::ru::mail::go::vydra::data::VydraResultStatus >(status_);
}
inline void VydraResultDoc::set_status(::ru::mail::go::vydra::data::VydraResultStatus value) {
  assert(::ru::mail::go::vydra::data::VydraResultStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:ru.mail.go.vydra.data.VydraResultDoc.status)
}

// optional .ru.mail.go.webbase.blobs.SiliconDocParserInfo siliconData = 2;
inline bool VydraResultDoc::has_silicondata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VydraResultDoc::set_has_silicondata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VydraResultDoc::clear_has_silicondata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VydraResultDoc::clear_silicondata() {
  if (silicondata_ != NULL) silicondata_->::ru::mail::go::webbase::blobs::SiliconDocParserInfo::Clear();
  clear_has_silicondata();
}
inline const ::ru::mail::go::webbase::blobs::SiliconDocParserInfo& VydraResultDoc::silicondata() const {
  const ::ru::mail::go::webbase::blobs::SiliconDocParserInfo* p = silicondata_;
  // @@protoc_insertion_point(field_get:ru.mail.go.vydra.data.VydraResultDoc.siliconData)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::webbase::blobs::SiliconDocParserInfo*>(
      &::ru::mail::go::webbase::blobs::_SiliconDocParserInfo_default_instance_);
}
inline ::ru::mail::go::webbase::blobs::SiliconDocParserInfo* VydraResultDoc::mutable_silicondata() {
  set_has_silicondata();
  if (silicondata_ == NULL) {
    silicondata_ = new ::ru::mail::go::webbase::blobs::SiliconDocParserInfo;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.vydra.data.VydraResultDoc.siliconData)
  return silicondata_;
}
inline ::ru::mail::go::webbase::blobs::SiliconDocParserInfo* VydraResultDoc::release_silicondata() {
  // @@protoc_insertion_point(field_release:ru.mail.go.vydra.data.VydraResultDoc.siliconData)
  clear_has_silicondata();
  ::ru::mail::go::webbase::blobs::SiliconDocParserInfo* temp = silicondata_;
  silicondata_ = NULL;
  return temp;
}
inline void VydraResultDoc::set_allocated_silicondata(::ru::mail::go::webbase::blobs::SiliconDocParserInfo* silicondata) {
  delete silicondata_;
  silicondata_ = silicondata;
  if (silicondata) {
    set_has_silicondata();
  } else {
    clear_has_silicondata();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.vydra.data.VydraResultDoc.siliconData)
}

// optional .ru.mail.go.vydra.data.VydraResultInfo info = 3;
inline bool VydraResultDoc::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VydraResultDoc::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VydraResultDoc::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VydraResultDoc::clear_info() {
  if (info_ != NULL) info_->::ru::mail::go::vydra::data::VydraResultInfo::Clear();
  clear_has_info();
}
inline const ::ru::mail::go::vydra::data::VydraResultInfo& VydraResultDoc::info() const {
  const ::ru::mail::go::vydra::data::VydraResultInfo* p = info_;
  // @@protoc_insertion_point(field_get:ru.mail.go.vydra.data.VydraResultDoc.info)
  return p != NULL ? *p : *reinterpret_cast<const ::ru::mail::go::vydra::data::VydraResultInfo*>(
      &::ru::mail::go::vydra::data::_VydraResultInfo_default_instance_);
}
inline ::ru::mail::go::vydra::data::VydraResultInfo* VydraResultDoc::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    info_ = new ::ru::mail::go::vydra::data::VydraResultInfo;
  }
  // @@protoc_insertion_point(field_mutable:ru.mail.go.vydra.data.VydraResultDoc.info)
  return info_;
}
inline ::ru::mail::go::vydra::data::VydraResultInfo* VydraResultDoc::release_info() {
  // @@protoc_insertion_point(field_release:ru.mail.go.vydra.data.VydraResultDoc.info)
  clear_has_info();
  ::ru::mail::go::vydra::data::VydraResultInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void VydraResultDoc::set_allocated_info(::ru::mail::go::vydra::data::VydraResultInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
  // @@protoc_insertion_point(field_set_allocated:ru.mail.go.vydra.data.VydraResultDoc.info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace data
}  // namespace vydra
}  // namespace go
}  // namespace mail
}  // namespace ru

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ru::mail::go::vydra::data::VydraSourceDoc_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::vydra::data::VydraSourceDoc_Type>() {
  return ::ru::mail::go::vydra::data::VydraSourceDoc_Type_descriptor();
}
template <> struct is_proto_enum< ::ru::mail::go::vydra::data::VydraResultStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ru::mail::go::vydra::data::VydraResultStatus>() {
  return ::ru::mail::go::vydra::data::VydraResultStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vydra_2eproto__INCLUDED
